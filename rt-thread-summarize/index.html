<!-- build time:Sun Jun 02 2024 15:43:25 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="命运转轮" href="https://arachnid.cc/rss.xml"><link rel="alternate" type="application/atom+xml" title="命运转轮" href="https://arachnid.cc/atom.xml"><link rel="alternate" type="application/json" title="命运转轮" href="https://arachnid.cc/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="history,RTOS"><link rel="canonical" href="https://arachnid.cc/rt-thread-summarize/"><title>RT-Thread 应用总结 | Arachnid's blog = 命运转轮 = Life is ...the time you did something you're afraid of doing</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="loader-state"><svg viewBox="0 0 178 40" width="178" height="40"><path class="air" d="M 46 16.5 h -20 a 8 8 0 0 1 0 -16" fill="none" stroke="#E85725" stroke-width="1" stroke-linejoin="round" stroke-linecap="round"></path><g id="car"><svg viewBox="0 0 118 28.125" x="30" y="11.725" width="118" height="28.125"><defs><circle id="circle" cx="0" cy="0" r="1"></circle><g id="wheel"><use href="#circle" fill="#1E191A" transform="scale(10)"></use><use href="#circle" fill="#fff" transform="scale(5)"></use><path fill="#1E191A" stroke="#1E191A" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.2" stroke-dashoffset="0" d="M -3.5 0 a 4 4 0 0 1 7 0 a 3.5 3.5 0 0 0 -7 0"></path><use href="#circle" fill="#1E191A" transform="scale(1.5)"></use><path fill="none" stroke="#F9B35C" stroke-width="0.75" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="20 14 8 5" d="M 0 -7.5 a 7.5 7.5 0 0 1 0 15 a 7.5 7.5 0 0 1 0 -15"></path><path fill="none" stroke="#fff" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.1" stroke-dashoffset="0" d="M -6.5 -6.25 a 10 10 0 0 1 13 0 a 9 9 0 0 0 -13 0"></path></g></defs><g transform="translate(51.5 11.125)"><path stroke-width="2" stroke="#1E191A" fill="#EF3F33" d="M 0 0 v -2 a 4.5 4.5 0 0 1 9 0 v 2"></path><rect fill="#1E191A" x="3.25" y="-3" width="5" height="3"></rect></g><g transform="translate(10 24.125)"><g transform="translate(59 0)"><path id="shadow" opacity="0.7" fill="#1E191A" d="M -64 0 l -4 4 h 9 l 8 -1.5 h 100 l -3.5 -2.5"></path></g><path fill="#fff" stroke="#1E191A" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" d="M 0 0 v -10 l 35 -13 v 5 l 4 0.5 l 0.5 4.5 h 35.5 l 30 13"></path><g fill="#fff" stroke="#1E191A" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round"><path d="M -6 0 v -22 h 10 z"></path><path d="M 105 0 h -3 l -12 -5.2 v 6.2 h 12"></path></g><g fill="#949699" opacity="0.7"><rect x="16" y="-6" width="55" height="6"></rect><path d="M 24 -14 l 13 -1.85 v 1.85"></path></g><g fill="none" stroke="#1E191A" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round"><path stroke-dasharray="30 7 42" d="M 90 0 h -78"></path><path d="M 39.5 -13 h -15"></path></g><path fill="#fff" stroke="#1E191A" stroke-width="2.25" stroke-linejoin="round" d="M 48.125 -6 h -29 v 6 h 29"></path><rect x="48" y="-7.125" width="6.125" height="7.125" fill="#1E191A"></rect><g fill="#1E191A"><rect x="60" y="-15" width="1" height="6"></rect><rect x="56.5" y="-17.5" width="6" height="2.5"></rect></g></g><g class="wheels" transform="translate(0 18.125)"><g transform="translate(10 0)"><use href="#wheel"></use></g><g transform="translate(87 0)"><use href="#wheel" stroke-dashoffset="-22"></use></g></g></svg></g><g fill="none" stroke-width="1" stroke-linejoin="round" stroke-linecap="round"><path class="air" stroke="#E85725" d="M 177.5 34 h -10 q -16 0 -32 -8"></path><path class="air" stroke="#949699" d="M 167 28.5 c -18 -2 -22 -8 -37 -10.75"></path><path class="air" stroke="#949699" d="M 153 20 q -4 -1.7 -8 -3"></path><path class="air" stroke="#E85725" d="M 117 16.85 c -12 0 -12 16 -24 16 h -8"></path><path class="air" stroke="#949699" d="M 65 12 q -5 3 -12 3.8"></path><path class="air" stroke="#949699" stroke-dasharray="9 10" d="M 30 13.5 h -2.5 q -5 0 -5 -5"></path><path class="air" stroke="#949699" d="M 31 33 h -10"></path><path class="air" stroke="#949699" d="M 29.5 23 h -12"></path><path class="air" stroke="#949699" d="M 13.5 23 h -6"></path><path class="air" stroke="#E85725" d="M 28 28 h -27.5"></path></g></svg></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"><a href="/rt-thread-summarize" class="link external" itemprop="url">RT-Thread 应用总结<i class="ic i-link-alt"></i></a></h1><div class="meta"><span class="item" title="创建时间：2022-02-25 21:33:59"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-02-25T21:33:59+08:00">2022-02-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Arachnid's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://arachnid.cc/picture/(30).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(28).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(3).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(25).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(12).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(1).webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="cn"><link itemprop="mainEntityOfPage" href="https://arachnid.cc/rt-thread-summarize/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.webp"><meta itemprop="name" content="夏沫の浅雨"><meta itemprop="description" content="Life is ...the time you did something you're afraid of doing, 不曾亏欠，不曾辜负，如此足矣"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="命运转轮"></span><div class="body md" itemprop="articleBody"><p>官方文档介绍：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnQtdGhyZWFkLm9yZy9kb2N1bWVudC9zaXRlLyMvcnQtdGhyZWFkLXZlcnNpb24vcnQtdGhyZWFkLXN0YW5kYXJkL1JFQURNRQ==">RT-Thread 文档中心</span></p><h1 id="各模块-api接口"><a class="anchor" href="#各模块-api接口">#</a> 各模块 API 接口</h1><p>由于 RT-Thread 实时操作系统跟各大类 RTOS 应用原理大致相同，因此不再详述各模块功能的作用了（各模块功能的详细信息可参考以前的 《<a href="https://arachnid.cc/categories/RTOS/">FreeRTOS 专栏</a>》），只总结各类功能接口的 API 调用函数。</p><p>官方 API 参考手册：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnQtdGhyZWFkLm9yZy9kb2N1bWVudC9hcGkvaW5kZXguaHRtbA==">RT-Thread API 参考手册</span></p><p><img data-src="04thread_sta.png" alt=""></p><h2 id="线程管理"><a class="anchor" href="#线程管理">#</a> 线程管理</h2><h3 id="a-线程使用"><a class="anchor" href="#a-线程使用">#</a> A、线程使用</h3><p><img data-src="04thread_ops.png" alt="线程相关操作"></p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>创建线程</td><td>rt_thread_t rt_thread_create(const char *name, void (*entry)(void *parameter), void *parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick);</td><td>该函数将<strong>从动态堆内存中</strong>创建一个线程对象并分配线程对象内存和堆栈。</td><td>xTaskCreate()</td></tr><tr><td>删除线程</td><td>rt_err_t rt_thread_delete(rt_thread_t thread);</td><td>调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。</td><td>vTaskDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>初始线程</td><td>rt_err_t rt_thread_init(struct rt_thread *thread, const char *name, void (*entry)(void *parameter), void *parameter, void *stack_start, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick);</td><td>使用该函数创建的线程，线程句柄 (或者说线程控制块指针) 、线程栈所占用的内存空间，均通过全局变量的方式进行分配，内核不负责动态分配内存空间（即由用户提供，<strong>属于静态分配</strong>，在编译时就被确定、被分配处理）。</td><td>xTaskCreateStatic()</td></tr><tr><td>脱离线程</td><td>rt_err_t rt_thread_detach (rt_thread_t thread);</td><td>与 rt_thread_delete () 函数相对应，使线程对象在线程队列和内核对象管理器中被脱离。注：线程本身不应调用这个接口脱离线程本身</td><td>vTaskDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>启动线程</td><td>rt_err_t rt_thread_startup(rt_thread_t thread);</td><td>当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>线程睡眠</td><td>rt_err_t rt_thread_sleep(rt_tick_t tick); rt_err_t rt_thread_delay(rt_tick_t tick); rt_err_t rt_thread_mdelay(rt_int32_t ms);</td><td>这三个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。</td><td>vTaskDelay()</td></tr></tbody></table><p>对比：<a href="https://arachnid.cc/freertos-task/">FreeRTOS 篇章之任务管理</a></p><h3 id="b-挂起和恢复"><a class="anchor" href="#b-挂起和恢复">#</a> B、挂起和恢复</h3><ul class="task-list"><li><p><strong>线程挂起的函数接口：</strong></p><p><code>rt_err_t rt_thread_suspend (rt_thread_t thread);</code></p><p>线程挂起接口 rt_thread_suspend () 的参数和返回值见下表：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程挂起成功</td></tr><tr><td>RT_ERROR</td><td>线程挂起失败，因为该线程的状态并不是就绪状态</td></tr></tbody></table></li><li class="task-list-item"><p><input type="checkbox" id="cbx_0" disabled><label for="cbx_0">注：RT-Thread 对此此函数有严格的使用限制，该函数只能使用来挂起当前线程（即自己挂起自己），不可以在线程 A 中尝试挂起线程 B，而且在挂起线程自己后，需要立刻调用 <code>rt_schedule()</code> 函数进行手动的线程上下文切换。用户只需要了解该接口的作用即可，强烈不建议在程序中使用该接口，该接口可以视为是内部接口。这是因为 A 线程在尝试挂起 B 线程时，A 线程并不清楚 B 线程正在运行什么程序，一旦 B 线程正在使用例如互斥量、信号量等影响、阻塞其他线程的内核对象，那么 A 线程尝试挂起 B 线程的操作将会引发连锁反应，严重危及系统的实时性（有些地方会将其描述为死锁，实际上这种现象不是死锁，但是也不比死锁好到哪去）。</label></p></li><li><p><strong>线程恢复的函数接口：</strong></p><p><code>rt_err_t rt_thread_resume (rt_thread_t thread);</code></p><p>线程恢复接口 rt_thread_resume () 的参数和返回值见下表：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程恢复成功</td></tr><tr><td>RT_ERROR</td><td>线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态</td></tr></tbody></table></li></ul><p>以上这两个函数类似于 <a href="https://arachnid.cc/freertos-critical-scheduler/">FreeRTOS 篇章之临界区与调度器</a> 里面的调度器中的操作，但其要求并不一样。</p><h2 id="信号量"><a class="anchor" href="#信号量">#</a> 信号量</h2><p><img data-src="06sem_ops.png" alt="信号量相关接口"></p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>创建信号量</td><td>rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);</td><td>系统<strong>动态分配</strong>一个 semaphore 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 semaphore 相关的部分。</td><td>xSemaphoreCreateBinary()</td></tr><tr><td>删除信号量</td><td>rt_err_t rt_sem_delete(rt_sem_t sem);</td><td>通过删除信号量以释放系统资源，适用于动态创建的信号量。</td><td>vSemaphoreDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>初始信号量</td><td>rt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value, rt_uint8_t flag);</td><td><strong>属于静态分配</strong>，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。</td><td>xSemaphoreCreateBinaryStatic()</td></tr><tr><td>脱离信号量</td><td>rt_err_t rt_sem_detach(rt_sem_t sem);</td><td>让信号量对象从内核对象管理器中脱离，适用于静态初始化的信号量。</td><td>vSemaphoreDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>获取信号量</td><td>rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);</td><td>通过获取信号量来获得信号量资源实例，当信号量值大于零时，线程将获得信号量，并且相应的信号量值会减 1。</td><td>xSemaphoreTake() / xSemaphoreTakeFromISR()</td></tr><tr><td>无等待获取信号量</td><td>rt_err_t rt_sem_trytake(rt_sem_t sem);</td><td>与 <code>rt_sem_take(sem, RT_WAITING_NO)</code> 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - <code>RT_ETIMEOUT</code> 。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>释放信号量</td><td>rt_err_t rt_sem_release(rt_sem_t sem);</td><td>释放之前所获得的信号量资源实例。</td><td>xSemaphoreGive() / xSemaphoreGiveFromISR()</td></tr></tbody></table><p>对比：<a href="https://arachnid.cc/freertos-binary-semaphore/">FreeRTOS 篇章之二值信号量</a></p><h2 id="互斥量"><a class="anchor" href="#互斥量">#</a> 互斥量</h2><p><img data-src="06mutex_ops.png" alt="互斥量相关接口"></p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>创建互斥量</td><td>rt_mutex_t rt_mutex_create (const char *name, rt_uint8_t flag);</td><td>系统将先从对象管理器中<strong>动态分配</strong>一个 mutex 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 mutex 相关的部分。</td><td>xSemaphoreCreateMutex()</td></tr><tr><td>删除互斥量</td><td>rt_err_t rt_mutex_delete (rt_mutex_t mutex);</td><td>通过删除互斥量以释放系统资源，适用于动态创建的互斥量。</td><td>vSemaphoreDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>初始互斥量</td><td>rt_err_t rt_mutex_init (rt_mutex_t mutex, const char *name, rt_uint8_t flag);</td><td><strong>属于静态分配</strong>，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。</td><td>xSemaphoreCreateMutexStatic()</td></tr><tr><td>脱离互斥量</td><td>rt_err_t rt_mutex_detach (rt_mutex_t mutex);</td><td>把互斥量对象从内核对象管理器中脱离，适用于静态初始化的互斥量。</td><td>vSemaphoreDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>获取互斥量</td><td>rt_err_t rt_mutex_take (rt_mutex_t mutex, rt_int32_t time);</td><td>当线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。</td><td>xSemaphoreTake()</td></tr><tr><td>无等待获取互斥量</td><td>rt_err_t rt_mutex_trytake(rt_mutex_t mutex);</td><td>与 <code>rt_mutex_take(mutex, RT_WAITING_NO)</code> 的作用相同，即当线程申请的互斥量资源实例不可用的时候，它不会等待在该互斥量上，而是直接返回 - <code>RT_ETIMEOUT</code> 。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>释放互斥量</td><td>rt_err_t rt_mutex_release(rt_mutex_t mutex);</td><td>使用该函数接口时，只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。</td><td>xSemaphoreGive()</td></tr></tbody></table><p>对比：<a href="https://arachnid.cc/freertos-mutex-semaphore/">FreeRTOS 篇章之互斥量</a></p><h2 id="事件集"><a class="anchor" href="#事件集">#</a> 事件集</h2><p><img data-src="06event_ops.png" alt="事件相关接口"></p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>创建事件集</td><td>rt_event_t rt_event_create(const char *name, rt_uint8_t flag);</td><td>系统从对象管理器中<strong>动态分配</strong>事件集对象，并初始化这个对象，然后初始化父类 IPC 对象。</td><td>xEventGroupCreate()</td></tr><tr><td>删除事件集</td><td>rt_err_t rt_event_delete(rt_event_t event);</td><td>通过删除事件集对象控制块来释放系统资源，适用于动态创建的事件集。</td><td>vEventGroupDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>初始事件集</td><td>rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);</td><td><strong>属于静态分配</strong>，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。</td><td>xEventGroupCreateStatic()</td></tr><tr><td>脱离事件集</td><td>rt_err_t rt_event_detach(rt_event_t event);</td><td>将该事件集从内核对象管理器中脱离，适用于静态初始化的事件集。</td><td>vEventGroupDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>发送事件</td><td>rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);</td><td>通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。</td><td>xEventGroupSetBits() / xEventGroupSetBitsFromISR()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>接收事件</td><td>rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved);</td><td>系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 <code>RT_EVENT_FLAG_CLEAR</code> 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - <code>RT_ETIMEOUT</code> 。</td><td>xEventGroupWaitBits()</td></tr></tbody></table><p>对比：<a href="https://arachnid.cc/freertos-event/">FreeRTOS 篇章之事件位和事件组</a></p><h2 id="邮箱"><a class="anchor" href="#邮箱">#</a> 邮箱</h2><p><img data-src="07mb_ops.png" alt="邮箱相关接口"></p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>创建邮箱</td><td>rt_mailbox_t rt_mb_create (const char *name, rt_size_t size, rt_uint8_t flag);</td><td>创建邮箱对象时会先从对象管理器中分配一个邮箱对象，然后给邮箱<strong>动态分配一块内存空间</strong>用来存放邮件，这块内存的大小等于邮件大小（4 字节）与邮箱容量的乘积，接着初始化接收邮件数目和发送邮件在邮箱中的偏移量。</td><td>xQueueCreate()</td></tr><tr><td>删除邮箱</td><td>rt_err_t rt_mb_delete (rt_mailbox_t mb);</td><td>释放相应的系统资源，当操作一旦完成，邮箱将被永久性的删除。</td><td>vQueueDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>初始邮箱</td><td>rt_err_t rt_mb_init(rt_mailbox_t mb, const char *name, void *msgpool, rt_size_t size, rt_uint8_t flag);</td><td><strong>属于静态分配</strong>，与创建邮箱不同的是，静态邮箱对象的内存是在系统编译时由编译器分配的，一般放于读写数据段或未初始化数据段中，其余的初始化工作与创建邮箱时相同。</td><td>xQueueCreateStatic()</td></tr><tr><td>脱离邮箱</td><td>rt_err_t rt_mb_detach(rt_mailbox_t mb);</td><td>把静态初始化的邮箱对象从内核对象管理器中脱离。</td><td>vQueueDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>发送邮件</td><td>rt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);</td><td>发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针；当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 - <code>RT_EFULL</code> 的返回值。</td><td>xQueueOverwrite() / xQueueOverwriteFromISR()</td></tr><tr><td>等待方式发送邮件</td><td>rt_err_t rt_mb_send_wait (rt_mailbox_t mb, rt_uint32_t value, rt_int32_t timeout);</td><td>与 rt_mb_send () 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间；如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</td><td></td></tr><tr><td>发送紧急邮件</td><td>rt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);</td><td>与发送邮件几乎一样，唯一的不同是，当发送紧急邮件时，邮件被<strong>直接插队放入了邮件队首</strong>，这样，接收者就能够优先接收到紧急邮件，从而及时进行处理。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>接收邮件</td><td>rt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);</td><td>只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 <code>RT_EOK</code> 的返回值，否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</td><td>xQueueReceive() / xQueueReceiveFromISR()</td></tr></tbody></table><p>对比：<a href="https://arachnid.cc/freertos-queue/">FreeRTOS 篇章之队列管理</a> 中的消息数目为 1 的队列</p><p>注：由于 FreeRTOS 中并没有邮箱这一概念（邮箱这概念在 uCOS 中有），但是其原理类似于利用队列发送单一数目的信息，由于在 32 系统上 4 字节（32 bit）的内容恰好可以放置一个指针，因此该信息通常为<strong>数据指针</strong>。</p><h2 id="消息队列"><a class="anchor" href="#消息队列">#</a> 消息队列</h2><p><img data-src="07msg_ops.png" alt="消息队列相关接口"></p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>创建队列</td><td>rt_mq_t rt_mq_create(const char *name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag);</td><td>从对象管理器中<strong>动态分配</strong>一个消息队列对象，然后给消息队列对象分配一块内存空间，组织成空闲消息链表，这块 <code>内存的大小 = [消息大小 + 消息头（用于链表连接）的大小] x 消息队列最大个数</code> ，接着再初始化消息队列，此时消息队列为空。</td><td>xQueueCreate()</td></tr><tr><td>删除队列</td><td>rt_err_t rt_mq_delete(rt_mq_t mq);</td><td>删除它以释放系统资源，一旦操作完成，消息队列将被永久性地删除。</td><td>vQueueDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>初始队列</td><td>rt_err_t rt_mq_init(rt_mq_t mq, const char *name, void *msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag);</td><td><strong>属于静态分配</strong>，跟创建消息队列对象类似，只是静态消息队列对象的内存是在系统编译时由编译器分配的，一般放于读数据段或未初始化数据段中。</td><td>xQueueCreateStatic()</td></tr><tr><td>脱离队列</td><td>rt_err_t rt_mq_detach(rt_mq_t mq);</td><td>将使消息队列对象被从内核对象管理器中脱离。</td><td>vQueueDelete()</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>发送信息</td><td>rt_err_t rt_mq_send (rt_mq_t mq, void *buffer, rt_size_t size);</td><td>线程或者中断服务程序都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（- <code>RT_EFULL</code> ）。</td><td>xQueueSend() / xQueueSendFromISR() xQueueSendToFront() / xQueueSendToFrontFromISR()</td></tr><tr><td>等待方式发送信息</td><td>rt_err_t rt_mq_send_wait(rt_mq_t mq, const void *buffer, rt_size_t size, rt_int32_t timeout);</td><td>与 rt_mq_send () 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。</td><td></td></tr><tr><td>发送紧急信息</td><td>rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);</td><td>与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>接收信息</td><td>rt_err_t rt_mq_recv (rt_mq_t mq, void *buffer, rt_size_t size, rt_int32_t timeout);</td><td>当消息队列中有消息时，接收者才能接收消息，否则接收者会根据超时时间设置，或挂起在消息队列的等待线程队列上，或直接返回。</td><td>xQueueReceive() / xQueueReceiveFromISR()</td></tr></tbody></table><p>对比：<a href="https://arachnid.cc/freertos-queue/">FreeRTOS 篇章之队列管理</a></p><h1 id="中断管理"><a class="anchor" href="#中断管理">#</a> 中断管理</h1><p><img data-src="09interrupt_ops.png" alt="中断相关接口"></p><p>对于上图，通常用的较多的是：</p><h2 id="全局中断开关"><a class="anchor" href="#全局中断开关">#</a> 全局中断开关</h2><p><strong>全局中断开关也称为</strong>中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。</p><table><thead><tr><th>函数功能</th><th>API 接口</th><th>函数描述</th><th>与 FreeRTOS 相匹配的函数</th></tr></thead><tbody><tr><td>关闭整个系统的中断</td><td>rt_base_t rt_hw_interrupt_disable(void);</td><td>关闭整个系统的中断</td><td>taskENTER_CRITICAL() / taskENTER_CRITICAL_FROM_ISR()</td></tr><tr><td>恢复整个系统的中断</td><td>void rt_hw_interrupt_enable(rt_base_t level);</td><td>恢复系统的上一个中断状态</td><td>taskEXIT_CRITICAL() / taskEXIT_CRITICAL_FROM_ISR( x )</td></tr></tbody></table><p><strong>（1）rt_hw_interrupt_disable () API 函数</strong></p><p>原型： <code>rt_base_t rt_hw_interrupt_disable(void);</code></p><p>返回参数：</p><ul><li>rt_hw_interrupt_disable 函数运行前的中断状态</li></ul><p><strong>（2）rt_hw_interrupt_enable () API 函数</strong></p><p>原型： <code>void rt_hw_interrupt_enable(rt_base_t level);</code></p><p>输入参数：</p><ul><li>前一次 rt_hw_interrupt_disable 返回的中断状态</li></ul><p>注：在这里就相当于 <a href="https://arachnid.cc/freertos-critical-scheduler/">FreeRTOS 篇章之临界区与调度器</a> 里面的临界段中的操作。</p><h2 id="中断通知"><a class="anchor" href="#中断通知">#</a> 中断通知</h2><p>当整个系统被中断打断，进入中断处理函数时，需要通知内核当前已经进入到中断状态。</p><p>针对这种情况，RT-Thread 提供如下两个接口：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">rt_interrupt_enter</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 用于通知内核，当前已经进入了中断状态，并增加中断嵌套深度（执行 rt_interrupt_nest++）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">rt_interrupt_leave</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 用于通知内核，当前已经离开了中断状态，并减少中断嵌套深度（执行 rt_interrupt_nest--）</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>注：不要在应用程序中调用这两个接口函数。</pre></td></tr></table></figure><p>其实这两个函数等同于 FreeRTOS 中带 FromISR 后缀的函数说明。</p><h1 id="rt-thread-studio上手"><a class="anchor" href="#rt-thread-studio上手">#</a> RT-Thread Studio 上手</h1><p>安装及环境搭建过程可以直接参看官方的指导文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnQtdGhyZWFkLm9yZy9kb2N1bWVudC9zaXRlLyMvZGV2ZWxvcG1lbnQtdG9vbHMvcnR0aHJlYWQtc3R1ZGlvL3VtL3N0dWRpby11c2VyLWJlZ2lu">RT-Thread Studio 使用文档</span></p><p><strong>以下只是简单记录部分关键点：</strong></p><h2 id="控制台调试口修改"><a class="anchor" href="#控制台调试口修改">#</a> 控制台调试口修改</h2><p>在新建项目过程中，可从 GUI 窗口中选择配置，如下图：</p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226114622.png" alt="TIM截图20220226114622"></p><p>当后期需要重新分配时，则需要在代码和 RT-Thread setting 中修改了，（以修改为 <code>UART 3</code> 为例）修改内容如下：</p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226120341.png" alt="TIM截图20220226120341"></p><h2 id="串口终端集成显示"><a class="anchor" href="#串口终端集成显示">#</a> 串口终端集成显示</h2><p>在 RT-Thread Studio 上，是可以通过点击工具栏 <code>终端</code> 按钮，来打开对应的终端功能窗口查看输出信息的，并且同样支持与 RT-Thread 特有的 <code>finsh</code> 命令进行交互，串口终端显示操作如下：</p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226141345.png" alt="TIM截图20220226141345"></p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226142044.png" alt="TIM截图20220226142044"></p><h2 id="与-cubemx联合编程"><a class="anchor" href="#与-cubemx联合编程">#</a> 与 CubeMX 联合编程</h2><p>此操作的前提条件是已经安装了 STM32CubeMX</p><h3 id="a-启动-cubemx-settings配置"><a class="anchor" href="#a-启动-cubemx-settings配置">#</a> A、启动 CubeMX settings 配置</h3><p>新建的工程，都是优先使用内部时钟源（如下图），但实际情况下，大部分是使用外部时钟的，因为其稳定性比较好；因此，以修改外部时钟为例。</p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226115723.png" alt="TIM截图20220226115723"></p><p>由于 RT-Thread Studio 支持与 CubeMX 联合编程，所以我们只需在项目资源管理器中启动 <code>CubeMX settings</code> 进行配置就好（如下图），进入界面后，其操作实际等同于操作 STM32CubeMX。</p><p><img data-src="image-20220226210308862.png" alt="image-20220226210308862"></p><h3 id="b-cubemx-settings配置生成注意点"><a class="anchor" href="#b-cubemx-settings配置生成注意点">#</a> B、CubeMX settings 配置生成注意点</h3><ul><li><p>尽量生成 GCC 工程，因为 RT-Thread Studio 用的是 gcc 编译器<br><img data-src="image-20220226233830986.png" alt="image-20220226233830986"></p></li><li><p>选择生成独立的 .c .h 文件<br><img data-src="313583-20201110104753899-295524523.png" alt="img"></p></li><li><p>生成完成后返回界面，会提示替换了 <code>stm32xxx_hal_conf.h</code> 文件，因此，我们需要把原来的配置，同步过去，该哪些配置需要打开的，都一一打开。</p></li></ul><h3 id="c-添加编译规则"><a class="anchor" href="#c-添加编译规则">#</a> C、添加编译规则</h3><p>在生成 CubeMX 产生的工程后，打开 <code>drv_clk.c</code> 文件，你会发现 <code>clk_init()</code> 函数里面被自动更改了（如下图）；这也就意味着什么呢？记得备份啦，或者上 git /svn 进行版本管理啦。</p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226143627.png" alt="TIM截图20220226143627"></p><p>于是乎，对工程进行编译时，发现一堆报错，不禁怀疑 RT-Thread Studio 是否支持与 CubeMX 联合编程的。。。</p><p>在这里就需要对编译做相关操作了：</p><p>（1）在生成的 cubemx 文件夹里，先检查 cubemx 文件夹下有没有 <code>SConscript</code> 文件，如果有就跳过创建环节，检查内容。</p><p>（2）核查并更改 <code>SConscript</code> 文件里面的内容。</p><p>（3）有时候在生成 CubeMX 产生的工程后，RT-Thread Studio 会帮你生成一个 <code>SConscript</code> 文件，并写好了规则，如果是已有的，那么可以尝试先编译一下是否有新增的源码进行编译，如果没有，那么可以仿照如下的代码进行修改：</p><p><img data-src="TIM%E6%88%AA%E5%9B%BE20220226150650.png" alt="TIM截图20220226150650"></p><p>其中，上面规则里的 <code>src</code> 部分，需要根据实际内容增删需要编译的源文件（如下）：</p><figure class="highlight markdown"><figcaption data-lang="markdown"></figcaption><table><tr><td data-num="1"></td><td><pre>src = Split('''</pre></td></tr><tr><td data-num="2"></td><td><pre>Src/stm32g4xx_hal_msp.c</pre></td></tr><tr><td data-num="3"></td><td><pre>Src/main.c</pre></td></tr><tr><td data-num="4"></td><td><pre>Src/dma.c</pre></td></tr><tr><td data-num="5"></td><td><pre>Src/gpio.c</pre></td></tr><tr><td data-num="6"></td><td><pre>Src/usart.c</pre></td></tr><tr><td data-num="7"></td><td><pre>''')</pre></td></tr></table></figure><p>当然，为了一劳永逸，你也可以把它修改成这样子：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 引入 building 模块中所有的东西</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> building <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 获取当前路径。</span></pre></td></tr><tr><td data-num="5"></td><td><pre>cwd <span class="token operator">=</span> GetCurrentDir<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 使能选择</span></pre></td></tr><tr><td data-num="8"></td><td><pre>search_EN <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># add cubemx drivers</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># search_EN 为 0 时，手动选择添加需要编译的源文件</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># search_EN 为 1 时，自动搜寻与 SrcRemove 匹配以外的源文件</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> search_EN<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	src <span class="token operator">=</span> Split<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	Src/stm32f4xx_hal_msp.c</pre></td></tr><tr><td data-num="16"></td><td><pre>	Src/main.c</pre></td></tr><tr><td data-num="17"></td><td><pre>	'''<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">else</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	src <span class="token operator">=</span> Glob<span class="token punctuation">(</span><span class="token string">'Src/*.c'</span><span class="token punctuation">)</span>	</pre></td></tr><tr><td data-num="20"></td><td><pre>	SrcRemove<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Src/stm32f4xx_it.c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	SrcRemove<span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Src/system_stm32f4xx.c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment"># 创建头文件路径列表，并保存至 path 中</span></pre></td></tr><tr><td data-num="24"></td><td><pre>path <span class="token operator">=</span> <span class="token punctuation">[</span>cwd <span class="token operator">+</span> <span class="token string">'/Inc'</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment"># 这是 RT-Thread 基于 SCons 扩展的一个方法（函数）。</span></pre></td></tr><tr><td data-num="27"></td><td><pre>group <span class="token operator">=</span> DefineGroup<span class="token punctuation">(</span><span class="token string">'cubemx'</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> depend <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">,</span> CPPPATH <span class="token operator">=</span> path<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>Return<span class="token punctuation">(</span><span class="token string">'group'</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>通过上面，你可能发现，为什么文件中的 <code>stm32f4xx_it.c</code> 和 <code>system_stm32f4xx.c</code> 不加入构建；其实你可以尝试一下加入编译一下，你就会发现玄机了。</p><p>更多的关于 SCons 工具的使用可以观看如下链接：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnQtdGhyZWFkLm9yZy9kb2N1bWVudC9zaXRlLyMvZGV2ZWxvcG1lbnQtdG9vbHMvc2NvbnMvc2NvbnM/aWQ9c2NvbnMtJUU3JUFFJTgwJUU0JUJCJThC">https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-%e7%ae%80%e4%bb%8b</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9zY29ucy5vcmcvZG9jL3Byb2R1Y3Rpb24vSFRNTC9zY29ucy11c2VyL2luZGV4Lmh0bWw=">https://scons.org/doc/production/HTML/scons-user/index.html</span></p><p>最后记得更新 Sconscripts（在项目资源管理器选择目标工程 -&gt; 右键 -&gt; 更新 <code>Sconscripts</code> ）：</p><p><img data-src="image-20220226231733878.png" alt="image-20220226231733878"></p><h3 id="d-迁移-cubemx产生的代码"><a class="anchor" href="#d-迁移-cubemx产生的代码">#</a> D、迁移 CubeMX 产生的代码</h3><p>当完成上面操作后，再次构建工程，或多或少还会出现错误，大概率是函数重复定义导致，比如 <code>multiple definition of main</code> 。这时候可以如下操作：</p><p><img data-src="20220226173146.png" alt="20220226173146"></p><p>嘛，或许有时候在 CubeMX 初次生成的 main () 函数上自带了 <code>__WEAK</code> 弱处理关键字，但后期在多次更改 CubeMX settings 配置后，会有出现去掉 <code>__WEAK</code> 的情况，所以为了安全，还是把 <code>__WEAK</code> 添加到上述的保护区域位置去吧。</p><p>除了以上情况，在 CubeMX settings 配置更多外设时，需要把 cubemx/Src 里的 main.c 文件里的配置函数，手动移加到 RT-Thread 工程的 main.c 主文件函数中（一些 RTT 配置里面有的，就不用添加过去了，避免功能出错，例如 ETH 的配置）。如下图：</p><p><img data-src="20220226172930.png" alt="20220226172930"></p><div class="tags"><a href="/tags/history/" rel="tag"><i class="ic i-tag"></i> history</a> <a href="/tags/RTOS/" rel="tag"><i class="ic i-tag"></i> RTOS</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-02-22 22:59:02" itemprop="dateModified" datetime="2023-02-22T22:59:02+08:00">2023-02-22</time></span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="rt-thread-summarize/" class="item leancloud_visitors" data-flag-title="RT-Thread 应用总结" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span id="busuanzi_value_page_pv"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 投喂</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.webp" alt="夏沫の浅雨 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.webp" alt="夏沫の浅雨 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>夏沫の浅雨 <i class="ic i-at"><em>@</em></i>命运转轮</li><li class="link"><strong>本文链接：</strong> <a href="https://arachnid.cc/rt-thread-summarize/" title="RT-Thread 应用总结">https://arachnid.cc/rt-thread-summarize/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/modbus-family/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;arachnid.cc&#x2F;picture&#x2F;(15).webp" title="Modbus家族之开篇"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> modbus</span><h3>Modbus家族之开篇</h3></a></div><div class="item right"><a href="/modbus-rtu-protocol/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;arachnid.cc&#x2F;picture&#x2F;(14).webp" title="Modbus家族之 RTU"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> modbus</span><h3>Modbus家族之 RTU</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%84%E6%A8%A1%E5%9D%97-api%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">各模块 API 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">线程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">A、线程使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">B、挂起和恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">互斥量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%9B%86"><span class="toc-number">1.4.</span> <span class="toc-text">事件集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%AE%E7%AE%B1"><span class="toc-number">1.5.</span> <span class="toc-text">邮箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.6.</span> <span class="toc-text">消息队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">中断管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E6%96%AD%E5%BC%80%E5%85%B3"><span class="toc-number">2.1.</span> <span class="toc-text">全局中断开关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%80%9A%E7%9F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">中断通知</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rt-thread-studio%E4%B8%8A%E6%89%8B"><span class="toc-number">3.</span> <span class="toc-text">RT-Thread Studio 上手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%B0%83%E8%AF%95%E5%8F%A3%E4%BF%AE%E6%94%B9"><span class="toc-number">3.1.</span> <span class="toc-text">控制台调试口修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AF%E9%9B%86%E6%88%90%E6%98%BE%E7%A4%BA"><span class="toc-number">3.2.</span> <span class="toc-text">串口终端集成显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-cubemx%E8%81%94%E5%90%88%E7%BC%96%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">与 CubeMX 联合编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%90%AF%E5%8A%A8-cubemx-settings%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">A、启动 CubeMX settings 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-cubemx-settings%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">B、CubeMX settings 配置生成注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%B7%BB%E5%8A%A0%E7%BC%96%E8%AF%91%E8%A7%84%E5%88%99"><span class="toc-number">3.3.3.</span> <span class="toc-text">C、添加编译规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-%E8%BF%81%E7%A7%BB-cubemx%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.4.</span> <span class="toc-text">D、迁移 CubeMX 产生的代码</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="夏沫の浅雨" data-src="/images/avatar.webp"><p class="name" itemprop="name">夏沫の浅雨</p><div class="description" itemprop="description">不曾亏欠，不曾辜负，如此足矣</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">73</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyYWNobmlkLTk3" title="https:&#x2F;&#x2F;github.com&#x2F;Arachnid-97"><i class="ic i-github"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjM2MTA4MzU=" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;23610835"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友人帐</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-info-circle"></i>关于</a></li><li class="item"><a href="/atom.xml" rel="section"><i class="ic i-rss"></i>RSS</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/modbus-family/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/modbus-rtu-protocol/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/modbus/" title="分类于 modbus">modbus</a></div><span><a href="/modbus-rtu-protocol" title="Modbus家族之 RTU">Modbus家族之 RTU<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/RTOS/" title="分类于 FreeRTOS">FreeRTOS</a></div><span><a href="/freertos-mutex-semaphore" title="FreeRTOS 篇章之互斥量">FreeRTOS 篇章之互斥量<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/using-wireshark" title="wireshark 使用">wireshark 使用<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/vscode-config" title="vscode 常用配置">vscode 常用配置<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Linux-environment-variables" title="Linux 环境变量的增删改">Linux 环境变量的增删改<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/filtering-algorithm" title="常用滤波算法（纯C实现）">常用滤波算法（纯C实现）<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hexo/" title="分类于 Hexo-shoka">Hexo-shoka</a></div><span><a href="/hexo-shoka-create" title="博客搭建笔记之 Hexo-shoka">博客搭建笔记之 Hexo-shoka<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/dmx512-protocol" title="DMX512 协议">DMX512 协议<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/linux-command-summary" title="Linux 命令简述总结">Linux 命令简述总结<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/SDCC-develop" title="SDCC 编译器 + VSCode 开发">SDCC 编译器 + VSCode 开发<i class="ic i-link-alt"></i></a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">夏沫の浅雨 @ Arachnid's blog</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="count"><span class="icon"><i class="ic i-person"></i> <span id="busuanzi_value_site_uv"></span>人 <span class="post-meta-divider">|</span> <span class="icon"><i class="ic i-eye"></i> <span id="busuanzi_value_site_pv"></span>次 <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">515k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">8:46</span></span></span></div><div class="create_time"><span class="icon"><i class="ic i-clock"></i> <span id="timeDate">正在加载</span> <span id="times">...</span><script>function createtime(){var n=new Date("04/28/2022 15:45:50");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML=" 本站存活 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script></span></div><div class="powered-by">Powered-by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"rt-thread-summarize/",favicon:{show:"ψ(｀∇´)ψ 欢迎回来!",hide:"《原子弹入门及制造》"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,mermaid:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="/js/combined-file.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->