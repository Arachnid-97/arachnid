<!-- build time:Tue Jan 31 2023 21:48:00 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="命运转轮" href="https://arachnid.cc/rss.xml"><link rel="alternate" type="application/atom+xml" title="命运转轮" href="https://arachnid.cc/atom.xml"><link rel="alternate" type="application/json" title="命运转轮" href="https://arachnid.cc/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="history"><link rel="canonical" href="https://arachnid.cc/docs/Essay/%E6%9D%A5%E5%AD%A6%E7%82%B9%20Makefile/"><title>来学点 Makefile | Arachnid's blog = 命运转轮 = Life is ...the time you did something you're afraid of doing</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">来学点 Makefile</h1><div class="meta"><span class="item" title="创建时间：2019-07-14 17:36:57"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2019-07-14T17:36:57+08:00">2019-07-14</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>14k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Arachnid's blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://arachnid.cc/picture/(25).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(31).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(12).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(8).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(24).webp"></li><li class="item" data-background-image="https://arachnid.cc/picture/(20).webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://arachnid.cc/docs/Essay/%E6%9D%A5%E5%AD%A6%E7%82%B9%20Makefile/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="夏沫の浅雨"><meta itemprop="description" content="Life is ...the time you did something you're afraid of doing, 不曾亏欠，不曾辜负，如此足矣"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="命运转轮"></span><div class="body md" itemprop="articleBody"><p><strong>参考链接：</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9zZWlzbWFuLmdpdGh1Yi5pby9ob3ctdG8td3JpdGUtbWFrZWZpbGUvaW5kZXguaHRtbA==">跟我一起写 Makefile — 跟我一起写 Makefile 1.0 文档</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9mYW56aGVuZy5vcmcvYXJjaGl2ZXMvNDM=">Makefile 简明教程 - FanZheng's blog</span></p><p><span class="exturl" data-url="aHR0cHM6Ly9oYWNrZXIteWhqLmdpdGh1Yi5pby9yZXNvdXJjZXMvZ3VuX21ha2UucGRm">https://hacker-yhj.github.io/resources/gun_make.pdf</span></p><blockquote><p>在使用 gcc 编译器开发的时候，会用到 Makefile，那么，就来记录一下 Makefile 的学习。</p><p>首先呢，先说明一下观看顺序，咳咳，其实就是自己学的时候后面发现这样学更有趣味。</p><p><strong>正式入主题：</strong></p><ol><li>先大致看一下上面链接一的内容，先不用深记，只需大概知道有哪些内容，对应在哪个位置就行了，因为后面还要返回去，毕竟大神写的文章细味斟酌，回头品尝又是一番滋味；</li><li>链接二的内容可谓是初学者福利啊（至少对于我来说是这样），作者挑了一些常用的内容列举出来，话不多说，结合例子容易理解，然后可以每学一个内容可以回去翻看链接一大神写的内容，相互结合更好学习</li><li>链接三是另一个大佬整理出来的 GNU make 中文手册</li><li>最后，下文是本人觉得有要用到的一些知识的整理</li></ol></blockquote><h1 id="makefile结构说明"><a class="anchor" href="#makefile结构说明">#</a> Makefile 结构说明</h1><p>Makefile 里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p><ol><li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li><li>隐晦规则。由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由 make 所支持的。</li><li>变量的定义。在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C 语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</li><li>文件指示。其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的 <code>include</code> 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译 <code>#if</code> 一 样；还有就是定义一个多行的命令。</li><li>注释。Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用 <code>#</code> 字符，这个就 像 C/ C++ 中的 <code>//</code> 一样。如果你要在你的 Makefile 中使用 <code>#</code> 字符，可以用反斜杠进行 转义，如： <code>\#</code> 。</li></ol><h1 id="文件说明"><a class="anchor" href="#文件说明">#</a> 文件说明</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>WINDOWS</strong></th><th style="text-align:center"><strong>LINUX</strong></th></tr></thead><tbody><tr><td style="text-align:center">目标文件</td><td style="text-align:center">.obj</td><td style="text-align:center">.o</td></tr><tr><td style="text-align:center">静态库</td><td style="text-align:center">.lib</td><td style="text-align:center">.a</td></tr><tr><td style="text-align:center">动态库</td><td style="text-align:center">.dll</td><td style="text-align:center">.so</td></tr></tbody></table><p>约定俗成，一般开发者使用的 makefile 文件是大写字母开头的 Makefile，使用者使用的是小写的 makefile（<em>默认的情况下，<strong>make</strong> 命令会在当前目录下按顺序找寻文件名为 <strong>“ GNUmakefile ”</strong> 、 <strong>“ makefile ”</strong> 、 <strong>“ Makefile ”</strong> 的文件，找到了就解析这个文件。在这三个文件名中，最好使用 “Makefile” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “ GNUmakefile ” ，这个文件是 GNU 的 make 识别的。有另外一些 make 只对全小写的 “ makefile ” 文件名敏感，但是基本上来说，大多数的 make 都支持 <strong>“ makefile ”</strong> 和 <strong>“ Makefile ”</strong> 这两种默认文件名。<strong>我们也可以使用 <code>make –f filename</code> 指定所要解释的 Makefile 的文件名</strong></em>）</p><h1 id="make-的工作方式"><a class="anchor" href="#make-的工作方式">#</a> <strong>make</strong> 的工作方式</h1><p>- 1. 读入主 Makefile (主 Makefile 中可以引用其他 Makefile)</p><p>- 2. 读入被 include 的其他 Makefile</p><p>- 3. 初始化文件中的变量</p><p>- 4. 推导隐晦规则，并分析所有规则</p><p>- 5. 为所有的目标文件创建依赖关系链</p><p>- 6. 根据依赖关系，决定哪些目标要重新生成</p><p>- 7. 执行生成命令</p><h1 id="makefile-的规则"><a class="anchor" href="#makefile-的规则">#</a> Makefile 的规则</h1><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>target ... : prerequisites ...</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>&lt;tab> command</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>       ...</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>       ...</pre></td></tr></table></figure><p>&quot;目标&quot; 是必需的，不可省略；&quot;前置条件&quot; 和 &quot;命令&quot; 都是可选的，但是两者之中必须至少存在一个。</p><p><strong>Target（目标）</strong></p><p>可以是一个 object file（目标文件），也可以是一个执行文件，还可以是一个标签（label），指明 make 命令所要构建的对象。目标（target）后面必须有冒号 <code>:</code></p><p><strong>Prerequisites（前置条件）</strong></p><p>生成该 target 所依赖的文件和 / 或 target。前置条件通常是一组文件名，之间用空格分隔。它指定了 “目标” 是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 late-modification 时间戳比目标的时间戳新），“目标” 就需要重新构建</p><p><strong>Command（命令）</strong></p><p>该 target 要执行的命令（任意的 Shell 命令）。表示如何更新目标文件，有一行或多行的 Shell 命令组成。它是构建 “目标” 的具体命令，他是运行结果通常就是生成目标文件。每行命令行必须以 tap 键作为开头</p><p>注意：</p><ul><li>必须讲明， <strong>Makefile 的命令是要调用 shell 来运行的</strong> ，而到底是使用的哪个 shell 取决于 Makefile 中 SHELL 变量的设置，默认为 <code>/bin/sh</code> 就是 bash。</li><li><strong>在 Makefile 中使用 bash 的变量。</strong> Makefile 中使用 <code>$()</code> 引用的是 Makefile 内的变量，如果想使用 bash 环境的变量要使用双美元引用 <code>$$</code> ，使用单个 <code>$</code> 引用的变量全部被解释为 Makefile 的变量。以此类推，如果要想试图用 bash 中的进程号码就要使用四个 <code>$</code> ，即： <code>$$$$</code> 。</li><li>另外，值得强调的一点是： <strong>Makefile 是一次发送一行命令，每发送一次命令，就会启动一个 subshell 来运行</strong>。这意味着命令之间不能共享变量，而且 bash 中可以使用的 for 和 while，在这里面也不能换行，因为每行会被单独的发送给 bash 来执行。要解决这个问题，要么使用 Makefile 中的换行符 <code>\</code> ，要么写成单行的形式。</li><li>在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以 Tab 键开头的，那么 make 会认为其是一个空命令。</li></ul><h1 id="注释符"><a class="anchor" href="#注释符">#</a> <code>#</code> 注释符</h1><p><code>#</code> 字符是注释符，Makefile 把 <code>#</code> 字符后面的内容作为注释内容处理（shell、perl 脚本也是使用 <code>#</code> 字符作为注释符）。如果某行的第一个非空字符为 <code>#</code> ，则此行会被 make 解释为注释行（命令行除外，如果 Tab 字符之后使用 <code>#</code> 字符，则会被 make 解释为命令行）。</p><p>注释行的结尾如果存在反斜线 <code>\</code> ，那么下一行也被作为注释行。</p><p>如果需要注视多行，在注释行的结尾加行反斜线 (), 下一行也被注释，可以注释多行。</p><p><strong>建议在书写 Makefile 时将注释作为一个独立的行，而不要和 Makefile 的有效行放在同一行中书写。make 有时候会把 # 字符之前的内容作为有效行的内容（如定义变量的时候）。</strong></p><p>当在 Makefile 中需要使用字符 # 时，可以使用 <code>\</code> 加 <code>#</code> （ <code>\#</code> ）来实现，表示将 <code>#</code> 字符作为一个普通字符而不是注释符。</p><h1 id="gcc常用参数"><a class="anchor" href="#gcc常用参数">#</a> GCC 常用参数</h1><p>**-c：** 只编译不链接，仅生成目标文件</p><p>**-o：** 指定输出文件名</p><p>**-l：** 手动添加链接库</p><p>**-E：** 生成预处理文件</p><p>**-S：** 生成汇编文件</p><p>**-I：** 将系统缺省的头文件路径扩展到当前路径</p><p>**-O2：** 表示我们希望编译器在编译的时候对我们的程序进行一定程度的优化。2 表示我们优化的级别是 2。范围是 1-3（O/ O2/ O3）。不过习惯上我们都使用 2 的优化级别</p><p>**-g：** 生成调试信息</p><p>**-Wall：** 显示警告信息</p><h1 id="基础变量"><a class="anchor" href="#基础变量">#</a> 基础变量</h1><ul><li><code>=</code> 递归展开：变量<strong>只在引用时</strong>才确定它的值，因此这句话在 Makefile 中的任何位置都没有区别，即使它引用了其他变量，除非对自身多次赋值。需要注意避免循环定义</li><li><code>:=</code> 直接展开：变量的值在写这句话时就已经确定。若它引用了其他变量，则直接用那个变量当前的值，而不管该变量在此之后值如何变化</li><li><code>?=</code> 条件赋值：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值，<strong>它是递归展开的</strong></li><li><code>+=</code> 追加赋值：给变量追加内容，<strong>但会在追加内容之前添加一个空格</strong>。它是直接展开还是递归展开取决于该变量上一次赋值的方式</li></ul><h1 id="自动变量automatic-variables"><a class="anchor" href="#自动变量automatic-variables">#</a> 自动变量（Automatic Variables）</h1><ul><li><code>$@</code> ：<strong>表示规则中的目标文件集</strong>。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li><li><code>$%</code> ：仅当目标是函数库文件中，<strong>表示规则中的目标成员名</strong>。例如，如果一个目标是 <code>foo.a(bar.o)</code> ， 那么， <code>$%</code> 就是 <code>bar.o</code> ， <code>$@</code> 就是 <code>foo.a</code> 。如果目标不是函数库文件（Unix 下是 <code>.a</code> ，Windows 下是 <code>.lib</code> ），那么，其值为空。</li><li><code>$&lt;</code> ：<strong>依赖目标中的第一个目标名字</strong>。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li><li><code>$?</code> ：<strong>所有比目标新的依赖目标的集合</strong>。以空格分隔。</li><li><code>$^</code> ：<strong>所有的依赖目标的集合</strong>。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</li><li><code>$+</code> ：这个变量很像 <code>$^</code> ，<strong>也是所有依赖目标的集合；只是它不去除重复的依赖目标</strong>。</li><li><code>$*</code> ：这个变量表示目标模式中 <code>%</code> 及其之前的部分。如果目标是 <code>dir/a.foo.b</code> ，并且目标的模式是 <code>a.%.b</code> ，那么， <code>$*</code> 的值就是 <code>dir/a.foo</code> 。这个变量对于构造有关联的 文件名是比较有较。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出，但是，如果目标文件的 后缀是 make 所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为 <code>.c</code> 是 make 所能识别的后缀名，所以， <code>$*</code> 的值就是 <code>foo</code> 。<strong>这个特性是 GNU make 的， 很有可能不兼容于其它版本的 make</strong>，所以，你应该尽量避免使用 <code>$*</code> ，除非是在隐含规则或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么 <code>$*</code> 就是空值。</li></ul><h1 id="隐晦规则"><a class="anchor" href="#隐晦规则">#</a> 隐晦规则</h1><h2 id="关于命令的变量"><a class="anchor" href="#关于命令的变量">#</a> 关于命令的变量</h2><ul><li>AR : 函数库打包程序。默认命令是 <code>ar</code></li><li>AS : 汇编语言编译程序。默认命令是 <code>as</code></li><li>CC : C 语言编译程序。默认命令是 <code>cc</code></li><li>CXX : C++ 语言编译程序。默认命令是 <code>g++</code></li><li>CO : 从 RCS 文件中扩展文件程序。默认命令是 <code>co</code></li><li>CPP : C 程序的预处理器（输出是标准输出设备）。默认命令是 <code>$(CC) –E</code></li><li>FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 <code>f77</code></li><li>GET : 从 SCCS 文件中扩展文件的程序。默认命令是 <code>get</code></li><li>LEX : Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是 <code>lex</code></li><li>PC : Pascal 语言编译程序。默认命令是 <code>pc</code></li><li>YACC : Yacc 文法分析器（针对于 C 程序）。默认命令是 <code>yacc</code></li><li>YACCR : Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是 <code>yacc –r</code></li><li>MAKEINFO : 转换 Texinfo 源文件（ <code>.texi</code> ）到 Info 文件程序。默认命令是 <code>makeinfo</code></li><li>TEX : 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是 <code>tex</code></li><li>TEXI2DVI : 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是 <code>texi2dvi</code></li><li>WEAVE : 转换 Web 到 TeX 的程序。默认命令是 <code>weave</code></li><li>CWEAVE : 转换 C Web 到 TeX 的程序。默认命令是 <code>cweave</code></li><li>TANGLE : 转换 Web 到 Pascal 语言的程序。默认命令是 <code>tangle</code></li><li>CTANGLE : 转换 C Web 到 C。默认命令是 <code>ctangle</code></li><li>RM : 删除文件命令。默认命令是 <code>rm –f</code></li></ul><h2 id="关于命令参数的变量"><a class="anchor" href="#关于命令参数的变量">#</a> 关于命令参数的变量</h2><p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p><ul><li>ARFLAGS : 函数库打包程序 AR 命令的参数。默认值是 <code>rv</code></li><li>ASFLAGS : 汇编语言编译器参数。（当明显地调用 <code>.s</code> 或 <code>.S</code> 文件时）</li><li>CFLAGS : C 语言编译器参数。</li><li>CXXFLAGS : C++ 语言编译器参数。</li><li>COFLAGS : RCS 命令参数。</li><li>CPPFLAGS : C 预处理器参数。（ C 和 Fortran 编译器也会用到）。</li><li>FFLAGS : Fortran 语言编译器参数。</li><li>GFLAGS : SCCS “get” 程序参数。</li><li>LDFLAGS : 链接器参数。（如： <code>ld</code> ）</li><li>LFLAGS : Lex 文法分析器参数。</li><li>PFLAGS : Pascal 语言编译器参数。</li><li>RFLAGS : Ratfor 程序的 Fortran 编译器参数。</li><li>YFLAGS : Yacc 文法分析器参数。</li></ul><h1 id="make-自动推导"><a class="anchor" href="#make-自动推导">#</a> Make 自动推导</h1><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>foo.o: foo.c foo.h       <span class="token comment"># foo 模块</span></pre></td></tr><tr><td data-num="2"></td><td><pre>gcc <span class="token parameter variable">-c</span> foo.c</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>bar.o: bar.c bar.h </pre></td></tr><tr><td data-num="5"></td><td><pre>gcc <span class="token parameter variable">-c</span> bar.c </pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>main: main.c foo.h bar.h foo.o bar.o </pre></td></tr><tr><td data-num="8"></td><td><pre>gcc main.c <span class="token parameter variable">-o</span> main foo.o bar.o</pre></td></tr></table></figure><p>该例子的场景是：我们要通过 <code>main.c</code> 编译一个叫做 <code>main</code> 的程序，它需要使用 <code>foo.c</code> 和 <code>bar.c</code> 里的函数，同时需要引入相关头文件里的声明。该任务通过 <code>make main</code> 来执行。</p><p><code>foo.o</code> 是我们的目标， <code>foo.c</code> 和 <code>foo.h</code> 是目标所依赖的源文件，而只有一个命令 <code>gcc -c foo.c</code> （以 Tab 键开头）； <code>bar.o</code> 这个目标同理。这个规则告诉我们两件事：</p><ol><li>文件的依赖关系， <code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>foo.h</code> 的文件，如果 foo.c 和 <code>foo.h</code> 的文件日期要比 <code>foo.o</code> 文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖关系发生。</li><li>生成或更新 <code>foo.o</code> 文件，就是那个 gcc 命令。它说明了如何生成 <code>foo.o</code> 这个文件。 （当然， <code>foo.c</code> 文件 include 了 <code>foo.h</code> 文件）</li></ol><p>而 <code>main</code> 的 “依赖” 中有 <code>foo.o</code> 和 <code>bar.o</code> ，它们两个必须先被构建。当我们执行 <code>make main</code> 时，由于 <code>foo.o</code> 和 <code>bar.o</code> 并不存在， <code>make</code> 程序就会在 Makefile 中寻找这两个 “目标” 的构建方法，构建完成后再进行 <code>main</code> 的构建。</p><p>再看一下下面的例子，执行的结果同样跟上面的例子一样</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>foo.o: foo.h </pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>bar.o: bar.h </pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>main: main.c foo.h bar.h foo.o bar.o </pre></td></tr><tr><td data-num="6"></td><td><pre>gcc main.c <span class="token parameter variable">-o</span> main foo.o bar.o</pre></td></tr></table></figure><p>通过对比发现， <code>.o</code> 文件所依赖的 <code>.c</code> 文件省略掉了，同时也把命令省略了，这是为什么呢？</p><p>make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的 make 会自动识别，并自己推导命令。</p><p>只要 make 看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果 make 找到一个 <code>bar.o</code> ，那么 <code>bar.c</code> 就会是 <code>bar.o</code> 的依赖文件。并且 <code>gcc -c bar.c</code> 也会被推导出来，于是，我们的 Makefile 再也不用写得这么复杂；这样就得到了上面第二个例子。这种方法，也就是 make 的 “隐晦规则” 。</p><p>但在日常使用中，我们为什么要像 <code>foo.o: foo.c foo.h</code> 一样将必然存在的文件设置成 “依赖” 呢？<strong>因为 make 存在这样一种机制，如果 “目标” 中的某个 “依赖项” 的修改时间晚于上次 make 该 “目标” 的时间，就说明该 “目标” 过时了，需要重新构建。如果你不把影响该 “目标” 的所有必要的 “依赖” 都写上，那当你修改某个文件后，make 就会因为 “目标” 已存在而不再构建。</strong></p><p>因此， <code>foo.c/foo.h</code> 或 <code>bar.c/bar.h</code> 的修改会导致 <code>foo.o</code> 或 <code>bar.o</code> 过时而重新构建，从而使得 main 也必须重新构建。</p><h1 id="makefile-的伪目标phony"><a class="anchor" href="#makefile-的伪目标phony">#</a> Makefile 的伪目标（.PHONY）</h1><p>(1) 伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。</p><p>(2) 伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。</p><p>(3) 伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用 <code>.PHONY</code> 来明确声明它是伪目标。</p><p>典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标，一般格式如下:</p><figure class="highlight makefile"><figcaption data-lang="makefile"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean   <span class="token comment"># 这句没有也行，但是最好加上</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token target symbol">clean</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    -rm -f *.o</pre></td></tr></table></figure><p>下面列举一些常用的伪目标，如果在自己项目的 Makefile 合理使用这些伪目标的话，可以让我们自己的 Makefile 看起来更专业</p><table><thead><tr><th>伪目标</th><th>含义</th></tr></thead><tbody><tr><td>all</td><td>所有目标的目标，其功能一般是编译所有的目标</td></tr><tr><td>clean</td><td>删除所有被 make 创建的文件</td></tr><tr><td>install</td><td>安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去</td></tr><tr><td>print</td><td>列出改变过的源文件</td></tr><tr><td>tar</td><td>把源程序打包备份，也就是一个 tar 文件</td></tr><tr><td>dist</td><td>创建一个压缩文件，一般是把 tar 文件压成 z 文件，或是 gz 文件</td></tr><tr><td>TAGS</td><td>更新所有的目标，以备完整地重编译使用</td></tr><tr><td>check 或 test</td><td>一般用来测试 Makefile 的流程</td></tr></tbody></table><h1 id="条件语句"><a class="anchor" href="#条件语句">#</a> 条件语句</h1><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>&lt;conditional-directive></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>&lt;text-if-true></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>else</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>&lt;text-if-false></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>endif</pre></td></tr></table></figure><p>其中 <code>&lt;conditional-directive&gt;</code> 表示条件关键字，这个关键字有四个。条件语句的目的是通过判断来决定 Makefile 中的相应位置应该有什么内容</p><ul><li><strong>第一个条件关键字是 <code>ifeq</code> 。语法是：</strong></li></ul><pre><code>ifeq (&lt;arg1&gt;, &lt;arg2&gt;)

ifeq '&lt;arg1&gt;' '&lt;arg2&gt;'

ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;

ifeq &quot;&lt;arg1&gt;&quot; '&lt;arg2&gt;'

ifeq '&lt;arg1&gt;' &quot;&lt;arg2&gt;&quot;
</code></pre><p>比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，相同为真。</p><ul><li><strong>第二个条件关键字是 <code>ifneq</code> 。语法是：</strong></li></ul><pre><code>ifneq (&lt;arg1&gt;, &lt;arg2&gt;)

ifneq '&lt;arg1&gt;' '&lt;arg2&gt;'

ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;

ifneq &quot;&lt;arg1&gt;&quot; '&lt;arg2&gt;'

ifneq '&lt;arg1&gt;' &quot;&lt;arg2&gt;&quot;
</code></pre><p>其比较参数 <code>arg1</code> 和 <code>arg2</code> 的值是否相同，如果不同，则为真；和 <code>ifeq</code> 类似。</p><ul><li><strong>第三个条件关键字是 <code>ifdef</code> 。语法是：</strong></li></ul><pre><code>ifdef &lt;variable-name&gt;
</code></pre><p>如果变量 <code>&lt;variable-name&gt;</code> 的值非空，那到表达式为真。否则，表达式为假。当然， <code>&lt;variable-name&gt;</code> 同样可以是一个函数的返回值。注意， <code>ifdef</code> 只是测试一个变量 是否有值，其并不会把变量扩展到当前位置。</p><ul><li><strong>第四个条件关键字是 <code>ifndef</code> 。其语法是：</strong></li></ul><pre><code>ifndef &lt;variable-name&gt;
</code></pre><p>如果变量 <code>&lt;variable-name&gt;</code> 的值空，那到表达式为真。否则，表达式为假。，和 <code>ifdef</code> 是相反的意思。</p><h1 id="字符串处理函数"><a class="anchor" href="#字符串处理函数">#</a> 字符串处理函数</h1><h2 id="subst"><a class="anchor" href="#subst">#</a> subst</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(subst <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：字符串替换函数</li><li>功能：把字串 <code>&lt;text&gt;</code> 中的 <code>&lt;from&gt;</code> 字符串替换成 <code>&lt;to&gt;</code> 。</li><li>返回：函数返回被替换过后的字符串。</li><li>示例：</li></ul><pre><code>$(subst ee,EE,feet on the street)
</code></pre><p>把 <code>feet on the street</code> 中的 <code>ee</code> 替换成 <code>EE</code> ，返回结果是 <code>fEEt on the strEEt</code> 。</p><h2 id="patsubst"><a class="anchor" href="#patsubst">#</a> patsubst</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(patsubst <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>replacement</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：模式字符串替换函数。</li><li>功能：查找 <code>&lt;text&gt;</code> 中的单词（单词以 “空格”、“Tab” 或 “回车” “换行” 分隔）是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里， <code>&lt;pattern&gt;</code> 可以 包括通配符 <code>%</code> ，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么， <code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串。 （可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符）</li><li>返回：函数返回被替换过后的字符串。</li><li>示例：</li></ul><pre><code>$(patsubst %.c,%.o,x.c.c bar.c)
</code></pre><p>把字串 <code>x.c.c bar.c</code> 符合模式 <code>%.c</code> 的单词替换成 <code>%.o</code> ，返回结果是 <code>x.c.o bar.o</code></p><ul><li>备注：这和我们前面 “变量章节” 说过的相关知识有点相似。如 <code>$(var:&lt;pattern&gt;=&lt;replacement&gt;;)</code> 相当于 <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code> ，而 <code>$(var: &lt;suffix&gt;=&lt;replacement&gt;)</code> 则相当于 <code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code> 。</li></ul><p>例如有:</p><pre><code>objects = foo.o bar.o baz.o，
</code></pre><p>那么， <code>$(objects:.o=.c)</code> 和 ​ <code>$(patsubst %.o,%.c,$(objects))</code> 是一样的。</p><h2 id="strip"><a class="anchor" href="#strip">#</a> strip</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(strip <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：去空格函数。</li><li>功能：去掉 <code>&lt;string&gt;</code> 字串中开头和结尾的空字符。</li><li>返回：返回被去掉空格的字符串值。</li><li>示例：</li></ul><pre><code>$(strip a b c )
</code></pre><p>把字串 <code>a b c&lt;空格&gt;</code> 去掉开头和结尾的空格，结果是 <code>a b c</code> 。</p><h2 id="findstring"><a class="anchor" href="#findstring">#</a> findstring</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(findstring <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>find</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>in</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：查找字符串函数</li><li>功能：在字串 <code>&lt;in&gt;</code> 中查找 <code>&lt;find&gt;</code> 字串。</li><li>返回：如果找到，那么返回 <code>&lt;find&gt;</code> ，否则返回空字符串。</li><li>示例：</li></ul><pre><code>$(findstring a,a b c)
$(findstring a,b c)
</code></pre><p>第一个函数返回 <code>a</code> 字符串，第二个返回空字符串</p><h2 id="filter"><a class="anchor" href="#filter">#</a> filter</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(filter <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern...</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：过滤函数</li><li>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</li><li>返回：返回符合模式 <code>&lt;pattern&gt;</code> 的字串。</li><li>示例：</li></ul><pre><code>sources := foo.c bar.c baz.s ugh.h
foo: $(sources)
    cc $(filter %.c %.s,$(sources)) -o foo
</code></pre><p><code>$(filter %.c %.s,$(sources))</code> 返回的值是 <code>foo.c</code> <code>bar.c</code> <code>baz.s</code> 。</p><h2 id="filter-out"><a class="anchor" href="#filter-out">#</a> filter-out</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(filter-out <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern...</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：反过滤函数</li><li>功能：以 <code>&lt;pattern&gt;</code> 模式过滤 <code>&lt;text&gt;</code> 字符串中的单词，去除符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</li><li>返回：返回不符合模式 <code>&lt;pattern&gt;</code> 的字串。</li><li>示例：</li></ul><pre><code>objects=main1.o foo.o main2.o bar.o
mains=main1.o main2.o
</code></pre><p><code>$(filter-out $(mains),$(objects))</code> 返回值是 <code>foo.o</code> <code>bar.o</code> 。</p><h2 id="sort"><a class="anchor" href="#sort">#</a> sort</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(sort <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：排序函数</li><li>功能：给字符串 <code>&lt;list&gt;</code> 中的单词排序（升序）。</li><li>返回：返回排序后的字符串。</li><li>示例： <code>$(sort foo bar lose)</code> 返回 <code>bar foo lose</code> 。</li><li>备注： <code>sort</code> 函数会去掉 <code>&lt;list&gt;</code> 中相同的单词。</li></ul><h2 id="word"><a class="anchor" href="#word">#</a> word</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(word <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>n</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：取单词函数</li><li>功能：取字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。（从一开始）</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。如果 <code>&lt;n&gt;</code> 比 <code>&lt;text&gt;</code> 中的 单词数要大，那么返回空字符串。</li><li>示例： <code>$(word 2,foo bar baz)</code> 返回值是 <code>bar</code> 。</li></ul><h2 id="wordlist"><a class="anchor" href="#wordlist">#</a> wordlist</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(wordlist <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ss</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>e</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：取单词串函数</li><li>功能：从字符串 <code>&lt;text&gt;</code> 中取从 <code>&lt;ss&gt;</code> 开始到 <code>&lt;e&gt;</code> 的单词串。 <code>&lt;ss&gt;</code> 和 <code>&lt;e&gt;</code> 是一个数字。</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 中从 <code>&lt;ss&gt;</code> 到 <code>&lt;e&gt;</code> 的单词字串。如果 <code>&lt;ss&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数， 那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的单词串。</li><li>示例： <code>$(wordlist 2,3,foo bar baz)</code> 返回值是 <code>bar baz</code> 。</li></ul><h2 id="words"><a class="anchor" href="#words">#</a> words</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(words <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：单词个数统计函数</li><li>功能：统计 <code>&lt;text&gt;</code> 中字符串中的单词个数。</li><li>返回：返回 <code>&lt;text&gt;</code> 中的单词数。</li><li>示例： <code>$(words foo bar baz)</code> 返回值是 <code>3</code> 。</li><li>备注：如果我们要取 <code>&lt;text&gt;</code> 中最后的一个单词，我们可以这样： <code>$(word $(words &lt;text&gt;),&lt;text&gt;)</code> 。</li></ul><h2 id="firstword"><a class="anchor" href="#firstword">#</a> firstword</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(firstword <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：首单词函数 ——firstword。</li><li>功能：取字符串 <code>&lt;text&gt;</code> 中的第一个单词。</li><li>返回：返回字符串 <code>&lt;text&gt;</code> 的第一个单词。</li><li>示例： <code>$(firstword foo bar)</code> 返回值是 <code>foo</code> 。</li><li>备注：这个函数可以用 word 函数来实现： <code>$(word 1,&lt;text&gt;)</code> 。</li></ul><p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中 应用的例子。我们知道，make 使用 <code>VPATH</code> 变量来指定 “依赖文件” 的搜索路径。于是，我们可以 利用这个搜索路径来指定编译器对头文件的搜索路径参数 <code>CFLAGS</code> ，如：</p><pre><code>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))
</code></pre><p>如果我们的 <code>$(VPATH)</code> 值是 <code>src:../headers</code> ，那么 <code>$(patsubst %,-I%,$(subst :, ,$(VPATH)))</code> 将返回 <code>-Isrc -I../headers</code> ， 这正是 cc 或 gcc 搜索头文件路径的参数。</p><h1 id="文件名操作函数"><a class="anchor" href="#文件名操作函数">#</a> 文件名操作函数</h1><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p><h2 id="dir"><a class="anchor" href="#dir">#</a> dir</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(dir <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>names...</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：取目录函数 —— dir。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出目录部分。目录部分是指最后一个反斜杠 <code>/</code> 之前 的部分。如果没有反斜杠，那么返回 <code>./</code> 。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的目录部分。</li><li>示例： <code>$(dir src/foo.c hacks)</code> 返回值是 <code>src/ ./</code> 。</li></ul><h2 id="notdir"><a class="anchor" href="#notdir">#</a> notdir</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(notdir <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>names...</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：取文件函数 —— notdir。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出非目录部分。非目录部分是指最後一个反斜杠 <code>/</code> 之后的部分。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的非目录部分。</li><li>示例： <code>$(notdir src/foo.c hacks)</code> 返回值是 <code>foo.c hacks</code> 。</li></ul><h2 id="suffix"><a class="anchor" href="#suffix">#</a> suffix</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(suffix <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>names...</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：取後缀函数 —— suffix。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的后缀。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的后缀序列，如果文件没有后缀，则返回空字串。</li><li>示例： <code>$(suffix src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>.c .c</code> 。</li></ul><h2 id="basename"><a class="anchor" href="#basename">#</a> basename</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(basename <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>names...</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：取前缀函数 —— basename。</li><li>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的前缀部分。</li><li>返回：返回文件名序列 <code>&lt;names&gt;</code> 的前缀序列，如果文件没有前缀，则返回空字串。</li><li>示例： <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>src/foo src-1.0/bar hacks</code> 。</li></ul><h2 id="addsuffix"><a class="anchor" href="#addsuffix">#</a> addsuffix</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(addsuffix <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>suffix</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>names...</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：加后缀函数 —— addsuffix。</li><li>功能：把后缀 <code>&lt;suffix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</li><li>返回：返回加过后缀的文件名序列。</li><li>示例： <code>$(addsuffix .c,foo bar)</code> 返回值是 <code>foo.c bar.c</code> 。</li></ul><h2 id="addprefix"><a class="anchor" href="#addprefix">#</a> addprefix</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(addprefix <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prefix</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>names...</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：加前缀函数 —— addprefix。</li><li>功能：把前缀 <code>&lt;prefix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</li><li>返回：返回加过前缀的文件名序列。</li><li>示例： <code>$(addprefix src/,foo bar)</code> 返回值是 <code>src/foo src/bar</code> 。</li></ul><h2 id="join"><a class="anchor" href="#join">#</a> join</h2><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(join <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list1</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list2</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><ul><li>名称：连接函数 —— join。</li><li>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中。</li><li>返回：返回连接过后的字符串。</li><li>示例： <code>$(join aaa bbb,111 222 333)</code> 返回值是 <code>aaa111 bbb222 333</code> 。</li></ul><h1 id="foreach-函数"><a class="anchor" href="#foreach-函数">#</a> foreach 函数</h1><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile 中的 foreach 函数 几乎是仿照于 Unix 标准 Shell（/bin/sh）中的 for 语句，或是 C-Shell（/bin/csh）中的 foreach 语句而构建的。它的语法是：</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(foreach <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>var</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>text</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><p>这个函数的意思是，把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code> 所指定的变量中， 然后再执行 <code>&lt;text&gt;</code> 所包含的表达式。每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中， <code>&lt;text&gt;</code> 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， <code>&lt;text&gt;</code> 所返回的 每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。</p><p>所以， <code>&lt;var&gt;</code> 最好是一个变量名， <code>&lt;list&gt;</code> 可以是一个表达式，而 <code>&lt;text&gt;</code> 中一般会 使用 <code>&lt;var&gt;</code> 这个参数来依次枚举 <code>&lt;list&gt;</code> 中的单词。举个例子：</p><pre><code>names := a b c d

files := $(foreach n,$(names),$(n).o)
</code></pre><p>上面的例子中， <code>$(name)</code> 中的单词会被挨个取出，并存到变量 n 中， <code>$(n).o</code> 每次 根据 <code>$(n)</code> 计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回，所以， <code>$(files)</code> 的值是 <code>a.o b.o c.o d.o</code> 。</p><p>注意，foreach 中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach 函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用，其作用域只在 foreach 函数当中。</p><h1 id="if-函数"><a class="anchor" href="#if-函数">#</a> if 函数</h1><p>if 函数很像 GNU 的 make 所支持的条件语句 —— ifeq（参见前面所述的章节），if 函数的语法是：</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(if <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>condition</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>then-part</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><p>或是</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(if <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>condition</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>then-part</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>else-part</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><p>可见，if 函数可以包含 “else” 部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。 <code>&lt;condition&gt;</code> 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真， 于是， <code>&lt;then-part&gt;</code> 会被计算，否则 <code>&lt;else-part&gt;</code> 会被计算。</p><p>而 if 函数的返回值是，如果 <code>&lt;condition&gt;</code> 为真（非空字符串），那个 <code>&lt;then-part&gt;</code> 会是整个函数的返回值，如果 <code>&lt;condition&gt;</code> 为假（空字符串），那么 <code>&lt;else-part&gt;</code> 会是 整个函数的返回值，此时如果 <code>&lt;else-part&gt;</code> 没有被定义，那么，整个函数返回空字串。</p><p>所以， <code>&lt;then-part&gt;</code> 和 <code>&lt;else-part&gt;</code> 只会有一个被计算。</p><h1 id="call函数"><a class="anchor" href="#call函数">#</a> call 函数</h1><p>call 函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中， 你可以定义许多参数，然后你可以 call 函数来向这个表达式传递参数。其语法是：</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>$(call <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>expression</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parm1</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parm2</span><span class="token punctuation">></span></span>,...,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parmn</span><span class="token punctuation">></span></span>)</pre></td></tr></table></figure><p>当 make 执行这个函数时， <code>&lt;expression&gt;</code> 参数中的变量，如 $(1) 、 $(2) 等，会 被参数 <code>&lt;parm1&gt;</code> 、 <code>&lt;parm2&gt;</code> 、 <code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的 返回值就是 call 函数的返回值。例如：</p><pre><code>reverse =  $(1) $(2)

foo = $(call reverse,a,b)
</code></pre><p>那么， <code>foo</code> 的值就是 <code>a b</code> 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p><pre><code>reverse =  $(2) $(1)

foo = $(call reverse,a,b)
</code></pre><p>此时的 <code>foo</code> 的值就是 <code>b a</code> 。</p><p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第 2 个及其之后的 参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格。</p><div class="tags"><a href="/tags/history/" rel="tag"><i class="ic i-tag"></i> history</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-01-11 22:58:35" itemprop="dateModified" datetime="2023-01-11T22:58:35+08:00">2023-01-11</time></span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="docs/Essay/来学点 Makefile/" class="item leancloud_visitors" data-flag-title="来学点 Makefile" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span id="busuanzi_value_page_pv"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="夏沫の浅雨 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="夏沫の浅雨 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>夏沫の浅雨 <i class="ic i-at"><em>@</em></i>命运转轮</li><li class="link"><strong>本文链接：</strong> <a href="https://arachnid.cc/docs/Essay/%E6%9D%A5%E5%AD%A6%E7%82%B9%20Makefile/" title="来学点 Makefile">https://arachnid.cc/docs/Essay/来学点 Makefile/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/docs/Essay/ADC%E9%87%87%E6%A0%B7%E5%80%BC%E8%BD%AC%E5%8C%96%E6%88%90%E7%94%B5%E5%8E%8B%E5%80%BC%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;arachnid.cc&#x2F;picture&#x2F;(19).webp" title="ADC采样值转化成电压值详解"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>ADC采样值转化成电压值详解</h3></a></div><div class="item right"><a href="/docs/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/DMX512%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;arachnid.cc&#x2F;picture&#x2F;(17).webp" title="DMX512协议"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>DMX512协议</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#makefile%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">Makefile 结构说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">文件说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#make-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">make 的工作方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#makefile-%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">Makefile 的规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text"># 注释符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gcc%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">GCC 常用参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8F%98%E9%87%8F"><span class="toc-number">7.</span> <span class="toc-text">基础变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8Fautomatic-variables"><span class="toc-number">8.</span> <span class="toc-text">自动变量（Automatic Variables）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E6%99%A6%E8%A7%84%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">隐晦规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">9.1.</span> <span class="toc-text">关于命令的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">9.2.</span> <span class="toc-text">关于命令参数的变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#make-%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC"><span class="toc-number">10.</span> <span class="toc-text">Make 自动推导</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#makefile-%E7%9A%84%E4%BC%AA%E7%9B%AE%E6%A0%87phony"><span class="toc-number">11.</span> <span class="toc-text">Makefile 的伪目标（.PHONY）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">字符串处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#subst"><span class="toc-number">13.1.</span> <span class="toc-text">subst</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#patsubst"><span class="toc-number">13.2.</span> <span class="toc-text">patsubst</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strip"><span class="toc-number">13.3.</span> <span class="toc-text">strip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#findstring"><span class="toc-number">13.4.</span> <span class="toc-text">findstring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter"><span class="toc-number">13.5.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter-out"><span class="toc-number">13.6.</span> <span class="toc-text">filter-out</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort"><span class="toc-number">13.7.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#word"><span class="toc-number">13.8.</span> <span class="toc-text">word</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wordlist"><span class="toc-number">13.9.</span> <span class="toc-text">wordlist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#words"><span class="toc-number">13.10.</span> <span class="toc-text">words</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#firstword"><span class="toc-number">13.11.</span> <span class="toc-text">firstword</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">文件名操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dir"><span class="toc-number">14.1.</span> <span class="toc-text">dir</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notdir"><span class="toc-number">14.2.</span> <span class="toc-text">notdir</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suffix"><span class="toc-number">14.3.</span> <span class="toc-text">suffix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#basename"><span class="toc-number">14.4.</span> <span class="toc-text">basename</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addsuffix"><span class="toc-number">14.5.</span> <span class="toc-text">addsuffix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addprefix"><span class="toc-number">14.6.</span> <span class="toc-text">addprefix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-number">14.7.</span> <span class="toc-text">join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#foreach-%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">foreach 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if-%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">if 函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#call%E5%87%BD%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">call 函数</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="夏沫の浅雨" data-src="/images/avatar.jpg"><p class="name" itemprop="name">夏沫の浅雨</p><div class="description" itemprop="description">不曾亏欠，不曾辜负，如此足矣</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">52</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">17</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyYWNobmlkLTk3" title="https:&#x2F;&#x2F;github.com&#x2F;Arachnid-97"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友人帐</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-info-circle"></i>关于</a></li><li class="item"><a href="/atom.xml" rel="section"><i class="ic i-magic"></i>RSS</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/docs/Essay/ADC%E9%87%87%E6%A0%B7%E5%80%BC%E8%BD%AC%E5%8C%96%E6%88%90%E7%94%B5%E5%8E%8B%E5%80%BC%E8%AF%A6%E8%A7%A3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/docs/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/DMX512%E5%8D%8F%E8%AE%AE/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/modbus/" title="分类于 modbus">modbus</a></div><span><a href="/docs/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/Modbus%E5%AE%B6%E6%97%8F%E4%B9%8B%E5%BC%80%E7%AF%87/" title="Modbus家族之开篇">Modbus家族之开篇</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/RTOS/" title="分类于 FreeRTOS">FreeRTOS</a></div><span><a href="/docs/RTOS/FreeRTOS%20%E7%AF%87%E7%AB%A0%E4%B9%8B%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/" title="FreeRTOS 篇章之任务管理">FreeRTOS 篇章之任务管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/RTOS/" title="分类于 FreeRTOS">FreeRTOS</a></div><span><a href="/docs/RTOS/FreeRTOS%20%E7%AF%87%E7%AB%A0%E4%B9%8B%20FreeRTOSConfig.h%E5%88%86%E6%9E%90/" title="FreeRTOS 篇章之 FreeRTOSConfig.h分析">FreeRTOS 篇章之 FreeRTOSConfig.h分析</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/docs/Linux/%E5%9F%BA%E4%BA%8E%E5%AE%98%E6%96%B9%E6%8C%87%E5%AF%BC%E5%AE%89%E8%A3%85%20Arch%20Linux/" title="基于官方指导安装 Arch Linux">基于官方指导安装 Arch Linux</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a></div><span><a href="/docs/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%EF%BC%88%E7%BA%AFC%E5%AE%9E%E7%8E%B0%EF%BC%89/" title="常用滤波算法（纯C实现）">常用滤波算法（纯C实现）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/docs/Electronic/%E4%B8%89%E5%A4%A7%E6%97%A0%E6%BA%90%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E9%98%BB/" title="三大无源器件之电阻">三大无源器件之电阻</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/docs/markdown%E8%AF%AD%E6%B3%95%E6%B5%8B%E8%AF%95/" title="markdown语法测试">markdown语法测试</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/docs/Essay/Cortex-M3M4M7%20%E6%95%85%E9%9A%9C%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/" title="Cortex-M3&#x2F;M4&#x2F;M7 故障异常分析">Cortex-M3/M4/M7 故障异常分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hexo/" title="分类于 Hexo-shoka">Hexo-shoka</a></div><span><a href="/docs/Hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E4%B9%8B%20shoka%E9%85%8D%E7%BD%AE/" title="博客搭建笔记之 shoka配置">博客搭建笔记之 shoka配置</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/docs/EDA/Altium%20Designer%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/" title="Altium Designer常用总结">Altium Designer常用总结</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">夏沫の浅雨 @ Arachnid's blog</span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="count"><span class="icon"><i class="ic i-person"></i> <span id="busuanzi_value_site_uv"></span>人 <span class="post-meta-divider">|</span> <span class="icon"><i class="ic i-eye"></i> <span id="busuanzi_value_site_pv"></span>次 <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">358k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:06</span></span></span></div><div class="create_time"><span class="icon"><i class="ic i-clock"></i> <span id="timeDate">正在加载</span> <span id="times">...</span><script>function createtime(){var n=new Date("04/28/2022 15:45:50");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML=" 本站存活 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script></span></div><div class="powered-by">Powered-by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"docs/Essay/来学点 Makefile/",favicon:{show:"ψ(｀∇´)ψ 欢迎回来!",hide:"《原子弹入门及制造》"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script async src="/js/sakura-small.js"></script><script src="/js/combined-file.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:210,height:380,hOffset:50,vOffset:-25},mobile:{show:!1,scale:.5},react:{opacityDefault:.7,opacityOnHover:.8},log:!1})</script></body></html><!-- rebuild by hrmmi -->