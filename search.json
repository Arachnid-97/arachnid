[{"title":"POSIX 线程设计应用","url":"/posix-pthread/","content":"\n\n\n# 线程管理\n\n## 基本操作\n\n### pthread_create\n\n创建一个线程\n\n```c\n#include <pthread.h>\n\nint pthread_create(pthread_t *restrict thread,\n                   const pthread_attr_t *restrict attr,\n                   void *(*start_routine)(void *),\n                   void *restrict arg);\n```\n\nParameter：\n\n- thread --- 返回一个唯一的线程 ID\n- attr --- 可以指定线程属性对象，或者以 NULL 为缺省值\n- start_routine --- 线程执行函数\n- arg --- 为 `start_routine` 传递的参数，NULL 为缺省值\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EAGAIN --- 资源不足或超出创建线程数，无法创建\n- EINVAL --- 无效 `attr` 参数属性\n- EPERM --- 没有权限设置调度策略和 `attr` 中的参数\n\nnote：当 `attr` 属性为缺省 NULL 时，此线程默认为 `joinable` 属性。 \n\n\n\n### pthread_self\n\n获取调用线程的 ID；可以查看一个线程自己的线程 ID，需要知道的是线程也有 ID 的，且具有唯一的线程 ID\n\n```c\n#include <pthread.h>\n\npthread_t pthread_self(void);\n```\n\nReturn：\n\n- 此函数始终成功，返回调用线程的 ID\n\n\n\n### pthread_equal\n\n比较俩个线程 ID，当线程 ID 相同时返回非 0，不同时返回 0\n\n```c\n#include <pthread.h>\n\nint pthread_equal(pthread_t t1, pthread_t t2);\n```\n\nParameter：\n\n- t1 and t2：线程的 ID\n\nReturn：\n\n- nonzero --- 俩线程 ID 相等\n- zero --- 俩线程 ID 不同\n\n\n\n### pthread_join\n\n线程可以是 joinable 或 detached 的。 如果一个线程是 joinable，那么另一个线程可以调用 `pthread_join()` 等待该线程终止（挂起当前线程，阻塞式等待线程结束，如果线程已结束则立即返回）\n\n```c\n#include <pthread.h>\n\nint pthread_join(pthread_t thread, void **retval);\n```\n\nParameter：\n\n- thread --- 需要终止的线程 ID\n- retval --- 退出的状态返回值，用于提供给 `pthread_exit()`\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EDEADLK --- 检测到死锁或自身调用\n- EINVAL --- 该线程非 joinable 线程或另一个线程已经在等待加入这个线程\n- ESRCH --- 传入的 `thread` 参数是不存在的线程 ID\n\n\n\n### pthread_detach\n\n用于把 joinable 线程转变为 detached 线程，一旦把 joinable 线程被设置为 detached 的，那么这个线程就不能被 `pthread_join()` 调用\n\n```c\n#include <pthread.h>\n\nint pthread_detach(pthread_t thread);\n```\n\nParameter：\n\n- thread --- 需要修改的线程 ID\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EINVAL --- 该线程非 joinable 线程\n- ESRCH --- 传入的 `thread` 参数是不存在的线程 ID\n\n\n\n### pthread_exit\n\n终止线程，也就是终止自己的执行\n\n```c\n#include <pthread.h>\n\nvoid pthread_exit(void *retval);\n```\n\nParameter：\n\n- retval --- 由 `pthread_join()` 提供参数，或以 NULL 为缺省值自身调用结束\n\n\n\n## 参数配置\n\n### pthread_attr_t\n\n`pthread_attr_t` 数据类型，以下函数都调用该结构属性：\n\n```c\ntypedef struct\n{\n       int                       detachstate;   // 线程的分离状态\n       int                       schedpolicy;   // 线程的调度策略\n       structsched_param         schedparam;    // 线程的优先级\n       int                       inheritsched;  // 线程的继承性\n       int                       scope;         // 线程的作用域\n       size_t                    guardsize;     // 线程栈的警戒缓冲区大小\n       int                       stackaddr_set; // 线程的栈设置\n       void*                     stackaddr;     // 线程栈的地址\n       size_t                    stacksize;     // 线程栈的大小\n} pthread_attr_t;\n```\n\n- detachstate：表示新线程是否与进程中其他线程脱离同步， 如果设置为 `PTHREAD_CREATE_DETACHED` 则新线程不能用 `pthread_join()` 来同步，且在退出时自行释放所占用的资源；缺省为 `PTHREAD_CREATE_JOINABLE` 状态。\n\n  这个属性也可以在线程创建并运行以后用 `pthread_detach()` 来设置，而一旦设置为 `PTHREAD_CREATE_DETACH` 状态（不论是创建时设置还是运行时设置）则不能再恢复到 `PTHREAD_CREATE_JOINABLE` 状态。\n\n- schedpolicy：表示新线程的调度策略，主要包括 `SCHED_OTHER`（正常、非实时）、`SCHED_RR`（实时、轮转法）和 `SCHED_FIFO`（实时、先入先出）三种，缺省为 `SCHED_OTHER`，后两种调度策略仅对超级用户有效；运行时可以用过 `pthread_setschedparam()` 来改变。\n\n- schedparam：一个 `struct sched_param` 结构，目前仅有一个 `sched_priority` 整型变量表示线程的运行优先级。这个参数仅当调度策略为实时（即 `SCHED_RR` 或 `SCHED_FIFO` ）时才有效，并可以在运行时通过 `pthread_setschedparam()` 函数来改变，缺省为 0。\n\n- inheritsched：有两种值可供选择：`PTHREAD_EXPLICIT_SCHED` 和 `PTHREAD_INHERIT_SCHED` ，前者表示新线程使用显式指定调度策略和调度参数（即由 `schedpolicy` 和 `schedparam` 属性确定），而后者表示继承调用者线程的调度策略和调度参数。缺省为 `PTHREAD_EXPLICIT_SCHED` 。\n\n- scope：表示线程间竞争 CPU 的范围，也就是说线程优先级的有效范围。POSIX 的标准中定义了两个值：`PTHREAD_SCOPE_SYSTEM` 和 `PTHREAD_SCOPE_PROCESS` ，前者表示与系统中所有线程一起竞争资源（CPU 等），后者表示仅与同一进程中的线程竞争资源（CPU 等）。目前 LinuxThreads 仅实现了 `PTHREAD_SCOPE_SYSTEM` 值。\n\n- guardsize：控制着线程栈保护区大小，以避免栈溢出，默认设置为系统的页大小。\n\n  可以把 `guardsize` 线程属性设为 0，从而不允许属性的这种特征行为发生：在这种情况下不会提供警戒缓存区。同样地，如果对线程属性 `stackaddr` 作了修改，系统就会假设我们会自己管理栈，并使警戒栈缓冲区机制无效，等同于把 `guardsize` 线程属性设为 0。\n\n  如果 `guardsize` 大于零，则会为每个使用 attr 创建的线程提供大小至少为 `guardsize` 字节的溢出保护区。\n\n- stackaddr_set：\n\n- stackaddr：该属性设置新线程所用栈的栈地址。\n\n- stacksize：该属性设置新线程所用栈的栈大小。\n\n\n\n### pthread_attr_init\n\n线程属性初始化\n\n```c\n#include <pthread.h>\n\nint pthread_attr_init(pthread_attr_t *attr);\n```\n\n\n\n### pthread_attr_destroy\n\n销毁线程属性对象\n\n```c\n#include <pthread.h>\n\nint pthread_attr_destroy(pthread_attr_t *attr);\n```\n\n\n\n### 设置 / 获取线程的分离状态\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\n// detachstate：PTHREAD_CREATE_DETACHED or PTHREAD_CREATE_JOINABLE\n\nint pthread_attr_setdetachstate(pthread_attr_t *attr,\n                                int detachstate);\n\nint pthread_attr_getdetachstate(const pthread_attr_t *attr,\n                                int *detachstate);\n```\n\n\n\n### 设置 / 获取线程的调度策略\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\n// policy：SCHED_FIFO, SCHED_RR or SCHED_OTHER\n\nint pthread_attr_setschedpolicy(pthread_attr_t *attr,\n                                int policy);\n\nint pthread_attr_getschedpolicy(const pthread_attr_t *restrict attr,\n                                int *restrict policy);\n```\n\n\n\n### 设置 / 获取线程的优先级\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\nint pthread_attr_setschedparam(pthread_attr_t *restrict attr,\n                               const struct sched_param *restrict param);\n\nint pthread_attr_getschedparam(const pthread_attr_t *restrict attr,\n                               struct sched_param *restrict param);\n```\n\n所用系统支持的优先级最大最小值可以使用如下函数查询：\n\n```c\n#include <sched.h>\n\nint sched_get_priority_max(int policy);\nint sched_get_priority_min(int policy);\n```\n\n**note：**\n\n该属性值仅当调度策略为实时（即 SCHED_RR 或 SCHED_FIFO ）时才有效，因此一般使用以下函数设置优先级：\n\n```c\n#include <pthread.h>\n\nstruct sched_param sched;\nsched.sched_priority = -1;\npthread_t pidtake;\n\n\npthread_create(&pidtake, NULL, thread_take, NULL);\npthread_setschedparam(pidtake, SCHED_RR, &sched);\n```\n\n\n\n### 设置 / 获取线程的继承性\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\n// inheritsched：PTHREAD_INHERIT_SCHED or PTHREAD_EXPLICIT_SCHED\n\nint pthread_attr_setinheritsched(pthread_attr_t *attr,\n                                 int inheritsched);\n\nint pthread_attr_getinheritsched(const pthread_attr_t *restrict attr,\n                                 int *restrict inheritsched);\n```\n\n\n\n### 设置 / 获取线程的作用域\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\n// scope：PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS\n\nint pthread_attr_setscope(pthread_attr_t *attr,\n                          int scope);\n\nint pthread_attr_getscope(const pthread_attr_t *restrict attr,\n                          int *restrict scope);\n```\n\n\n\n### 设置 / 获取线程栈保护区大小\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\nint pthread_attr_setguardsize(pthread_attr_t *attr,\n                              size_t guardsize);\n\nint pthread_attr_getguardsize(const pthread_attr_t *restrict attr,\n                              size_t *restrict guardsize);\n```\n\n\n\n### 设置 / 获取线程的内存区域\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\nint pthread_attr_setstackaddr(pthread_attr_t *attr,\n                              void *stackaddr);\n\nint pthread_attr_getstackaddr(const pthread_attr_t *restrict attr,\n                              void **restrict stackaddr);\n```\n\n\n\n### 设置 / 获取线程的栈大小\n\n该属性值设置及获取由如下两个函数进行：\n\n```c\n#include <pthread.h>\n\nint pthread_attr_setstacksize(pthread_attr_t *attr,\n                              size_t stacksize);\n\nint pthread_attr_getstacksize(const pthread_attr_t *restrict attr,\n                              size_t *restrict stacksize);\n```\n\n\n\n# 信号量\n\n## sem_init\n\n初始化一个匿名信号量\n\n```c\n#include <semaphore.h>\n\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n```\n\nParameter：\n\n- sem --- 返回一个信号量\n- pshared --- 为 0 表示该信号量在某个进程中的多个线程之间共享，该信号量应当能够被所有的线程访问，例如是一个全局变量或者是在堆上动态分配的变量；若不为 0 ，表示在进程间共享，那么该信号量应该位于共享内存的区域中\n- value --- 指定信号量的初始值\n\nReturn：\n\n- zero --- success\n- nonzero（-1） --- error\n\n\n\n## sem_wait / sem_trywait / sem_timedwait\n\n锁定给定的信号量\n\n对于 `sem_wait` ，如果信号量的值 `sval` 大于 0 ，`sem_wait` 会对 `sval` 减 1 ，函数立即返回。如果 `sval` 为 0 ，`sem_wait` 将阻塞调用者（某个进程或线程），直到 `sval` 重新大于 0 或者调用者被 Linux 系统中的系统调用 `signal()` 函数中断 。\n\n对于 `sem_trywait` ，如果对 `sval` 的减 1 操作不能完成，`sem_trywait` 不会阻塞调用者，而是返回一个 `error`，并设置 `errno` 为 `EAGAIN` 。\n\n对于 `sem_timedwait` ，如果 `sval` 为 0，则阻塞等待，当阻塞时长超过 `abs_timeout` 返回失败（ `errno` 设置为 `ETIMEDOUT` ） 。\n\n```c\n#include <semaphore.h>\n\nstruct timespec {\n    time_t tv_sec;      /* Seconds */\n    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */\n};\n\nint sem_wait(sem_t *sem);\nint sem_trywait(sem_t *sem);\nint sem_timedwait(sem_t *restrict sem,\n                  const struct timespec *restrict abs_timeout);\n```\n\nParameter：\n\n- sem --- 需加锁的信号量\n- abs_timeout --- `struct timespec` 结构的超时时间值\n\nReturn：\n\n- zero --- success\n- nonzero（-1） --- error\n\n\n\n## sem_post\n\n释放给定的信号量，对信号量的值 `sem_val` 进行加 1 操作，如果该信号量的值最终大于 0 ，则唤醒被 `semwait()` 阻塞的另一个进程或线程，并重新锁定该信号量\n\n```c\n#include <semaphore.h>\n\nint sem_post(sem_t *sem);\n```\n\nParameter：\n\n- sem --- 需解锁的信号量\n\nReturn：\n\n- zero --- success\n- nonzero（-1） --- error\n\n\n\n## sem_getvalue\n\n获取给定信号量的值\n\n```c\n#include <semaphore.h>\n\nint sem_getvalue(sem_t *restrict sem, int *restrict sval);\n```\n\nParameter：\n\n- sem --- 需获取的信号量\n- sval --- 返回的当前信号量的值\n\nReturn：\n\n- zero --- success\n- nonzero（-1） --- error\n\n\n\n## sem_destroy\n\n销毁一个匿名信号量\n\n```c\n#include <semaphore.h>\n\nint sem_destroy(sem_t *sem);\n```\n\nParameter：\n\n- sem --- 需销毁的信号量\n\nReturn：\n\n- zero --- success\n- nonzero（-1） --- error\n\n\n\n# 互斥锁\n\n在多线程编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。 每个对象都对应于一个可称为 \"互斥锁\" 的标记，这个标记用来保证在任一时刻， 只能有一个线程访问该对象。**互斥锁也可以叫线程锁**。\n\n## 基本操作\n\n### PTHREAD_MUTEX_INITIALIZER\n\n静态初始化互斥锁\n\n```c\n# define PTHREAD_MUTEX_INITIALIZER \\\n   { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }\n```\n\neg：\n\n```c\npthread_mutex_t s_mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n\n\n\n### pthread_mutex_init\n\n动态初始化互斥锁\n\n```c\n#include <pthread.h>\n\nint pthread_mutex_init(pthread_mutex_t *mutex,\n                       const pthread_mutexattr_t *mutexattr);\n```\n\nParameter：\n\n- mutex --- 返回一个唯一的互斥锁 ID\n- mutexattr --- 可以指定互斥锁属性对象，或者以 NULL 为缺省值\n\nReturn：\n\n- zero --- 此函数始终成功\n\n\n\n### pthread_mutex_lock\n\n锁定给定的互斥锁，阻塞调用。如果这个互斥锁此时正在被其它线程占用， 那么 `pthread_mutex_lock()` 调用会进入到这个互斥锁的等待队列中，并会进入阻塞状态， 直到拿到该锁之后才会返回。\n\n```c\n#include <pthread.h>\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n```\n\nParameter：\n\n- mutex --- 需加锁的互斥锁 ID\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EINVAL --- 未正确初始化\n- EDEADLK --- 互斥锁已经被调用线程锁定（仅 `PTHREAD_MUTEX_ERRORCHECK` 类型互斥锁）\n\n\n\n### pthread_mutex_trylock\n\n锁定给定的互斥锁，**非**阻塞调用。当请求的锁正在被占用的时候， 不会进入阻塞状态，而是立刻返回，并返回一个错误代码 `EBUSY`，意思是说， 有其它线程正在使用这个锁。\n\n```c\n#include <pthread.h>\n\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n```\n\nParameter：\n\n- mutex --- 需加锁的互斥锁 ID\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EBUSY --- 互斥锁无法获取，因为目前已被锁定占用\n\n- EINVAL --- 未正确初始化\n\n\n\n### pthread_mutex_unlock\n\n释放给定的互斥锁\n\n```c\n#include <pthread.h>\n\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n\nParameter：\n\n- mutex --- 需解锁的互斥锁 ID\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EINVAL --- 未正确初始化\n- EPERM --- 调用线程未拥有互斥锁（仅 `PTHREAD_MUTEX_ERRORCHECK` 类型互斥锁）\n\n\n\n### pthread_mutex_destroy\n\n销毁由 `pthread_mutex_init` 动态初始化的互斥锁，释放它可能持有的资源\n\n```c\n#include <pthread.h>\n\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n```\n\nParameter：\n\n- mutex --- 需销毁的互斥锁 ID\n\nReturn：\n\n- zero --- success\n- nonzero --- error code on Errors\n\nErrors：\n\n- EBUSY --- 互斥锁目前已被锁定占用，无法进行销毁\n\n\n\n## 参数配置\n\n### pthread_mutexattr_t\n\n`pthread_mutexattr_t` 数据类型，以下函数都调用该结构属性：\n\n```c\n/* Data structures for mutex handling.  The structure of the attribute\n   type is not exposed on purpose.  */\ntypedef union\n{\n    struct __pthread_mutex_s\n    {\n        int __lock;\n        unsigned int __count;\n        int __owner;\n#if __WORDSIZE == 64\n        unsigned int __nusers;\n#endif\n        /* KIND must stay at this position in the structure to maintain\n           binary compatibility.  */\n        int __kind;\n#if __WORDSIZE == 64\n        int __spins;\n        __pthread_list_t __list;\n# define __PTHREAD_MUTEX_HAVE_PREV  1\n#else\n        unsigned int __nusers;\n        __extension__ union\n        {\n            int __spins;\n            __pthread_slist_t __list;\n        };\n#endif\n    } __data;\n    char __size[__SIZEOF_PTHREAD_MUTEX_T];\n    long int __align;\n} pthread_mutex_t;\n```\n\n\n\n### pthread_mutexattr_init\n\n互斥锁属性初始化\n\n```c\n#include <pthread.h>\n\nint pthread_mutexattr_init(pthread_mutexattr_t *attr);\n```\n\n\n\n### pthread_mutexattr_destroy\n\n销毁互斥锁属性对象\n\n```c\n#include <pthread.h>\n\nint pthread_mutexattr_destroy(pthread_mutexattr_t *attr);\n```\n\n\n\n### pthread_mutexattr_settype\n\n设置互斥锁类型属性\n\n```c\n#include <pthread.h>\n\nint pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);\n```\n\n如果互斥锁类型为 `PTHREAD_MUTEX_NORMAL`，则不提供死锁检测。尝试重新锁定互斥锁会导致死锁。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或未锁定，则将产生不确定的行为。\n\n如果互斥锁类型为 `PTHREAD_MUTEX_ERRORCHECK`，则会提供错误检查。如果某个线程尝试重新锁定的互斥锁已经由该线程锁定，则将返回错误。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。\n\n如果互斥锁类型为 `PTHREAD_MUTEX_RECURSIVE`，则该互斥锁会保留锁定计数这一概念。线程首次成功获取互斥锁时，锁定计数会设置为 1。线程每重新锁定该互斥锁一次，锁定计数就增加 1。线程每解除锁定该互斥锁一次，锁定计数就减小 1。 锁定计数达到 0 时，该互斥锁即可供其他线程获取。如果某个线程尝试解除锁定的互斥锁不是由该线程锁定或者未锁定，则将返回错误。\n\n如果互斥锁类型是 `PTHREAD_MUTEX_DEFAULT`，则尝试以递归方式锁定该互斥锁将产生不确定的行为。对于不是由调用线程锁定的互斥锁，如果尝试解除对它的锁定，则会产生不确定的行为。如果尝试解除锁定尚未锁定的互斥锁，则会产生不确定的行为。\n\n\n\n# 条件变量\n\n\n\n\n\n# 读写锁\n\n\n\n\n\n# 自旋锁\n\n\n\n\n\n\n\n","tags":["Linux"]},{"title":"Linux 设备常用操作","url":"/linux-device-common-operation/","content":"\n\n\n# 串口测试\n\n1、获取串口号\n\n一般串口都是以 `/dev/ttyS#` 的格式显示，所以第一个连接的串口就是 `/dev/ttyS0`，第二个连接的串口就是 `/dev/ttyS1` … 以此类推。\n\nUSB 转串口适配，没有额外驱动，它们会显示为 `/dev/ttyUSB#`，如 `/dev/ttyUSB0` 。\n\n可以通过如下命令获取：\n\n```bash\nls -l /dev/ttyS*\n```\n\nnote：\n\n一般来说，通过 `ls -l /dev/ttyS*` 获取出来的串口是包含虚拟串口和存在但未连接的串口，这时候可以通过 `cat /proc/tty/driver/serial` 来获取真实连接的串口，或者使用 `dmesg | grep ttyS*` 来查看， eg：\n\n```bash\nroot@debian:/# ls -l /dev/ttyS*\ncrw-rw---- 1 root dialout 4, 64 Oct 25 19:29 /dev/ttyS0\ncrw-rw---- 1 root dialout 4, 65 Oct 25 19:29 /dev/ttyS1\ncrw-rw---- 1 root dialout 4, 66 Oct 25 19:29 /dev/ttyS2\ncrw-rw---- 1 root dialout 4, 67 Oct 25 19:29 /dev/ttyS3\nroot@debian:/# cat /proc/tty/driver/serial\nserinfo:1.0 driver revision:\n0: uart:16550A port:000003F8 irq:4 tx:0 rx:0\n1: uart:unknown port:000002F8 irq:3\n2: uart:unknown port:000003E8 irq:4\n3: uart:unknown port:000002E8 irq:3\nroot@debian:/#\nroot@debian:/# dmesg | grep ttyS*\n[    0.095756] printk: console [tty0] enabled\n[    2.520985] 00:01: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A\n[   11.074576] systemd[1]: Created slice system-getty.slice.\nroot@debian:/#\n```\n\n串口0 的 uart 值时 16550A，tx 值为 0，rx 值也为 0，因此我们断定本机只有一个串口，是串口 0，即 ttyS0。\n\n2、配置属性\n\n使用 `stty` 命令来更改配置串口属性（详情查看 `man stty`），比如我们设置串口 `/dev/ttyS0` 波特率为 `115200` 和 `odd parity`，命令如下：\n\n```bash\nstty -F /dev/ttyS0 115200 parodd\n```\n\n3、读写操作\n\n使用 `echo` 向串口发送数据，如：\n\n```bash\necho “command” > /dev/ttyS0\n```\n\n利用 `cat` 来监听串口中的数据，如：\n\n```bash\ncat /dev/ttyS0\n```\n\n监听数据并保存到 txt 文本中，如：\n\n```bash\ncat /dev/ttyS0 > file.txt\n```\n\nnote：接受信息的时候，对方发送需要加入换行符才能真正收到，否则只是存在接收缓冲区中而并未显示。\n\n\n\n# CAN 测试\n\n1、获取 CAN 设备\n\n```bash\nip a\n```\n\n通常 CAN 设备以 `can#` 的格式显示，eg：`can0` 。\n\n2、配置属性\n\n使用 `ip link set` 对 CAN 设备进行配置，这里设置 `can0` 波特率为 `500Kbps` ，自动重启时间为 `10ms` ，其中 `up` 表示打开该端口。\n\n```bash\nip link set can0 up type can bitrate 500000 restart-ms 10\n```\n\n常见可选：\n\n`triple-sampling on` ：表示打开 3 次采样，在较低波特率下，建议使用该参数。 如果波特率较高，例如高达到 500Kbps 以上，建议将其关闭。\n\n`restart-ms` ：自动重启的频率。\n\nnote：\n\n使用 `ip -details link show can#` 可以获取详细的参数。 \n\n3、读写操作\n\n使用 `cansend` 发送数据，如：\n\n```bash\ncansend can0 123#1122334455667788\n```\n\n其中，`can0` 表示要使用的 CAN 接口，`123` 表示 CAN ID，`#` 后面的数字表示发送的数据，这里是 16 进制格式的数据。\n\n利用 `candump` 来监听 CAN 总线上的数据，如：\n\n```bash\ncandump can0\n```\n\n4、自动使能 CAN 总线\n\nLinux 上 CAN 总线接口总是以网络设备形式呈现的，默认系统启动时 CAN 总线处于 down 模式，需要手动使用 `ip` 命令等配置并使能 `up` 。但也可以使用系统 network 的 interfaces 文件来实现 CAN 总线自动化配置和激活：\n\n```text\nauto can0\niface can0 inet manual\n        pre-up /sbin/ip link set $IFACE type can bitrate 500000 restart-ms 10\n        up /sbin/ip link set $IFACE up\n        down /sbin/ip link set $IFACE down\n```\n\n\n\n# 无线连接\n\n1、获取无线网卡\n\n```bash\niw dev\n\n# or\n\nip a\n```\n\n通常无线设备名字以 `wl#` 开头的格式显示，eg：`wlan0` 。\n\n2、检查网卡状态\n\n```bash\nip link show wlan0\n```\n\n如果在 <> 中没有 `UP` 的字样，表示网卡没有激活；可以尝试启动：\n\n```bash\nip link set wlan0 up\n```\n\n3、检查无线连接状态\n\n```bash\niw wlan0 link\n```\n\n如果没有连接会显示 `Not connected` 。\n\n4、扫描可连接的无线网络\n\n```bash\niw wlan0 scan | grep SSID\n```\n\n找到你需要的连接的无线网络名 `<wifi_name>` 。\n\n5、无线连接\n\n一般有两种连接方式：\n\n- 对于没有密码的连接最为简单，直接连接即可：\n\n  ```bash\n  iw dev wlan0 connect <wifi_name>\n  ```\n\n- 而如果网络是有密码，使用的是 WPA 或 WPA2 协议的话，连接就稍微复杂点，需要用到 `wpa_supplicant` 工具：\n\n  ```bash\n  # <wifi_name> 即需要连接的无线网络名\n  # <password> 即 WPA 或 WPA2 协议的验证密码\n  wpa_supplicant -B -i wlan0 -c<(wpa_passphrase \"<wifi_name>\" \"<password>\")\n  ```\n\n6、为无线网卡分配 IP 地址\n\n```bash\ndhclient wlan0\n```\n\nnote：\n\n如果之前为该网卡分配过 IP，可能会出现错误，只需要把 dhclient 信息后面 () 里的进程杀掉，再重新执行即可。","tags":["Linux"]},{"title":"GCC 应用总结","url":"/gcc-compiler-summary/","content":"\n\n\n# 关键字\n\n## weak 关键字\n\n一般用法：`__attribute__((weak))` ，用于定义或声明对应的函数是一个 weak 属性。\n\n在Linux开发环境中，有强符号和弱符号，符号简单来说就是函数、变量的名字，对于全局（非局部、非`static`）的函数和变量，能不能重名是有一定规矩的，强、弱符号就是针对这些全局函数和变量来说的。\n\n| 符号类型 | 对象                     |\n| -------- | ------------------------ |\n| 强       | 函数名，赋初值的全局变量 |\n| 弱       | 未初始化的全局变量       |\n\n当代码中同时存在多个强或弱的全局变量时，要遵守如下规则：\n\n- 强符号只能定义一次，否则编译错误；\n- 强弱符号同时存在，以强符号为准；\n- 没有强符号，则从多个弱符号中任选一个，用 `–fno-common` 编译选项可以在这种情况下输出 warning 提示。\n\n\n\n## constructor 和 destructor 关键字\n\n`__attribute__((constructor))` 与 `__attribute__((destructor))` 的用法。\n\n`__attribute__((constructor))` 与 `__attribute__((destructor))` 是 GCC 中用来修饰函数的，constructor 可以使被修饰的函数在 main() 执行前被调用，destructor 可以使被修饰的函数在 main() 执行结束或 exit() 调用结束后被执行。\n\n```c\n__attribute__((constructor)) void constructor_func() {\n    // ...\n}\n \n__attribute__((destructor)) void destructor_func() {\n    // ...\n}\n```\n\n一个程序中可以存在多个 constructor 和 destructor，使用优先级区分执行顺序，数字越小表示优先级越高（100 以内的优先级为保留数字不能设置）。constructor 中优先级越高越靠前执行，destructor 中优先级越高越靠后执行。不加优先级参数相当于最低优先级。\n\n```c\n__attribute__((constructor(priority)))) void constructor_func() {\n    // ...\n}\n \n__attribute__((destructor(priority)))) void destructor_func() {\n    // ...\n}\n```\n\n\n\n## unused 关键字\n\n`__attribute__((used))`，表示对于这个函数可能不会调用它、可能用不到它，编译器不用进行 warning 提示。\n而在嵌入式中 中断函数都是由内部的中断处理机制通过中断向量做跳转调用的，不是开发人员 “显式” 去调用的，因此在一些规则检查比较严格的编译器上编译时，就会出现类似于上面的警告，为了视野干净我们就添加这个属性。\n\n\n\n# option\n\n## nano.specs 选项\n\n`nano.specs` 是一个特殊的 specs 文件，它是为了在资源受限的环境中使用而优化的，比如在嵌入式系统或微控制器中。当你使用 `--specs=nano.specs` 选项时，编译器会使用 “nano” 版本的 C 库，而这个版本的库被设计为比标准的 GNU C 库 (glibc) 更小，占用更少的 ROM 和 RAM。\n\n**主要特点**:\n\n- **体积小**：nano 版本的库被优化以减小体积，适合那些对存储空间有严格限制的系统。\n- **资源使用低**：这些库在设计时考虑到了内存使用，以尽可能减少动态内存分配。\n- **功能减少**：为了减小体积，某些不常用的功能可能被移除或替换为更简单的实现。\n\n在 `Makefile` 上加上 option ：\n\n```makefile\nCLIBS = -specs=nano.specs\n```\n\n\n\n## -wrap 选项\n\n`-wrap` 选项可以使 GCC 在编译链接的时候，转而调用 `__wrap_symbol` 的定义，另外还有一个相关函数 `__real_symbol`，对于只声明不定义的 symbol，会对其调用到真正的 symbol 符号。\n\n以下是 GCC linker option `–wrap` 的描述：\n\n```text\nUse a wrapper function for symbol. Any undefined reference to symbol will be resolved to\n__wrap_symbol. Any undefined reference to __real_symbol will be resolved to symbol. This \ncan be used to provide a wrapper for a system function. The wrapper function should be \ncalled __wrap_symbol. If it wishes to call the system function, it should call __real_symbol.\nHere is a trivial example:\nvoid *\n__wrap_malloc (int c)\n{\n    printf (\"malloc called with %ld\\n\", c);\n    return __real_malloc (c);\n}\nIf you link other code with this file using --wrap malloc, then all calls to malloc will\ncall the function __wrap_malloc instead. The call to __real_malloc in __wrap_malloc will\ncall the real malloc function. You may wish to provide a __real_malloc function as well, \nso that links without the --wrap option will succeed. If you do this, you should not put \nthe definition of __real_malloc in the same file as __wrap_malloc; if you do, the assembler \nmay resolve the call before the linker has a chance to wrap it to malloc.\n```\n\n像一般对 malloc、free、printf 进行调换：\n\n在 `Makefile` 上加上 option ：\n\n```makefile\nWRAP = -Wl,-wrap,malloc -Wl,-wrap,free\n\nWRAP += -Wl,-wrap,printf\n```\n\n在函数里：\n\n```c\n__attribute__((weak)) void *__wrap_malloc(size_t sz) {\n    printf(\"__wrap_malloc: size = %d\\n\", sz);\n    return pvPortMalloc(sz);\n}\n\n__attribute__((weak)) void __wrap_free(void *ptr) {\n    printf(\"__wrap_free: addr = %p\\n\", ptr);\n    vPortFree(ptr);\n}\n\nint __real_printf(const char *format, ...);\nint __wrap_printf(const char *format, ...) {\n    return __real_printf(format);\n}\n```\n\n上面实现了对 `malloc` 的引用转换成调用 `__wrap_malloc` 函数了，同样的 `__wrap_free` 和 `__wrap_printf` 也一样；但是有区别的是，`__wrap_printf` 里面调用了 `__real_printf`，因此，可以理解对 `printf` 的引用其实是不变的；而由于 `__wrap_malloc` 和 `__wrap_free` 分别实现打印和调用 `pvPortMalloc` 及 `vPortFree` 新的接口，所以在对 `malloc` 和 `free` 引用的时候，是有打印输出并转而执行新的函数接口。\n\n**note：**\n\n在针对所有 “undefined reference to symbol” 中引用 symbol 的源文件里面不能有 symbol 的定义，否则汇编器在处理源文件的时候就会解析这个 symbol，链接器也就没有机会 wrap 这个 symbol 了；嘛简单点说就是需要 wrap 的函数不要跟原函数同时定义在一个源文件。\n\n\n\n## -Wunused 选项\n\n在 GCC 中，如果你想要检查程序中未使用的变量，函数或标签，可以使用以下编译参数：\n\n`-Wunused-variable` ：此选项会让 GCC 发出警告，如果你的代码中定义了一个变量，但从未使用过它。\n\n`-Wunused-function` ：此选项会让 GCC 发出警告，如果你的代码中定义了一个静态函数，但从未使用过它。\n\n`-Wunused-label`：此选项会让 GCC 发出警告，如果你的代码中定义了一个标签，但从未使用过它。\n\n你也可以使用 `-Wunused` 参数来启用所有未使用相关的警告，这相当于 `-Wunused-variable -Wunused-function -Wunused-label` 。\n\n**note：**\n\n如果说 `unused` 关键字是作用于指定的函数，那么 `-Wunused` 的这些选项就是作用于整个编译范围。\n\n\n\n# 预处理命令\n\n## #error\n\n在编译遇到 `#error` 指令时，它会停止编译过程，并显示一个错误消息，同时包含该指令的文件名和行号；这通常用于当编译器检查到不满足特定条件时，强制编译失败。\n\n\n\n##  #warning\n\n在编译遇到 `#warning` 指令时，它会继续编译，但会在编译输出中显示一个警告消息，同时包含该指令的文件名和行号。\n\n\n\n# 预定义宏\n\n `__LINE__` 和 `__FILE__` 分别用来显示当前的行号和文件名。\n\n","tags":["gcc"]},{"title":"Linux c exit 与 return 区别","url":"/linux_c-exit-and-return/","content":"\n\n\n# 功能\n\n- _exit() ：退出程序。\n- exit（0）：运行正常退出程序；\n- exit（1）：运行异常退出程序；\n- return（）：返回函数，若在主函数中，则会退出函数并返回值。\n\n\n\n# _exit() 和 exit() 区别\n\n- exit() 会将缓冲区的数据写完再结束进程到内核中去（退出进程会清理 I/O 缓冲区）。\n\n- _exit() 直接结束进程进入到内核中。\n\n- exit() 函数定义在 stdlib.h 中，_exit() 定义在 unistd.h 中。\n\n- 图示：\n\n  ![img](91748e224d81a92ab21cf272b5244e21.png)\n\n\n\n示例：\n\n**_exit()**\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main(void) {\n\tprintf(\"hello\\n\");\n\tprintf(\"OK\");\n\t_exit(0);\n} \n```\n\n输出结果：\n\n```bash\nhello\n```\n\n**exit()**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n\tprintf(\"hello\\n\");\n\tprintf(\"OK\");\n\texit(0);\n}\n```\n\n输出结果：\n\n```bash\nhello\nOK\n```\n\n**原因：**\n\nprintf 函数使用的是缓冲 I/O 的方式，该函数在遇到 `\\n` 换行符时自动的从缓冲区中将记录读出。\n\nexit() 将缓冲区的数据写完后才能退出来，所以调用 exit() 函数后程序并不会马上退出，会把 OK 也输出出来。\n\n_exit() 是直接退出进入到内核中了。\n\n \n\n# exit(0) 和 exit(1) 区别\n\n- exit(0)：运行正常退出程序。\n- exit(1)：运行异常退出程序，返回值 1 是返回给操作系统的。\n\n \n\n# return 和 exit() 区别\n\n- return 是关键字；exit() 是函数。\n- return 是语言级别的，表示调用堆栈的返回；而 exit() 是系统调用级别的，表示进程的结束。\n- return 是退出（返回）函数，将控制权移交给递归的前一级；exit() 是直接退出进程。\n- 在最初调用的 main 函数中调用 return 和 exit 的现象很模糊，非主函数中调用 return 和 exit 效果很明显。","tags":["Linux","linux_c"]},{"title":"VMware 下 ubuntu 空间回收","url":"/vmware-space-recycling/","content":"\n\n\n方法一：\n\n通过在 `虚拟机设置` 中的 `硬盘` 项，进行 `碎片整理` 和 `压缩` 处理。\n\n\n\n方法二：\n\n清空虚拟机系统的回收站\n\n在 Ubuntu 下，删除了某些文件，而当准备清空回收站的时候，却发现无法清空，打开回收站，在里面进行文件删除时提示 “Failed to delete the item from the trash”。\n\n解决方法如下：\n\n1. 打开桌面的主文件夹，按组合键 Ctrl+H（显示隐藏文件），找到以下路径：`/home/user/.local/share/Trash` （注：user 是用户名，根据你的用户名而变）。\n\n2. 在上面的路径下点击鼠标右键，选择 “在终端中打开”。\n\n3. 运行命令 `sudo rm -rf *` 这时，便可以删除那些平时无法删除的文件。\n\n\n\n方法三：\n\n删除 `.cache` 等配置文件\n\n```bash\n# 查看 365 天以上的配置文件：\nfind ~/.cache/ -depth -type f -atime +365\n# 确认后可删除\nfind ~/.cache/ -type f -atime +365 -delete\n```\n\n\n\n方法四：\n\n清除快照，通过进入 `快照管理器` 把所有快照删除掉。\n\n**note：**\n\n有时候在删除快照的时候点了取消，这时候会存在残留的情况，可以在关机的情况下，拍摄快照，然后再进行删除，这样系统就会把残留的快照重新整合删除，以达到全部删除的效果。\n\n\n\n方法五：\n\n在 VMware Workstation 的安装目录下，有一个 `vmware-vdiskmanager.exe` 程序，在该目录下打开终端，输入：\n\n```shell\nvmware-vdiskmanager.exe -k \"vmdk 文件路径\"\n```\n\n如果安装虚拟机时选择的是将磁盘存储为多个文件，而非存储为单个文件，则只需选择名为：`虚拟机名.vmdk` 的那个 vmdk 文件 （文件名不带 s 的那种）\n\n这样就可以使用 `vmware-vdiskmanager.exe` 程序对 VM 磁盘文件 vmdk 进行压缩\n\n执行过程会显示压缩进度，完成后会提示：\n\n```shell\nShrink: 100% done.\nShrink completed successfully.\n```\n\n**note：**\n\n虚拟机不能有快照，否则会显示：“为该虚拟机禁用了磁盘压缩。”\n\n\n\n方法六：\n\n在虚拟机中利用命令来释放磁盘空间。\n\n搜索查看磁盘挂载点：\n\n```bash\nsudo vmware-toolbox-cmd disk list\n```\n\n对 `/` 分区所在的虚拟硬盘进行清理，`/` 表示你的磁盘挂载点，可以从上一步 list列表中取值，不清楚的用户可以直接执行：\n\n```bash\nsudo /usr/bin/vmware-toolbox-cmd disk wipe /\nsudo /usr/bin/vmware-toolbox-cmd disk shrink /\n```\n\n也可以使用如下脚本来收缩所有的挂载磁盘：\n\n```bash\n#! /bin/bash\n \nLOG_FILE=~/vmdiskshrink.log\nDISK_LIST=$(sudo /usr/bin/vmware-toolbox-cmd disk list)\necho -e \"will shrink disk: \\n############\\n${DISK_LIST}\\n############\" | tee ${LOG_FILE}\nfor mydisk in ${DISK_LIST}\ndo\n    if [ ! -d ${mydisk} ] ;then\n        continue\n    fi\n    read -t 10 -p \"shrink ${mydisk} ?<Y/n>\" myselect\n    if [ \"${myselect,,}\" = \"n\" ] ;then\n        continue\n    fi\n    echo \"start wipe ${mydisk}\" | tee -a ${LOG_FILE}\n    sudo /usr/bin/vmware-toolbox-cmd disk wipe ${mydisk}\n    echo \"start shrink ${mydisk}\" | tee -a ${LOG_FILE}\n    sudo /usr/bin/vmware-toolbox-cmd disk shrink ${mydisk}\ndone\n```\n\n**note：**\n\n虚拟机不能有快照，否则会显示：“为该虚拟机禁用了磁盘压缩。”","tags":["Ubuntu"]},{"title":"zlist 链表分析","url":"/zlist/","content":"\n\n\n# 数据结构定义\n\n## 比较函数指针\n\n```c\ntypedef int (zlist_compare_fn) (\n    void *item1, void *item2);\n```\n\n## 析构函数指针\n\n```c\ntypedef void (zlist_free_fn) (\n    void *data);\n```\n\n## 节点\n\n```c\ntypedef struct _node_t {\n    struct _node_t *next;   // 指向下一个节点\n    void *item;             // 节点当中的元素\n    zlist_free_fn *free_fn; // 元素对应的析构函数\n} node_t;\n```\n\n## 链表\n\n```c\nstruct _zlist_t {\n    node_t *head;                   // 头节点\n    node_t *tail;                   // 尾节点\n    node_t *cursor;                 // 当前访问节点\n    size_t size;                    // 元素数量\n    bool autofree;                  // 如果为真，使用默认析构元素，否则使用节点自带的析构\n    zlist_compare_fn *compare_fn;   // 自定义的比较函数回调，用来比较两个元素\n};\n```\n\n\n\n# 函数定义\n\n## 创建链表对象\n\n```c\n/* List constructor. */\nzlist_t *\nzlist_new (void)\n{\n    zlist_t *self = (zlist_t *) zmalloc (sizeof (zlist_t));\n    assert (self);\n    return self;\n}\n```\n\n## 销毁链表对象\n\n```c\n/* List destructor. */\nvoid\nzlist_destroy (zlist_t **self_p)\n{\n    assert (self_p);\n    if (*self_p) {\n        zlist_t *self = *self_p;\n        zlist_purge (self);\n        freen (self);\n        *self_p = NULL;\n    }\n}\n```\n\n## 访问链表第一个元素\n\n```c\n/* Return the item at the head of list. If the list is empty, returns NULL.\n   Leaves cursor pointing at the head item, or NULL if the list is empty. */\nvoid *\nzlist_first (zlist_t *self)\n{\n    assert (self);\n    // 将游标移动到链首位置\n    self->cursor = self->head;\n    // 返回链首元素\n    if (self->cursor)\n        return self->cursor->item;\n    else\n        return NULL;\n}\n```\n\n## 访问链表下一个元素\n\n```c\n/* Return the next item. If the list is empty, returns NULL. To move to\n   the start of the list call zlist_first (). Advances the cursor. */\nvoid *\nzlist_next (zlist_t *self)\n{\n    assert (self);\n    // 将游标移动到下一个，如果是首次访问，那么设置为首节点\n    if (self->cursor)\n        self->cursor = self->cursor->next;\n    else\n        self->cursor = self->head;\n    // 如果当前游标非空，那么返回里面的元素\n    if (self->cursor)\n        return self->cursor->item;\n    else\n        return NULL;\n}\n```\n\n## 访问链表最后一个元素\n\n```c\n/* Return the item at the tail of list. If the list is empty, returns NULL.\n   Leaves cursor pointing at the tail item, or NULL if the list is empty. */\nvoid *\nzlist_last (zlist_t *self)\n{\n    assert (self);\n    // 将游标移动到链尾位置\n    self->cursor = self->tail;\n    // 返回链尾元素\n    if (self->cursor)\n        return self->cursor->item;\n    else\n        return NULL;\n}\n```\n\n## 访问链表当前元素\n\n```c\n/* Return current item in the list. If the list is empty, or the cursor\n   passed the end of the list, returns NULL. Does not change the cursor. */\nvoid *\nzlist_item (zlist_t *self)\n{\n    assert (self);\n    // 访问当前游标的元素\n    if (self->cursor)\n        return self->cursor->item;\n    else\n        return NULL;\n}\n```\n\n## 添加链尾元素\n\n```c\n/* Append an item to the end of the list, return 0 if OK or -1 if this\n   failed for some reason. */\nint\nzlist_append (zlist_t *self, void *item)\n{\n    if (!item)\n        return -1;\n\n    // 构造节点\n    node_t *node = (node_t *) zmalloc (sizeof (node_t));\n    assert (node);\n\n    // 如果支持自动回收，那么按字符串的形式申请内存并拷贝一份\n    if (self->autofree) {\n        item = strdup ((char *) item);\n        assert (item);\n    }\n    // 新节点中保存元素\n    node->item = item;\n    // 当前链尾与新节点进行链接\n    if (self->tail)\n        self->tail->next = node;\n    // 链尾是空说明是首次操作，链头指向节点\n    else\n        self->head = node;\n\n    // 新节点设为链尾\n    self->tail = node;\n    node->next = NULL;\n\n    // 链尾大小 + 1\n    self->size++;\n    // 游标重置为空\n    self->cursor = NULL;\n    return 0;\n}\n```\n\n## 添加链首元素\n\n```c\n/* Push an item to the start of the list, return 0 if OK or -1 if this\n   failed for some reason. */\nint\nzlist_push (zlist_t *self, void *item)\n{\n    if (!item)\n        return -1;\n\n    node_t *node = (node_t *) zmalloc (sizeof (node_t));\n    assert (node);\n\n    // 如果支持自动回收，那么按字符串的形式申请内存并拷贝一份\n    if (self->autofree) {\n        item = strdup ((char *) item);\n        assert (item);\n    }\n    node->item = item;\n    // 设置新节点的下1个节点是链首节点\n    node->next = self->head;\n    // 链首属性设置为新节点\n    self->head = node;\n    // 如果链尾属性是空，说明是首次操作，设置为新节点\n    if (self->tail == NULL)\n        self->tail = node;\n\n    self->size++;\n    self->cursor = NULL;\n    return 0;\n}\n```\n\n## 删除链首元素\n\n```c\n/* Remove item from the beginning of the list, returns NULL if none. */\nvoid *\nzlist_pop (zlist_t *self)\n{\n    node_t *node = self->head;\n    void *item = NULL;\n    if (node) {\n        // 获得链首元素引用\n        item = node->item;\n        // 链首指向下1个节点（这时节点已从链表中删除）\n        self->head = node->next;\n        // 若链表里只有1个节点，那么链尾也置空\n        if (self->tail == node)\n            self->tail = NULL;\n        // 释放已删除的节点\n        freen (node);\n        // 链表大小-1\n        self->size--;\n    }\n    // 当前游标置空\n    self->cursor = NULL;\n    // 返回元素\n    return item;\n}\n```\n\n## 判断元素是否存在\n\n```c\n/* Checks if an item already is present. Uses compare method to determine if\n   items are equal. If the compare method is NULL the check will only compare\n   pointers. Returns true if item is present else false. */\nbool\nzlist_exists (zlist_t *self, void *item)\n{\n    assert (self);\n    assert (item);\n    node_t *node = self->head;\n\n    while (node) {\n        // 链表有自定义比较函数，那就用它来比较\n        if (self->compare_fn) {\n            if ((*self->compare_fn)(node->item, item) == 0)\n                return true;\n        }\n        // 否则直接用双等号比较\n        else\n        if (node->item == item)\n            return true;\n        // 取下1个节点比较\n        node = node->next;\n    }\n    return false;\n}\n```\n\n## 查找并删除元素\n\n```c\n/* Remove the item from the list, if present. Safe to call on items that\n   are not in the list. */\nvoid\nzlist_remove (zlist_t *self, void *item)\n{\n    node_t *node, *prev = NULL;\n\n    // 首先，我们通过遍历把这个节点找到\n    for (node = self->head; node != NULL; node = node->next) {\n        if (self->compare_fn) {\n            if ((*self->compare_fn)(node->item, item) == 0)\n            break;\n        }\n        // 找到了就跳出替换\n        else\n        if (node->item == item)\n            break;\n\n        // 每次保存遍历的节点，当下次找到，这个节点就是前节点\n        prev = node;\n    }\n\n    // 将删的节点已找到\n    if (node) {\n        // 前节点指向节点的下1个节点\n        if (prev)\n            prev->next = node->next;\n        // 这里说明链表只有1个节点，链头设置为空\n        else\n            self->head = node->next;\n\n        // 这里说明节点在链尾\n        if (node->next == NULL)\n            // 前节点设置成链尾\n            self->tail = prev;\n        // 游标刚好指向节点\n        if (self->cursor == node)\n            //游标设置成前节点\n            self->cursor = prev;\n\n        // 自动删除标志为真\n        if (self->autofree)\n            // 释放当前节点的元素的内存空间\n            freen (node->item);\n        // 不为真就用节点析构函数（如果有）\n        else\n        if (node->free_fn)\n            (node->free_fn)(node->item);\n\n        // 释放节点本身的内存空间\n        freen (node);\n        // 元素总数减1\n        self->size--;\n    }\n}\n```\n\n## 复制链表对象\n\n```c\n/* Make a copy of list. If the list has autofree set, the copied list will\n   duplicate all items, which must be strings. Otherwise, the list will hold\n   pointers back to the items in the original list. If list is null, returns\n   NULL. */\nzlist_t *\nzlist_dup (zlist_t *self)\n{\n    if (!self)\n        return NULL;\n\n    zlist_t *copy = zlist_new ();\n    assert (copy);\n\n    if (self->autofree)\n        zlist_autofree(copy);\n\n    copy->compare_fn = self->compare_fn;\n\n    node_t *node;\n    for (node = self->head; node; node = node->next) {\n        if (zlist_append (copy, node->item) == -1) {\n            zlist_destroy (&copy);\n            break;\n        }\n    }\n    return copy;\n}\n```\n\n## 清理链表所有元素\n\n```c\n/* Purge all items from list. */\nvoid\nzlist_purge (zlist_t *self)\n{\n    assert (self);\n    node_t *node = self->head;\n    while (node) {\n        node_t *next = node->next;\n        if (self->autofree)\n            freen (node->item);\n        else\n        if (node->free_fn)\n            (node->free_fn)(node->item);\n\n        freen (node);\n        node = next;\n    }\n    self->head = NULL;\n    self->tail = NULL;\n    self->cursor = NULL;\n    self->size = 0;\n}\n```\n\n## 获得链表大小\n\n```c\n/* Return the number of items in the list. */\nsize_t\nzlist_size (zlist_t *self)\n{\n    return self->size;\n}\n```\n\n## 链表排序\n\n```c\n/* Sort the list. If the compare function is null, sorts the list by\n   ascending key value using a straight ASCII comparison. If you specify\n   a compare function, this decides how items are sorted. The sort is not\n   stable, so may reorder items with the same keys. The algorithm used is\n   combsort, a compromise between performance and simplicity. */\nvoid\nzlist_sort (zlist_t *self, zlist_compare_fn compare_fn)\n{\n    zlist_compare_fn *compare = compare_fn;\n    if (!compare) {\n        compare = self->compare_fn;\n        if (!compare)\n            compare = (zlist_compare_fn *) strcmp;\n    }\n    // 梳排序算法:\n    // 1.算法从两个游标同时开始遍历\n    // 2.两个游标之间存在间隔(gap)\n    // 3.第1个游标是链头，第2个游标按间隔计算\n    // 4.两个游标遍历的同时会交换元素\n    // 5.每一轮至少需要交换1次\n    // 6.间隔每1轮按递减率1.3进行缩短\n    // 7.当间隔小于等于1或者交换0次时算法终止\n    size_t gap = self->size;\n    bool swapped = false;\n    while (gap > 1 || swapped) {\n        if (gap > 1)\n            gap = (size_t) ((double) gap / 1.3);\n        node_t *base = self->head;\n        node_t *test = self->head;\n        size_t jump = gap;\n        while (jump--)\n            test = test->next;\n\n        swapped = false;\n        while (base && test) {\n            if ((*compare) (base->item, test->item) > 0) {\n                // 依据比较函数进行元素交换\n                void *item = base->item;\n                base->item = test->item;\n                test->item = item;\n                swapped = true;\n            }\n            base = base->next;\n            test = test->next;\n        }\n    }\n}\n```\n\n## 设置比较函数\n\n```c\n/* Sets a compare function for this list. The function compares two items.\n   It returns an integer less than, equal to, or greater than zero if the\n   first item is found, respectively, to be less than, to match, or be\n   greater than the second item.\n   This function is used for sorting, removal and exists checking. */\nvoid\nzlist_comparefn (zlist_t *self, zlist_compare_fn fn)\n{\n    assert (self);\n    self->compare_fn = fn;\n}\n```\n\n## 设置元素销毁函数\n\n```c\n/* Set a free function for the specified list item. When the item is\n   destroyed, the free function, if any, is called on that item.\n   Use this when list items are dynamically allocated, to ensure that\n   you don't have memory leaks. You can pass 'free' or NULL as a free_fn.\n   Returns the item, or NULL if there is no such item. */\nvoid *\nzlist_freefn (zlist_t *self, void *item, zlist_free_fn fn, bool at_tail)\n{\n    node_t *node = self->head;\n    // 给链尾设置析构函数，这个标志是为了提高算法效率\n    if (at_tail)\n        node = self->tail;\n\n    // 根据元素值遍历找节点并设置析构函数\n    while (node) {\n        if (node->item == item) {\n            node->free_fn = fn;\n            return item;\n        }\n        node = node->next;\n    }\n    return NULL;\n}\n```\n\n## 设置自动销毁状态\n\n```c\n/* Set list for automatic item destruction; item values MUST be strings.\n   By default a list item refers to a value held elsewhere. When you set\n   this, each time you append or push a list item, zlist will take a copy\n   of the string value. Then, when you destroy the list, it will free all\n   item values automatically. If you use any other technique to allocate\n   list values, you must free them explicitly before destroying the list.\n   The usual technique is to pop list items and destroy them, until the\n   list is empty. */\nvoid\nzlist_autofree (zlist_t *self)\n{\n    assert (self);\n    self->autofree = true;\n}\n```\n\n"},{"title":"Linux 网络管理套件","url":"/net-tools-vs-proute2/","content":"\n\n\n# 简述\n\n- net-tools 起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 Linux 内核中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护，甚至一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持 iproute2。\n\n- iproute2 的出现旨在从功能上取代 net-tools，是目前主流 Linux 所配带的网络套件，同时提供 net-tools 下 ifconfig 和 route 命令所不具备的高级特性。\n\n| net-tools        | iproute2         | note                                |\n| ---------------- | ---------------- | ----------------------------------- |\n| ifconfig         | ip link          | Listing interfaces                  |\n| ifconfig -a      | ip addr          | Show addresses                      |\n| route            | ip route         | Routing tables                      |\n| arp              | ip neigh         | Neighbors                           |\n| iptunnel         | ip tunnel        | Tunnels                             |\n| nameif, ifrename | ip link set name | Rename network interfaces           |\n| ipmaddr          | ip maddr         | Multicast                           |\n| netstat          | ss               | Show various networking statistics  |\n| brctl            | bridge           | Handle bridge addresses and devices |\n\n\n\n# 基本对照\n\n## 列出 active 网卡接口信息\n\n- net-tools\n\n```bash\nifconfig\n```\n\n- iproute2\n\n```bash\nip link show up\n```\n\n## 显示网络接口 ip 地址\n\n显示所有接口或指定接口（eg：eth0）的 ip 地址\n\n- net-tools\n\n```bash\nifconfig -a\n\nifconfig eht0\n```\n\n- iproute2\n\n```bash\nip a\n\nip addr show dev eth0\n```\n\n## 激活或禁止网络接口\n\n启动或关闭某个接口（eg：eth0）\n\n- net-tools\n\n```bash\nifconfig eth0 up/down\n```\n\n- iproute2\n\n```bash\nip link set up/down eth0\n```\n\n## 分配 ipv4/ipv6 地址\n\n给某个接口（eg：eth0）临时配置 ipv4/ipv6 地址, 并加上子掩码\n\n- net-tools\n\n```bash\nifconfig eth0 192.168.1.56 netmask 255.255.255.0\n\nifconfig eth0 inet6 add 2002:0db5:0:f102::1/64\n```\n\n- iproute2\n\n```bash\nip addr add 192.168.1.56/24 dev eth0\n\nip -6 addr add 2002:0db5:0:f102::1/64 dev eth0\n```\n\n## 删除 ipv4/ipv6 地址\n\n就 ip 地址的移除而言，除了给接口分配全 0 地址外，net-tools 没有提供任何合适的方法来移除网络接口的 ipv4 地址。\n\n- net-tools\n\n```bash\nifconfig eth0 0\n\nifconfig eth0 inet6 del 2002:0db5:0:f102::1/64\n```\n\n- iproute2\n\n```bash\nip addr del 192.168.1.56/24 dev eth0\n\nip -6 addr del 2002:0db5:0:f102::1/64 dev eth0\n```\n\n## 修改 MAC 地址\n\n- net-tools\n\n```bash\nifconfig eth0 hw ether 00:AA:BB:CC:DD:EE\n```\n\n- iproute2\n\n```bash\nip link set dev eth0 address 00:AA:BB:CC:DD:EE\n```\n\n## 查看套接字统计信息\n\n- net-tools\n\n```bash\nnetstat\n\nnetstat -l\n```\n\n- iproute2\n\n```bash\nss\n\nss -l\n```\n\n## 查看 ARP 表\n\n- net-tools\n\n```bash\narp -an\n```\n\n- iproute2\n\n```bash\nip n\n```\n\n## 添加、删除或查看多播地址\n\n对某个接口（eg：eth0）临时操作多播地址及查看\n\n- net-tools\n\n```bash\nipmaddr add 33:44:00:00:00:01 dev eth0\nipmaddr del 33:44:00:00:00:01 dev eth0\n\nipmaddr show dev eth0\n```\n\n- iproute2\n\n```bash\nip maddr add 33:44:00:00:00:01 dev eth0\nip maddr del 33:44:00:00:00:01 dev eth0\n\nip maddr list dev eth0\n```\n\n## 查看 ip 路由表\n\n- net-tools\n\n```bash\nroute -n\n```\n\n- iproute2\n\n```bash\nip route\n```\n\n## 添加或修改默认路由\n\n对某个接口（eg：eth0）添加或修改默认路由\n\n- net-tools\n\n```bash\nroute add/del default gw 192.168.10.1 eth0\n```\n\n- iproute2\n\n```bash\nip route add/del default via 192.168.10.1 dev eth0\n```\n\n## 添加或删除静态路由\n\n对某个接口（eg：eth0）添加或删除静态路由\n\n- net-tools\n\n```bash\nroute add -net 172.14.32.0/24 gw 192.168.1.1 dev eth0\n\nroute del -net 172.14.32.0/24\n```\n\n- iproute2\n\n```bash\nip route add 172.14.32.0/24 via 192.168.1.1 dev eth0\n\nip route del 172.14.32.0/24\n```\n\n\n\n# 参考\n\nhttps://dougvitale.wordpress.com/2011/12/21/deprecated-linux-networking-commands-and-their-replacements/\n\nhttps://www.baturin.org/docs/iproute2/","tags":["Linux"]},{"title":"Linux 网络一探究竟","url":"/linux-network-config-tool/","content":"\n\n\n\n# 常见网络配置工具包\n\n配置「Linux 操作系统」的网络有以下几款主流的配置工具可供选择：\n\n| 配置工具                                                     | 说明                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [ifupdown](https://manpages.debian.org/buster/ifupdown/interfaces.5.en.html) | 用来启动/关闭网络的标准工具（Debian 及部分衍生版本特有），配置文件在 `/etc/network/interfaces`。 |\n| [systemd-networkd](https://wiki.archlinux.org/title/Systemd-networkd) | systemd 是许多发行版默认的 kernel 程序，其中 systemd-networkd 组件可用于网络配置管理，配置文件在 `/etc/systemd/network/`。 |\n| [NetworkManager](https://wiki.archlinux.org/title/NetworkManager) | 一个为桌面版提供的图形化前端工具，也可以使用内嵌的 `nmcli` 和 `nmtui` 进行配置。 |\n| [netplan](https://netplan.io/)                               | 通过 YAML 文件管理网络配置，支持 systemd-networkd 和 NetworkManager 作为后端程序，配置文件在 `/etc/netplan/*.yaml`。 |\n\n\n\n# ifupdown\n\n`ifupdown` 网络管理器一直以来都是 Debian 默认使用的网络管理器。大多数教程描述的配置 `/etc/network/interfaces` 文件就是来自于对 `ifupdown` 网络的管理。\n\n与早期版本的 Red Hat 发行版类似，Debian 把网络配置写在一个文件内，并从文件内加载配置。\n\n但与 Red Hat 系发行版不同的是，Red Hat 发行版将不同的网卡配置文件保存在 `/etc/sysconfig/network-scripts/` 文件夹中，而 Debian 则将网卡配置统一写在 `/etc/network/interfaces` 文件中。\n\n同样的，像 Debian 的衍生版本也会延续将网络配置文件统一写在 `/etc/network/interfaces` 文件中，例如早期的 Ubuntu 系统，而在 Ubuntu 18.04 LTS 后将使用 `netplan` 命令和基于 `/etc/netplan/*.yaml` 文件的配置方法；如果在 Ubuntu 18 上打开 `/etc/network/interfaces` 文件将会看到提示，而 Ubuntu 20 上则已经完全移除了 `/etc/network/interfaces` 文件。\n\n\n\n对于 `ifupdown` 的文件配置，虽然系统默认的网络配置文件是在 `/etc/network/interfaces` 文件中，但 Debian 给出的最佳实现是将网络配置保存到 `/etc/network/interface.d/` 下；一些常规的配置如下：\n\n- 使用 DHCP 自动配置接口\n\n  ```txt\n  auto eth0\n  allow-hotplug eth0\n  iface eth0 inet dhcp\t# ipv4 DHCP 模式\n  # iface eth0 inet6 dhcp/auto\t# ipv6 DHCP 或 Auto 模式\n  ```\n\n- 使用静态 IP 配置接口\n\n  ipv4：\n\n  ```txt\n  auto eth0\n  iface eth0 inet static\n  \taddress 192.0.2.7/24\n  \tnetmask 255.255.255.0\n  \tgateway 192.0.2.254\n  ```\n\n  ipv6：\n\n  ```txt\n  auto eth0\n  iface eth0 inet6 static\n  \taddress 2001:db8::c0ca:1eaf/64\n  \tnetmask 64\n  \tgateway 2001:db8::1ead:ed:beef\n  ```\n\n- 设置 DNS\n\n  如果你要直接 ping 域名就需要开启 DNS 服务，在这里有两种方法：\n\n  一种是修改 `/etc/resolv.conf` 文件，添加需要配置的 DNS，例如添加两个 DNS 服务：\n\n  ```txt\n  nameserver 8.8.8.8\n  nameserver 114.114.114.114\n  ```\n\n  另一种是直接编辑 `/etc/network/interfaces` 文件，但这种需要 `resolvconf` 程序的支持：\n\n  ```txt\n  auto eth0\n  iface eth0 inet static\n  \taddress 192.0.2.7/24\n  \tnetmask 255.255.255.0\n  \tgateway 192.0.2.254\n  \tdns-nameservers 8.8.8.8 114.114.114.114\t# 此行便是用作 DNS 解析，对于多个解析地址，应共用一行并用空格区分\n  ```\n\n  note：这两种方法各有缺点，`/etc/resolv.conf` 中的 DNS 配置将会被 C 库或其它解析器库所查找并解析 DNS 服务，同时该文件还会被 resolvconf、network-manager 及 DHCP 客户端修改所覆盖；而在 `/etc/network/interfaces` 上编辑，则需要提供 `resolvconf` 程序，可以使用 `which resolvconf` 命令查看是否存在，否者将要进行下载才可使用。\n\n- 网络接口生效\n\n  ```bash command:(\"[root@localhost] $\":1-2)\n  systemctl restart networking\n  ifdown eth0 && ifup eth0\n  ```\n\ntips：\n\n在 `/etc/network/interfaces` 文件中一般用 `auto` 或者 `allow-hotplug` 来定义接口的启动行为。\n\n- auto：在系统启动的时候启动网络接口，无论网络接口有无连接（插入网线）；如果该接口配置了 DHCP，则无论有无网线，系统都会去执行 DHCP，如果没有插入网线，则等该接口超时后才会继续。\n- allow-hotplug：只有当内核从该接口检测到热插拔事件后才启动该接口。如果系统开机时该接口没有插入网线，则系统不会启动该接口，系统启动后，如果插入网线，系统会自动启动该接口（也就是将网络接口设置为热插拔模式），但是值得注意的是，重启 `networking` 之后网卡不能自动重启。\n\n\n\n# systemd-networkd\n\n`systemd-networkd` 网络管理器是 `systemd` 软件包其中的一个组件，目前一些主流的 Linux 系统都内置着 `systemd` 包，像 Arch、Debian、Ubuntu 等。\n\n- 静态 IP 配置\n\n  ```bash command:(\"[root@localhost] $\":2)\n  # 启动 \"ens37\" 接口并配置一个静态地址。 此处设置的网关将被用作默认路由。\n  cat > /etc/systemd/network/10-static-ens37.network << EOF\n  [Match]\n  Name=ens37\n  \n  [Network]\n  Address=192.168.0.2/24\n  Gateway=192.168.0.1\n  DNS=192.168.0.1\n  EOF\n  ```\n\n- DHCP 配置\n\n  ```bash command:(\"[root@localhost] $\":2)\n  # 在所有名字以 \"en\" 开头的接口(也就是以太网接口)上开启 DHCPv4 与 DHCPv6\n  cat > /etc/systemd/network/10-dhcp-en.network << EOF\n  [Match]\n  Name=en*\n  \n  [Network]\n  DHCP=yes\n  EOF\n  ```\n\n- 服务启动\n\n  ```bash command:(\"[root@localhost] $\":1-2)\n  systemctl start systemd-networkd\n  systemctl enable systemd-networkd\n  ```\n\n\n\n剩下的这里就不详细阐述了，说一下值得注意的点吧：\n\n- 如果 *.network* 文件中指定了 DNS 条目，则 *systemd-resolved* 服务是必需的， [systemd-resolved](https://wiki.archlinux.org/title/systemd-resolved) 是可选的，它是一个为本地应用程序提供网络名称（DNS）解析服务。\n- 配置文件位于 `/usr/lib/systemd/network`，非持久化的运行时网络配置目录位于 `/run/systemd/network` ，本地管理网络配置位于 `/etc/systemd/network`。`/etc/systemd/network` 中的配置文件具有最高优先级。\n- 如果某个网络接口既没有配置静态 IPv6 地址、也没有启用 DHCPv6 或 IPv6LL 的话， 将会被视为禁用 IPv6 支持。同时，systemd 将会自动向 `/proc/sys/net/ipv6/conf/if_name/disable_ipv6` 中写入\"1\"，以彻底禁用此接口上的 IPv6 支持。\n\nref：\n\nhttps://wiki.archlinuxcn.org/wiki/Systemd-networkd\n\nhttps://wiki.debian.org/SystemdNetworkd\n\nhttps://www.jinbuguo.com/systemd/systemd.network.html\n\nhttps://lisongmin.github.io/os-systemd-networkd/\n\n\n\n# NetworkManager\n\n`NetworkManager` 是一个为系统提供检测和配置功能以便自动连接到网络的程序。`NetworkManager` 的功能对无线和有线网络都很有用。其有两个组件：\n\n1. 一个以超级用户运行的守护进程（network-manager）；\n2. 一个前端管理程序（network-manager-gnome、network-manager-kde 或者 cnetworkmanager）。\n\n**默认情况下，`NetworkManager` 不接管任何 `/etc/network/interfaces` 里配置的网络接口，而对于已经在 `/etc/network/interfaces` 中声明过的网络接口，在 Desktop 环境上你会看到 `NetworkManager` 菜单中相应的网络接口显示 “device not managed”，但如果使用 `NetworkManager` 的 `nmcli` 或 `nmtui` 工具去配置 `/etc/network/interfaces` 中声明过的网络接口，可能会对该网卡造成冲突（包括其它的网络配置服务共存也将导致冲突）。**\n\n如果希望 `NetworkManager` 接管在 `/etc/network/interfaces` 配置了的网络接口，则进行以下操作：\n\n1. 在 `/etc/NetworkManager/NetworkManager.conf` 里把 `[ifupdown]` 中的 `managed` 属性修改为此设置 `managed=true`；如果有手动改过 `/etc/network/interfaces`，那么 `NetworkManager` 会自行把这行改成：`managed=false`；\n\n2. 以 root 形式重新启动 `NetworkManager` 服务：`sudo systemctl restart NetworkManager`。\n\n`NetworkManager` 除了给 Desktop 环境带来图形操作，还内置提供了一个命令行界面（nmcli）和一个基于 curses 的界面（nmtui）这两个工具：\n\n- nmcli\n\n```bash command:(\"[root@localhost] $\":2)\n# 查看 nmcli 使用说明\nnmcli --help\nUsage: nmcli [OPTIONS] OBJECT { COMMAND | help }\n\nOPTIONS\n  -a, --ask                                ask for missing parameters\n  -c, --colors auto|yes|no                 whether to use colors in output\n  -e, --escape yes|no                      escape columns separators in values\n  -f, --fields <field,...>|all|common      specify fields to output\n  -g, --get-values <field,...>|all|common  shortcut for -m tabular -t -f\n  -h, --help                               print this help\n  -m, --mode tabular|multiline             output mode\n  -o, --overview                           overview mode\n  -p, --pretty                             pretty output\n  -s, --show-secrets                       allow displaying passwords\n  -t, --terse                              terse output\n  -v, --version                            show program version\n  -w, --wait <seconds>                     set timeout waiting for finishing operations\n\nOBJECT\n  g[eneral]       NetworkManager's general status and operations\n  n[etworking]    overall networking control\n  r[adio]         NetworkManager radio switches\n  c[onnection]    NetworkManager's connections\n  d[evice]        devices managed by NetworkManager\n  a[gent]         NetworkManager secret agent or polkit agent\n  m[onitor]       monitor NetworkManager changes\n```\n\n- nmtui\n\n```bash command:(\"[root@localhost] $\":2,5)\n# 查看 NetworkManager 是否启动\nnmcli networking\nenabled\n# 调出伪图形界面，然后根据选项编辑网络配置，最后启用网络连接。\nnmtui\n```\n\n![img](FQ0$U9UCJOL_LF_H{5}3Z41-1709729923652.jpg)\n\nnote：\n\n一些 `NetworkManager` 网络命令处理：\n\n```bash command:(\"[root@localhost] $\":2,4)\n# 重启服务\nsystemctl restart NetworkManager\n# 查看开机自启是否启用\nsystemctl list-unit-files --type service | grep NetworkManager\n```\n\n附：\n\nhttps://wiki.debian.org/zh_CN/NetworkManager\n\n\n\n# netplan\n\nnetplan 是 Canonical(Ubuntu) 开发的，作为某些 Linux 发行版（主力为 ubuntu Linux 发行版）上默认的网络配置命令行工具。netplan 使用 YAML 描述文件来配置网络，然后，通过这些描述为任何给定的底层呈现工具（主要就是 `systemd-networkd` 和 `networkmanager` 二种工具）生成必要的配置选项。在 Ubuntu 17.10 引入 netplan 作为 network 的替代品，Ubuntu 20.04 正式使用 netplan 作为网络配置工具。\n\n![img](a1a80854-netplan_design_overview.svg)\n\nA、指定 NetworkManager 接管网络\n\n```bash command:(\"[root@localhost] $\":1)\ncat /etc/systemd/network/xxx.yaml\n# Let NetworkManager manage all devices on this system\nnetwork:\n  version: 2\n  renderer: NetworkManager\n```\n\n最后就可以使用可视化界面配置网络了，一般像在桌面上使用无线连接就会很方便，而不用使用 `iw` 等命令搜索 WiFi 然后指定 SSID 这么麻烦。\n\nB、指定 systemd-networkd 接管网络\n\n- ipv4 DHCP\n\n  ```yaml\n  network:\n    version: 2\n    renderer: networkd\n    ethernets:\n      ens33:\n        dhcp4: yes\n        dhcp4-overrides:\n          route-metric: 100\n  ```\n\n- 单网卡多网段\n\n  ```yaml\n  network:\n    version: 2\n    renderer: networkd\n    ethernets:\n      ens33:\n        addresses:\n        - 192.168.1.20/24\n        - 192.168.50.20/24\n       nameservers:\n         addresses: [8.8.8.8]\n       routes:\n        - to: 0.0.0.0/0\n          via: 192.168.1.1\n          metric: 1000\n        - to: 0.0.0.0/0\n          via: 192.168.50.1\n          metric: 1000\n  ```\n\n- 桥接\n\n  ```yaml\n  network:\n    version: 2\n    renderer: networkd\n    ethernets:\n      enp3s0:\n        dhcp4: yes\n    bridges:\n      br0:\n        interfaces: [enp3s0]\n        dhcp4: no\n        addresses:\n          - 192.168.1.20/24\n        routes:\n         - to: 0.0.0.0/0\n           via: 192.168.1.1\n           metric: 1000\n        nameservers:\n          addresses: [8.8.8.8]\n  ```\n\n命令：\n\n- netplan generate\n\n  将 `yaml` 文件中的设置转换为适合正在使用的渲染器的配置，但不应用它们。\n\n- netplan apply\n  应用配置，使配置生效；会自动调用 `netplan generate`。\n\n- netplan try\n  测试配置，然后等待用户的确认；如果取消确认或超时退出则自动恢复配置，注意不是恢复配置文件。\n\nnote：\n\n**注意在 `/etc/netplan` 目录下，有多个 `yaml` 文件存在时，netplan 是根据字母表排序，挨个生效的，后面的 `yaml` 指定的配置会覆盖前面的 `yaml` 指定的配置。**\n\n**`netplan` 会一次从以下 3 个位置读取配置文件，并且按照优先级，仅有一个位置的配置文件生效：**\n\n- **`/run/netplan` 优先级最高**\n- **`/etc/netplan` 次优先级**\n- **`/lib/netplan` 最低优先级**\n\nref：\n\nhttps://cloud-atlas.readthedocs.io/zh-cn/latest/linux/ubuntu_linux/network/netplan.html\n\nhttps://www.vicsys.com.tw/zh-hans/tech/ub/ub-network.html\n\n\n\n# other\n\n其他包含网络配置的重要文件，但我们在这里不会碰到他们：\n\n- `/etc/hosts` - 操作系统中使用的计算机文件，用于将主机名映射到 IP 地址。`hosts` 文件是一个纯文本文件，通常按照惯例命名为 `hosts`。\n- `/etc/hostname` - 分配给连接到计算机网络的设备的标签，并用于识别各种形式的电子通信设备。\n- `/etc/resolv.conf` - 各种操作系统中的计算机文件，用于配置域名系统（DNS）解析器库。该文件是纯文本文件，通常由网络管理员或管理系统配置任务的应用创建。因此 `/etc/resolv.conf` 是依据网络管理产生，修改 `resolv.conf` 只在本次有作用，重启服务将会重置。\n\n\n\n# 总结\n\n桌面环境建议使用 NetworkManager；在服务器上建议使用默认的配置工具 network，或者切换到 systemd-networkd；但是只能选取其一。除了 network 不支持无线配置，其余三个都支持。\n\n## 关于 NetworkManager 与 systemd-networkd 之间的切换\n\nA、停用 Network Manager 并激活 systemd-networkd\n\n- 停止并禁用 NetworkManager：\n\n  ```bash\n  sudo systemctl stop NetworkManager\n  sudo systemctl disable NetworkManager\n  sudo systemctl mask NetworkManager\n  ```\n\n- 启动和激活 systemd-networkd：\n\n  ```bash\n  sudo systemctl unmask systemd-networkd\n  sudo systemctl enable systemd-networkd\n  sudo systemctl start systemd-networkd\n  ```\n\nB、激活 NetworkManager 关闭 systemd-networkd\n\n- 停止并禁用 systemd-networkd：\n\n  ```bash\n  sudo systemctl disable systemd-networkd\n  sudo systemctl mask systemd-networkd\n  sudo systemctl stop systemd-networkd\n  ```\n\n- 启动和激活 NetworkManager：\n\n  ```bash\n  sudo systemctl unmask NetworkManager\n  sudo systemctl enable NetworkManager\n  sudo systemctl start NetworkManager\n  ```\n\n\n\n## 关于 netplan 指定 renderer\n\n在 `/etc/netplan` 目录下将配置文件 `.yaml` 中的 `renderer` 字段更改为需要的后端工具：\n\n- NetworkManager\n\n  ```yaml\n  network:\n    version: 2\n    renderer: NetworkManager\n  ```\n\n- systemd-networkd\n\n  ```yaml\n  network:\n    version: 2\n    renderer: networkd\n    ethernets:\n      enxx：\n        ...\n  ```\n\n最后执行：`netplan apply`；如果使用 `NetworkManager` 则不需要编写后面的 `ethernets` 字段了，完全交由 GUI 界面操作；而如果 `renderer` 指定 `networkd` ，则为 `ethernets` 编写对应的网卡配置信息，以使 `netplan` 配置到 `systemd-networkd` 工具上。\n\n\n\n# 参考\n\n\nhttps://wiki.archlinux.org/title/Network_configuration\n\nhttps://wiki.debian.org/NetworkConfiguration\n\nhttps://pan-xiao.gitbook.io/debian/config/network\n\nhttps://itboon.github.io/linux-20/network/configuration/\n\n\n\n","tags":["Linux"]},{"title":"Linux 环境变量的增删改","url":"/linux-environment-variables/","content":"\n\n\n# shell 和 bash\n\n在计算机科学中，shell 俗称壳（用来区别于核，核是指 “内核”），shell 是指 “提供使用者使用界面” 的软件（命令解析器）。它类似于 `DOS` 下的 `command.com` 和后来的 `cmd.exe`。它接收用户命令，然后调用相应的应用程序。\n\n在很多并不正式的场合，这两个名词表达的意思相同，即命令解释器。但从严格的意义上讲，命令行是指供用户输入命令的界面，其本身只是接受输入，然后把命令传递给命令解释器，后者就是 shell，从本质上讲，shell 是一个程序，它在用户和操作系统之间提供了一个面向行的可交互接口，用户在命令行中输入命令，运行在后台的 shell 把命令转换成指令代码发送给操作系统。shell 并非只有命令行这一种形式，例如 GNOME、KDE 等图形界面也是 shell，不过它们是 GUI shell，都是为了解决人机交互的问题。\n\n目前在 Linux 环境下有几种不同类型的 shell，常用的有 Bourne Shell（sh）、Bourne Again Shell（bash）、Z Shell（zsh）、C Shell（csh）、tcsh（csh 的扩展）、Korn Shell（ksh）、pdksh（ksh 的扩展）。不同的 Shell 提供不同的语法和特性。\n\nbash 相当于 shell 中的某个，shell 的范围更广。bash 的全称是 Bourne Again Shell。\n\n# 获取当前环境变量\n\n- `echo $varname` 命令输出当前指定的环境变量的值\n\n  使用 `echo` 命令可以输出指定的环境变量的值，例如：`echo $PATH`，该命令会输出当前用户的 `PATH` 环境变量值。如果你想查看其他环境变量，只需要将上述命令中的 `PATH` 替换为其他环境变量即可。\n\n- `export` 命令显示当前系统定义的所有环境变量\n\n- `printenv` / `env` 命令查看所有已定义环境变量或指定的环境变量\n\n  `printenv` 或 `env` 都可以输出所有已定义的环境变量及其对应的值。`printenv` 命令也可以单独输出当前指定的环境变量的值，例如：`printenv SHELL`，该命令会输出已定义的 `SHELL` 环境变量值。而 `env` 命令，可以使用 `env | grep VARIABLE_NAME`，查看对应的 `VARIABLE_NAME` 环境变量值。\n\nnote：`PATH` 变量定义了运行命令的查找路径，以冒号 `:` 分割不同的路径，使用 `export` 定义的时候可加双引号也可不加。\n\n\n\n# 设置环境变量\n\n## 临时环境变量\n\n### export 命令\n\n`export` 命令也可用于设置环境变量。\n\n在 shell 中执行程序时，shell 会提供一组环境变量。`export` 可新增，修改或删除环境变量，供后续执行的程序使用。`export` 的效力仅限于该次登陆操作。\n\n### set 命令\n\n`set` 命令作用主要是显示系统中已经存在的 shell 变量，以及设置 shell 变量的新变量值。使用 `set` 更改 shell 特性时，符号 \"+\" 和 \"-\" 的作用分别是打开和关闭指定的模式。`set` 命令不能够定义新的 shell 变量。\n\n具体可看：https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html\n\n\n\n## 永久环境变量\n\n### 系统级\n\n1. `/etc/environment` ：系统在登录时读取的第一个文件，用于为所有进程设置环境变量。系统使用此文件时并不是执行此文件中的命令，而是根据 `KEY=VALUE` 模式的代码，对 `KEY` 赋值以 `VALUE`，因此文件中如果要定义 `PATH` 环境变量，只需加入类似如 `PATH=$PATH:/xxx/bin` 的代码即可。\n\n2. `/etc/profile` ：是系统登录时执行的第二个文件，可以用于设定针对全系统所有用户的环境变量，并从 `/etc/profile.d` 目录的配置文件中搜集 shell 的设置；这个文件，是任何用户登陆操作系统以后都会读取的文件（如果用户的 shell 是 csh 、tcsh 、zsh ，则不会读取此文件）。该文件一般是调用 `/etc/bash.bashrc` 文件。\n\n3. `/etc/bash.bashrc` ：系统级的 `bashrc` 文件，为每一个运行 bash shell 的用户执行此文件。此文件会在用户每次打开 bash shell 时执行一次；因此，如果你想让每个使用 bash 的用户每新开一个 bash 和每次登陆都执行某些操作，或者给他们定义一些新的环境变量，就可以在这个里面设置。\n\nnote：\n\n- 生效时间：使用相同的用户打开新的终端时生效，或者手动更新环境变量生效（见更新环境变量）\n\n- 生效期限：永久有效\n\n- 生效范围：==所有用户==\n\n### 用户级\n\n1. ~/.profile: 是对应当前登录用户的 `profile` 文件，用于定制当前用户的个人工作环境。每个用户都可使用该文件输入专用于自己使用的 shell 信息，当用户登录时，该文件仅仅执行一次。默认情况下，会设置一些环境变量，执行用户的 `.bashrc` 文件。\n\n2. ~/.bashrc: 是对应当前登录用户的 bash 初始化文件，当用户每次打开 bash shell 时，系统都会执行此文件一次。通常设置环境变量修改这个文件。\n\nnote：\n\n- 生效时间：使用相同的用户打开新的终端时生效，或者手动更新环境变量生效（见更新环境变量）\n- 生效期限：永久有效\n- 生效范围：==仅对当前用户有效==\n\n\n\n**总结：**\n\n环境变量的分类可以简单的分成用户级别的环境变量以及系统级别的环境变量。\n\n系统级别环境变量定义文件：`/etc/bash.bashrc`（部分系统为：`/etc/bashrc`）、`/etc/profile`（部分系统为：`/etc/bash_profile`）、`/etc/environment`\n\n用户级别环境变量定义文件：`~/.bashrc`、`~/.profile`（部分系统为：`~/.bash_profile`）\n\n另外在用户环境变量中，系统会首先读取 `~/.profile`（或者 `~/.bash_profile`）文件，如果没有该文件则读取 `~/.bash_login`，根据这些文件中内容再去读取 `~/.bashrc`。\n\n环境变量加载顺序：\n\n`/etc/enviroment` –> `/etc/profile` –> `/etc/bash.bashrc` –> `~/.profile` –> `~/.bashrc`\n\n\n\n**tips：**\n\n一般在 `/etc/profile.d/` 目录下创建一个自定义脚本会是修改环境变量的更好方法，这样无论你在一个终端中如何切换用户，环境变量依然存在。eg：\n\n```bash command:(\"[root@localhost] $\":1)\ncat > /etc/profile.d/test.sh << EOF\nexport PATH=$PATH:/home/arachnid/mysql/bin\nEOF\n```\n\n\n\n# 删除环境变量\n\n如果是临时环境变量，或者是要临时删除一下环境变量，可以使用 `unset` 命令：`unset VARIABLE_NAME`；如果是要永久删除配置文件中的环境变量，需要去相应的配置文件中移除相关的配置项。\n\n\n\n# 更新环境变量\n\neg：更新 `/etc/profile` 文件的环境变量\n\n```bash command:(\"[root@localhost] $\":1,5)\nsource /etc/profile\n\n# or\n\n. /etc/profile\n```\n\n\n\n# 常用环境变量\n\n| 变量    | 内容                                                         |\n| ------- | ------------------------------------------------------------ |\n| DISPLAY | 如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 “:0”， 意思是由 X 产生的第一个显示器。 |\n| EDITOR  | 文本编辑器的名字。                                           |\n| SHELL   | shell 程序的名字。                                           |\n| HOME    | 用户家目录。                                                 |\n| LANG    | 定义了字符集以及语言编码方式。                               |\n| OLD_PWD | 先前的工作目录。                                             |\n| PAGER   | 页输出程序的名字。这经常设置为 /usr/bin/less。               |\n| PATH    | 由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。 |\n| PS1     | Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量内容可以全面地定制。 |\n| PWD     | 当前工作目录。                                               |\n| TERM    | 终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。 |\n| TZ      | 指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。 |\n| USER    | 你的用户名                                                   |\n\n\n\n# 参考\n\nhttps://wiki.archlinux.org/title/Environment_variables\n\nhttps://www.cnblogs.com/youyoui/p/10680329.html\n\nhttp://rvdsd.top/2018/04/28/Linux/Linux环境变量/","tags":["Linux"]},{"title":"debian 11 桌面安装 OMV 6","url":"/omv6-install/","content":"\n\n\n# Debian 安装\n\n需要注意的几个点是：\n\n1. 安装语言的时候选择英文安装，否者会造成部分乱码，至于后面想要使用中文，安装完成后再配置就好了。\n2. 配置软件包不需要选择网络镜像，后期再配置镜像源。\n3. 勾选 ssh 服务，以方便远程操作；至于是否选择图形界面，随个人喜好。\n\n\n\n## 基本配置\n\n### 添加 sudo 管理组\n\n`your_name is not in the sudoers file. This incident will be reported.`\n\n出现这种情况一般是你用普通用户键入 `sudo` 命令，但这个用户又没有加入 `sudo` 组上面，导致权限不够。\n\n解决（以下操作皆在 root 下执行）：\n\n通过追加到 sudo 组的形式，使用命令：\n\n```bash command:(\"[root@localhost] $\":2)\n# 追加（append）用户到指定组（Group）\nusermod -a -G sudo your_name\n```\n\n又或者，以修改 `/etc/sudoers` 文件的形式：\n\n```bash command:(\"[root@localhost] #\":1)\nvisudo\n```\n\n然后移动光标，在 `# User privilege specification` 下面添加 `your_name ALL=(ALL:ALL) ALL` ，根据提示 `写入 ^O` ，`回车 Enter` 确认保存， `退出 ^X`  ，得到：\n\n\n```bash command:(\"[root@localhost] #\":1)\ncat /etc/sudoers\n\\#\n\\# This file MUST be edited with the 'visudo' command as root.\n\\#\n\\# Please consider adding local content in /etc/sudoers.d/ instead of\n\\# directly modifying this file.\n\\#\n\\# See the man page for details on how to write a sudoers file.\n\\#\nDefaults\tenv_reset\nDefaults\tmail_badpass\nDefaults\tsecure_path=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\n\n\\# Host alias specification\n\n\\# User alias specification\n\n\\# Cmnd alias specification\n\n\\# User privilege specification\nroot\tALL=(ALL:ALL) ALL\nyour_name\tALL=(ALL:ALL) ALL\n\n\\# Allow members of group sudo to execute any command\n%sudo\t ALL=(ALL:ALL) ALL\n\n\\# See sudoers(5) for more information on \"@include\" directives:\n\n@includedir /etc/sudoers.d\n```\n\nnote：\n\n`su` 带有 `-` ，这和 `su` 是不同的，在用命令 `su` 的时候只是切换到 root，但没有把 root 的环境变量传过去，还是当前用户的环境变量，用 `su -` 命令会将环境变量也一起带过去，就像和 `root` 登录一样。关于 `su -` 的分析可参看：[dpkg-reconfigure命令找不到问题解决](https://cloudbool.com/dpkg-reconfigure-bash-command-not-found.html)\n\n\n\n### 避免提示光盘安装软件包\n\n`Media change: please insert the disc labeled 'Debian GNU/Linux xxx DVD' Media change: please insert the disc labeled.`\n\n在 Debian 系统中，如果您碰巧使用 DVD 安装，当你调用 `apt` 时，会抛出一个错误消息，表示存储库 cdrom 没有发布文件，并要求插入 Debian 光盘来离线安装软件包，这时候我们需要绕过去掉提示，以便使用网络安装。\n\n```bash command:(\"[user@localhost] $\":1)\nsudo nano /etc/apt/sources.list\n```\n\n得到：\n\n```text sources.list\n# deb cdrom:[Debian GNU/Linux 11.8.0 _Bullseye_ - Official amd64 DVD Binary-1 20231007-14:05]/ bullseye contrib main\n\ndeb cdrom:[Debian GNU/Linux 11.8.0 _Bullseye_ - Official amd64 DVD Binary-1 20231007-14:05]/ bullseye contrib main\n\n# Line commented out by installer because it failed to verify:\n#deb http://security.debian.org/debian-security bullseye-security main contrib\n# Line commented out by installer because it failed to verify:\n#deb-src http://security.debian.org/debian-security bullseye-security main contrib\n```\n\n可以看到，默认是先通过 `deb cdrom:...` 安装软件的。所以在前面加一个 `#` 把这行注释掉即可；最后 `写入 ^O` ，`回车 Enter` 确认保存， `退出 ^X` 。\n\n\n\n### 更换软件包镜像源\n\n`E: Package 'xxx' has no installation candidate.`\n\n这种情况一般是软件包获取不到，可能是网络问题，也可能是因为源的问题，换个好一点的镜像源就行了。\n\n例如：更换为 [清华源地址](https://mirrors.tuna.tsinghua.edu.cn/help/debian/)\n\n```bash command:(\"[user@localhost] $\":1-3)\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.back\nsudo nano /etc/apt/sources.list\nsudo apt update\n```\n\nnote：\n\n先找到镜像源文件并备份，然后使用 `nano` 编辑，把获取到的镜像源地址全部覆盖替换原有的文本，最后再执行 `apt update` 更新软件包，至此就可以安装原本装失败的软件了。如果用不习惯 `nano` 编辑器，可以安装 `vim` 。\n\n\n\n### 内核编译工具\n\n`make[n]: *** /lib/modules/kernel_version-amd64/build: No such file or directory.`\n\n在编译部署内核模块的时候，如果报这个错误，是因为没有 `linux-headers` 导致。\n\n```bash command:(\"[user@localhost] $\":1-2)\nsudo apt update\nsudo apt install linux-headers-$(uname -r)-amd64\n```\n\nnote：\n\n命令 `uname -r` 就是用来获取当前内核版本的。\n\n一般编译驱动会用到 `sudo apt-get install build-essential linux-headers-$(uname -r)-amd64`\n\n\n\n### 网卡驱动添加\n\n获取网卡型号：\n\n```bash command:(\"[user@localhost] $\":1)\nlspci | grep -i net\n02:00.0 Network controller: Realtek Semiconductor Co., Ltd. RTL8723BE PCIe Wireless Network Adapter\n03:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)\n```\n\n其中 `Ethernet controller` 后面的表示以太网有线网卡，这里是 RTL8111/8168/8411； `Network controller` 后面表示无线网卡，这里则是 RTL8723BE。\n\n- 有线网卡\n\n  一般主板上的有线网卡都是自带驱动的，但不排除驱动不管用或者另类没有，这个时候就需要自己找驱动，当然，如果有现成编译好打好包的驱动，那么只需要用 U盘 copy 到系统然后进行安装即可，如果没有，那么就需要自己编译驱动了，这是一个很麻烦的事，特别是你完全没网的时候，光是安装一堆依赖都得一个个找。。。\n\n  当然你也可以找个联网的虚拟机，安装一样的系统，编译好再 copy 过去；或者利用 `apt-cache depends package_name` 获取安装依赖，然后一个个安装；对于 `.deb` 文件，可以用 `dpkg --info path_deb_file` 查看。\n\n- 无线网卡\n\n  在 Debian 最小安装中，是不存在无线网卡驱动的，只能自己安装：\n\n  - intel 的无线网卡驱动：\n\n    ```bash command:(\"[root@localhost] #\":1)\n    apt install firmware-iwlwifi\n    ```\n\n    支持型号：https://packages.debian.org/bullseye/firmware-iwlwifi\n\n  - realtek（小螃蟹）的无线网卡驱动：\n\n    ```bash command:(\"[root@localhost] #\":1)\n    apt install firmware-realtek\n    ```\n\n    支持型号：https://packages.debian.org/bullseye/firmware-realtek\n\n  - 高通的无线网卡驱动：\n\n    ```bash command:(\"[root@localhost] #\":1)\n    apt install firmware-atheros\n    ```\n\n    支持型号：https://packages.debian.org/bullseye/firmware-atheros\n\n  - other：\n\n    当然，如果你像一劳永逸，可以直接安装 `firmware-nonfree` 整个大包，或者在里面找相应的型号子包安装：https://packages.debian.org/source/bullseye/firmware-nonfree；而对于其它比较新的设备或者不在清单上的设备，可以去官网或者开源广场上找，但大部分需要自己编译驱动。\n\n关于网卡驱动安装完后，可以 `reboot` 重启，然后执行 `dmesg -l err` 查看日志，看驱动是否生效，如果没有，将会出现 error，然后排查解决就好了。\n\n\n\n### 引导时间修改\n\n如果你是单系统，可以更改引导时间缩短跳转启动系统的时间。\n\n```bash command:(\"[root@localhost] #\":1)\nnano /etc/default/grub\n```\n\n更改 `GRUB_TIMEOUT` 数值为 1，这里建议不要改成 0，留出 1s 的时间，防止以后有用到。\n\n```bash command:(\"[root@localhost] #\":1)\ncat /etc/default/grub\n# If you change this file, run 'update-grub' afterwards to update\n# /boot/grub/grub.cfg.\n# For full documentation of the options in this file, see:\n#   info -f grub -n 'Simple configuration'\n\nGRUB_DEFAULT=0\nGRUB_TIMEOUT=1\nGRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"\nGRUB_CMDLINE_LINUX=\"\"\n\n# Uncomment to enable BadRAM filtering, modify to suit your needs\n# This works with Linux (no patch required) and with any kernel that obtains\n# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)\n#GRUB_BADRAM=\"0x01234567,0xfefefefe,0x89abcdef,0xefefefef\"\n\n# Uncomment to disable graphical terminal (grub-pc only)\n#GRUB_TERMINAL=console\n\n# The resolution used on graphical terminal\n# note that you can use only modes which your graphic card supports via VBE\n# you can see them in real GRUB with the command `vbeinfo'\n#GRUB_GFXMODE=640x480\n\n# Uncomment if you don't want GRUB to pass \"root=UUID=xxx\" parameter to Linux\n#GRUB_DISABLE_LINUX_UUID=true\n\n# Uncomment to disable generation of recovery mode menu entries\n#GRUB_DISABLE_RECOVERY=\"true\"\n\n# Uncomment to get a beep at grub start\n#GRUB_INIT_TUNE=\"480 440 1\"\n```\n\n最后更新 Grub：\n\n```bash command:(\"[root@localhost] #\":1)\nupdate-grub\n```\n\nnote：\n\n可以通过 `systemd-analyze time` 查看开机时间，通过 `systemd-analyze blame` 查看开机服务占用时间。\n\n\n\n### ssh 配置\n\n在安装的时候有勾选 ssh 服务的话，那么只需要配置一下文件即可，否则就需要自己去下载。（当然，这里只是前置使用，后期安装 OMV 后，将由 OMV 接管）\n\n\n\n### 安装中文输入法\n\n在 linux 系统中，常见的两大输入法框架：ibus 和 fcitx，而这里使用 Fcitx5，是用来接替 Fcitx 的。\n\n> 注意： fcitx5 包仅提供基本框架，且仅支持英文。如果要输入其他语言（例如中文或日文），则需要安装输入法引擎（IME）。\n\n\n\nFcitx5 输入法引擎有以下几种：\n\n**中文**\n\n- fcitx5-chewing包：是流行的繁体中文注音输入引擎，它基于 libchewing包。\n\n- fcitx5-chinese-addons包：包含与中文相关的 addon，例如拼音、双拼和五笔。\n\n- fcitx5-rime包：使用 Rime 引擎。\n\n**日文**\n\n- fcitx5-anthy包：是流行的日文输入引擎。但是，它已不再受到积极开发。\n\n- fcitx5-kkc包：是日文假名输入引擎，它基于 libkkc包。\n\n- fcitx5-mozc包：基于 Mozc（Google 日文输入法的开源版本）。\n\n- fcitx5-skk包：是日文假名输入引擎，它基于 libskk包。\n\n**其他语言**\n\n- fcitx5-hangul包：用于输入韩文，基于 libhangul包。\n- fcitx5-unikey包：可用于输入越南语字符。\n- fcitx5-m17n包：可用于各种语言。\n\n\n\n\n1、卸载旧版及其余输入法\n\n```bash command:(\"[root@localhost] #\":1)\napt purge fcitx* ibus*\n```\n\n2、安装 Fcitx5 简体中文输入\n\n```bash command:(\"[root@localhost] #\":1)\napt install fcitx5 fcitx5-chinese-addons\n```\n\n3、重启配置\n\n```bash command:(\"[root@localhost] #\":1)\nreboot\n```\n\n开机后查看 fcitx5 是否随桌面环境自动启动，如无，则添加开机自启：\n\n```bash command:(\"[root@localhost] #\":1,4)\nif [ ! -d \"~/.config/autostart/\" ]; then\n mkdir  ~/.config/autostart/\nfi\ncp /usr/share/applications/org.fcitx.Fcitx5.desktop ~/.config/autostart/\n```\n\n4、添加拼音输入\n\n在应用中打开 Fcitx5 配置，然后在输入法中添加中文拼音，同时在全局选项中配置输入法切换快捷键（默认是 `Ctrl + 空格键` 切换）。\n\n5、修改全局变量\n\n- 使用 `im-config` 组件配置\n\n```bash command:(\"[root@localhost] #\":1-3)\napt install im-config\n\nim-config\n```\n\n进入图形界面选择 Fcitx5 输入法。\n\n- 编辑 `/etc/environment`\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/environment\n```\n\n添加如下全局配置：\n\n```text /etc/environment\nGTK_IM_MODULE=fcitx\nQT_IM_MODULE=fcitx\nXMODIFIERS=@im=fcitx\nSDL_IM_MODULE=fcitx\nINPUT_METHOD=fcitx\nGLFW_IM_MODULE=ibus\n```\n\n资料：\n\nhttps://wiki.archlinuxcn.org/wiki/Fcitx5\n\nhttps://wiki.debian.org/zh_CN/I18n/Fcitx5\n\n\n\n## 节电处理\n\n### 无线\n\n软件关闭蓝牙功能：\n\n```bash command:(\"[root@localhost] #\":1)\nrfkill block bluetooth\n```\n\n软件关闭 wifi 功能：\n\n```bash command:(\"[root@localhost] #\":1)\nrfkill block wifi\n```\n\n\n\n### USB\n\n添加 USB 空闲自动挂起处理，空闲等待时间为 2S，`reboot` 重启生效：\n\n```bash command:(\"[root@localhost] #\":1-2)\necho 'ACTION==\"add\", SUBSYSTEM==\"usb\",  ATTR{power/control}=\"auto\", ATTR{power/autosuspend_delay_ms}=\"2000\"' > /etc/udev/rules.d/50-usb_power_save.rules\nreboot\n```\n\n其它控制：\n\n`ATTR{power/control}=\"on\"` or `ATTR{power/autosuspend_delay_ms}=\"-1\"`，表示禁用挂起；`ATTR{power/wakeup}=\"enable\"`，表示使能 usb 唤醒，写入 `disable` 则关闭。\n\n如果想要单独设置，可以如下查看 usb 设备对应的 udev 字段，eg：查看 Logitech 鼠标：\n\n```bash command:(\"[root@localhost] #\":1)\nlsusb\nBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\nBus 001 Device 003: ID 0bda:b728 Realtek Semiconductor Corp. RTL8723B Bluetooth\nBus 001 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver\nBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\n\nlsusb -tvv\n/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/7p, 5000M\n    ID 1d6b:0003 Linux Foundation 3.0 root hub\n    /sys/bus/usb/devices/usb2  /dev/bus/usb/002/001\n/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/9p, 480M\n    ID 1d6b:0002 Linux Foundation 2.0 root hub\n    /sys/bus/usb/devices/usb1  /dev/bus/usb/001/001\n    |__ Port 4: Dev 2, If 1, Class=Human Interface Device, Driver=usbhid, 12M\n        ID 046d:c52b Logitech, Inc. Unifying Receiver\n        /sys/bus/usb/devices/1-4  /dev/bus/usb/001/002\n    |__ Port 4: Dev 2, If 2, Class=Human Interface Device, Driver=usbhid, 12M\n        ID 046d:c52b Logitech, Inc. Unifying Receiver\n        /sys/bus/usb/devices/1-4  /dev/bus/usb/001/002\n    |__ Port 4: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 12M\n        ID 046d:c52b Logitech, Inc. Unifying Receiver\n        /sys/bus/usb/devices/1-4  /dev/bus/usb/001/002\n    |__ Port 8: Dev 3, If 0, Class=Wireless, Driver=btusb, 12M\n        ID 0bda:b728 Realtek Semiconductor Corp. RTL8723B Bluetooth\n        /sys/bus/usb/devices/1-8  /dev/bus/usb/001/003\n    |__ Port 8: Dev 3, If 1, Class=Wireless, Driver=btusb, 12M\n        ID 0bda:b728 Realtek Semiconductor Corp. RTL8723B Bluetooth\n        /sys/bus/usb/devices/1-8  /dev/bus/usb/001/003\n\nudevadm info -a /dev/bus/usb/001/002\n\nUdevadm info starts with the device specified by the devpath and then\nwalks up the chain of parent devices. It prints for every device\nfound, all possible attributes in the udev rules key format.\nA rule to match, can be composed by the attributes of the device\nand the attributes from one single parent device.\n\n  looking at device '/devices/pci0000:00/0000:00:15.0/usb1/1-4':\n    KERNEL==\"1-4\"\n    SUBSYSTEM==\"usb\"\n    DRIVER==\"usb\"\n    ATTR{authorized}==\"1\"\n    ATTR{avoid_reset_quirk}==\"0\"\n    ATTR{bConfigurationValue}==\"1\"\n    ATTR{bDeviceClass}==\"00\"\n    ATTR{bDeviceProtocol}==\"00\"\n    ATTR{bDeviceSubClass}==\"00\"\n    ATTR{bMaxPacketSize0}==\"8\"\n    ATTR{bMaxPower}==\"98mA\"\n    ATTR{bNumConfigurations}==\"1\"\n    ATTR{bNumInterfaces}==\" 3\"\n    ATTR{bcdDevice}==\"1211\"\n    ATTR{bmAttributes}==\"a0\"\n    ATTR{busnum}==\"1\"\n    ATTR{configuration}==\"RQR12.11_B0032\"\n    ATTR{devnum}==\"2\"\n    ATTR{devpath}==\"4\"\n    ATTR{idProduct}==\"c52b\"\n    ATTR{idVendor}==\"046d\"\n    ATTR{ltm_capable}==\"no\"\n    ATTR{manufacturer}==\"Logitech\"\n    ATTR{maxchild}==\"0\"\n    ATTR{power/active_duration}==\"5486884\"\n    ATTR{power/async}==\"enabled\"\n    ATTR{power/autosuspend}==\"2\"\n    ATTR{power/autosuspend_delay_ms}==\"2000\"\n    ATTR{power/connected_duration}==\"5486884\"\n    ATTR{power/control}==\"on\"\n    ATTR{power/level}==\"on\"\n    ATTR{power/persist}==\"1\"\n    ATTR{power/runtime_active_kids}==\"0\"\n    ATTR{power/runtime_active_time}==\"5486602\"\n    ATTR{power/runtime_enabled}==\"forbidden\"\n    ATTR{power/runtime_status}==\"active\"\n    ATTR{power/runtime_suspended_time}==\"0\"\n    ATTR{power/runtime_usage}==\"1\"\n    ATTR{power/wakeup}==\"enabled\"\n    ATTR{power/wakeup_abort_count}==\"0\"\n    ATTR{power/wakeup_active}==\"0\"\n    ATTR{power/wakeup_active_count}==\"0\"\n    ATTR{power/wakeup_count}==\"0\"\n    ATTR{power/wakeup_expire_count}==\"0\"\n    ATTR{power/wakeup_last_time_ms}==\"0\"\n    ATTR{power/wakeup_max_time_ms}==\"0\"\n    ATTR{power/wakeup_total_time_ms}==\"0\"\n    ATTR{product}==\"USB Receiver\"\n    ATTR{quirks}==\"0x0\"\n    ATTR{removable}==\"removable\"\n    ATTR{rx_lanes}==\"1\"\n    ATTR{speed}==\"12\"\n    ATTR{tx_lanes}==\"1\"\n    ATTR{urbnum}==\"34\"\n    ATTR{version}==\" 2.00\"\n\n...\n```\n\n**参看：**\n\nhttps://docs.kernel.org/driver-api/usb/power-management.html\n\nhttps://wiki.archlinux.org/title/Udev#Waking_from_suspend_with_USB_device\n\nhttp://www.reactivated.net/writing_udev_rules.html#example-printer\n\n\n\n### cpu 调度\n\n一般支持以下几种策略，旧内核可能不支持 `schedutil` ：\n\n| Governor     | Description                                                  |\n| ------------ | ------------------------------------------------------------ |\n| performance  | Run the CPU at the maximum frequency, obtained from `/sys/devices/system/cpu/cpuX/cpufreq/scaling_max_freq`. |\n| powersave    | Run the CPU at the minimum frequency, obtained from `/sys/devices/system/cpu/cpuX/cpufreq/scaling_min_freq`. |\n| userspace    | Run the CPU at user specified frequencies, configurable via `/sys/devices/system/cpu/cpuX/cpufreq/scaling_setspeed`. |\n| ondemand     | Scales the frequency dynamically according to current load. Jumps to the highest frequency and then possibly back off as the idle time increases. |\n| conservative | Scales the frequency dynamically according to current load. Scales the frequency more gradually than ondemand. |\n| schedutil    | Scheduler-driven CPU frequency selection.                    |\n\n关于 `schedutil` 的原理可看：https://deepinout.com/android-system-analysis/android-cpu-related/principle-analysis-of-cpu-governor-schedutil.html\n\n\n\n查看 cpu 支持的调度策略及当前使用的模式：\n\n```bash command:(\"[root@localhost] #\":1,3)\ncat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors\nconservative ondemand performance schedutil\ncat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\nschedutil\n```\n\n\n\n修改所有 cpu 的策略：\n\n```bash command:(\"[root@localhost] #\":1)\necho governor | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor\ngovernor\n```\n\nnote：`governor` 为支持的策略之一，选你需要更改的就好了。\n\n**注意，该操作只在当前生效，任何复位或重启后，都将恢复默认操作，因此如果要让每次生效，那么需要编写开机脚本或写入内核。**\n\n\n\n查看各 cpu 频率：\n\n```bash command:(\"[root@localhost] #\":1)\ncat /proc/cpuinfo | grep -E '^model name|^cpu MHz'\nmodel name      : Intel(R) Pentium(R) Silver J5040 CPU @ 2.00GHz\ncpu MHz         : 1029.564\nmodel name      : Intel(R) Pentium(R) Silver J5040 CPU @ 2.00GHz\ncpu MHz         : 1168.290\nmodel name      : Intel(R) Pentium(R) Silver J5040 CPU @ 2.00GHz\ncpu MHz         : 818.342\nmodel name      : Intel(R) Pentium(R) Silver J5040 CPU @ 2.00GHz\ncpu MHz         : 960.974\n```\n\n资料：\n\nhttps://wiki.archlinux.org/title/CPU_frequency_scaling#Scaling_governors\n\nhttps://blog.kelu.org/tech/2021/05/13/bios-config-remark.html\n\n\n\n### 睡眠与休眠\n\n关于 Suspend，Linux 内核提供了四种电源模式，如下表：\n\n| 模式    | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| freeze  | 冻结 I/O 设备，将它们置于低功耗状态，使处理器进入空闲状态，唤醒最快，耗电比其它 standby, mem, disk 方式高。 |\n| standby | 除了冻结 I/O 设备外，还会暂停系统，唤醒较快，耗电比其它 mem, disk 方式高。 |\n| mem     | 将运行状态数据存到内存，并关闭外设，进入等待模式，唤醒较慢，耗电比 disk 方式高。（实际由 `/sys/power/mem_sleep` 抉择） |\n| disk    | 将运行状态数据存到硬盘，然后关机，唤醒最慢；对于嵌入式系统，由于没有硬盘，所以一般不支持。（实际由 `/sys/power/disk` 抉择） |\n\n然，虽然 linux 内核支持，但实际上不同的平台，对应的支持也是不一样的；可以使用以下命令查看对 Suspend 支持：\n\n```bash command:(\"[root@localhost] #\":1)\ncat /sys/power/state\nfreeze mem disk\n```\n\n在这里，就只支持 3 种：`freeze` 、 `mem` 、 `disk` 。\n\n\n\n在 linux 中，有两个比较特殊的 Suspend 管理，那就是 `mem` 和 `disk` ，分别是 **Suspend to RAM（挂起到内存，通称睡眠）** 和 **Suspend to disk（挂起到硬盘，通称休眠）** 这两种电源管理模式，它们默认使用的 ACPI 定义如下：\n\n- Suspend to RAM（挂起到内存，通称睡眠）\n\n  ACPI 定义的 **S3** 睡眠状态。通过将机器中大多数和 RAM 不相关的部件断电来工作，RAM 是恢复机器状态所必需的。由于可以节省大量电力，建议笔记本电脑在使用电池运行且盖子关闭时（或用户在一段时间内处于非活动状态）自动进入此模式。\n\n- Suspend to disk（挂起到硬盘，通称休眠）\n\n  ACPI 定义的 **S4** 睡眠状态。将机器状态保存到交换空间并关闭机器。再次开机后，恢复状态。直到开机前，机器都不会有任何待机功耗。\n\nnote：实际上， `mem` 和 `disk` 是由它们对应的配置文件决定的，但一般默认会使用上面的 ACPI 状态。\n\n\n\n对于 `mem` 和 `disk` 的控制：\n\n`mem` 模式的操作由 `/sys/power/mem_sleep` 抉择，常见以下几种睡眠处理：\n\n-  deep：Suspend-To-RAM，对应 ACPI 为 S3；\n-  shallow：Power-On Suspend，对应 ACPI 为 S1；\n-  s2idle：Suspend-To-Idle，对应 ACPI 为 S0；\n\n`disk` 模式的操作则由 `/sys/power/disk` 抉择，常见以下几种休眠处理：\n\n- platform：使用平台（BIOS支持）提供的方法将把系统置于超低功耗状态（如 ACPI S4），使得额外的唤醒选项可用，并且让平台固件在唤醒之后可能允许做一个简简的初始化；\n- shutdown：顾名思义就是关闭系统设备断电；\n- reboot：这个。。。不用说了吧；\n- suspend：系统混合挂起，是的没错，可以将睡眠和休眠混合，可以通过在  `/etc/systemd/sleep.conf` 文件进行配置以达到效果，可参考：[挂起或休眠请求时的混合睡眠](https://wiki.archlinuxcn.org/wiki/电源管理#挂起或休眠请求时的混合睡眠) ；\n- test_resume：诊断操作。先是加载镜像（就好像系统刚从休眠中醒来，当前运行的内核实例是还原内核），然后再恢复整个系统。\n\n查看支持：\n\n```bash command:(\"[root@localhost] #\":1,3)\ncat /sys/power/mem_sleep\ns2idle [deep]\ncat /sys/power/disk\n[platform] shutdown reboot suspend test_resume\n```\n\n如果想要切换相应的控制，只需往写入你要的处理模式就好了；当然，这只是在下一次中生效，当执行完一次后将会恢复；若要设成永久处理，那么可以通过修改内核属性来达到效果。\n\n\n\n**自动休眠：**\n\n一般作为服务器，是不需要自动休眠的，但对于一周也用不了多少次的，可能使用自动休眠会省电一点，配合唤醒功能即可达到快速恢复工作环境的效果。\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/default/grub\n```\n\n然后添加 `GRUB_CMDLINE_LINUX=\"mem_sleep_default=deep\"` ，然后重新生成 `grub.cfg` 文件，重启生效：\n\n```bash command:(\"[root@localhost] #\":1-2)\ngrub-mkconfig -o /boot/grub/grub.cfg\nreboot\n```\n\n资料：\n\nhttps://wiki.archlinux.org/title/Power_management/Suspend_and_hibernate\n\nhttps://man.archlinux.org/man/sleep.conf.d.5\n\nhttps://wiki.archlinux.org/title/Power_management#Suspend_and_hibernate\n\nhttps://www.unixtutorial.org/disable-sleep-on-ubuntu-server/\n\nhttps://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html\n\n\n\n更多电源管理：https://wiki.archlinux.org/title/Power_management#Power_saving\n\nKernel 参数：https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt\n\n\n\n## 图形环境切换\n\n前提：系统已经安装了桌面环境，需要禁止桌面环境，以纯命令行启动，以节约性能。\n\n获取当前系统运行的界面模式：\n\n```bash command:(\"[root@localhost] #\":1)\nsystemctl get-default\n```\n\n纯命令行启动：\n\n```bash command:(\"[root@localhost] #\":1-2)\nsystemctl set-default multi-user.target\nreboot\n```\n\nnote：如果想从命令行中启动桌面，可以通过相应的图形界面启动命令来启动，例如启动 xfce4 的桌面：`startxfce4` .\n\n桌面环境启动：\n\n```bash command:(\"[root@localhost] #\":1-2)\nsystemctl set-default graphical.target\nreboot\n```\n\n\n\n对于多桌面，可以使用下面命令，然后选择对应的桌面系统，输入序号确认：\n\n```bash command:(\"[root@localhost] #\":1)\nupdate-alternatives --config x-session-manager\n```\n\n如果要删除 `x-session-manager` 的某个选项，可以先通过以下方式列出其路径，然后通过删除选项（eg：gnome-session）：\n\n```bash command:(\"[root@localhost] #\":1-2)\nupdate-alternatives --list x-session-manager\nupdate-alternatives --remove x-session-manager /usr/bin/gnome-session\n```\n\n参考：\n\nhttps://unix.stackexchange.com/questions/367294/how-do-i-change-my-default-session\n\n\n\n## 远程唤醒\n\n首先，查看系统主板 BIOS 是否支持 Wake-On-LAN ，要是支持的话，必须先启动它，因为它被默认设禁用。\n\n然后，需要一个支持 Wake-On-LAN 的网卡；==无线网卡并不支持==。你需要运行 `ethtool` 命令查看网卡是否支持 Wake-On-LAN ：\n\n```bash command:(\"[root@localhost] #\":1-2)\napt install ethtool\nethtool eno1 | grep Wake-on\n        Supports Wake-on: pumbg\n        Wake-on: d\n```\n\n这条命令输出的 `Supports Wake-on` 字段会告诉你你的网卡支持哪些功能，同时 `Wake-on` 指示着当前配置的模式，一般有以下几种选项：\n\n- d -- 禁用（disable）\n- p -- 物理活动唤醒（Wake on PHY activity）\n- u -- 单播消息唤醒（Wake on unicast activity）\n- m -- 多播（组播）消息唤醒（Wake on multicast activity）\n- b -- 广播消息唤醒（Wake on broadcast activity）\n- a -- ARP 唤醒（Wake on ARP activity）\n- g -- 特定数据包唤醒（magic packet activity）\n\n修改 wol 功能：\n\n```bash command:(\"[root@localhost] #\":1-2)\nethtool -s eno1 wol g\nethtool eno1 | grep Wake-on\n        Supports Wake-on: pumbg\n        Wake-on: g\n```\n\n此刻已经开启 magic packet 唤醒了，然后执行 `ip a` 查看网卡的 mac 地址和 ip 并记录，再写入 `echo mem > /sys/power/state` ，让系统进入休眠，再在另一台主机测试网络唤醒。\n\n- Windows\n\n  可以选择该工具使用：[Wake On Lan Command Line](https://www.depicus.com/wake-on-lan/wake-on-lan-cmd) 。\n\n- Linux\n\n  可以安装对应的 pack 包（eg：etherwake），这里就不多说了。\n\n当你能成功唤醒后，就证明你的主板支持，bios 上的 wol 有启用，系统配置上也打开了。\n\n最后，对于部分系统，可能有些在设置完显示 `Wake-on: g` 后，重启会变回默认配置，这时可以编写一个开机启动服务：\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/systemd/system/wol@.service\n```\n\n添加如下内容：\n\n```text wol@.service\n[Unit]\nDescription=Wake-on-LAN for %i\nRequires=network.target\nAfter=network.target\n\n[Service]\nExecStart=/usr/bin/ethtool -s %i wol g\nType=oneshot\n\n[Install]\nWantedBy=multi-user.target\n```\n\n然后 [Install] 区块中的 `WantedBy` 字段，是表示该服务所在的 Target。如 `WantedBy=multi-user.target` 指的是该服务所属于 `multi-user.target` ；当执行 `systemctl enable xxx.service` 命令时，`xxx.service` 的符号链接就会被创建在 `/etc/systemd/system/multi-user.target` 目录下。可以通过 `systemctl get-default` 命令查看系统默认启动的 target，一般为 `multi-user` 或者是 `graphical`。因此配置好相应的 `WantedBy` 字段，可以实现服务的开机启动。\n\n`multi-user.target` 表示多用户命令行状态； `graphical.target` 表示图形用户状态，它依赖于 `multi-user.target` 。官方文档有一张非常清晰的 [Target 依赖关系图](https://www.freedesktop.org/software/systemd/man/bootup.html#System Manager Bootup)。\n\n嘛，如果你是用图形界面的，也是可以用 `multi-user.target` 的，因为 `graphical.target` 依赖 `multi-user.target` ，可以利用命令 `systemctl list-units --type=target` 查看到 `multi-user.target` 是处于 Active 状态的。\n\n最后，重新加载所有的 systemd 服务，打开自启动并启动服务，其中 `@` 后面跟随的是你的 wol 网卡名称：\n\n```bash command:(\"[user@localhost] $\":1-3)\nsudo systemctl daemon-reload\nsudo systemctl enable wol@eno1\nsudo systemctl start wol@eno1\n```\n\nnote：\n\n对于 systemd 服务的控制，可以使用如下命令：\n\n```bash\nsystemctl [command] [unit]\n```\n\n[command]：\n\n- start：立刻启动后面接的 unit。\n\n- stop：立刻关闭后面接的 unit。\n- restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。\n- reload：不关闭 unit 的情况下，重新载入配置文件，让设置生效。\n- enable：设置下次开机时，后面接的 unit 会被启动。\n- disable：设置下次开机时，后面接的 unit 不会被启动。\n\n- status：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。\n- is-active：目前有没有正在运行中。\n- is-enable：开机时有没有默认要启用这个 unit。\n- kill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。\n- show：列出 unit 的配置。\n- mask：注销 unit，注销后你就无法启动这个 unit 了。\n- unmask：取消对 unit 的注销。\n\n一些其它命令：\n\n```bash\nsystemctl poweroff # 系统关机\n\nsystemctl reboot # 重新开机\n\nsystemctl suspend # 进入暂停模式\n\nsystemctl hibernate # 进入休眠模式\n\nsystemctl rescue # 强制进入救援模式\n\nsystemctl emergency # 强制进入紧急救援模式\n```\n\n资料：\n\nhttps://wiki.archlinux.org/title/Wake-on-LAN\n\nhttps://wiki.debian.org/WakeOnLan\n\n\n\n## 异常记录查看\n\n使用 `last -x shutdown reboot` 命令可以查看系统的关机和重启记录，包括异常关机。该命令会显示每次关机或重启的时间、持续时间。\n\n使用 `dmesg | grep \"shutdown\"` 命令可以查看内核的消息缓冲区，筛选出关机的相关信息。\n\n参考：\n\n\nhttps://unix.stackexchange.com/questions/9819/how-to-find-out-from-the-logs-what-caused-system-shutdown\n\nhttps://blog.csdn.net/qq_28345657/article/details/126833131\n\n\n\n## 系统备份\n\nlinux 系统说白了就是一个强大的文件系统，既然是文件，哪能不能像日常备份文件那样直接压缩备份呢？答案是可以，只是在备份压缩的时候注意把各个文件的权限都保留下来。\n\n在备份之前先了解一下 linux 的系统目录结构：\n\n| 文件夹 | 英文全称 | 文件夹作用 |\n| --- | --- | --- |\n| /boot | Boot | 存放的启动 Linux 时使用的内核文件，包括连接文件以及镜像文件。 |\n| /bin | Binaries | 存放着最常用的程序和指令，所有用户都可以执行。是 `/usr/bin` 目录的软连接。 |\n| /sbin | Super User Binaries | 保存和系统环境设置相关的命令，只有超级用户可以使用这些命令，有些命令可以允许普通用户查看。是 `/usr/sbin` 目录的软连接。 |\n| /usr | Unix Software Resources | 用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 |\n| /usr/bin | Unix Software Resources Binaries | 系统用户使用的应用程序与指令。 |\n| /usr/sbin | Unix Software Resources Superuser Binaries | 超级用户使用的比较高级的管理程序和系统守护程序。 |\n| /usr/local | Unix Software Resources Local | 安装第三方软件的安装目录，一般是通过编译源码的方式安装的程序。 |\n| /usr/src | Unix Software Resources Source | 内核源代码默认的放置目录。 |\n| /dev | Devices | 存放的是 Linux 的外部设备。注意：在 Linux 中访问设备和访问文件的方式是相同的。 |\n| /etc | Editable Text Configuration Chest | 存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 |\n| /opt | Optional Application Software Packages | 可选应用软件包，第三方安装的软件保存位置，存放软件安装包。 |\n| /lib | Library | 存放基本代码库（比如 c++ 库），其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 |\n| /proc | Processes | 虚拟文件系统，数据保存在内存中，存放当前进程信息 |\n| /root | Root | 系统管理员的用户主目录。 |\n| /tmp | Temporary | 存放临时文件 |\n| /var | Variable | 存放经常修改的数据，比如程序运行的日志文件（`/var/log` 目录下）。 |\n| /home | Home | 用户缺省宿主目录。 |\n| /lost+found | Lost And Found | 一般情况下为空的，存放一些系统出错的检查结果 |\n| /srv | Server | 服务数据目录 |\n| /sys | System | 这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中。 |\n| /mnt | Mount | 挂载目录。临时文件系统的安装点，默认挂载光驱和软驱的目录 |\n| /media | Media | 挂载目录。 挂载媒体设备，如软盘和光盘 |\n| /misc | Miscellaneous Device | 挂载目录。 挂载NFS服务 |\n| /run | Run | 里面的东西是系统运行时需要的，不能随便删除。当系统重启时，这个目录下的文件应该被删掉或清除；下次系统运行时重新生成。 |\n\n\n\n备份系统：\n\n```bash command:(\"[user@localhost] $\":1||\"[root@localhost] #\":2-3)\nsudo -s\ncd /\ntar -zcvpf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys --exclude=/media --exclude=/srv/dev-disk-by-uuid* /\n```\n\n恢复系统：\n\n如果原来的 Debian 系统已经崩溃，无法进入。则可以在目标机上用 ISO、LiveCD 等启动，挂载磁盘（一般会自动挂载到 `/media` 文件夹）\n\n```bash command:(\"[user@localhost] $\":1||\"[root@localhost] #\":2-3)\nsudo -s\ntar -zcvpf backup.tgz -C /media/<对应的磁盘>\nmkdir -p proc lost+found mnt sys media\n```\n\n\n\n# 安装 openmediavault 6.x\n\n在操作如下流程前，要进行备份！备份！备份！\n\n具体安装以 https://docs.openmediavault.org/en/latest/installation/on_debian.html 为准。\n\n1、临时配置环境变量\n\n```bash command:(\"[root@localhost] #\":1-3)\nexport LANG=C.UTF-8\nexport DEBIAN_FRONTEND=noninteractive\nexport APT_LISTCHANGES_FRONTEND=none\n```\n\n2、添加软件包存储库\n\n进入文件编辑：\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/apt/sources.list.d/openmediavault.list\n```\n\n然后粘贴以下存储库链接（这里使用的是 [北外镜像](https://mirrors.bfsu.edu.cn/help/openmediavault/)，以加快国内访问速度，当然你也可以使用源链接），保存退出：\n\n```text openmediavault.list\ndeb https://mirrors.bfsu.edu.cn/OpenMediaVault/public shaitan main\ndeb https://mirrors.bfsu.edu.cn/OpenMediaVault/packages shaitan main\n## Uncomment the following line to add software from the proposed repository.\n# deb https://mirrors.bfsu.edu.cn/OpenMediaVault/public shaitan-proposed main\n# deb https://mirrors.bfsu.edu.cn/OpenMediaVault/packages shaitan-proposed main\n## This software is not part of OpenMediaVault, but is offered by third-party\n## developers as a service to OpenMediaVault users.\n# deb https://mirrors.bfsu.edu.cn/OpenMediaVault/public shaitan partner\n# deb https://mirrors.bfsu.edu.cn/OpenMediaVault/packages shaitan partner\n```\n\n3、添加 openmediavault 密钥\n\n```bash command:(\"[root@localhost] #\":1-2)\napt-get install --yes gnupg\nwget --quiet --output-document=- https://packages.openmediavault.org/public/archive.key | gpg --dearmor --yes --output \"/usr/share/keyrings/openmediavault-archive-keyring.gpg\"\n```\n\n4、更新软件包源并安装 omv\n\n```bash command:(\"[root@localhost] #\":1-2)\napt-get update\napt-get --yes --auto-remove --show-upgraded \\\n    --allow-downgrades --allow-change-held-packages \\\n    --no-install-recommends \\\n    --option DPkg::Options::=\"--force-confdef\" \\\n    --option DPkg::Options::=\"--force-confold\" \\\n    install openmediavault\n```\n\n5、同步系统配置\n\n```bash command:(\"[root@localhost] #\":1)\nomv-confdbadm populate\n```\n\nnote：\n\n对于网络服务，现在只解析 `/etc/network/interfaces` 以获取当前的网络配置。 如果以不同的方式配置网络（例如通过 `systemd` 或 `NetworkManager`），则不会填充数据库，并且不包含使用 `netplan for systemd-networkd 和 systemd-resolved` 部署网络配置所需的信息。 在这种情况下，请使用 `omv-firstaid` 命令执行初始网络配置。\n\n如果想通过 openmediavault 使用的服务重新部署网络配置，则执行：\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/network/interfaces\n```\n\n然后把里面的网卡配置用 `#` 注释掉，接着：\n\n```bash command:(\"[root@localhost] #\":1-3)\nrm /etc/systemd/network/*\nnetplan apply\nomv-salt deploy run systemd-networkd\n```\n\n\n\n## omv6 基本配置\n\n## 用户账户设置\n\n安装完 omv 后，如果有使用 `同步系统配置` 操作，那么，在 `用户` -> `用户` 管理中可以看到前面安装系统时创建的用户，之后，你可以在这里创建或修改各类用户；为了安全你也可以禁掉 root 用户，以避免 root 登录，需要注意权限问题，避免登录 omv web 无法操作。\n\nnote：如果存在多个用户，在众多用户里，至少要有一个用户添加到 `openmediavault-admin` 的 `ssh group` 中，这将决定在登录 omv web 后是否拥有配置操作，否则任意用户登录 omv web 上都不存完整的配置操作。具体可看 **omv 登陆后界面只剩仪表盘** 。\n\n\n\n## 配置 SSH\n\n进入 `服务` -> `SSH`，选择勾选 `已启用` 选项，接着按个人需求修改配置，同时为能 SSH 登录操作的用户添加到 `ssh group` ；如果你想为了安全，而选择关闭 `允许 root 登陆` 和 `密码验证` 选项，那么需要注意的是，至少要为一个用户添加 `ssh group` ，否则将没有用户可以登录 SSH，同时为用户配置好 SSH 密钥对。\n\nnote：SSH 密钥对生成，需要先在本机系统中（即需要控制的机器上，一般就是我们的 windows 系统上），输入 `ssh-keygen` 命令，然后输入存储的路径及命名 `~/.ssh/omv-id_rsa` ，如果需要为调用私钥而添加密码认证，则输入密码，否者直接留空回车，不设密码，最后再次确认回车，至此就生成了 SSH 密钥对了；紧接着在 omv web 的 `用户` -> `用户` 中选择你需要进行 SSH 密钥登录的账户，然后编辑，在 `SSH 公钥` 中添加刚才生成的密钥对中的公钥（即 `omv-id_rsa.pub` ），至此就完成了。\n\n\n\n## 创建 Raid 软阵列\n\n在这里，不选择在 omv 页面上创建，而是使用命令创建。以 Raid 1 为例：\n\n1. 准备两个硬盘，最好使用同型号的不同批次跟产期的，如果选择不同型号的，那么要考虑转速、缓存、容量这些尽可能一致。\n\n2. `lsblk` 获取需要建立 Raid 的磁盘名称 `sdx` （sdx可以为 sda、sdb 等）。\n\n3. 使用 `fdisk /dev/sdx` 分别为两块磁盘创建单一分区。\n\n   - `m` ：查看命令操作。\n   - `d` ：删除已有分区。\n   - `n` ：创建新的分区。\n   - `p` ：查看创建分区。\n   - `w` ：应用分区信息。\n\n   ```text\n   按 n 创建新的分区。\n   然后按 p 选择主分区。\n   接下来选择分区号为 1。\n   按两次回车键默认将整个容量分配给它。\n   然后，按 p 来打印创建好的分区。\n   按 l，列出所有可用的类型。\n   按 t 修改分区类型。\n   键入 29 设置为 Linux 的 RAID 类型，然后按 Enter 确认。\n   然后再次使用 p 查看我们所做的更改。\n   使用 w 保存更改。\n   ```\n\n4. 利用 `mdadm` 命令建立 Raid 软阵列。\n\n   - 检查 sdx 分区并确认 Raid 分区的类型 `mdadm -E /dev/sdx` 。\n\n   - 假设用 `dev/sdb1` 和 `dev/sdc1` 两个磁盘创建一个名为 `/dev/md0` 的 Raid 1 设备 `mdadm --create /dev/md0 --level=1 --raid-device=2 /dev/sd[b-c]1` 。\n\n   - 查看 Raid 同步状态 `cat /proc/mdstat` 。初次建立构建，需要很长一段时间。可以通过以下命令调整 Raid 同步速度：\n\n     ```bash command:(\"[root@localhost] #\":1-2)\n     sysctl -w dev.raid.speed_limit_max=2000000\n     sysctl -w dev.raid.speed_limit_min=100000\n     ```\n\n   - 使用 `mdadm -E /dev/sdx1` 分别查看 Raid 设备类型。\n\n   - 为 `dev/md0` 创建 ext4 文件系统 `mkfs.ext4 /dev/md0` ，最好等初始化构建完成后操作。\n\n   - 检查 Raid 信息 `mdadm -D /dev/md0` 。\n\n常见的 RAID 磁盘阵列：\n\n| 阵列           | 描述                                                         | 特点                                                         |\n| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| JBOD（线性）   | JBOD 不是标准的 RAID 级别，它只是在近几年才被一些厂家提出，并被广泛采用。虽然 JBOD 让多个磁盘看来似乎只有一个，但它是通过把多个驱动器合并成一个大的逻辑磁盘来做到这一点的。 | - 任意一块硬盘损坏，整个 JBOD 都无法使用。<br/>- 未损坏的硬盘上的数据不会丢失，但恢复数据存在门槛。 |\n| RAID 0         | RAID 0 是组建磁盘阵列中最简单的一种形式，只需要2块以上的硬盘即可。 RAID 0 是 RAID 磁盘阵列中性能最好的硬盘组合方式，但没有提供冗余或错误修复能力。 | 按照一定规则，将文件拆分存储在 RAID 0 中，一旦一块硬盘损坏，整个 RAID 0 的所有数据全部丢失。 |\n| RAID 1（镜像） | RAID 1 称为磁盘镜像，由至少 2 块硬盘组成。原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件。只要系统中任何一对镜像盘中至少有一块磁盘可以使用，甚至可以在一半数量的硬盘出现问题时系统都可以正常运行。它是 RAID 磁盘阵列中性能最差，数据安全性最佳的。 | 会损失一半硬盘容量。                                         |\n| RAID 5         | RAID 5 被称为 “分布式奇偶校验的独立磁盘结构” ，需最低 3 块硬盘组成。<br/>每在 RAID 5 中存入一个文件，3 块硬盘中：1 块用于存储该文件；2 块用于生成奇偶校验信息。 | 只要 RAID 5 中只有 1 块硬盘损坏，就可以替换该硬盘并恢复数据；会损失 1 块硬盘容量。 |\n| RAID 6         | RAID 6 是对 RAID 5 的扩展，需最低 4 块硬盘组成。<br/>每在 RAID 6 中存入一个文件，4 块硬盘中：2 块用于存储该文件；2 块用于生成奇偶校验信息。 | 只要 RAID 6 中有任意 2 块硬盘损坏，就可以替换这 2 块硬盘并恢复数据；会损失 2 块硬盘容量。 |\n| RAID 10        | RAID 10 需要至少 4 块硬盘组成，每 2 块硬盘组成一个 RAID 1 ，2 个 RAID 1 组成一个 RAID 0 。性能与安全性在 RAID 0 和 RAID 1 中取得了一个平衡。 | 性能比 RAID 0 差，比 RAID 1 高；安全性同于 RAID 1 。         |\n\n扩展：\n\nhttps://www.cnblogs.com/felix-zp/p/9738724.html\n\nhttps://www.flysfeq.site/index.php/archives/65/\n\nhttps://www.cnblogs.com/37yan/p/7489597.html\n\nhttps://www.cnblogs.com/lpfuture/p/6385657.html\n\nhttps://cloud-atlas.readthedocs.io/zh-cn/latest/linux/storage/software_raid/raid-check.html\n\n\n\n## 替换更新镜像源\n\n配置基本链接的镜像源（原因是在你安装完 omv 后，前面配置的软件包存储库链接将会修改为官方默认的链接，此时需要重新设置镜像）：\n\n```bash command:(\"[root@localhost] #\":1-5)\nomv-env set OMV_APT_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/OpenMediaVault/public\"\nomv-env set OMV_APT_ALT_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/OpenMediaVault/packages\"\nomv-env set OMV_APT_KERNEL_BACKPORTS_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/debian\"\nomv-env set OMV_APT_SECURITY_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/debian-security\"\nomv-salt stage run all\n```\n\n然后执行：\n\n```bash command:(\"[root@localhost] #\":1-2)\napt update\nreboot\n```\n\n重启后回到 omv 网页，你会看到有提示显示可以更新软件。\n\nnote：\n\n对于使用 `omv-env set` 更换源，其实是在不同的 `openmediavault` 文件写入，这些文件可以在 `/etc/apt/sources.list.d/` 中找到。\n\n\n\n## 安装 omv-extras\n\n由于国内原因，防 github 解析错误，执行以下操作，如果这时候已经出现网络问题，则使用手动方法，查看 [GitHub520](https://github.com/521xueweihan/GitHub520) ：\n\n```bash command:(\"[root@localhost] #\":1)\nsed -i \"/# GitHub520 Host Start/Q\" /etc/hosts && curl https://raw.hellogithub.com/hosts >> /etc/hosts\n```\n\n根据[官方](https://wiki.omv-extras.org/doku.php?id=omv6:new_user_guide#omv-extras)提供，安装 omv-extras：\n\n```bash command:(\"[root@localhost] #\":1)\nwget -O - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash\n```\n\n然后刷新 omv 网页，即可在 `系统` 中找到 omv-extras。\n\n如果网络不好可以手动安装：\n\n1. 进入 https://github.com/OpenMediaVault-Plugin-Developers/packages 下载对应的插件包，然后把插件包放到 omv 上，路径自己决定，然后进入该路径执行：\n\n```bash command:(\"[root@localhost] #\":1)\ndpkg -i openmediavault-omvextrasorg_xxx.deb\n```\n\n更新 omv-extras 镜像源：\n\n```bash command:(\"[root@localhost] #\":1-4)\nomv-env set OMV_EXTRAS_APT_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/OpenMediaVault/openmediavault-plugin-developers\"\nomv-env set OMV_DOCKER_APT_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/docker-ce/linux/debian\"\nomv-env set OMV_PROXMOX_APT_REPOSITORY_URL \"https://mirrors.bfsu.edu.cn/proxmox/debian\"\nomv-salt stage run all\n```\n\n\n\n## 安装 docker\n\n进入 `系统` -> `插件`，搜索 `compose` ，点击选择下载，然后等待下载完成；\n\n进入 `系统` -> `omv-extras`，勾选 `Docker repo`，点保存；\n\n最后在 `服务` -> `Compose` 中可以找到 `设置`，查看 Docker 状态是否为 `Installed and running`，如果不是，可以尝试重启 Docker 或者重新安装 Docker；再不行就回到第二点先取消勾选接着保存，然后再把  `Docker repo` 勾选上保存并重复后面操作。\n\n参考：https://wiki.omv-extras.org/doku.php?id=omv6:docker_in_omv#dokuwiki__top\n\n如果 Docker 无法运行，输入 `systemctl status docker` 查看状态，然后再执行 `systemctl restart docker` 看是否成功，如果显示如下错误：\n\n```text\nJob for docker.service failed because the control process exited with error code.\nSee \"systemctl status docker.service\" and \"journalctl -xe\" for details.\n```\n\n可以使用命令 `journalctl -xe` 和 `dockerd --debug` 来分析无法运行的错误。\n\n参考：https://stackoverflow.com/questions/55906503/docker-how-to-fix-job-for-docker-service-failed-because-the-control-process-ex\n\n\n\n### docker 换源\n\n编辑 `/etc/docker/daemon.json` 配置文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/docker/daemon.json\n```\n\n更改为以下信息：\n\n```json daemon.json\n{\n  \"data-root\":\"/var/lib/docker\", // docker 存储路径\n  \"registry-mirrors\": [\n    \"https://docker.mirrors.ustc.edu.cn\" // 更改换源\n  ],\n  \"storage-driver\": \"overlay2\",\n  \"storage-opts\": [\n    \"overlay2.override_kernel_check=true\",\n    \"overlay2.size=15G\"\n  ],\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"80m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\nnote：如果是在 `/etc/docker/daemon.json` 文件上指定 Docker 存储路径，那么，在 `服务` -> `Compose` -> `设置` -> `Docker` 中的 `Docker 存储` 上留空配置（该下方有备注说明）。\n\n最后，使用如下命令重启生效：\n\n```bash command:(\"[root@localhost] #\":1-2)\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n完成后使用 `docker info` 命令，查看 `Registry Mirrors:` 是否为配置的镜像源。\n\n\n\n## 安装 portainer 管理面板\n\n如果你喜欢敲命令来操作 Docker，那么这点你可以跳过了，否则可以安装 portainer 对 Docker 进行页面管理。\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":2,5)\n# 拉取汉化版镜像\ndocker pull 6053537/portainer-ce:latest\n\n# 启动容器\ndocker run -d \\\n  --name portainer \\\n  -p 9000:9000 \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v /app/portainer_data:/data \\\n  --privileged=true \\\n  --restart always \\\n  6053537/portainer-ce\n```\n\n参数解释：\n\n- `-d` ：以后台模式运行容器。\n- `--name portainer` ：设置容器的名称为 `portainer`。\n- `-p 9000:9000` ：将容器的 9000 端口映射到主机的 9000 端口，使得 portainer 的 Web 界面可以通过主机的端口访问。\n- `-v /var/run/docker.sock:/var/run/docker.sock` 和 `-v /app/portainer_data:/data` ：将主机 `/var/run/` 目录下的 `docker.sock` 和 `/app/portainer_data` 目录下的 `portainer_data` 分别映射进容器的 `/var/run/docker.sock` 和 `/data` 路径。\n- `--restart always` ：确保容器在退出时自动重启。\n- `6053537/portainer-ce`：指定使用的 Docker 镜像。\n\nnote：在 `docker run` 执行后面加入 `--restart=always` 可以使开机后会自动启动面板，否者还要自己连到设备启动。\n\n最后通过访问 `http://localhost:9000` 来访问 portainer 的 Web 界面。\n\n\n\n## 安装 ddns-go 进行动态域名解析\n\n建立存放路径：\n\n```bash command:(\"[root@localhost] #\":1)\nmkdir -p /app/ddns-go\n```\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":1,3)\ndocker pull jeessy/ddns-go:latest\n\ndocker run -d \\\n  --name ddns-go \\\n  --net=host \\\n  -v /app/ddns-go:/root \\\n  --restart always \\\n  jeessy/ddns-go \\\n  -l :9877 -f 600\n```\n\n参数解释：\n\n- `--net=host` ：使用 docker host 模式\n\n- `-l` ：通过传参命令，指定监听地址\n- `-f` ：通过传参命令，同步间隔时间(秒)\n\n### 使用 ipv6\n\n通过网卡获取：\n\n需要使用 docker host 模式，如果不能从网卡获取 240 开头的外网 ipv6 地址，那么将会显示 “没有找到可用的网卡” 不可选。\n\n通过命令获取：\n\n```bash\nip -6 addr show eth0 | grep -v deprecated | grep 'inet6 [^f:]' | awk -F' ' '{print $2}' | awk -F'/' '{print $1}' | tail -1\n```\n\n然后是步骤拆解：\n\n1. `ip -6 addr show eth0`，显示网卡（eth0）的全部ipv6地址\n2. `grep -v deprecated`，去除已经失效（deprecated）的地址\n3. `grep 'inet6 [^f:]'`，显示有ipv6地址的那一行（不包含f开头的内网ipv6地址）\n4. `awk -F' ' '{print $2}'`，根据空格符号分列，打印第二列\n5. `awk -F'/' '{print $1}'`，根据斜杠符号/分列，打印第一列\n6. `tail -1`，显示最后一行\n\n参看：[DDNS-GO通过命令获取有效的IPv6地址](https://ruohai.wang/202404/ddns-go-use-shell-command-to-get-valid-ipv6-addr/)\n\n### 重置密码\n\n由于 ddns-go 设置密码必须使用复杂密码，因此如果忘记忘记，可以使用以下命令重置：\n\n```bash command:(\"[root@localhost] #\":1-2)\ndocker exec ddns-go ./ddns-go -resetPassword 123456\ndocker restart ddns-go\n```\n\n或者进入容器的控制终端后台：\n\n```bash command:(\"[root@localhost] #\":1||\"/app #\":2,8)\ndocker exec -it ddns-go /bin/sh\nls -al /root/\ntotal 16\ndrwxr-xr-x    2 root     root          4096 Dec  1 15:50 .\ndrwxr-xr-x    1 root     root          4096 Dec  1 15:04 ..\n-rw-------    1 root     root           180 Dec  1 16:13 .ash_history\n-rw-------    1 root     root           958 Dec  1 16:28 .ddns_go_config.yaml\nvi /root/.ddns_go_config.yaml\n```\n\n通过编辑 `/root/.ddns_go_config.yaml` 文件更改账号密码。\n\n\n\n## 安装 webdav 服务\n\n建立存放路径及生成配置文件：\n\n```bash command:(\"[root@localhost] #\":2-4)\n# $WEBDAV_PATH 为你 webdav 部署共享的路径\nmkdir -p /app/webdav /<$WEBDAV_PATH>\ncd /<$WEBDAV_PATH>/app/webdav\nvim config.yml\n```\n\n添加配置：\n\n```yaml config.yml\naddress: 0.0.0.0\nport: 8081\n\n# TLS-related settings if you want to enable TLS directly.\ntls: false\ncert: cert.pem\nkey: key.pem\n\n# Prefix to apply to the WebDAV path-ing. Default is '/'.\nprefix: /\n\n# Enable or disable debug logging. Default is 'false'.\ndebug: false\n\n# Disable sniffing the files to detect their content type. Default is 'false'.\nnoSniff: false\n\n# The directory that will be able to be accessed by the users when connecting.\n# This directory will be used by users unless they have their own 'directory' defined.\n# Default is '.' (current directory).\ndirectory: .\n\n# The default permissions for users. This is a case insensitive option. Possible\n# permissions: C (Create), R (Read), U (Update), D (Delete). You can combine multiple\n# permissions. For example, to allow to read and create, set \"RC\". Default is \"R\".\npermissions: R\n\n# The default permissions rules for users. Default is none.\nrules: []\n\n# Logging configuration\nlog:\n  # Logging format ('console', 'json'). Default is 'console'.\n  format: console\n  # Enable or disable colors. Default is 'true'. Only applied if format is 'console'.\n  colors: true\n  # Logging outputs. You can have more than one output. Default is only 'stderr'.\n  outputs:\n  - stderr\n\n# CORS configuration\ncors:\n  # Whether or not CORS configuration should be applied. Default is 'false'.\n  enabled: false\n  credentials: false\n  allowed_headers:\n    - Depth\n  allowed_hosts:\n    - http://localhost:8081\n  allowed_methods:\n    - GET\n  exposed_headers:\n    - Content-Length\n    - Content-Range\n\n# The list of users. If the list is empty, then there will be no authentication.\n# Otherwise, basic authentication will automatically be configured.\n#\n# If you're delegating the authentication to a different service, you can proxy\n# the username using basic authentication, and then disable webdav's password\n# check using the option:\n#\n# noPassword: true\nusers:\n  # Example 'john' user with bcrypt encrypted password, with custom directory.\n  - username: john\n    password: \"{bcrypt}$2y$10$zEP6oofmXFeHaeMfBNLnP.DO8m.H.Mwhd24/TOX2MWLxAExXi4qgi\"\n    directory: /data\n```\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":1,3)\ndocker pull ghcr.io/hacdias/webdav:latest\n\ndocker run -d \\\n  --name webdav \\\n  -v /<$WEBDAV_PATH>/:/data \\\n  -v /app/webdav/config.yml:/webdav_config.yml:ro \\\n  -p 6065:8081 \\\n  --restart always \\\n  ghcr.io/hacdias/webdav \\\n  -c /webdav_config.yml\n```\n\n参数解释：\n\n- `-v /app/webdav/config.yml:/webdav_config.yml:ro` ：将主机的 `config.yml` 配置文件映射为容器的 `/webdav_config.yml` 文件，用于启动参数的获取。\n- `-p 6065:8081` ：将容器的 8081 端口映射到主机的 6065 端口，使得 portainer 的 Web 界面可以通过主机的端口访问。\n- `-c /webdav_config.yml` ：通过传参命令，指定读取（容器内路径）启动参数配置。\n\n\n\n## 安装 komga 漫画管理\n\n为你的 komga 存放创建数据和配置文件夹：\n\n```bash command:(\"[root@localhost] #\":2)\n# $PATH 为你存储盘的路径\nmkdir -p /<$PATH>/komga/config /<$PATH>/komga/data\n```\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":1,3)\ndocker pull gotson/komga:latest\n\ndocker run -d \\\n  --name komga \\\n  -v /<$PATH>/komga/data:/data \\\n  -v /<$PATH>/komga/config:/config \\\n  -p 25600:25600 \\\n  -e TZ=Asia/Shanghai \\\n  --restart always \\\n  --user \"0:0\" \\\n  gotson/komga\n```\n\n参数解释：\n\n- `-v /<$PATH>/komga/data:/data` 和 `-v /<$PATH>/komga/config:/config` ：将对应存储盘目录下的 `/komga/data` 和 `/komga/config` 目录分别映射进容器的 `/data` 和 `/config` 路径，用于数据和配置的持久化。\n- `-e TZ=Asia/Shanghai` ：设置容器的环境变量 `TZ`，用于指定时区。\n- `--user \"0:0\"` ：以 root 用户运行容器，这对于某些环境的权限管理是必要的。\n\nnote：用 docker 容器安装的话，在 `添加库` 时选择的根文件夹填写的是容器内部的路径（即上面的 `/data` 目录下）。\n\n拓展：https://www.himiku.com/archives/komga.html\n\n\n\n## 安装 gitea 代码管理\n\n为你的 gitea 存放创建数据和配置文件夹：\n\n```bash command:(\"[root@localhost] #\":2)\n# $PATH 为你存储盘的路径\nmkdir -p /<$PATH>/gitea/data\n```\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":1,3)\ndocker pull gitea/gitea:latest\n\ndocker run -d \\\n  --name gitea \\\n  -v /<$PATH>/gitea/data:/data \\\n  -v /etc/timezone:/etc/timezone:ro \\\n  -v /etc/localtime:/etc/localtime:ro \\\n  -p 3000:3000 \\\n  -p 2220:22 \\\n  --restart always \\\n  gitea/gitea\n```\n\n官方安装：https://docs.gitea.com/zh-cn/installation/install-with-docker\n\n\n\n## 安装 calibre-web 图书管理\n\n为你的 calibre-web 存放创建数据和配置文件夹：\n\n```bash command:(\"[root@localhost] #\":2)\n# $PATH 为你存储盘的路径\nmkdir -p /<$PATH>/calibre/config /<$PATH>/calibre/book\n```\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":1,3)\ndocker pull ghcr.io/gshang2017/calibre-web:latest\n\ndocker run -d \\\n  --name=calibre-web \\\n  -e PUID=0 \\\n  -e PGID=0 \\\n  -e TZ=Asia/Shanghai \\\n  -e DOCKER_MODS=linuxserver/calibre-web:calibre \\\n  -p 8083:8083 \\\n  -v /<$PATH>/calibre/config:/config \\\n  -v /<$PATH>/calibre/library:/books \\\n  --restart always \\\n  ghcr.io/gshang2017/calibre-web\n```\n\n\n\n## 安装 jellyfin 影视库\n\n为你的 jellyfin 存放创建缓存和配置文件夹：\n\n```bash command:(\"[root@localhost] #\":2-5)\n# $PATH 为你的影视存放路径\nmkdir -p /app/jellyfin\ncd /app/jellyfin\nmkdir -p cache config\nmkdir -p /<$PATH>/media\n```\n\n运行 Docker：\n\n```bash command:(\"[root@localhost] #\":1,3)\ndocker pull nyanmisaka/jellyfin:latest\n\ndocker run -d \\\n  --name=jellyfin \\\n  -e PUID=0 \\\n  -e PGID=0 \\\n  -e TZ=Asia/Shanghai \\\n  -p 8096:8096 \\\n  -v /app/jellyfin/config:/config \\\n  -v /app/jellyfin/cache:/cache \\\n  --mount type=bind,source=/srv/dev-disk-by-uuid-fb7da335-33b8-4fac-8bbe-24c4cd13ccf7/media,destination=/media,ro=true \\\n  --restart always \\\n  nyanmisaka/jellyfin\n```\n\n添加插件：\n\n控制台 -> 目录 -> 存储库 -> 点击加号进行添加\n\n```text\nhttps://github.com/cxfksword/jellyfin-plugin-metashark/releases/download/manifest/manifest_cn.json\n\nhttps://raw.githubusercontent.com/metatube-community/jellyfin-plugin-metatube/dist/manifest.json\n```\n\n\n\n## 安装 photoview 图片相册\n\n创建 photoview 配置文件夹及相册存放位置：\n\n```bash command:(\"[root@localhost] #\":2-3)\n# $PATH 为你的相册存放路径\nmkdir -p /app/photoview\nmkdir -p /<$PATH>/pictures\ncd /app/photoview\n```\n\n根据官方说明，由于配置参数过多，因此采用 docker compose 的方法，添加 `docker-compose.yml` 配置文件：\n\n```bash command:(\"[root@localhost] #\":1)\ntouch docker-compose.yml\n```\n\n写入：\n\n```yaml docker-compose.yml\nservices:\n  photoview:\n    image: viktorstrate/photoview:latest\n    hostname: photoview\n    container_name: photoview\n    restart: always\n    user: root\n    stop_grace_period: 10s\n    ports:\n      - \"2430:80\" ## HTTP port (host:container)\n    ## This ensures that DB is initialized and ready for connections.\n    ## Comment out the entire `depends_on` section if PHOTOVIEW_DATABASE_DRIVER is set to `sqlite` in the .env\n    depends_on:\n      mariadb:\n        condition: service_healthy\n    ## Security options for some restricted systems\n    security_opt:\n      - seccomp:unconfined\n      - apparmor:unconfined\n    environment:\n      PHOTOVIEW_DATABASE_DRIVER: ${PHOTOVIEW_DATABASE_DRIVER}\n      ## Comment out the next variable in the case PHOTOVIEW_DATABASE_DRIVER is set to `sqlite` or `postgres` in the .env\n      PHOTOVIEW_MYSQL_URL: \"${MARIADB_USER}:${MARIADB_PASSWORD}@tcp(photoview-mariadb)/${MARIADB_DATABASE}\"\n      ## Uncomment the next line if PHOTOVIEW_DATABASE_DRIVER is set to `sqlite` in the .env\n      # PHOTOVIEW_SQLITE_PATH: ${PHOTOVIEW_SQLITE_PATH}\n      PHOTOVIEW_LISTEN_IP: \"0.0.0.0\"\n      ## Optional: If you are using Samba/CIFS-Share and experience problems with \"directory not found\"\n      ## Enable the following Godebug\n      # - GODEBUG=asyncpreemptoff=1\n      ## Optional: To enable map related features, you need to create a mapbox token.\n      ## A token can be generated for free here https://account.mapbox.com/access-tokens/\n      ## It's a good idea to limit the scope of the token to your own domain, to prevent others from using it.\n      MAPBOX_TOKEN: ${MAPBOX_TOKEN}\n    volumes:\n      ## Example:\n      ## - \"/host/folder:/container/folder\"\n      - \"/etc/localtime:/etc/localtime:ro\" ## use local time from host\n      - \"/etc/timezone:/etc/timezone:ro\"   ## use timezone from host\n      ## Uncomment the next line if PHOTOVIEW_DATABASE_DRIVER is set to `sqlite` in the .env\n      # - \"${HOST_PHOTOVIEW_LOCATION}/database:/home/photoview/database\"\n      - \"${HOST_PHOTOVIEW_LOCATION}/storage:/home/photoview/media-cache\"\n      ## Change This in the .env file: to the directory where your photos are located on your server.\n      ## You can mount multiple paths if your photos are spread across multiple directories.\n      ## The same path as the container path set here, you'll need to provide on the Photoview's init page (the one between the ':' chars).\n      ## If you mount several folders, provide the path to the parent one on the init page.\n      ## If you mount several folders, make sure that there are no direct mappings to the media root folder.\n      ## This means that you need to also modify the container path of the HOST_PHOTOVIEW_MEDIA_ROOT\n      ## to something like '/photos/main'. Note that this new name ('main' in this example) will become an album in Photoview.\n      - \"${HOST_PHOTOVIEW_MEDIA_ROOT}:/photos:ro\"\n      ## *Additional* media folders can be mounted like this (set the variable in .env file)\n      ## Note that a mount cannot be located in a subfolder of another mount.\n      # - \"${HOST_PHOTOVIEW_MEDIA_PRIVATE}:/private:ro\"\n\n  ## Comment out the `mariadb` service if PHOTOVIEW_DATABASE_DRIVER is set to `sqlite` or `postgres` in the .env\n  mariadb:\n    image: mariadb:lts\n    hostname: photoview-mariadb\n    container_name: photoview-mariadb\n    restart: unless-stopped\n    stop_grace_period: 5s\n    ## Optimized MariaDB startup command for better performance and compatibility\n    command: mariadbd --innodb-buffer-pool-size=512M --transaction-isolation=READ-COMMITTED --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --max-connections=512 --innodb-rollback-on-timeout=OFF --innodb-lock-wait-timeout=120\n    security_opt: ## see https://github.com/MariaDB/mariadb-docker/issues/434#issuecomment-1136151239\n      - seccomp:unconfined\n      - apparmor:unconfined\n    environment:\n      MARIADB_AUTO_UPGRADE: \"1\"\n      MARIADB_DATABASE: ${MARIADB_DATABASE}\n      MARIADB_USER: ${MARIADB_USER}\n      MARIADB_PASSWORD: ${MARIADB_PASSWORD}\n      MARIADB_ROOT_PASSWORD: ${MARIADB_ROOT_PASSWORD}\n    volumes:\n      ## Example:\n      ## - \"/host/folder:/container/folder\"\n      - \"/etc/localtime:/etc/localtime:ro\" ## use local time from host\n      - \"/etc/timezone:/etc/timezone:ro\"   ## use timezone from host\n      - \"${HOST_PHOTOVIEW_LOCATION}/database/mariadb:/var/lib/mysql\" ## DO NOT REMOVE\n    healthcheck:\n      test: healthcheck.sh --connect --innodb_initialized\n      interval: 1m\n      timeout: 5s\n      retries: 5\n      start_period: 3m\n```\n\n添加 `.env` 环境变量：\n\n```bash command:(\"[root@localhost] #\":1)\ntouch .env\n```\n\n写入：\n\n\n```text\n##================***================##\n## These are the environment setup variables.\n## Start setting up your instance from here.\n## Syntax of the .env file is next:\n## VARIABLE_NAME=variable value with everything after the '=' and till the end of the line.\n## The variables with values, set in the docker-compose.yml directly, are for advanced configuration.\n##================***================##\n\n##----------Host variables-----------##\n## This is the current folder, where all Photoview files and folders (except of your media library) are located\nHOST_PHOTOVIEW_LOCATION=/app/photoview\n\n## This is where your original photos and videos located.\n## Provide here the path to single root folder for your media collection.\nHOST_PHOTOVIEW_MEDIA_ROOT=/<$PATH>/pictures\n## If you'd like to map multiple folders from different locations, create additional variables\n## here like the next one and modify the docker-compose.yml to match them and use in volume mappings.\n# HOST_PHOTOVIEW_MEDIA_PRIVATE=\n##-----------------------------------##\n\n##-------Photoview variables---------##\n## PHOTOVIEW_DATABASE_DRIVER could have one of values: `mysql` (default), `sqlite`, `postgres`\nPHOTOVIEW_DATABASE_DRIVER=mysql\n\n## Optional: To enable map related features, you need to create a mapbox token.\n## A token can be generated for free here https://account.mapbox.com/access-tokens/\n## It's a good idea to limit the scope of the token to your own domain, to prevent others from using it.\n# MAPBOX_TOKEN=yourToken\n##-----------------------------------##\n\n##----------Video variables----------##\n## Set the hardware acceleration when encoding videos.\n## Support `qsv`, `vaapi`, `nvenc`.\n## Only `qsv` is verified with `/dev/dri` devices.\n# PHOTOVIEW_VIDEO_HARDWARE_ACCELERATION=\n##-----------------------------------##\n\n##--------MariaDB variables----------##\n## Comment out these variables if PHOTOVIEW_DATABASE_DRIVER is `sqlite` or `postgres`\n## Use password generator to generate secret values and replace these defaults\nMARIADB_DATABASE=photoview\nMARIADB_USER=photoview\n## Note: If your `MARIADB_PASSWORD` contains special characters (e.g. `@`), make sure to URL-encode them.\nMARIADB_PASSWORD=photosecret\nMARIADB_ROOT_PASSWORD=superphotosecret\n##-----------------------------------##\n\n##---------SQLite variables----------##\n## Uncomment the next line if PHOTOVIEW_DATABASE_DRIVER is `sqlite`\n# PHOTOVIEW_SQLITE_PATH=/app/photoview/database/photoview.db\n##-----------------------------------##\n\n##-------PostgreSQL variables--------##\n## Uncomment the next lines if PHOTOVIEW_DATABASE_DRIVER is `postgres`\n# PGSQL_DATABASE=photoview\n# PGSQL_USER=photoview\n## Note: If your `PGSQL_PASSWORD` contains special characters (e.g. `@`), make sure to URL-encode them.\n# PGSQL_PASSWORD=superphotosecret\n## See https://www.postgresql.org/docs/current/libpq-ssl.html for possible ssl modes\n# PGSQL_SSL_MODE=prefer\n##-----------------------------------##\n\n##-------Watchtower variables--------##\n## The POLL_INTERVAL in sec\nWATCHTOWER_POLL_INTERVAL=86400\nWATCHTOWER_TIMEOUT=30s\nWATCHTOWER_CLEANUP=true\n##\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\//////////////////##\n```\n\nnote：\n\n一般需要修改的是 `Photoview variables` 中的内容。\n\n修改完成后，使用以下命令进行部署：\n\n```bash command:(\"[root@localhost] #\":1)\ndocker-compose up -d\n```\n\n\n\n# other\n\n## omv 登陆后界面只剩仪表盘\n\n一般会出现这种情况是因为更换了用户，但管理权限没有给过去，或者以非管理员登录等，总之就是登录用户没有足够的权限，如果你还禁止了 root 登录，那么你可以使用如下命令把权限给到你要登录的用户 `USER_NAME` 上：\n\n```bash command:(\"[user@localhost] $\":1)\nsudo usermod -a -G openmediavault-admin USER_NAME\n```\n\n参考：https://forum.openmediavault.org/index.php?thread/45443-omv6-web-gui-only-with-dashboard-lost-everything-and-i-m-admin-user/\n\n\n\n## /dev/dm-* 文件系统\n\ndm 是 Device Mapper 的缩写，Device Mapper 是 Linux 2.6 内核中提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略，当前比较流行的 Linux 下的逻辑卷管理器如 LVM2（Linux Volume Manager 2 version)、EVMS(Enterprise Volume Management System)、dmraid(Device Mapper Raid Tool)等都是基于该机制实现的。\n\n既然是映射，那么就有对应关系，那到底对应着什么，可以使用如下命令查看：\n\n1. `dm-*` 一般是在 `/dev` 文件夹里，而且还不止一个，可以使用 `ls /dev/dm*` 查看所有 `dm` 设备映射。\n2. 使用命令 `dmsetup ls` 查看 `dm-*` 对应的设备，其中 `dm` 后面的数字对应（xxx， xx）里的第二个数字。如果想详细查看信息，可以使用 `dmsetup info` 命令，而 `Major, minor:` 对应 （xxx， xx）。\n3. 输入 `more /etc/fstab` 命令查找对应关系，如此便能找到映射点。\n\n\n\n## 挂载新硬盘文件系统失败\n\n这里导致出现的问题是新硬盘替换旧硬盘，然后旧硬盘可能有共享、引用之类的，因此在旧硬盘不存在的情况下，当你为新硬盘建立了文件系统后，并为其挂载保存的的时候，会出现无法保存并挂载成功，这时候就必须先把旧的不存在的硬盘的文件系统卸载掉先，否者会影响新的文件系统挂载；而如果旧的文件系统是有使用共享服务的，那么需要根据其依赖关系（`磁盘` -> `文件系统` -> `共享文件夹` -> `服务(SMB, FTP等)`）逐步解除并保证卸载成功，这样才可以为新的硬盘挂载文件系统。\n\n\n\n## 手动测试硬盘\n\n1. 使用 [smartctl](https://man.archlinux.org/man/smartctl.8) 分析硬盘\n   - `smartctl -i /dev/sdxy` 显示磁盘基本信息。\n   - `smartctl -H /dev/sdxy` 显示硬盘的健康状况。\n   - `smartctl -A /dev/sdxy` 显示硬盘的详细信息。\n   - `smartctl -t short /dev/sdxy` 后台检测硬盘，消耗时间短，用第二条命令查看结果。\n   - `smartctl -t long /dev/sdxy` 后台检测硬盘，消耗时间长，用第二条命令查看结果。\n   - `smartctl -l selftest /dev/sdxy` 显示硬盘检测日志。\n   - `smartctl -l error /dev/sda` 显示硬盘错误汇总。\n2. 使用 [badblocks](https://man.archlinux.org/man/badblocks.8) 扫描硬盘\n   - `badblocks -sv -o ~/sdxy_blocks.txt /dev/sdxy` 前台显示扫描进度，并将结果保存到文档上。\n3. 使用 [hdparm](https://man.archlinux.org/man/hdparm.8) 测硬盘读速\n   - `hdparm -Ttv /dev/sdxy` 该命令将显示磁盘的缓存和读性能。\n   - `hdparm -tv --direct /dev/sdxy` 添加 `--direct` 选项将绕过硬盘驱动器的缓冲区高速缓存，从而直接从磁盘读取。\n4. 使用 [dd](https://man.archlinux.org/man/dd.1) 测硬盘写速\n   - `sync; dd if=/dev/zero of=/srv/dev-disk-by-uuid-xxx/tempfile bs=1M count=5120; sync` 以 1MByte 为单位，写入 5120 次，即写入往 tempfile 文件写入 5GB 大小的零数据值。\n\n\n\n## omv 开关机导致硬盘不安全计数增加\n\n在 SCSI disk 中，有一个 `manage_start_stop` flag，它可以控制 disk 的启停，将该值置 1 的时候，将使得 disk 减速关闭，从而让 disk 关机时磁头会复位；如果关机时 disk 磁头不复位直接断电，就会有磁头弹回去的声音，并且这种情况下，硬盘的 SMART 数据里，C0（不安全关机计数）的值应该会 +1，硬盘也有损坏的风险。\n\n因此，正常情况下，普通 SATA 硬盘的这项属性的值默认为 1，关机时磁头会复位。可以通过下面的命令查看所有磁盘这项属性的值：\n\n```bash command:(\"[root@localhost] #\":1)\ncat /sys/class/scsi_disk/*/manage_start_stop\n```\n\n如果上面的文件不存在，可以使用以下命令查看：\n\n```bash command:(\"[root@localhost] #\":1)\ncat /sys/block/sdX/device/scsi_disk/*/manage_start_stop\n# sdX 为对应硬盘符\n```\n\n然后，对于修改，可以使用：\n\n```bash command:(\"[root@localhost] #\":1)\nfor i in /sys/class/scsi_disk/*/manage_start_stop; do echo 1 > $i; done\n```\n\n对所有的 SCSI disk 进行更改，同样的，可以把该条命令增加至开机脚本，使其每次生效。\n\n参考：\n\n[Serial ATA (SATA) shutdown info](https://www.linux-ata.org/shutdown.html)\n\n[How To Spin Down Hard Disks at Shutdown on LSI HBAs on Linux](https://romaco.ca/blog/2017/08/06/how-to-spin-down-hard-disks-at-shutdown-on-lsi-hbas-on-linux/)\n\nhttps://github.com/torvalds/linux/commit/3cc2ffe5c16dc65dfac354bc5b5bc98d3b397567\n\n\n\n## 硬盘 APM 及 AAM 设置\n\n在 omv wed 的 `存储器` -> `磁盘` -> `编辑` 中，存在 APM（高级电源管理）和 AAM（自动声音管理）。AAM（Automactic acoustics management）自动噪声管理，指通过调整硬盘盘片转速在安静和高性能之间切换；APM（Advanced power management）高级电源管理，即调节硬盘的睡眠状态，有利于节省移动设备的电能。\n\n所以，适当降低 AAM 有利于降低转速，实现噪声的控制，增大 APM 有利于杜绝硬盘进入睡眠，从而避免磁头频繁进出停泊区产生摩擦噪音。\n\n对于  APM/AAM 信息的获取，可以使用以下命令查看：\n\n```bash command:(\"[root@localhost] #\":1)\nhdparm -B -M /dev/sdX\n```\n\n如果您的驱动器不支持 AAM，您将收到消息：`APM_level=not support` ；\n\n如果您的驱动器不支持 AAM，您将收到消息：`acoustic=not support` 。\n\n然后根据实际情况，在 omv wed 的 `存储器` -> `磁盘` -> `编辑` 中进行设置。\n\n\n\n## 权限管理\n\n### 共享权限\n\nFTP/SMB 服务共享权限(OMV系统) < 用户权限(OMV系统) < 文件夹/文件权限 < ACL 特殊权限\n\neg：\n\n1. 当 “共享文件夹A” 权限缺少 `r` 读权限时, 即使” 用户权限” 设置了 `rw` 读写也无法列出该文件夹里的内容。\n2. 如果 “用户B” 对 “共享文件夹C” 设置了 “禁止读写”，即使该文件夹权限是 `rwx` 读写执行，也无法打开 “共享文件夹C” 。\n\n### 登录权限\n\n该权限主要是服务器管理处理，除了上面的禁用 ssh 上的 root 登录及私钥访问，还应禁用避免使用 `su` 和 `sudo` 切换到 root 用户。\n\n- 禁用 `su` 命令：\n\n  - 修改 `/etc/pam.d/su` 配置\n\n    ```bash command:(\"[root@localhost] #\":1)\n    vim /etc/pam.d/su\n    \n    # 去除以下注释\n    auth required pam_wheel.so\n    ```\n\n  - 修改 `/etc/login.defs` 配置\n\n    ```bash command:(\"[root@localhost] #\":1)\n    vim /etc/login.defs\n    \n    # 找到 SU_WHEEL_ONLY 定义并改写成以下配置\n    SU_WHEEL_ONLY yes\n    ```\n\n  如此一来，只有指定加入 `wheel` group 的用户才能使用 `su` 命令，同样也就禁用了 `su -` 切换 root 了；\n\n- 禁用 `su -` 命令：\n\n  如果觉得禁用 `su` 该操作覆盖范围太大了，可以通过 `visudo` 命令修改 `/etc/sudoers` 文件，对指定的用户或群组进行限制，eg：\n\n  ```text sudoers\n  # User privilege specification\n  admin   ALL=(ALL:ALL)     ALL, !/usr/bin/su -\n  \n  # Allow members of group sudo to execute any command\n  %wheel  ALL=(ALL:ALL)     ALL, !/usr/bin/su -\n  ```\n\n  以上例子分别表示对 `admin` 用户及 `wheel` 群组做了 `su -` 命令限制。\n\n- 禁用 `sudo` 升权：\n\n  一般来说，除了安装系统的时候配置的用户拥有 `sudo` 权限，后期创建用户时，除非明确加入 `sudo` 组或改写 `/etc/sudoers` 文件配置，否则是不支持 `sudo` 命令操作的。\n\n- 防止 `sudo su -` 直接串权：\n\n  虽说利用 `sudo` 升权后，同样拥有 root 权限，但与实际登录 root 账户有所区别，毕竟使用 `sudo` 是有操作记录的，而直接 root 登录后无法跟踪其操作。\n\n  通过设置上面的 \"**禁用 `su` 命令**\" 或 \"**禁用 `su -` 命令**\" ，同样可以防止 `sudo su -` 操作，但无法防止 `sudo -` 后执行 `su -` 切换到 root 环境，如果要禁掉该操作，可以简单粗暴的使用上面的 \"禁用 `sudo` 升权\" 操作，或者通过修改 `vim /etc/pam.d/su` 文件进行滤除操作。\n\n- root 用户禁用：\n\n  **（注意：在进行该操作前要至少确保有一个用户可以提权到 root 权限，以避免出现没有超级权限的可能。）**\n\n  除了在 omv web 的 `服务` -> `SSH` 中禁用 root 登录外，还可以在用户配置上禁用 root 账号，使其无法使用登录（包括本机终端登录）。通过执行以下命令：\n\n  ```bash command:(\"[root@localhost] #\":2,6,10,14,18)\n  # 查看 root 帐号密码信息，第二个字符 P 表示有密码\n  passwd -S root\n  root P 01/22/2024 0 99999 7 -1\n  \n  # 删除 root 密码\n  passwd -d root\n  passwd: password expiry information changed.\n  \n  # 确认删除密码，此时第二个字符为 NP 即 No Password\n  passwd -S root\n  root NP 01/22/2024 0 99999 7 -1\n  \n  # 禁用锁定 root 帐号\n  passwd -l root\n  passwd: password expiry information changed.\n  \n  # 确认删除密码，此时第二个字符为 L 即 Lock\n  passwd -S root\n  root L 01/22/2024 0 99999 7 -1\n  ```\n\nnote：\n\n关于查看 `sudo` 执行操作信息，可通过 `cat /var/log/auth.log` 命令查看，对于文件内大量出现 `pam_unix(cron:session): session opened for user root by (uid=0)` 的解决办法，通过以下操作滤除信息：\n\n```bash command:(\"[root@localhost] #\":1)\nvim /etc/pam.d/common-session-noninteractive\n```\n\n找到下行：\n\n```text\nsession required        pam_unix.so\n```\n\n在其上一行添加：\n\n```text\nsession     [success=1 default=ignore] pam_succeed_if.so service in cron quiet use_uid\n```\n\n保存退出后，重启 crond 服务：\n\n```bash command:(\"[root@localhost] #\":1)\nservice cron restart\n```\n\n参考：[auth.log大量出现pam_unix(cron:session): session opened for user root by (uid=0)解决办法](https://www.cnblogs.com/azureology/p/15114686.html)","tags":["Linux"]},{"title":"关于 Keil 的一些总结性使用","url":"/summary-of-keil-tool-use/","content":"\n\n\n# for C51\n\n## 数据存储类型（data,idata,xdata,code）\n\n参考： `Keil > Help > uVision Help > Cx51 Compiler User’s Guide > Language Extensions > Memory Types`\n\n| 关键字 | 存储空间 | 地址范围 | 访问方式 |\n| --- | --- | --- | --- |\n| data | 内部RAM（最大 128 bytes）| 0x00~0x7F | 直接寻址 |\n| idata | 内部RAM（最大 256 bytes） | 0x00~0xFF | 间接寻址 |\n| bdata | 内部RAM（指定 16 bytes） | 0x20~0x2F | 位寻址/直接寻址 |\n| pdata | 扩展RAM（最大 256 bytes） | 0x00~0xFF | 间接寻址 |\n| xdata | 扩展RAM（最大 64K bytes） | 0x0000~0xFFFF | 间接寻址 |\n| code | Flash（最大 64K bytes） | 0x0000~0xFFFF | 间接寻址 |\n\n- data\n\n  data 内存类型只能用于声明变量，不能声明函数。\n\n  该内存使用 8 位地址直接寻址片上 RAM。\n\n  优点是访问速度最快，缺点是数据量的大小受到限制（只有 128 字节或更少）。\n\n- idata\n\n  idata 内存类型只能用于声明变量，不能声明函数。\n\n  该内存使用 8 位地址间接寻址片上 RAM。\n\n  最大可访问 256 字节，其中低位上的数据空间地址和 data 的相应地址重叠，只是访问方式不同。\n\n- bdata\n\n  bdata 内存类型只能用于声明变量，不能声明函数。\n\n  bdata 可使用 8 位地址直接访问，属于片上位可寻址 RAM。\n\n  用 bdata 类型声明的变量是位可寻址的，可以使用位指令进行读写。\n\n- pdata\n\n  pdata 内存类型只能用于声明变量，不能声明函数。\n\n  该内存使用 8 位地址间接寻址以 256 字节为一页的 扩展 RAM。\n\n  pdata 在大小上是有限的（最大 256 字节）。\n\n- xdata\n\n  xdata 内存类型只能用于声明变量，不能声明函数。\n\n  该内存使用 16 位地址间接寻址扩展 RAM。\n\n  xdata 的容量限制为 64K 或更少。\n\n- code\n\n  code 内存类型可用于声明常量或函数。\n\n  该存储器使用 16 位地址进行片上或外部扩展访问。\n\n  code 内存限制为 64K。\n\n  - 对于常量( ROM 变量)。对象限制为 64K，并且不能跨越 64K边界。代码声明的常量变量位于 code 内存类中。\n\n  - 对于程序代码(函数)。程序函数默认存储在 code 内存类中。代码内存类型说明符不是必需的。\n\n\n\n## const 和 code 的修饰使用\n\n参考： `Keil > Help > uVision Help > Cx51 Compiler User’s Guide > Language Extensions > Type Qualifiers > const`\n\nconst：const 关键字所修饰的变量（注意是变量而非常量），是用来表明该变量的操作行为为只读处理，表示其值在程序执行期间不可改变（即程序员向编译器承诺这个变量不会修改），但你说它只读不可修改，用指针指向该变量然后访问修改，它却又可以修改，所以一般严谨的来说它是直接访问不可修改。前面也说了，const修饰后的并非常量，因此在 C51 中存储在 RAM 上，至于在哪个存储区域 data? idata? xdata? 跟你所指定的分配或基于内存模型配置进行隐式的分配有关。\n\ncode：code 用于声明存储在只读存储器中。code 关键字通常与函数或程序的定义一起使用，也可以用来修饰常量，限制其只能存储在 ROM 中，从而节省了宝贵的 RAM 资源。\n\n总结：\n1. const 声明的对象被 Keil C51 存放在数据区 RAM 中 （可以为 data、idatd、xdata，具体看分配）；\n2. 要想将变量存放到代码区 ROM 中以节省 RAM 资源，需更换为 code 关键字去声明对象；\n3. 虽然可以使用指针访问并修改 const 声明的对象，但最好不要这么做，因为 Keil C51 不一定会如程序员预想那样处理代码；\n4. 无论是 const 还是 code 修饰的对象，都具有不可修改的特性，最大的区别可能是一个存放在数据区一个存放在代码区，因此在使用这些修饰符时，需要根据实际需求选择合适的修饰符。\n\n\n\n## printf 输出打印\n\n在 C51 上，printf 的转换说明符跟常用的是有区别的，如果配置不当，那么打印输出的结果是错乱的（eg：char 使用 '%d' 转换）；既然不一样，那么对应的数据类型是分别使用哪些转换说明符呢？\n\n参考： `Keil > Help > uVision Help > Cx51 Compiler User’s Guide > Library Reference > Reference > printf`\n\n| 转换说明符 | 变量类型 | 描述 |\n| --- | --- | --- |\n| %bd | char | 带符号字符型 |\n| %hd | short | 带符号短整型 |\n| %d | int | 带符号整形 |\n| %ld | long int | 带符号长整型 |\n| %bu | unsigned char | 无符号字符型 |\n| %hu | unsigned short | 无符号短整型 |\n| %u | unsigned int | 无符号整型 |\n| %lu | unsigned long int | 无符号长整形 |\n| %bx | unsigned char | 无符号十六进制字符型 |\n| %hx | unsigned short | 无符号十六进制短整型 |\n| %x | unsigned int | 无符号十六进制整型 |\n| %lx | unsigned long int | 无符号十六进制长整型 |\n\n```c\n#include <stdio.h>\n\nvoid tst_printf (void) {\n  char a = 1;\n  int b  = 12365;\n  long c = 0x7FFFFFFF;\n\n  unsigned char x = 'A';\n  unsigned int y  = 54321;\n  unsigned long z = 0x4A6F6E00;\n\n  float f = 10.0;\n  float g = 22.95;\n\n  char buf [] = \"Test String\";\n  char *p = buf;\n\n  printf (\"char %bd int %d long %ld\\n\",a,b,c);\n  printf (\"Uchar %bu Uint %u Ulong %lu\\n\",x,y,z);\n  printf (\"xchar %bx xint %x xlong %lx\\n\",x,y,z);\n  printf (\"String %s is at address %p\\n\",buf,p);\n  printf (\"%f != %g\\n\", f, g);\n  printf (\"%*f != %*g\\n\", (int)8, f, (int)8, g);\n}\n```\n\n\n\n## 内存池\n\n在 C51 中，malloc 等内存管理函数并不能像在 PC 上一样直接调用，这涉及到了内存池的概念。\n\n要想使用内存管理操作，这里需要 3 个步骤：\n1. 声明一个合适的存储空间；\n2. 利用 `init_mempool()` 初始化内存池；\n3. 调用相关的内存管理 API。\n\n参考： `Keil > Help > uVision Help > Cx51 Compiler User’s Guide > Library Reference > Reference > init_mempool`\n\neg：\n```c\n#include <stdlib.h>\n\nstatic char xdata mempool[512];\n\nvoid tst_init_mempool (void) {\n  int i;\n  char xdata *str;\n\n  init_mempool (&mempool, sizeof(mempool));   // 初始化内存池\n\n  str = malloc (100);   // 申请内存\n\n  for (i = 0; i < 26; i++)\n    str[i] = 'A' + i;\n\n  str[i] = '\\0';\n  printf(\"%s\\n\", str);\n\n  free (str);   // 释放内存\n}\n```\n\n\n\n# for MDK\n\n## 设置 noinit\n\n设置 noinit 的 ram 区域有什么用？\n\n对于 noinit 的 ram，等同于不断电的 EEPROM，可以在非上电复位后，依然保存该值，你可能会说，不是有备用域寄存器吗，但是你是否想到这样操作起来会比较麻烦，需要配置相应的操作寄存器；而对于直接把 ram noinit，那么可以跟以前一样直接读写数据，也不怕非上电复位导致数据清零；常见的例子有 bootloader 带参数信息跳转、强制复位前的信息保留等。\n\n[ARM: Uninialized Variables Get Initialized](https://developer.arm.com/documentation/ka003046/latest)\n\n**1、AC5 编译器**\n\n可以在分散文件中定义 `UNINIT` 的分区段：\n\n```txt\nLR_IROM1 0x08000000 0x00080000  { ; load region size_region\n  ER_IROM1 0x08000000 0x00080000  { ; load address = execution address\n   *.o (RESET, +First)\n   *(InRoot$$Sections)\n   .ANY (+RO)\n  }\n  RW_IRAM1 0x20000000 UNINIT 0x00000100  { ;no init section\n        *(NO_INIT)\n   }\n  RW_IRAM2 0x20000100 0x0000FFF0  { ;all other rw data\n        .ANY(+RW +ZI)\n  }\n}\n```\n\n然后再在 c 代码上面调用指定： \n\n```c\nunsigned char  value[256] __attribute__((section(\"NO_INIT\"), zero_init));  \n```\n\n**2、AC6 编译器**\n\n也可以像下面这样利用 Target 配置指定地址：\n\n![QQ截图20240104152114](QQ截图20240104152114.png)\n\n**3、区别**\n\n如果使用分散表来设置，那么 AC5 跟 AC6 调用是有不同的：\n\n```txt\n// Arm Compiler 5\nunsigned long NI_longVar __attribute__( ( section( \"NoInit\"),zero_init) ) ;\n\n// Arm Compiler 6\nunsigned long NI_longVar __attribute__( ( section( \".bss.NoInit\")) ) ;\n```\n\n而如果是直接指定内存地址：\n\n```txt\n// Arm Compiler 5\nstatic uint32_t BootFlag __attribute__((section(\".ARM.__at_0x2001FFFC\")));\n\n// Arm Compiler 6\nstatic uint32_t BootFlag __attribute__((section(\".bss.ARM.__at_0x2001FFFC\")));\n```\n\n这种方法需要在分散表中定义 `UNINIT` 或在 Target 配置上勾选 `NoInit` 。\n\n\n\n## 半主机模式\n\n在嵌入式开发中，少不了 `printf` 等 C 库函数操作，一般来说，这些都是标准库上的操作，然在资源紧凑的单片机中，能不引入完整的 C 标准库就尽量不引入；而 keil 中，提供紧凑型的 C 库，称之为 `MicroLIB` ，因此我们在建项目的时候都会在：工程属性的 “ Target “ -> ” Code Generation “ 中勾选 ” Use MicroLIB “ 选项，这样避免在以后中使用了 printf、sprintf 等函数而出现异常，同时由于 `MicroLIB` 库是由官方亲自进行裁剪过，所以相对于 C 标准库编译出来的大小会小很多。\n\n虽说可以使用 `MicroLIB` 库，但由于裁剪的问题，注定它无法实现一些比较高级的功能，或者无法重定义该 I/O 功能，所以在某些时候，必须使用 C 标准库，那么在 keil 中如何实现，这就是下文要讨论的了。\n\n在应用程序代码中经常使用标准 I/O 库函数，如 printf()、scanf() 或 fgetc() 来执行输入/输出操作。 这些函数在标准 ARM 编译器 c 运行时库中的结构是：\n\n![](struct_comp_function.png)\n\n这样一来，要重新定位输入/输出，您可以：\n\n- 避免高级库函数。\n- 重新定义底层库函数。\n- 重新定义系统 I/O 功能。\n\n而对于重新定义低级库函数还是系统 I/O 函数是更好的解决方案，这取决于您的用例。例如，UART 每次只写一个字符，而默认的 fputc() 使用缓冲，因此重新定义不带缓冲区的函数可能适合 UART。但是，在可能进行缓冲区操作的地方，重新定义系统 I/O 函数可能更合适。\n\n半主机：Semihosting 是一种机制，通过调试器使 ARM 目标上运行的代码能够与主机上的输入/输出设施通信进行交互。当目标板脱离调试器单独运行时，则需要退出半主机模式，否则使得设备运行时会进入软件中断 BAEB 处。\n\n为了能让目标板在单独运行时进行输入/输出，而不进入软件中断 BAEB 处。因此在 keil 中，可以使用如下操作禁止进入半主机模式：\n\n- In C source code：\n\n  ```c\n  #if __ARMCC_VERSION >= 6000000\n  \t//https://developer.arm.com/documentation/100073/0622/The-Arm-C-and-C---Libraries/Support-for-building-an-application-with-the-C-library/Indirect-semihosting-C-library-function-dependencies\n      __asm(\".global __use_no_semihosting\");\n  #elif __ARMCC_VERSION >= 5000000\n  \t// https://developer.arm.com/documentation/dui0475/m/the-arm-c-and-c---libraries/support-for-building-an-application-with-the-c-library/indirect-semihosting-c-library-function-dependencies?lang=en\n  \t#pragma import(__use_no_semihosting)\n  #else\n      #error Unsupported compiler\n  #endif\n  ```\n\n- In armasm assembly language source code：\n\n  ```asm\n  IMPORT __use_no_semihosting\n  ```\n\n在禁用半主机模式后，对于标准 C 库一般会重定义实现以下 [Dependencies on low-level functions](https://developer.arm.com/documentation/dui0232/b/the-c-and-c---libraries/tailoring-the-input-output-functions/dependencies-on-low-level-functions?lang=en) 函数：\n\n```c\nstruct __FILE\n{\n    int handle; /* Add whatever you need here */\n};\n/* \n * Re-implementing the printf family. \n * The printf family consists of _printf(), printf(), _fprintf(), fprintf(), vprintf(), and vfprintf().\n */\n// https://www.keil.com/support/man/docs/armlib/armlib_chr1358938930943.htm\nFILE __stdout;\nint ferror(FILE *f)\n{\n    /* Your implementation of ferror */\n    return EOF;\n}\nint fputc(int ch, FILE *f)\n{\n\n}\n\n\n/* \n * Re-implementing the scanf family. \n * The scanf() family consists of scanf() and fscanf().\n */\n// https://www.keil.com/support/man/docs/armlib/armlib_chr1358938931161.htm\nFILE __stdin;\nint __backspace(FILE *f) { return 0; }\n// https://www.keil.com/support/man/docs/armlib/armlib_chr1358938931957.htm\nint fgetc(FILE *f)\n{\n\n}\n\n\nvoid _ttywrch(int ch)\n{\n    printf(\"%c\", ch);\n    (void)ch;\n}\n// https://www.keil.com/support/man/docs/armlib/armlib_chr1359122862227.htm\n\nvoid _sys_exit(int x)\n{\n    (void)x;\n    while (1)\n        ; /* endless loop */\n}\n// https://www.keil.com/support/man/docs/armlib/armlib_chr1359122859512.htm\n```\n\n附：\n\n**Indirect Semihosting 依赖函数表：**\n\n\n| Function                                                     | Usage                                                        |\n| :----------------------------------------------------------- | ------------------------------------------------------------ |\n| `__user_setup_stackheap()`                                   | Sets up and returns the locations of the stack and the heap. |\n| `__raise()`                                                  | Catching, handling, or diagnosing C library exceptions, without C signal support. (Tailoring error signaling, error handling, and program exit.) |\n| `__default_signal_handler()`                                 | Catching, handling, or diagnosing C library exceptions, with C signal support. (Tailoring error signaling, error handling, and program exit.) |\n| `__Heap_Initialize()`                                        | Choosing or redefining memory allocation. Avoiding the heap and heap-using C library functions supplied by Arm®. |\n| `ferror()` <br/>`fputc()` <br/>`__stdout`                    | Reimplementing the `printf` family. (Tailoring input/output functions in the C and C++ libraries.). |\n| `__backspace()` <br/>`fgetc()` <br/>`__stdin`                | Reimplementing the `scanf` family. (Tailoring input/output functions in the C and C++ libraries.). |\n| `fwrite()` <br/>`fputs()` <br/>`puts()` <br/>`fread()` <br/>`fgets()` <br/>`gets()` <br/>`ferror()` | Reimplementing the stream output family. (Tailoring input/output functions in the C and C++ libraries.). |\n\n**Direct Semihosting 依赖函数表：**\n\n| Function                                                     | Description                                                  |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| `__user_initial_stackheap()`                                 | Sets up and returns the locations of the stack and the heap. If you are using a scatter file at the link stage, you might have to re-implement this function. <br/>The linker issues an error when no semihosting is requested and `__user_initial_stackheap()` is not re-implemented. |\n| `_sys_exit()` <br/>`_ttywrch()`                              | Error signaling, error handling, and program exit.           |\n| `_sys_command_string()` <br/>`_sys_close()` <br/>`_sys_iserror()` <br/>`_sys_istty()` <br/>`_sys_flen()` <br/>`_sys_open()` <br/>`_sys_read()` <br/>`_sys_seek()` <br/>`_sys_write()` <br/>`_sys_tmpnam()` | Tailoring input/output functions in the C and C++ libraries. |\n| `clock()` <br/>`_clock_init()` <br/>`remove()` <br/>`rename()` <br/>`system()` <br/>`time()` | Tailoring other C library functions.                         |\n\n\n\n参考：\n\nAC5：https://developer.arm.com/documentation/dui0475/m\n\nAC6：https://developer.arm.com/documentation/100073/0622","tags":["IDE"]},{"title":"JTAG 和 SWD 接口定义","url":"/jtag-and-swd/","content":"\n\n\n# JTAG\n\nhttps://wiki.segger.com/JTAG\n\n## 引脚分布\n\n![img](JTAG_Port.png)\n\n## 接口定义\n\n|         PIN         |    SIGNAL     |   TYPE   |                         Description                          |\n| :-----------------: | :-----------: | :------: | :----------------------------------------------------------: |\n|        **1**        |     VTref     |  Input   | This is the target reference voltage. It is used to check if the target has power, to create the logic-level reference for the input comparators and to control the output logic levels to the target. It is normally fed from VDD of the target board and must not have a series resistor. |\n|        **2**        | Not connected |    NC    |                  This pin is not connected.                  |\n|        **3**        |     nTRST     |  Output  | JTAG Reset. Output from J-Link to the Reset signal of the target JTAG port. Typically connected to nTRST of the target CPU. This pin is normally pulled HIGH on the target to avoid unintentional resets when there is no connection. |\n|        **5**        |      TDI      |  Output  | JTAG data input of target CPU. It is recommended that this pin is pulled to a defined state on the target board. Typically connected to TDI of the target CPU. |\n|        **7**        |      TMS      |  Output  | JTAG mode set input of target CPU. This pin should be pulled up on the target. Typically connected to TMS of the target CPU. |\n|        **9**        |      TCK      |  Output  | JTAG clock signal to target CPU. It is recommended that this pin is pulled to a defined state of the target board. Typically connected to TCK of the target CPU. |\n|       **11**        |     RTCK      |  Input   | Return test clock signal from the target. Some targets must synchronize the JTAG inputs to internal clocks. To assist in meeting this requirement, you can use a returned, and adjusted, TCK to dynamically control the TCK rate. J-Link supports adaptive clocking, which waits for TCK changes to be echoed correctly before making further changes. Connect to RTCK if available, otherwise to GND. |\n|       **13**        |      TDO      |  Input   | JTAG data output from target CPU. Typically connected to TDO of the target CPU. |\n|       **15**        |    nRESET     |   I/O    | Target CPU reset signal. Typically connected to the RESET pin of the target CPU, which is typically called \"nRST\", \"nRESET\" or \"RESET\". This signal is an active low signal. |\n|       **17**        |     DBGRQ     |    NC    | This pin is not connected in J-Link. It is reserved for compatibility with other equipment to be used as a debug request signal to the target system. Typically connected to DBGRQ if available, otherwise left open. |\n|       **19**        |   5V-Supply   |  Output  | This pin can be used to supply power to the target hardware. Older J-Links may not be able to supply power on this pin. For more information about how to enable/disable the power supply, please refer to [Target power supply](https://wiki.segger.com/20-pin_J-Link_Connector#Target_power_supply). |\n| **4, 6, 8, 10, 12** |      GND      |  Ground  | GND pins connected to GND in J-Link. They should also be connected to GND in the target system. |\n| **14, 16, 18, 20**  |      Res      | Reserved | On some models like the J-Link ULTRA, these pins are reserved for firmware extension purposes. They can be left open or connected to GND in normal debug environment. They are not essential for JTAG or SWD in general **Please do not assume them to be connected to GND inside J-Link.** |\n\n## 连接拓扑\n\n![image-20230709160640502](image-20230709160640502.png)\n\n## 引脚概述\n\n| 序号 | 引脚   | 类型         | 说明                                                         |\n| ---- | ------ | ------------ | ------------------------------------------------------------ |\n| 9    | TCK    | 输出         | 目标时钟输入引脚，为目标 CPU 提供时钟逻辑信号。              |\n| 5    | TDI    | 输出         | 目标数据输入引脚，用于发送串行测试指令和数据给目标 CPU。     |\n| 7    | TMS    | 输出         | 目标模式选择引脚，TAP(Test access port) 控制器对接收到的信号进行解码，以控制测试操作。 |\n| 13   | TDO    | 输入         | 目标数据输出引脚，目标 CPU 串行输出测试指令和逻辑数据。      |\n| 3    | nTRST  | 输出（可选） | 可选的复位输入目标引脚，用来指示 TAP 控制器的异步初始化。    |\n| 11   | RTCK   | 输入         | 目标 CPU 返回的时钟信号，有些目标 CPU 需要同步时钟。         |\n| 15   | nRESET | 输入 / 输出  | 目标 CPU 复位信号。通常连接到目标 CPU 的 RESET 引脚。        |\n\n\n\n# SWD\n\nhttps://wiki.segger.com/SWD\n\n## 引脚分布\n\n![img](SWD_Port.png)\n\n## 接口定义\n\n|         PIN         |    SIGNAL     |   TYPE   |                         Description                          |\n| :-----------------: | :-----------: | :------: | :----------------------------------------------------------: |\n|        **1**        |     VTref     |  Input   | This is the target reference voltage. It is used to check if the target has power, to create the logic-level reference for the input comparators and to control the output logic levels to the target. It is normally fed from VDD of the target board and must not have a series resistor. |\n|        **2**        | Not connected |    NC    |                  This pin is not connected.                  |\n|        **3**        |   Not used    |    NC    | This pin is not used by J-Link when selecting SWD as interface type. If the device may also be accessed via JTAG, this pin may be connected to nTRST, otherwise leave open. |\n|        **5**        |   Not used    |    NC    | This pin is not used by J-Link when selecting SWD as interface type. If the device may also be accessed via JTAG, this pin may be connected to TDI, otherwise leave open. |\n|        **7**        |     SWDIO     |   I/O    | JTAG mode set input of target CPU. This pin should be pulled up on the target. Typically connected to TMS of the target CPU. |\n|        **9**        |     SWCLK     |  Output  | JTAG clock signal to target CPU. It is recommended that this pin is pulled to a defined state of the target board. Typically connected to TCK of the target CPU. |\n|       **11**        |   Not used    |    NC    | This pin is not used by J-Link when selecting SWD as interface type. If the device may also be accessed via JTAG, this pin may be connected to RTCK, otherwise leave open. |\n|       **13**        |      SWO      |  Input   | Serial Wire Output trace port. (Optional, not required for SWD communication.) |\n|       **15**        |    nRESET     |   I/O    | Target CPU reset signal. Typically connected to the RESET pin of the target CPU, which is typically called \"nRST\", \"nRESET\" or \"RESET\". This signal is an active low signal. |\n|       **17**        |   Not used    |    NC    |             This pin is not connected in J-Link.             |\n|       **19**        |   5V-Supply   |  Output  | This pin can be used to supply power to the target hardware. Older J-Links may not be able to supply power on this pin. For more information about how to enable/disable the power supply, please refer to [Target power supply](https://wiki.segger.com/20-pin_J-Link_Connector#Target_power_supply). |\n| **4, 6, 8, 10, 12** |      GND      |  Ground  | GND pins connected to GND in J-Link. They should also be connected to GND in the target system. |\n| **14, 16, 18, 20**  |      Res      | Reserved | On some models like the J-Link ULTRA, these pins are reserved for firmware extension purposes. They can be left open or connected to GND in normal debug environment. They are not essential for JTAG or SWD in general **Please do not assume them to be connected to GND inside J-Link.** |\n\n## 连接拓扑\n\n![image-20230709161124811](image-20230709161124811.png)\n\n## 引脚概述\n\n| 序号 | 引脚  | 类型         | 说明                                                         |\n| ---- | ----- | ------------ | ------------------------------------------------------------ |\n| 9    | SWCLK | 输出         | 时钟信号引脚。                                               |\n| 7    | SWDIO | 输入 / 输出  | 双向数据引脚。                                               |\n| 13   | SWO   | 输出（可选） | 可选的串行线跟踪输出引脚，允许 CPU 输出自定义数据，如 printf 输出，异步到 SWCLK 和其他调试引脚。 |\n| 15   | RESET | 输入 / 输出  | 目标 CPU 复位信号。通常连接到目标 CPU 的 RESET 引脚。        |\n\n\n\n# 参考\n\nhttps://wiki.segger.com/20-pin_J-Link_Connector\n\nhttps://developer.arm.com/documentation/101636/0100/Debug-and-Trace/JTAG-SWD-Interface\n\n![st-link接口定义:stm32f103c8t6 sw接口定义:上图序号swdpcb板上的](attach_16ace507bfe3aa34.png)\n\n# 电路\n\n![image-20230709180456489](image-20230709180456489.png)\n\n如果是要兼容 SWD，则需要在 `JTAG_TMS` 引脚的上拉电阻前端增加一个二极管，参照 `JTAG_nRESET` 上拉。\n\n\n\n关于 J-Link 输出供电问题：\n\n- 一次性编程器打开或者关闭 `5V-Supply` 电源输出指令：\n  `POWER ON` ：一次性使能编程器电源输出。\n  `POWER OFF` ：一次性关闭编程器电源输出。\n- 长期记录编程器打开或者关闭 `5V-Supply` 电源输出指令：\n  `POWER ON PERM` ：长期打开编程器电源输出。\n  `POWER OFF PERM` ：长期关闭编程器电源输出。\n\n\n\n# 附录\n\n![stm32jtag电路设计](f70ab2df53c840afbc9d41234b6cbef8.png)"},{"title":"二极管常见参数","url":"/diode-parameter-design/","content":"\n\n\n> 为了更好的描述及参照，以下参数大部分会重复记录，因此不一一重复描述，仅在第一次出现时加以概述。\n\n\n\n# 肖特基二极管\n\n**简称 \"SBD\"** 。利用**金属和半导体二者的接合面**的 \"肖特基效应\" 的整流作用。具有正向导通电压较低，导通恢复时间短的特性，但反向漏电流较多，突波耐受度较低。常见应用于**高频整流（低压大电流）**。\n\n**1、主要参数**\n\n1. 重复性峰值反向电压 VRRM（Repetitive peak reverse voltage）：即使没有反向电流，只要不断地提高反向电压，迟早会使肖特基二极管损坏。这种能施加的反向电压，不是瞬时电压，而是反复施加的反向电压。一般在直流电压中相当于最大直流反向耐压，而在交流电压中则用另一个参数 VRMS 表示（下方）。\n2. 平均正向整流电流 IF(AV)（Average forward rectified current）：指肖特基二极管长期运行时，根据允许温升折算出来的平均正向电流峰值。\n3. 浪涌电流 IFSM（Peak forward surge current）：允许流过的过星的正向电流。它不是正常电流，而是瞬间电流，这个值相当大。\n4. 导通压降 VF（Instantaneous forward voltage）：VF 为肖特基二极管正向导通时肖特基二极管两端的压降，选择肖特基二极管是尽量选择 VF 较小的肖特基二极管。\n5. 反向漏电流 IR（DC reverse current）：IR 指在肖特基二极管两端加入反向电压时，流过肖特基二极管的电流，肖特基二极管反向漏电流较大，选择肖特基二极管是尽量选择 IR 较小的肖特基二极管。\n\n**2、辅选参数**\n\n1. 均方根反向电压 VRMS（Root-Mean-Square voltage）：指正弦交流信号的有效电压值，`VRMS = (1/2√2) × VRRM ≈ 0.707 × VRRM` ；这里主要是指正常情况下工作的最大有效电压值，可以理解为所能承受的最大反复施加的正反向电压有效值。有一些 datasheet 上可能没有提供该参数，但是会提供 VRRM 的参数，所以可以利用公式来获取数值。\n2. 反向恢复时间 trr（Reverse recovery time）：当工作电压从正向电压变成反向电压时，二极管工作的理想情况是电流能瞬时截止。实际上，一般要延迟一点点时间。决定电流截止延时的量，就是反向恢复时间。虽然它直接影响二极管的开关速度，但不一定说这个值小就好。也即当肖特基二极管由导通突然反向时，反向电流由很大衰减到接近 IR 时所需要的时间。大功率开关管工作在高频开关状态时，此项指标至为重要。\n3. 工作频率 fM：由于 PN 结的结电容存在，当工作频率超过某一值时，它的单向导电性将变差。肖特基二极管的 fM 值相对于其它二极管来说较高，小体积的肖特基二极管最高可工作在 50GHz 的频率，该参数一般没有提供，因为大部分肖特基二极管的工作频率差异不大。\n\nnote：二极管的反向漏电流与反向电压大致呈指数关系，表示为：`I = Ir x e^(-Vr/Vt)` ，其中 `Ir` 为常数，代表二极管在反向饱和状态下的最小漏电流；`Vr` 为反向电压，`Vt` 为热电压常数，约为 26mV。\n\n由于肖特基二极管反向漏电流较大，并且随温度变化较大，因此当出现反向电压时，往往会导致正向极出现电压（反向电压增大或温度升高），导致 “反向导通” 的现象。\n\n![图3-6：不同金属的SBD的V<sub>F</sub>–I<sub>F</sub>曲线](chap3-4-2_en.png)\n\n\n\n# PN 结二极管\n\n**一般也称为 \"一般整流二极管\"、\"普通二极管\"** 。通过施加正向偏置，利用半导体中 PN 接合的整流性质来实现单向特性的应用，是最基本的半导体二极管。常见应用于**低频整流**以及**与电感并联保护其他器件**。\n\n**1、主要参数**\n\n1. 重复性峰值反向电压 VRRM（Repetitive peak reverse voltage）\n2. 均方根反向电压 VRMS（Root-Mean-Square voltage）\n3. 平均正向整流电流 IF(AV)（Average forward rectified current）：可以理解为额定工作电流。\n4. 导通压降 VF（Instantaneous forward voltage）\n5. 浪涌电流 IFSM（Peak forward surge current）\n\n**2、辅选参数**\n\n1. 直流阻断电压 VDC（DC blocking voltage）：当直流电压大于该参数电压，将会导致二极管击穿或烧毁。\n2. 反向漏电流 IR（DC reverse current）：当施加安全的反向电压时，二极管处于反向截止状态，但此时会有一个反向的电流泄漏。\n\n![img](diode07.png)\n\n\n\n# 齐纳二极管\n\n**一般也称为 \"稳压二极管\"** 。是利用二极管在反向电压作用下的齐纳击穿（崩溃）效应，制造而成的一种具有稳定电压功能的电子技术器件。齐纳二极管的正向偏置和一般二极管相同，但是其反向击穿电压（又称齐纳电压）的范围远大于一般的二极管，能承受比一般二极管更高的电压，而且齐纳二极管的反向电压操作是可逆的；常见的齐纳电压从 3 伏特到 100 伏特。常见应用于**直流稳压**。\n\n**1、主要参数**\n\n1. 稳压值 VZ（Zener voltage range）：理想稳压管的稳压值是一个固定的电压数值，但实际真实稳压管的稳定电压会在一定范围波动，有些型号的稳压管应用手册中会给出标称稳定电压值，最小稳定电压值和最大稳定电压值，但也有些手册中只给出标称稳定电压值。该值一般是一个范围值，并且处在一定的 IZT 条件下才符合，因此大多标识为 `VZ@IZT` 。\n2. 典型工作电流 IZT（Typical operating current）：也称为额定工作电流；额定工作电流是指稳压管可以长时间稳定工作，并且稳压性能最好时对应的工作电流值。\n3. 功率消耗 PD（Power dissipation）：最大耗散功率是指可以稳定工作的最大功率值，在工作电路中稳压管的功率不应超过这个值。\n4. 动态阻抗 ZZT and ZZK（Dynamic impedance）：由于 IZT 和 IZK 的存在，所以也分成了 ZZT 和 ZZK；一般写成 `ZZT@IZT` 和 `ZZK@IZK` ，分别表示在额定电流工作时的阻抗 ZZT 及在最小稳压电流时的阻抗 ZZK。稳压管的动态电阻等于电压变化与电流变化的比值。动态电阻越小稳压效果越好，这是因为动态电阻小，则相同电流变化引起的电压变化就越小，所以电压就越稳定。从稳压管的反向伏安特性可以看出，稳压管的工作电流越接近最大稳定工作电流则动态电阻越小，越接近最小工作电流则动态电阻越大。所以稳压管工作电流接近最大稳定工作电流时稳压效果才好。\n\n**2、辅选参数**\n\n1. 膝点电流 IZK（Knee-point operating current）：即拐点电流，也称为稳压的最小电流；最小稳定工作电流是指可以使稳压管具有稳压功能的最小工作电流，如果稳压管电流小于这个值，会进入反向截止区，在反向截止区稳压管是没有稳压功能的。\n2. 最大工作电流 IZM（Maximum operating current）：如果稳压管超过该电流则有烧毁危险。\n3. 反向电压 VR（Reverse voltage）：一般是给 IR 值作参考，表示在未进入稳压状态下的最大反向电压，并且小于 VZ。\n4. 反向漏电流 IR（DC reverse current）：一般标识为 `IR@VR` ，表示电压处于 VR 时 IR 的值，而此时的 VR 是 小于 VZ 的，因此并不能击穿齐纳管得到恒定的电压，这时就相当于一个反向阻断的普通二极管（可以看作不导通），但还是会有 IR 的漏电流。\n\n![Zener diode I-V Curve](zd-ivc.gif)\n\n\n\n# 开关二极管\n\n**一般也称为 \"小信号二极管\"** 。它是专门为电路上的“开”和“关”而设计和制造的，顾名思义，就是指具有开关功能的二极管。该二极管具有在正向施加电压时通过电流(ON)和在反向施加电压时停止(OFF)电流的性能。与其它二极管相比，反向恢复时间较短，即开关二极管从导通状态到完全关断状态所用的时间较短。常见应用于**开关电路**。\n\n开关二极管跟肖特基二极管很像，都具有反向恢复时间短的特性；但不同的是：\n\n- 开关二极管反向漏电流较低，更适用于需要截止状态下的高阻值应用。\n\n- 开关二极管反向耐压相对较高，一般开关二极管反向耐压会在 60 伏特以上至 100 多伏特；而肖特基二极管大部分反向耐压在 60 伏特以下、20 伏特以上。\n\n- 开关二极管峰值正向电流较低，一般都是毫安级别，而肖特基二极管峰值正向电流可达安培级别。\n\n**1、主要参数**\n\n1. 重复性峰值反向电压 VRRM（Repetitive peak reverse voltage）\n2. 平均正向整流电流 IF(AV)（Average forward rectified current）\n3. 浪涌电流 IFSM（Peak forward surge current）\n4. 功率消耗 PD（Power dissipation）\n5. 均方根反向电压 VRMS（Root-Mean-Square voltage）\n6. 反向恢复时间 trr（Reverse recovery time）\n\n**2、辅选参数**\n\n1. 导通压降 VF（Instantaneous forward voltage）\n2. 反向漏电流 IR（DC reverse current）\n\n![Diode ＜Types of Diodes＞ | Electronics Basics | ROHM](e5ac16c1-e7e0-406d-9e13-1d482ac1d98a.png)\n\n\n\n# 瞬态抑制二极管\n\n**一般也称为 \"TVS 管\"** 。是一种用于过电压保护和 ESD 保护的器件，主要应用于**保护后段的 IC 免受由静电和电源波动引起的意外过电压和浪涌**。\n\n**1、主要参数**\n\n1. 反向峰值工作电压 VRWM（Reverse stand-off voltage）：也称为反向关断电压。指设备可以连续承受的电压，没有雪崩破裂的危险。\n2. 击穿电压 VBR（Breakdown voltage）：完全导通的电压阈值。\n3. 箝位电压 VC（Clamping Voltage）：在脉冲峰值电流 Ipp 作用下器件两端的最大电压。\n4. 峰值脉冲电流 IPP（Peak pulse current）\n5. 反向漏电流 IR（DC reverse current）\n6. 典型结电容 Cj （Typical Junction Capacitance）：一般在图中可找到线性参数。\n\n**2、辅选参数**\n\n1. 测试电流 IT （Test Current）：结合图形查看参考。\n2. 峰值脉冲功耗 PPPM（Peak pulse power dissipation）：定义为设备在给定脉冲条件下消耗的瞬时功率，并且是在给定瞬态事件期间TVS结中消耗的功率的度量。它通过以下关系式计算：`PPPM = VC x IPP`，其中 PPPM = 峰值脉冲功耗（W），VC =箝位电压（V），IPP = 峰值脉冲电流（A）。\n\n![image-20230702211343539](image-20230702211343539.png)\n\nnote：挑选 TVS 管先看 **VRWM**，尽可能与**最大工作电压**接近，直流大概是 1.1~1.2 倍的最大工作电压，交流是 1.4~1.5 倍的最大工作电压；一般 **VBR** = VRWM / (0.8~0.9)；然后 **VC** 不高于被保护器件的最大允许安全电压；**Cj** 要尽量小，此值会影响 TVS 的响应时间；**IR** 也要尽量小，避免影响到静态电流及电流倒灌；**交流电压**只能用双向 TVS。\n\n\n\n# PIN 型二极管\n\n即在 P 型材料与 N 型材料中间插入一层低掺杂纯度的接近于本征半导体材料所组成的 I （Intrinsic）层。由于 I 层的存在，PIN 型二极管通常比普通的二极管拥有更宽的耗尽层，更大的接面电阻和更小的接面电容。常见应用于 **RF 领域**、**光电探测器**及**高压整流器（如 FRD/SRD）**。\n\n![What is PIN Diode? - Structure, Working, Characteristics & Its Applications](Construction-PIN-Diode-300x121.png)\n\n**常用参数（不同种类参考相应的参数）**\n\n- 平均正向整流电流 IF(AV)（Average forward rectified current）\n- 典型结电容 Cj （Typical Junction Capacitance）\n- 等效串联电阻 RS（Series resistance）：当二极管正向导通时，可以理解为串联了一个电阻，该值则为等效串联电阻阻值。一般出现在 RF 种类中，它可以量化电容对 RF 电流的有效电阻。\n- 反向电压 VR（Reverse voltage）\n- 功率消耗 PD（Power dissipation）\n- 导通压降 VF（Instantaneous forward voltage）\n\n\n\n# 快恢复/超快恢复二极管\n\n**简称 \"FRD/SRD\"** 。与常见的二极管不同，它是在 P 型、N 型材料中间增加了基区 I ，构成 P-I-N 结构，属 PIN 型二极管的一种；因基区很薄，反向恢复电荷很小，不仅大大减小了 trr 值，还降低了瞬态正向压降，使管子能承受很高的反向工作电压。常见应用于**开关电源**、**PWM脉宽调制器**及**变频器**。\n\n**1、主要参数**\n\n1. 重复性峰值反向电压 VRRM（Repetitive peak reverse voltage）\n2. 平均正向整流电流 IF(AV)（Average forward rectified current）\n3. 浪涌电流 IFSM（Peak forward surge current）\n4. 导通压降 VF（Instantaneous forward voltage）\n5. 反向漏电流 IR（DC reverse current）\n6. 反向恢复时间 trr（Reverse recovery time）\n\n**2、辅选参数**\n\n1. 均方根反向电压 VRMS（Root-Mean-Square voltage）\n2. 直流阻断电压 VDC（DC blocking voltage）\n\n![img](frd06_1.png)\n\n\n\n# 功率二极管\n\n功率二极管由重掺杂纯度的 **N+ 层构成阴极**，其上有一个轻掺杂的 N- 层外延包夹在重掺杂的 **P+ 阳极层**上，它们的交界处形成 PN 结，而这个**外延 N- 层被称为漂移层**。功率二极管与一般的二极管相比，具有更大的 PN 结面积，从而具有高达数百安培(KA)的高正向电流能力和高达数千伏(KV)的反向阻断电压。\n\n![image-20230708003940655](image-20230708003940655.png)\n\n主要要求：\n\n- 反向电压 VR 越高越好。\n- 导通压降 VF 尽可能低。\n- 关闭速度尽可能快。\n- 反向恢复时间 trr 越低越好。\n\n**1、主要参数**\n\n1. 重复性峰值反向电压 VRRM（Repetitive peak reverse voltage）\n2. 均方根反向电压 VRMS（Root-Mean-Square voltage）\n3. 平均正向整流电流 IF(AV)（Average forward rectified current）\n4. 浪涌电流 IFSM（Peak forward surge current）\n5. 工作温结 TJ（Operating junction temperature）：是指电子设备中半导体的最高工作温度。在操作中，它通常较封装外壳温度（Case temperature）高。\n\n**2、辅选参数**\n\n1. 导通压降 VF（Instantaneous forward voltage）\n2. 反向漏电流 IR（DC reverse current）\n3. 反向恢复时间 trr（Reverse recovery time）\n4. 典型结电容 Cj （Typical Junction Capacitance）\n\n![vi characteristics of power diode](image-13.png)\n\n参考：\n\nhttps://www.uv.es/marinjl/electro/diodo.html\n\nhttps://quick-learn.in/power-diode-structure-types-characteristics/\n\nhttps://www.idc-online.com/technical_references/pdfs/electrical_engineering/Constructional_Features_Operating_Principle_Characteristics_and_Specification_of_Power_Semiconductor_Diode.pdf\n\n[https://www.taiwansemi.com/assets/uploads/productcategoryfile/AN-1006_%E5%8A%9F%E7%8E%87%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%8F%82%E6%95%B0%E5%8F%8A%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D_A2012.pdf](https://www.taiwansemi.com/assets/uploads/productcategoryfile/AN-1006_功率二极管参数及特性介绍_A2012.pdf)\n\n\n\n# 信号二极管\n\n信号二极管可以说是一种大类型，其实上面的肖特基、普通的 PN、开关这些二极管有部分可称为信号二极管，它们之间存在着交集。因此选择参数只需选取适合的即可，这里就不去阐述了，看以下参考吧：\n\n[The Signal Diode](https://www.electronics-tutorials.ws/diode/diode_4.html)\n\n[What are signal diodes?](https://www.engineersgarage.com/signal-diode-construction-applications-specifications/)\n\n- **Signal Diode Vs Rectifier Diode**\n\n  | Signal Diode                                                 | Rectifier Diode                                |\n  | :----------------------------------------------------------- | :--------------------------------------------- |\n  | Signal diodes are used in lower voltage or lower current lanes of the circuit. | Rectifier diodes are used in power supplies.   |\n  | These diodes can handle the less forward current.            | These diodes can handle more forward currents. |\n  | These diodes can be designed with semiconductor materials like Ge, Si, and GaAs. | These diodes are made from a silicon material. |\n\n- **Signal Diode Vs Power Diode**\n\n  | Signal Diode                                                 | Power Diode                                                  |\n  | :----------------------------------------------------------- | :----------------------------------------------------------- |\n  | It constitutes a simple P-N junction with equal doping of P and N layer. | Power Diode consists of heavily doped n+, a lightly doped n– layer which is epitaxially grown on a heavily doped P+ layer. |\n  | Signal diode doesn’t block higher reverse voltage due to absence of drift region. | Power diode consists of drift region. Presence of drift region makes power diode capable of blocking higher reverse voltage. |\n  | It has lower Voltage, Current and Power rating.              | It has higher Voltage, Current and Power rating.             |\n  | It has lower switching speed.                                | It has higher switching speed.                               |\n  | Signal diodes have a lower forward voltage drop, which makes them more suitable for low-power applications. | Power diodes have a higher forward voltage drop than signal diodes. This means that more energy is required to turn them on, and they dissipate more power when conducting. |\n  | Signal diodes occupies less space as it comes in smaller sizes. | Power diodes are usually larger in size than signal diodes. This is because they need to handle higher current levels, which requires more material and space. |\n  | Signal diodes are suitable for low temperature ranges.       | Power diodes are often rated for higher temperature ranges than signal diodes. This is because they dissipate more power and generate more heat during operation. |\n  | Signal diodes are used in low-power applications such as signal detection, clipping, and switching. | Power diodes are used in power supplies, rectifiers, and other high-current applications. |\n\n- **Signal Diode Vs Small Signal Diode**\n\n  | Signal Diode                                                 | Small Signal Diode                                           |\n  | :----------------------------------------------------------- | :----------------------------------------------------------- |\n  | The construction of a signal diode is similar to the Mesa diode. | The construction of a small signal diode is similar to a PN junction diode. |\n  | It functions on high-voltage signals.                        | It functions on low-voltage signals.                         |\n  | Its junction area is high as compared to the small-signal diode. | Its junction area is very small, so it stores less charge and has low capacitance. |\n  | Signal diodes are used to operate small currents & high-frequency signals. | These diodes also operate the same as a signal diode.        |\n  | These diodes are frequently used in TV, radio, switching circuits, and communication applications. | These diodes are applicable in parametric amplifiers, high-speed switching & general purpose diode applications. |\n\n  \n\n\n\n# 拓展\n\nVRWM、VRRM、VRSM 及 VBR 参数关系\n\n![img](carac.gif)\n\n- 反向峰值工作电压(VRWM)：设备可以连续承受的电压，没有雪崩破裂的危险。\n- 重复性峰值反向电压(VRRM)：它可以在 1 毫秒的峰值内持续，每 10 毫秒连续重复一次。\n- 非重复性峰值反电压(VRSM)：也称为浪涌电压；每 10 分钟或更长时间只能支持 10ms 一次。\n- 击穿电压(VBR)：如果达到该值，即使只有一次，在 10 毫秒内，二极管可能会破坏或降低其特性。\n- 通常是 VBR > VRSM > VRRM > VRWM。\n\n\n\n# 相关资料\n\nhttps://www.electronicshub.org/diodes/\n\nhttps://www.electronics-tutorials.ws/category/diode\n\nhttps://www.rohm.com.cn/electronics-basics/diodes\n\nhttps://www.shindengen.com/products/semi/column/basic/diodes/diode.html\n\n","tags":["电子","硬件设计"]},{"title":"光电隔离、磁隔离和电容式隔离三种常见隔离技术的特性","url":"/isolation-techniques/","content":"\n\n\n\n在一些恶劣的高电压、高功率工作环境中应用传感器传输信号，需要使用隔离器确保信号的完整。\n\n为了防止高电压和高功率危险，设计中可以使用隔离器(isolator)作为系统的隔离屏障，使电压信号在传感器和控制器之间传递而不受共模电压的影响，确保信号完整。\n\n还有一个关键原因是，现实中一些电信基础设施需要高速地传输数据及信号，会涉及高功率，而使用隔离器可以令系统得到保护。\n\n电流隔离是电气系统中的一种隔离技术。在传感器和其他电子设备之间提供电流隔离，可以防止直流或不受控制的瞬态电流影响。然而，传感器传递的数据和能量仍然需要通过隔离屏障传送。\n\n电流隔离屏障有三种常见技术——光电隔离、磁隔离和电容式隔离。虽然这三种技术隔离屏障的介质有所不同，但最终目标都是相同的。\n\n\n\n#  光电隔离：成熟易用的技术\n\n光电隔离(或称光隔离)，是三种技术中使用最早的，并且易于使用。如下图：\n\n![img](190403-capacitive-isolation-img3.jpg)\n\n它利用光将信息传输到隔离栅的另一端。通常由发光二极管 (LED) 将信息传输到光敏接收器（如晶体管）。光隔离的主要优势是应用广泛，对于慢速数字信号传输是公认的低成本隔离解决方案；高速、数字光耦合器则往往较为昂贵。 光耦合器隔离法一般用于信号的直流状态很重要的场合。随着时间的推移，LED 可能会损耗，因此光隔离通常需要补偿和频带防护，以保证在整个寿命期间正常工作。\n\n\n\n# 磁隔离：速率高而磁场抗扰度弱\n\n磁耦是基于磁隔离技术的隔离器件，也成为磁隔离器。如下图：\n\n![img](190403-capacitive-isolation-img4.jpg)\n\n变压器隔离利用变压器线圈将信息传输到隔离栅的另一端。隔离栅一端的变压器绕组中的电流发生变化时，会在另一端的变压器绕组中感生相应的电流变化。变压器隔离法一般用于涉及交流信号（例如以太网）、非常适合进行变压器耦合的应用场合。变压器隔离在数据速率较高的系统中具有优势，而且它还可以用来提供隔离电源，但与其它解决方案相比，变压器通常非常庞大。\n\n我们会发现，有些磁耦可以以高达 100Mbps 速度的脉冲电流通过隔离屏障，磁耦的数据传输速率特性可以在 datasheet 中找到。\n\n但是要留意的是，磁耦的功耗会随着数据速率增加而增加。它对电磁干扰也很敏感，而在 HVAC 系统和涉及电机的工厂自动化环境中的磁场是很大。\n\n\n\n# 电容式隔离：更好的解决方案\n\n与磁隔离一样，电容式隔离具有用于编码和解码输入 AC 信号的数字电路，利用可变的电场在隔离屏障中传输信息。如下图：\n\n![img](190403-capacitive-isolation-img6.jpg)\n\n电容式隔离器无法传递直流信号，因此它们本身就是一个很好的隔离器。电容式隔离器不易受磁场噪声影响，而仍然保持高数据速率和低功耗；这种方法与光耦合器相比具有明显的性能优势，但通常很容易受共模和 ESD 瞬变影响。\n\n\n\n","tags":["电子"]},{"title":"Linux c 时间时区配置","url":"/linux_c-time-configuration/","content":"\n\n\n# 时间与日期\n\n**GMT 和 UTC**\n\nGMT，即格林尼治标准时间，也就是世界时。GMT 的正午是指当太阳横穿格林尼治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致 GMT 不精确，现在已经不再作为世界标准时间使用。\n\nUTC，即协调世界时。UTC 是以原子时秒长为基础，在时刻上尽量接近于 GMT 的一种时间计量系统。为确保 UTC 与 GMT 相差不会超过 0.9 秒，在有需要的情况下会在 UTC 内加上正或负闰秒。UTC 现在作为世界标准时间使用。\n\n所以，UTC 与 GMT 基本上等同，误差不超过 0.9 秒。\n\n**时区**\n\n地球自西向东旋转，东边比西边先看到太阳，东边的时间也比西边的早。为了统一世界的时间，1884 年的国际经度会议规规定将全球划分为 24 个时区（东、西各 12 个时区）。规定英国（格林尼治天文台旧址）为零时区（GMT+00），东 1-12 区，西 1-12 区，中国北京处于东 8 区（GMT+08）。\n\n若中国当前时间为 8 点整，则英国时间为 0 点整。\n\n**UTC时间与本地时间**\n\nUTC + 时区差 = 本地时间\n\n时区差东为正，西为负。在此，把东八区时区差记为 `+08`\n\nUTC + (+08) = 本地（北京）时间\n\n**UNIX 时间戳**\n\n由 Unix 内核提供的基本时间服务是自国际标准时间公元 1970 年 1 月 1 日 00:00:00 以来的秒数。\n\n\n\n# 时间及时区查看命令\n\n- 获取 UTC 世界时间\n\n`date -u`\n\n- 获取当地时间\n\n`date`\n\n- 获取当地时间及时差\n\n`date -R`\n\n\n\n# 时区设置命令\n\n**1、对于完整的 Linux 系统**\n\n1. 命令跟描述对不上号的 `tzselect`\n\n看起来很像一个时区选择的工具，但并非如此。事实上tzselect仅仅是一个查看时区表示方式的『向导』程序而已。通过依次询问大洲→国家→城市，最后告诉你如何TZ变量的写法，比如北京时间是：`Asia/Shanghai`\n\n2. TZ 变量\n\n根据上面的指导，可以获知通过修改 TZ 变量，直接修改时区信息，例如：\n\n```bash command:(\"[root@localhost] $\":1,3-4)\ndate -R\n Tue, 17 Jan 2017 13:57:06 +0000\nexport  TZ='Asia/Shanghai'\ndate -R\n Tue, 17 Jan 2017 19:57:18 +0600\n```\n\n但如果不写在环境变量文件配置里的话，一般是会话级的操作，取消重新打开便会失效；因此对于在 shell 中实现更改 TZ 变量，只能做到临时变更时区信息。\n\n正确做法是到 `/etc/profile` 里（或用户的 `~/.profile` 或 `~/.bashrc` 文件等），直接 `export TZ='xxx'` 更改时区（时区的名字可以用 `tzselect` 向导来确定）\n\n3. `/etc/localtime` 文件\n\n默认情况下情况下，TZ 属性是空，这时候是靠 `/etc/localtime` 文件来确定的时区。而此文件通常又是一个到 `/usr/share/zoneinfo/` 下各种时区文件的软连接。通过修改 `/etc/localtime` 指向的软连接，进而修改系统的时区。比如下面的方法，将 localtime 文件设置为了北京时间：\n\n```bash command:(\"[root@localhost] $\":1)\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n\n**2、对于裁剪的 Linux 系统，如：arm linux**\n\n1. `tzselect` 命令\n\n正常情况下，裁剪过的是不支持该命令的，因此相对于上面的 2、3 两点并不适用于此。\n\n2. TZ 变量\n\n与上面一样可通过修改 TZ 变量，直接修改时区信息，但与此不同的是，并不能通过 `TZ='Asia/Shanghai'` 去修改，只能通过时区偏移量来修改，例如我们中国的北京时间相对于 `UTC-0` 的偏移量是 `UTC+8` ；那么则修改为：\n\n```bash command:(\"[root@localhost] $\":1,3-4)\ndate -R\n Tue, 17 Jan 2017 13:57:06 +0000\nexport  TZ='CST-8'\ndate -R\n Tue, 17 Jan 2017 19:57:18 +0600\n```\n\n注意，在这里，UTC+、- 是相反的，UTC-8 代表的是相对于 UTC 加八个小时，反之减八个小时......；而 CST 则是对应为北京时区缩写。\n\n时区表信息可看：https://www.timeanddate.com/time/zones/\n\n3. `/etc/localtime` 文件\n\n由于裁剪问题，系统中是没有 `/usr/share/zoneinfo/` 文件夹的，如有需要，将 PC 端的 `/usr/share/zoneinfo` 整个 `zoneinfo` 文件夹复制到 rootfs 的 `/usr/share` 下，这样嵌入式系统中就有了 `timezone` 。\n\n最后同样执行：\n\n```bash command:(\"[root@localhost] $\":1)\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n\nnote：时区信息保存在 `/etc/localtime` 文件里，如果没有该文件则系统是零时区，有该文件时系统会去读取该文件。具体该文件的内容可以不同关心，在 `/usr/share/zoneinfo/` 目录下有各个时区对应的文件，只需要拷贝过去就可以。比如我们常用的东八区时间就是对应 `/usr/share/zoneinfo/Asia/Shanghai` 文件，只需要将该文件指向或拷贝到 `/etc/localtime` 就将系统时间改为东八区。\n\n\n\n# 常用 API\n\n## 时间结构体\n\n```c\nstruct tm {\n    int tm_sec;    /* Seconds (0-60) */\n    int tm_min;    /* Minutes (0-59) */\n    int tm_hour;   /* Hours (0-23) */\n    int tm_mday;   /* Day of the month (1-31) */\n    int tm_mon;    /* Month (0-11) */\n    int tm_year;   /* Year - 1900 */\n    int tm_wday;   /* Day of the week (0-6, Sunday = 0) */\n    int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */\n    int tm_isdst;  /* Daylight saving time */\n};\n```\n\n```c\nstruct timeval {\n    time_t      tv_sec;     /* seconds (秒) */\n    suseconds_t tv_usec;    /* microseconds (微秒) */\n};\n\nstruct timezone {\n    int tz_minuteswest;     /* minutes west of Greenwich */\n    int tz_dsttime;         /* type of DST correction */\n};\n```\n\n\n\n## 时间函数归类\n\n**1、C99 标准库函数**\n\n需 `#include <time.h>`\n\n- 获取时间戳：\n\n```c\n/* time()函数，返回一个从 1970 年 1 月 1 日 00:00:00 到现在的 time_t 类型 UTC 时间，当参数为 NULL 时直接返回秒数，当然也会将该值写入 t 指针指向的地址。 */\ntime_t time(time_t *t);\n\n/* mktime() 会把本地时间转换为 UTC 时间 */\ntime_t mktime(struct tm *tm);\n\n// note：两者区别在于传入的参数结构体不同，mktime 存在时区转换；time(t) 等价于 mktime(localtime(time(t)))。\n```\n\n- 获取 `struct tm` 类型的时间：\n\n```c\n/* gmtime() 是零时区，把 UTC 时间转换成北京时间的话，需要在年数上加 1900，月份上加 1，小时数加上 8。 */\nstruct tm *gmtime(const time_t *timep);\nstruct tm *gmtime_r(const time_t *timep, struct tm *result);\n\n/* localtime() 将得到本地时间，该函数与 gmtime() 唯一区别是，在转换成北京时间的小时数不需要加上 8。 */\nstruct tm *localtime(const time_t *timep);\nstruct tm *localtime_r(const time_t *timep, struct tm *result);\n\n// note：localtime 是将时区考虑在内了，转出的是当前时区的时间。但是注意，有些嵌入式设备上被裁减过的系统，时区没有被设置好，导致二者转出来的时间都是零时区的。在多线程应用里面，应该用后缀不带 `_r` 的函数，如： localtime_r 函数替代 localtime 函数，因为 localtime_r 是线程安全的，例子看第五大点。\n```\n\n- 时间日期格式化：\n\n```c\n/* 将 tm 结构中的时间信息转换为相应时间的字符串 */\nchar *asctime(const struct tm *tm);\nchar *asctime_r(const struct tm *tm, char *buf);\n\n/* 将日历时间参数 timep 转换为一个表示本地当前时间的字符串，函数已经由时区转换成当地时间 */\nchar *ctime(const time_t *timep);\nchar *ctime_r(const time_t *timep, char *buf);\n\n// note：两者区别在于传入的参数结构体不同，但转换出来的信息格式显示是一样的；asctime 是直接把时间格式化，而 ctime 是经过时区转换后再格式化输出；ctime(t) 等价于 asctime(localtime(t))。\n\n/* 常用时间格式化参数看下方描述 */\nsize_t strftime(char *s, size_t max, const char *format, const struct tm *tm);\n```\n\n在使用 `strftime` 时间格式化函数所涉及的相关参数的含义如下：\n\n| 参数 | 含义 |\n| --- | --- |\n| %F | 将时间格式化为年-月-日 |\n| %T | 将时间格式化为显示时分秒: hh:mm:ss |\n| %Y | 将时间格式化为带世纪部分的十制年份 |\n| %m | 将时间格式化为十进制表示的月份 |\n| %d | 将时间格式化为十进制的每月中的第几天 |\n| %H | 将时间格式化为24小时制的小时 |\n| %M | 将时间格式化为十进制表示的分钟数 |\n| %S | 将时间格式化为十进制表示的秒数 |\n\n更多参数请阅：https://www.runoob.com/cprogramming/c-function-strftime.html\n\n- 获取时间差：\n\n```c\ndouble difftime(time_t time1, time_t time0);\n```\n\n\n\n**2、Uinx 系统函数**\n\n需 `#include <sys/time.h>`\n\n```c\n#include <sys/time.h>\n获取 struct timeval 类型的时间：\n/* 相对于 time() 和 mktime() ，gettimeofday() 能获取更精准的微秒级别，及相应的时区信息，需要注意的是 tz 是依赖于系统，不同的系统可能存在获取不到的可能，因此通常设置为 NULL */\nint gettimeofday(struct timeval *tv, struct timezone *tz);\n// 成功则返回 0，失败返回 －1，错误代码存于 errno\n// EFAULT：指针 tv 或 tz 所指的内存空间无效。\n\n设置 struct timeval 类型的时间：\nint settimeofday(const struct timeval *tv,const struct timezone *tz);\n// 成功则返回 0，失败返回 －1，错误代码存于 errno\n// EPERM：调用进程没有足够权限调用 settimeofday()，即权限不够。\n// EINVAL：时区或其它内容无效，无法正确设置时间。\n\n// note：settimeofday 的修改时间需要在 root 权限下才能配置成功。\n```\n\n\n\n**3、总结**\n\n`time`、`gmtime`、`asctime` 所表示的时间都是 UTC 时间，只是数据类型不一样，\n而 `mktime`、`localtime`、`ctime` 的时间都存在时区之间变换。\n\n| 函数 | 传参类型 | 返回类型 | 时区转换 | 描述 |\n| --- | --- | --- | --- | --- |\n| time() | time_t | time_t | UTC+0 | 用于获取 UTC 零时区的时间戳格式 |\n| mktime() | struct tm | time_t | UTC-t | 用于获取 UTC 零时区的时间戳格式, 但会经过时区转换, 把本地时间内部换成 UTC+0 |\n| gmtime() | time_t | struct tm | UTC+0 | 用于获取 UTC 零时区的 |\n| localtime() | time_t | struct tm | UTC+t | |\n| asctime() | struct tm | string | UTC+0 | |\n| ctime() | time_t | string | UTC+t | |\n\n\n\n## 函数应用\n\n1、获取当前时区的时间戳偏移量\n\n```c\ntime_t get_localtime_interval(void)\n{\n    time_t timep_utc, timep_local;\n    struct tm tm_utc;\n\n    time(&timep_utc);\n\n    gmtime_r(&timep_utc, &tm_utc);\n\ttimep_local = mktime(&tm_utc);\n\n\treturn (timep_utc - timep_local);\n}\n```\n\n2、获取当前时区的时间戳（带时区的本地时间）\n\n```c\ntime_t get_time_stamp(void)\n{\n\ttime_t timep;\n\n\ttime(&timep);\n\ttimep += get_localtime_interval(timep);\n\n\treturn timep;\n}\n```\n\n3、获取时区偏移量\n\n```c\ntime_t get_time_stamp(void)\n{\n\ttime_t timep_zone;\n\n    timep_zone = get_localtime_interval(timep) / 3600;\n\n\treturn timep_zone;\n}\n```\n\n4、时区设置函数\n\n时间函数除了gmttime()、asctime() 不受环境变量 TZ 的影响外，大部分函数都受到环境变量 TZ 的影响，这几个函数是： localtime、mktime、ctime 和 strftime。如果定义了 TZ，则这些函数将使用其值以代替系统默认时区。\n\n在 Unix 环境下可以通过改变系统文件修改环境变量，也可以通过函数 setenv() 修改。\n\nTZ 指定了当前的系统时区。这个时区会影响我们所做的时间转换。例如假设当前的系统时间是 8:00AM，如果我们把当前的时区设置成东八区，则标准时间就是（即 UTC+0）的时间就是 8-8=0:00AM，如果是看成是东六区的话，则标准时间就变成了 8-6=2:00AM。\n\n```c\n#include <stdio.h>  \n#include <time.h>  \n#include <stdlib.h>    \nint main(int argc, const char * argv[])  \n{  \n    setenv(\"TZ\", \"CST-8\", 1);   // 北京东八区\n    // setenv(\"TZ\", \"UTC+0\", 1);   //将当前时区设置成标准区\n\n    char buf[64];\n    struct timeval tv;\n    struct tm* tm_time;\n    gettimeofday(&tv, NULL);\n    tm_time = gmtime(&tv.tv_sec);\n    strftime(buf, sizeof(buf), \"%a %b %m %H:%M:%S %Z %Y\", tm_time);\n    printf(\"GMT time: %s\\n\", buf);\n    tm_time = localtime(&tv.tv_sec);\n    strftime(buf, sizeof(buf), \"%a %b %m %H:%M:%S %Z %Y\", tm_time);\n    printf(\"local time: %s\\n\", buf);\n\n    return 0;\n}  \n```\n\n\n\n# localtime 和 localtime_r 区别\n\n示例来源（下方为原文备份记录）：https://blog.csdn.net/test1280/article/details/80917962\n\n`localtime` 和 `localtime_r` 的函数功能： converts the calendar time timep to broken-time representation\n\n在调用 `localtime` 和 `localtime_t` 函数时，需特别注意：\n\n- `localtime` 是不可重入函数，非线程安全\n\n- `localtime_r` 是可重入函数，线程安全\n\n1、使用 `localtime` 时不可重入示范：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n\nint main()\n{\n    time_t curTime = time(NULL);\n    time_t aftTime = curTime + 3600*3;\n\n    struct tm *pTm1 = localtime(&curTime);\n    struct tm *pTm2 = localtime(&aftTime);\n\n    fprintf(stdout, \"%04d%02d%02d%02d%02d%02d\\n\",\n            pTm1->tm_year + 1900,\n            pTm1->tm_mon + 1,\n            pTm1->tm_mday,\n            pTm1->tm_hour,\n            pTm1->tm_min,\n            pTm1->tm_sec);\n\n    fprintf(stdout, \"%04d%02d%02d%02d%02d%02d\\n\",\n            pTm2->tm_year + 1900,\n            pTm2->tm_mon + 1,\n            pTm2->tm_mday,\n            pTm2->tm_hour,\n            pTm2->tm_min,\n            pTm2->tm_sec);\n\n    return 0;\n}\n```\n\n编译 & 运行：\n\n```shell\n$ gcc -o main main.c\n$ ./main\n20180704225205\n20180704225205\n```\n\n调用 `localtime` 函数并获取其返回值（一个指向 `struct tm` 结构类型数据的指针）后，我们并未对返回值进行**显式地释放**。\n\n**这并没有什么问题（不会导致内存泄漏）**。\n\n因为 `localtime` 函数返回值是一个指针，指向一个静态变量，这个静态变量是库中的一个 `static struct tm` 类型数据。\n\nman localtime：\n\nThe return value points to a **statically allocated struct** which might **be overwritten** by **subsequent calls** to any of the date and time functions.\n\n这将引出新的问题，**同一进程**多个线程中同时调用（极短时间内连续调用） `localtime` 函数，返回值 `tm` 可能被覆盖。\n\n举个栗子：\n\n两个线程 A 和 B 同时调用 `localtime` 函数：\n\n时刻 1：线程 A 调用 `localtime` 函数，得到一个指针，指向 `static struct tm` 类型变量；（tm 中存储的值更新为 value-a）\n\n时刻 2：线程 B 调用 `localtime` 函数，得到一个指针，指向 `static struct tm` 类型变量；（tm 中存储的值更新为 value-b）\n\n时刻 3：线程 A 对 `localtime` 返回的指针进行相关引用操作（例如 printf 输出某字段），此时 `static struct tm` 中的值实际是 value-b，并非预期的 value-a。\n\n时刻 4：线程 B 对 `localtime` 返回的指针进行相关引用操作，此时 `static struct tm` 中的值实际是 value-b。\n\n上面的示范代码虽然是在同一线程中，但是已经可以简单模拟这样的多线程执行调用流程。\n\n**如何解决？**\n\n`localtime_r` 是 `localtime` 的可重入版本（线程安全版本）。\n\n`localtime` 不可重入是由于 `static struct tm` 是库中的一个静态变量，如果我们在调用 `localtime` 时传入一个 `struct tm` 类型变量（指针）用于存放结果，岂不是实现**可重入**？\n\nBingo！\n\n`struct tm *localtime(const time_t *timep);`\n\n`struct tm *localtime_r(const time_t *timep, struct tm *result);`\n\n\n调用 `localtime` 只需要传入指向 `time_t` 的一个常量指针；\n\n调用 `localtime_t` 不仅需要传入指向 `time_t` 的一个常量指针，还需要传入指向 `struct tm` 的一个指针，结果将存储在 `result` 指向的 `struct tm` 对象中；\n\nThe return value points to a statically allocated struct which might be overwritten by subsequent calls to any of the date and time functions.\n\nThe localtime_r() function does the same, **but stores the data in a user-supplied struct**.\n\n2、使用 `localtime_r` 时可重入示范：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n\nint main()\n{\n    time_t curTime = time(NULL);\n    time_t aftTime = curTime + 3600*3;\n\n    struct tm tm1;\n    struct tm tm2;\n    localtime_r(&curTime, &tm1);\n    localtime_r(&aftTime, &tm2);\n\n    fprintf(stdout, \"%04d%02d%02d%02d%02d%02d\\n\",\n            tm1.tm_year + 1900,\n            tm1.tm_mon + 1,\n            tm1.tm_mday,\n            tm1.tm_hour,\n            tm1.tm_min,\n            tm1.tm_sec);\n\n    fprintf(stdout, \"%04d%02d%02d%02d%02d%02d\\n\",\n            tm2.tm_year + 1900,\n            tm2.tm_mon + 1,\n            tm2.tm_mday,\n            tm2.tm_hour,\n            tm2.tm_min,\n            tm2.tm_sec);\n\n    return 0;\n}\n```\n\n编译 & 运行：\n\n```shell\n$ gcc -o main main.c\n$ ./main\n20180704200531\n20180704230531\n```\n\n\n\n# 参考\n\nhttps://www.cnblogs.com/sun-frederick/p/4772535.html\nhttps://blog.csdn.net/test1280/article/details/80917962\n\n","tags":["Linux","linux_c"]},{"title":"Linux 根文件系统的构建","url":"/linux-rootfs-create/","content":"\n\n\n> 开发平台：Ubuntu 18.04.6\n>\n> 目标平台：imx-6ull\n>\n> busybox 版本：[busybox-1.32.0.tar.bz2](https://busybox.net/downloads/busybox-1.32.0.tar.bz2)\n>\n> 编译工具链：gcc versions 10.3.1 20210621 (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29))\n\n\n\n# 环境搭建\n\n## 交叉编译器\n\n关于 arm linux 交叉编译工具链的搭建，这里就再不展开说明了，毕竟在此之前如果有移植过 uboot，那么这里就可以省略了，对于没有搭过交叉编译工具链的，可以查看上一篇 [imx-6ULL uboot 移植](https://arachnid.cc/6ull-uboot-transplant/) 的交叉编译搭建的环节。\n\n\n\n# 文件系统\n\n你可能听过这么一句 “Unix 系统中一切皆文件” 的话，它是指 Unix 系统中的所有的一切都可以通过文件的方式访问、管理，即使不是文件，也以文件的形式来管理；那么对于这些文件的管理，需要一个系统去管理集中访问，而这样一个系统称为文件系统，它可以使我们以文件 IO 的形式对文件目录进行访问，而非以 Flash 存储地址进行访问，在使用上更为方便轻松。\n\n## 组成\n\n对于现有的 Linux 版本，不同的 Linux 衍生版本其文件系统的根目录都略有不同，但整体上的组成没多大区别。\n\n![image-20240817230144056](image-20240817230144056.png)\n\n![image-20240817230822485](image-20240817230822485.png)\n\n一般来说，在构成最小 rootfs 的目录结构会包含以下几个：\n\n| 目录  | 说明                                                         | 补充             |\n| :---- | :----------------------------------------------------------- | :--------------- |\n| bin   | 可执行文件，主要的是系统命令，普通用户和 root 都可以执行     | 必须存在         |\n| dev   | 设备文件，设备树定义的节点就在这里                           | 必须存在         |\n| etc   | 存放着各配置文件                                             | 必须存在         |\n| home  | 系统预设的使用者家目录                                       | 非必须           |\n| lib   | 存放的是 32 bit 系统中的动态和静态链接库文件                 | 必须存在         |\n| lib64 | 64 bit 桌面系统存在的东西，存放着支持 64 bit 的运行库        | 嵌入式系统不需要 |\n| mnt   | 临时挂载目录，一般是空目录                                   | 非必须           |\n| opt   | 第三方软件安装存放目录 ，目前都安装在 /usr/local 目录里      | 非必须           |\n| proc  | 虚拟文件系统，是系统内存的映射，主要存放系统的内核、进程和网络状态 | 必须存在         |\n| sbin  | 系统管理命令存放目录，只有 root 可以使用，普通用户只可查看   | 必须存在         |\n| sys   | 系统使用的目录，虚拟文件系统。和 /proc/ 相似，该目录中的数据都保存在内存中 | 必须存在         |\n| usr   | 是 Unix Software Resource` `的缩写，也就是 Unix 操作系统软件资源目录 | 非必须           |\n| var   | 存放一些可以改变的数据，包括系统运行中需调用或改变的数据     | 必须存在         |\n\n\n\n# 构建\n\n根文件系统的制作方法有很多，像在已知的系统中把整个根文件系统打包出来然后再进行裁剪，或者使用三大神器 busybox、buildroot、yocto 构建等。\n\n利用已有的系统提取裁剪，这种方法一般适用于同平台版本的情况下，对于不同的平台版本下，可能会出现运行环境错误的情况；\n\n使用 busybox 构建文件系统，则仅仅只是帮我们构建好一些 shell 命令程序集，像 lib 库、/etc 目录下的一些文件都需要自己手动创建，如果需要用到第三方软件，还需要去移植一些第三方软件库，比如 alsa、iperf、mplayer 等等；而且 busybox 构建的根文件系统默认没有用户名和密码设置；\n\nbuildroot，它不仅包含了 busybox 的功能，而且里面还集成了各种软件包，当需要什么软件就选择什么软件，不需要额外移植；buildroot 可以构建完整的根文件系统，因此极大的方便了嵌入式 Linux 开发人员对根文件系统进行制作；\n\n至于 yocto 构建根文件系统，是一个古老的、很庞大的系统构建工具，其实其不单止可以构建根文件系统，还可以用来构建 u-boot、kernel、交叉编译工具链等等，一般为 SOC 厂家、设备厂商、系统开发这些用于统一发布标准套件，但由于操作复杂，开发学习时间也久，一般用户开发不会选择这一方式。\n\n\n\n## busybox\n\n官方下载：https://busybox.net/downloads/\n\n在这里选择下载 [busybox-1.32.0.tar.bz2](https://busybox.net/downloads/busybox-1.32.0.tar.bz2) 版本。\n\n对下载下来的 busybox 进行解压：\n\n```bash command:(\"[user@localhost] #\":1-2)\ntar -jxvf busybox-1.32.0.tar.bz2\ncd busybox-1.32.0\n```\n\n### 编译验证\n\n选择交叉编译工具对其进行默认编译：\n\n```bash command:(\"[user@localhost] #\":1||\"[root@localhost] #\":2-7)\nsudo -s\nexport ARCH=arm\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\nmake distclean\nmake defconfig\nmake\nmake install\n```\n\n最后，生成一个名为 `_install` 的文件目录（当然，你也可以使用 `CONFIG_PREFIX=rootfs_dir` 指定文件目录名称及路径），该目录就是本次默认配置所构建的残缺文件系统，为什么说是残缺，是因为还缺少相关的文件及目录，这个下面再说。\n\n### 自主配置\n\n前面说了，上面的操作只是构建了一个默认的配置用以验证，实际过程中，往往根据需要选择必要的功能，而在 busybox 中支持以下几种快速配置模式：\n\n- defconfig：缺省配置，也就是默认配置选项。\n- allyesconfi：全选配置，也就是选中 busybox 的所有功能。\n- allnoconfig：最小配置，什么都不选中，即空配置。\n\n在应用中，你可以先选择你最接近的快速配置进行初始化配置，然后再修改定制，这里笔者选择 `make allnoconfig` 进行配置初始化，配置完成后可通过查看是否有 `.config` 文件来验证配置成功。\n\n同样的，跟 [uboot](https://arachnid.cc/6ull-uboot-transplant/) 和 kernel 一样，在 busybox 中也存在图形界面配置操作（关于无法调出图形配置界面进行配置可看 [imx-6ULL kernel 移植](https://arachnid.cc/6ull-kernel-transplant/) 的图形配置说明）：\n\n```bash command:(\"[root@localhost] $\":1)\nmake menuconfig\n```\n\n关于其选项操作：\n\n```text\n    Settings ---> \t\t\t# BusyBox 的通用配置，一般采用默认值即可。\n--- Applets\n    Archival Utilities ---> \t\t\t# 压缩、解压缩相关工具。   \n    Coreutils ---> \t\t\t\t\t\t# 最基本的命令，如cat、cp、ls等。   \n    Console Utilities ---> \t\t\t\t# 控制台相关命令。   \n    Debian Utilities ---> \t\t\t\t# Debian 操作系统相关命令。   \n    klibc-utils ---> \t\t\t\t\t# 供 initramfs 所使用的最小化 libc 子集。\n    Editors ---> \t\t\t\t\t\t# 编辑工具，如 vi、awk、sed 等。   \n    Finding Utilities ---> \t\t\t\t# 查找工具，如find、grep、xargs。   \n    Init Utilities ---> \t\t\t\t# BusyBox init 相关命令。   \n    Login/Password Management Utilities ---> # 登陆、用户账号/密码等方面的命令。   \n    Linux Ext2 FS Progs ---> \t\t\t# ext2 文件系统的一些工具。   \n    Linux Module Utilities ---> \t\t# 加载/卸载模块等相关的命令。   \n    Linux System Utilities --->  \t\t# 一些系统命令。   \n    Miscellaneous Utilities ---> \t\t# 一些不好分类的命令，如crond、crontab。   \n    Networking Utilities --->    \t\t# 网络相关的命令和工具。   \n    Print Utilities --->    \t\t\t# print spool 服务及相关工具。   \n    Mail Utilities --->      \t\t\t# mail 相关命令。   \n    Process Utilities --->      \t\t# 进程相关命令，如ps、kill等。   \n    Runit Utilities --->    \t\t\t# runit 程序。   \n    Shells --->             \t\t\t# shell 程序。   \n    System Logging Utilities --->   \t# 系统日志相关工具，如 syslogd、klogd。\n---\n\tLoad an Alternate Configuration File\t\t# 加载备用配置文件\n\tSave Configuration to an Alternate File\t\t# 将配置保存到备用文件\n```\n\n然后在这里记录几个关键的配置：\n\n- 静态或者动态编译 busybox，取消选择静态编译，使得 busybox 可执行文件更小\n\n  ```text\n  -> Settings\n    -> [ ] Build static binary (no shared libs)\n  ```\n\n- 打开命令行编辑，增加 vi 编辑样式，其余默认或按需修改\n\n  ```text\n  -> Settings\n    -> [*] Command line editing\n       [*]   vi-style line editing commands\n  ```\n\n- 打开简洁式 help 命令提示\n\n  ```text\n  -> Settings\n    -> [*] Show applet usage messages\n       [ ]   Show verbose applet usage messages\n       [*]   Store applet usage messages in compressed form\n  ```\n\n- 选择支持 Unicode 编码，其余默认或按需修改\n\n  ```text\n  -> Settings\n    -> [*] Support Unicode\n       [*]   Check $LC_ALL, $LC_CTYPE and $LANG environment variables\n  ```\n\n- 取消对模块实用程序的简化，这样在该表将会额外多出几个拓展选项\n\n  ```text\n  -> Linux Module Utilities\n    -> [ ] Simplified modutils\n  ```\n\n- 打开设备自主管理功能，实现初始化常用设备和动态更新\n\n  ```text\n  -> Linux System Utilities\n    -> [*] mdev\n       [*]   Support /etc/mdev.conf\n       [*]     Support subdirs/symlinks\n       [*]       Support regular expressions substitutions when renaming dev\n       [*]     Support command execution at device addition/removal\n       [*]   Support loading of firmware\n       [*]   Support daemon mode\n  ```\n\n- 选择内核启动后 init 进程处理\n\n  ```text\n  -> Init Utilities\n    -> [*] init\n    -> [ ] linuxrc: support running init from initrd (not initramfs)\n  ```\n\n  在这里，取消勾选 `linuxrc` ；在 Linux2.4 内核及更低版本，由 `initrd` 引导加载文件系统，核心文件就是 `linuxrc` ，其通常是一个脚本文件，负责加载内核访问根文件系统必须的驱动， 以及加载根文件系统，如果你勾选上那么编译后你将会看到一个 `/linuxrc` 文件；Linux2.6 内核之后被 `initramfs` 取代，与 `initrd` 需要先解压再挂载模拟成一个块设备不同， `initramfs` 在编译阶段就被打包成 `cpio` 格式，内核可以直接将其解压建立文件系统。\n\n  为了保持向后兼容性，实际上，在这些发行版中， `initrd` 通常只是一个指向 `initramfs` 的符号链接；也就是说，你所看到的 `initrd` 实际上已经是现代化的 `initramfs` 了，通过 `ls -l linuxrc` 可以看到其实是个软链接而非文件脚本了。\n\n- shell 终端选择\n\n  ```text\n  -> Shells\n    -> [*] ash\n    -> [*] hush\n  ```\n\n  Almquist shell (也称为 A shell、ash 和 sh) 是一种轻量级 Unix shell（最大的特点就是轻量化）；Hush 是一个创新的 shell 脚本语言，它将 Lua 的简洁性和 Unix 的实用性融为一体。\n\n  ```text\n  -> Shells\n       Choose which shell is aliased to 'sh' name (ash)  --->\n       Choose which shell is aliased to 'bash' name (hush)  --->\n  ```\n\n  分别为 `sh` / `bash` 指定 ash 和 hush shell 名称。 \n\n### 添加中文支持\n\n在上面启用 Unicode 编码后，可以通过修改以下几个文件来实现中文显示。\n\n1、修改 `unicode.c` 文件\n\n```bash command:(\"[user@localhost] #\":1)\nsudo vim libbb/unicode.c\n```\n\n找到 `unicode_conv_to_printable2` 函数，进行以下修改：\n\n![image-20240822210341756](image-20240822210341756.png)\n\n2、修改 `printable_string.c` 文件\n\n```bash command:(\"[user@localhost] #\":1)\nsudo vim libbb/printable_string.c\n```\n\n找到 `printable_string2` 函数，进行以下修改：\n\n![image-20240822210801046](image-20240822210801046.png)\n\n\n\n## 编写脚本\n\n1、默认配置生成脚本\n\n```bash build.sh\n#!/bin/bash\n\n# 若之前已经导入到环境变量则不需要\nexport PATH=$PATH:/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport ARCH=arm\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\n\nmake distclean\n\nmake defconfig\n\nmake -j$(nproc)\nmake install -j$(nproc)\n```\n\n2、数据修改脚本\n\n```bash autobuild.sh\n#!/bin/bash\n\n# 若之前已经导入到环境变量则不需要\nexport PATH=$PATH:/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport ARCH=arm\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\n\nmake clean\n\nmake -j$(nproc)\nmake install -j$(nproc)\n```\n\n通过执行 `build.sh` 或 `make menuconfig` 修改及执行 `autobuild.sh` 得到所需的二进制执行程序，这时在生成的目录下可以看到：\n\n```text\n|\n|-- bin\n|-- sbin\n|-- usr\n     |-- bin\n     |-- sbin\n```\n\n\n\n## 补充 rootfs 目录\n\n根据上面 rootfs 的构成，尽管是要做最小 rootfs，除 busybox 生成的目录文件外，还需要我们去填补运行所需的目录文件。\n\n### 添加 lib 库\n\nLinux 中的应用程序一般都是需要动态库的，当然你也可以编译成静态的，但是静态的可执行文件会很大。如果编译为动态的话就需要动态库，所以我们需要向根文件系统中添加动态库，包括前面提到的 busybox 配置中的动态编译。这些动态库可以从调用的交叉编译器中获取，。\n\n**1、 `/lib` 库添加**\n\n```bash command:(\"[root@localhost:rootfs] #\":1-3)\nmkdir lib\ncp -d /usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf/libc/lib/*so* lib/\ncp -d /usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf/libc/lib/*.a lib/\n```\n\n复制 arm linux 交叉编译器下的 `libc/lib` 库里的 `*so*` 和 `*.a` 到 rootfs 的 `lib` 中， `-d` 连同软链接也一起拷贝。\n\n**2、 `/usr/lib` 库添加**\n\n```bash command:(\"[root@localhost:rootfs] #\":1-3)\nmkdir -p usr/lib\ncp -d /usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf/libc/usr/lib/*so* usr/lib\ncp -d /usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf/libc/usr/lib/*.a usr/lib\n```\n\n复制 arm linux 交叉编译器下的 `libc/usr/lib` 库里的 `*so*` 和 `*.a` 到 rootfs 的 `usr/lib` 中， `-d` 连同软链接也一起拷贝。\n\n### 完善根目录\n\n```bash command:(\"[root@localhost:rootfs] #\":1)\nmkdir  dev  etc  home  mnt  proc  sys  var\n```\n\n\n\n# 测试\n\n在完成上面的所有操作后，可以利用 NFS 网络挂载文件系统进行测试完善；关于 NFS 服务的搭建可看 [Ubuntu 搭建 tftp 及 NFS 服务](https://arachnid.cc/ubuntu-tftp-nfs-create/) 。\n\n对于利用 NFS 挂载根文件系统，可以通过修改 uboot 启动的 `bootargs` 配置来变更文件系统挂载路径，例如：\n\n```text\n=> setenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.100:/home/user/nfs_rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.100:192.168.1.1:255.255.255.0::eth0:off'\n=>\n=> saveenv\n```\n\n关于 uboot 改成 NFS 挂载 rootfs 的格式（更多信息可看 kernel 里面的 `Documentation/filesystems/nfs/nfsroot.txt` 及其相关文件）：\n\n```text\nroot=/dev/nfs nfsroot=[<server-ip>:]<root-dir>[,<nfs-options>] ip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>:<dns0-ip>:<dns1-ip>\n\n<server-ip>：服务器 IP 地址；比如这里的 PC 主机 IP 地址为 192.168.1.100。\n<root-dir>：根文件系统的存放路径，要保证放在 NFS 共享目录下；比如 /home/user/nfs_rootfs。\n<nfs-options>：NFS 的其他可选选项，一般不设置。\n<client-ip>：客户端 IP 地址，也就是开发板的 IP 地址。\n<server-ip>：服务器 IP 地址，前面已经说了。\n<gw-ip>：网关地址。\n<netmask>：子网掩码。\n<hostname>：客户机的名字，一般不设置，此值可以空着。\n<device>：设备名，也就是网卡名，一般是 eth0，eth1...。\n<autoconf>：自动配置，一般不使用，所以设置为 off。\n<dns0-ip>：DNS0 服务器 IP 地址，不使用。\n<dns1-ip>：DNS1 服务器 IP 地址，不使用。\n\n“proto=tcp”表示使用 TCP 协议，“rw”表示 nfs 挂载的根文件系统为可读可写。\n```\n\n在这里，结合 [imx-6ULL uboot 移植](https://arachnid.cc/6ull-uboot-transplant/) 篇章，可以配置成：\n\n```text\n=> setenv netargs setenv bootargs 'console=${console},${baudrate} root=/dev/nfs nfsroot=${serverip}:/home/user/nfs_rootfs,proto=tcp rw ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}::eth0:off'\n=>\n=> setenv nfsboot 'run findfdt; run findtee; mmc dev ${mmcdev}; mmc dev ${mmcdev}; run netargs; run loadimage; run loadfdt; bootz ${loadaddr} - ${fdt_addr}'\n=>\n=> saveenv\n=>\n=> run nfsboot\n```\n\n最后，通过运行 `nfsboot` 来启动。\n\n\n\n\n\n## 添加 rcS 文件\n\n通过 uboot 执行 `run nfsboot` 进入系统后，可以看到已经成功挂在 NFS 上的 rootfs 了：\n\n![img](JQKH{0OI%CXEAYY0PYJ}FW.png)\n\n但是在进入根文件系统的时候，打印上有一行报错，显示错误提示：\n\n```bash\ncan't run '/etc/init.d/rcS': No such file or directory\n```\n\n提示不能运行 `/etc/init.d/rcS` ，没有这个文件；该文件是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件\n\n那么补充一下这个文件，并写入以下内容：\n\n```shell rcS\n#!/bin/sh\n#\n# rcS\t\tCall all S??* scripts in /etc/rcS.d in\n#\t\tnumerical/alphabetical order.\n#\n# Version:\t@(#)/etc/init.d/rcS  2.76  19-Apr-1999  miquels@cistron.nl\n#\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin  # 初始化环境变量 PATH，操作系统执行程序默认到 PATH 指定的目录下寻找该程序\nrunlevel=S  # 设置系统运行级别为 S，即 single-user（单用户）模式\nprevlevel=N # 用来记录上一个运行级别的值，以便系统能够在需要时回到前一个运行级别，为 N 则表示没有\numask 022   # 指定当前用户在创建文件时的默认权限，默认 touch 创建一个文件的权限是 644\nexport PATH runlevel prevlevel  # 导出环境变量\n\n#\n#\tMount all file systems defined in /etc/fstab\n#\nmkdir /dev/pts\nmount -a    # 挂载 /etc/fstab 文件中指定的文件系统\n\n#\n#\tMake sure proc is mounted\n#\n[ -d \"/proc/1\" ] || mount /proc # 确保 /proc 已挂载\n\n#\n#\tTrap CTRL-C &c only in this shell so we can interrupt subprocesses.\n#\ntrap \":\" INT QUIT TSTP  # 捕捉 INT、QUIT、TSTP 信号\n\n#\n#\tCall all parts in order.\n#\nexec /etc/init.d/rc.local   # 转去执行 rc.local 文件中内容\n```\n\n### 补充 fstab 和 rc.local 文件\n\n在添加完 `/etc/init.d/rcS` 后再次运行：\n\n![QQ图片20240829205505](QQ图片20240829205505.png)\n\n可以看到本次打印已经没有上面的提示了，但是会多出两个文件的报错：\n\n\n```bash\nmount: can't read '/etc/fstab': No such file or directory\nmount: can't read '/etc/fstab': No such file or directory\n/etc/init.d/rcS: exec: line 34: /etc/init.d/rc.local: not found\n```\n\n分别是缺失 `/etc/fstab` 和 `/etc/init.d/rc.local` ，其实从上面的 rcS 文件上的注释可以看到，该文件是会调用 `fstab` 和 `rc.local` ，因此补充这两个文件：\n\n- `/etc/fstab`\n\n  用于指定系统需要挂载的文件系统，其格式如下：\n\n  ```text\n  <file system> <mount point> <type> <options> <dump> <pass>\n  \n  <file system>：要挂载的特殊的设备，也可以是块设备，比如 /dev/sda 等等\n  <mount point>：挂载点。\n  <type>：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。\n  <options>：挂载选项，一般使用 defaults，defaults 包含了 rw、suid、 dev、 exec、 auto、 nouser 和 async。\n  <dump>：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。\n  <pass>：磁盘检查设置，为 0 表示不检查。根目录 ‘/’ 设置为 1，其他的都不能设置为 1，因此这里一般设置为 0\n  ```\n\n  ```text fstab\n  # stock fstab - you probably want to override this with a machine specific one\n  \n  proc                 /proc                proc       defaults              0  0\n  tmpfs                /dev                 tmpfs      defaults              0  0\n  sysfs                /sys                 sysfs      defaults              0  0\n  devpts               /dev/pts             devpts     mode=0620,gid=5       0  0\n  ```\n\n- `/etc/init.d/rc.local`\n\n  该文件一般作为 `rcS` 文件的拓展，可有可无，用于设置特定的与系统级无关的操作\n\n  ```bash rc.local\n  #!/bin/sh\n  \n  # 设置从 /etc/hostname 文件中获取的主机名\n  /bin/hostname -F /etc/hostname\n  \n  # 使用 mdev 来管理热插拔设备，使 Linux 内核就可以在 /dev 目录下自动创建设备节点\n  echo /sbin/mdev > /proc/sys/kernel/hotplug\n  mdev -s\n  ```\n\n### 完善 /dev/pts 和 /etc/hostname\n\n在补充完上述的两个文件后，如果再次运行，那么还是会出现报错：\n\n![](QQ图片20240829205721.png)\n\n嘛，这也是预料之中：\n\n- 在 `fstab` 中需要挂载一个 /dev/pts 路径的虚拟文件系统，用于实现终端设备的动态分配和管理\n\n- `rc.local` 中需要读取 /etc/hostname 文件来获取主机名\n\n所以在 `rcS` 中的 `mount -a` 前面添加 `mkdir /dev/pts` 命令；创建 `/etc/hostname` 文件，并在里面填写你喜欢的开发板名字。\n\n再运行一次，这次就没有报错提示了，但是有个问题就是，终端的主机名和用户名都没有显示，与常规的终端显示不一样：\n\n![](QQ图片20240829205755.png)\n\n\n\n## 添加 profile 文件\n\n之前添加了 /bin/hostname 以获取主机名，并用 `hostname -F` 配置主机名，但实际效果是命令行的提示符是没有显示，而调用各种执行程序是没问题的，说明这部分是 Shell 变量设置导致的。\n\n查阅常见环境变量：\n\n- PATH：执行命令时要搜索的目录列表\n\n- HOME：当前用户的家目录\n\n- MAIL： 当前用户的邮件储蓄目录\n\n- SHELL：当前用户的 Shell 路径\n\n- TZ：时区\n\n- HISTSIZE：是指保存历史命令记录的条数\n\n- LOGNAME：是指当前用户的登录名\n\n- PWD：当前的工作目录\n\n- HOSTNAME：是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的\n\n- LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量\n\n- PS1：是基本提示符，对于 root 用户是 #，对于普通用户是 $\n\n- PS2：是附属提示符，默认是 “>” ，可以通过修改此环境变量来修改当前的命令符\n\n为了验证是否靠环境变量实现这一作用，编写一个 `profile` 文件：\n\n```shell profile\n# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))\n# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).\n\nPATH=$PATH:/usr/local/bin\n\nif [ ! -e /etc/localtime -a ! -e /etc/TZ ]; then\n\tTZ=\"UTC\"\t\t# Time Zone. Look at http://theory.uwinnipeg.ca/gnu/glibc/libc_303.html\n\t\t\t\t# for an explanation of how to set this to your local timezone.\n\texport TZ\nfi\n\nUSER=\"`id -un`\"\nLOGNAME=$USER\nHOSTNAME='/bin/hostname'\n\nif [ \"$HOME\" = \"/home/root\" ]; then\n   PATH=$PATH:/usr/local/sbin\nfi\n\nif [ \"$PS1\" ]; then\n# works for bash and ash (no other shells known to be in use here)\n   PS1='\\u@\\h:\\w\\$ '  # 显示主机名、当前路径等信息\nfi\n\nexport USER LOGNAME PATH PS1\n```\n\n上面的文件除了配置主机名变量和显示终端基本提示符，还追加 $PASH 路径、指定时区及用户名等。\n\n然后重启查看效果，是否能解决命令行提示符显示：\n\n![](QQ图片20240829205846.png)\n\n现在是：第一，profile 文件起了作用，hostname 显示出来了，路径指示也显示了；第二，还有个问题就是登录用户名没显示出来。\n\n\n\n## 添加 passwad , shadow , group , gshadow 文件\n\n前面已经在 `profile` 中加入了用户名变量，然而还是没从终端显示出来，那么是不是因为系统没有获取到用户配置信息呢？\n\n与用户配置信息有关的几个文件：\n\n-  **etc/passwad**\n\n  `/etc/passwd` 文件，是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。\n\n  文件中每行代表一个用户信息，以 `:` 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：\n\n  ```text\n  用户名 : 密码 : UID（用户ID） : GID（组ID） : 描述性信息 : 主目录 : Shell 路径\n  ```\n\n  添加以下信息：\n\n  ```text passwad\n  root:x:0:0:root:/home/root:/bin/bash\n  ```\n\n  note：\"x\" 表示此用户设有密码，但不是真正的密码，真正的密码保存在 `/etc/shadow` 文件中。\n\n-  **/etc/shadow**\n\n  `/etc/shadow` 文件，用于存储 Linux 系统中用户的密码信息。\n\n  文件中每行代表一个用户信息，以 `:` 作为分隔符，划分为 9 个字段，每个字段所表示的含义如下：\n\n  ```text\n  用户名 : 加密密码 : 最后一次修改时间 : 最小修改时间间隔 : 密码有效期 : 密码需要变更前的警告天数 : 密码过期后的宽限时间 : 账号失效时间 : 保留字段\n  ```\n\n  添加以下信息：\n\n  ```text shadow\n  root::19424:0:99999:7:::\n  ```\n\n  note：这里的加密密码保存的是真正加密的密码，目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法；而最后一次修改时间是指在 1970 年 1 月 1 日之后的第 n 天修改，eg：19424，可通过 `date -d \"1970-01-01 19424 days\" ` 得到 `2023年 03月 08日 星期三 00:00:00 CST`。\n\n\n-  **/etc/group**\n\n  `/ect/group` 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。\n\n  文件中每行代表一个用户组信息，以 `:` 作为分隔符，划分为 4 个字段，，每个字段所表示的含义如下：\n\n  ```text\n  组名 : 密码 : GID（组ID） : 该用户组中的用户列表\n  ```\n\n  添加以下信息：\n\n  ```text shadow\n  root:x:0:\n  ```\n\n  note：和 `/etc/passwd` 文件一样，这里的 \"x\" 仅仅是密码标识，真正加密后的组密码默认保存在 `/etc/gshadow` 文件中。\n\n-  **/etc/gshadow**\n\n  `/etc/gshadow` 文件，用于存储 Linux 系统中组用户的密码信息。\n\n  文件中每行代表一个组用户的密码信息，以 `:` 作为分隔符，划分为 4 个字段，每个字段所表示的含义如下：\n\n  ```text\n  组名 : 加密密码 : 组管理员 : 组附加用户列表\n  ```\n\n  添加以下信息：\n\n  ```text gshadow\n  root:*::\n  ```\n\n最后，添加上这几个文件后再运行一次：\n\n![](QQ图片20240829211053.png)\n\n这下子，基本的 rootfs 雏形就出来了。\n\n\n\n## 添加 inittab 文件\n\n为什么需要这个文件？Linux 内核启动完成后，内核通过启动第一个用户进程（init 进程）来启动其他用户记的进程或服务，init 进程是 Linux 系统中所有进程的父进程。\n\ninit 进程将解析 inittab 文件，运行操作系统的配置脚本，对 Linux 系统进行初始化：\n\n![img](1436095-20180709194017319-1896253481.png)\n\ninittab 文件是一个不可执行的文本文件，它被按照固定的格式书写，以供 init 进程识别；inittab 由若干条指令组成，每条指令的结构都相同，以 `:` 作为分隔符，划分为 4 个字段，每个字段所表示的含义如下：\n\n```text\nidentifier : runlevels : action : process\n```\n\n1. identifier\n\n   用于唯一标识 inittab 文件中的每条指令。\n\n2. runlevels\n\n   | level       | note                                                         |\n   | ----------- | ------------------------------------------------------------ |\n   | runlevel  0 | 让 init 关闭所有进程并终止系统。                             |\n   | runlevel  1 | 用来将系统转到单用户模式，单用户模式只能有系统管理员进入，在该模式下处理那些在有登录用户的情况下不能进行更改的文件，改 runlevel 的编号 1 也可以用 S 代替。 |\n   | runlevel  2 | 允许系统进入多用户的模式，但并不支持文件共享，这种模式很少应用。 |\n   | runlevel  3 | 最常用的运行模式，主要用来提供真正的多用户模式，也是多数服务器的缺省模式。 |\n   | runlevel  4 | 一般不被系统使用，用户可以设计自己的系统状态并将其应用到 runlevel。 |\n   | runlevel  5 | 将系统初始化为专用的 X Window 终端。对功能强大的 Linux 系统来说，这并不是好的选择，但用户如果需要这样，也可以通过在 runlevel 启动来实现该方案。 |\n   | runlevel  6 | 关闭所有运行的进程并重新启动系统。                           |\n\n3. action\n\n   | 字段       | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | sysinit    | 在系统初始化的时候 process 才会执行一次。                    |\n   | wait       | 告诉 init，要等待相应的进程执行完以后才能继续执行。          |\n   | once       | init 只运行一次该进程。                                      |\n   | respawn    | init 会监视这个 process，即使其结束后也会立即被重新启动。    |\n   | askfirst   | 与 respawn 类似，在运行 process 之前在控制台上显示 “Please press Enter to activate this console.”。只要用户按下 “Enter” 键以后才会执行 process。 |\n   | ctrlaltdel | 当 Ctrl+Alt+Del 三个键同时按下时会执行 process。             |\n   | restart    | 当 init 重启的时候才会执行 procee。                          |\n   | shutdown   | 关机的时候执行 process。                                     |\n\n4. process\n\n   表示所要执行的程序、脚本或命令等。\n\n在了解完 inittab 文件的作用后，那么你可以编写你所需要的执行操作了；在这里你可能会问，前面没有创建 `/etc/inittab` 文件，那为何可以对 Linux 系统进行初始化，这个其实查看代码可以看到，当无法获取 `/etc/inittab` 文件时，将会使用固定流程进行初始化：\n\n![image-20240829221814093](image-20240829221814093.png)\n\n但对于固定流程，我们更偏向于自定义初始化流程，因此可以简单编写：\n\n```text inittab\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\n::sysinit:/etc/init.d/rcS\n\n::askfirst:-/bin\n#::askfirst:-/bin/login\n\n# Stuff to do before rebooting\n::ctrlaltdel:/sbin/reboot\n\n# umount all filesystem\n::shutdown:/bin/umount -a -r\n#::shutdown:/sbin/swapoff -a\n\n# restart init process\n::restart:/sbin/init\n\n# Example of how to put a getty on a serial line (for a terminal)\n::once:/sbin/getty -L tty0 115200 vt100 -n root -I \"Auto login as root ...\"\n```\n\n\n\n# 扩展 bosybox 执行命令\n\n这里的拓展命令，并不是指基于原有的 bosybox 工程追加命令，而是通过新的工程编译成独立的执行文件，用以拓展命令。\n\n对于新增编译的 bosybox，一般要满足两个要求：\n\n1. glibc 版本的兼容\n2. 尽可能使 bosybox 版本一致\n\n\n\n## GLIBC 版本获取\n\n**方法一：**\n\n```c get_glibc_version.c\n#include<stdio.h>                                                                \n#include<gnu/libc-version.h>\n \nint main(void)\n{\n   char * str_gnu_ver = gnu_get_libc_version();\n \n   printf(\"gnuc lib version : %s \\n\",str_gnu_ver);\n   printf(\"__GLIBC__ =  %d \\n\",__GLIBC__);\n   printf(\"__GLIBC_MINOR__  = %d \\n\",__GLIBC_MINOR__);\n \n   return 0 ;\n}\n```\n\n编译运行： \n\n```bash command:(\"[root@localhost] $\":1-2)\ngcc get_glibc_version.c -o get_glibc_version\n./get_glibc_version\ngnuc lib version : 2.23 \n__GLIBC__ =  2 \n__GLIBC_MINOR__  = 23\n```\n\n这里利用哪个交叉编译器，输出的版本就是该编译器的 GLIBC 版本。\n\nnote：GNU C 从 2.0 开始，为 GLIBC 提供两个常量 `__GLIBC__` 和 `__GLIBC_MINOR__` 用来指示版本。\n\n**方法二：**\n\n对于开发平台，找到你的交叉编译器所在的安装文件夹，从里面找到 `libc.so.6` 文件，在该目录下或指向该目录（eg：`/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf/libc/lib/`），运行以下命令：\n\n```bash command:(\"[root@localhost] $\":1)\nstrings /usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf/libc/lib/libc.so.6 | grep ^GLIBC\nGLIBC_2.4\nGLIBC_2.5\nGLIBC_2.6\nGLIBC_2.7\nGLIBC_2.8\nGLIBC_2.9\nGLIBC_2.10\nGLIBC_2.11\nGLIBC_2.12\nGLIBC_2.13\nGLIBC_2.14\nGLIBC_2.15\nGLIBC_2.16\nGLIBC_2.17\nGLIBC_2.18\nGLIBC_2.22\nGLIBC_2.23\nGLIBC_2.24\nGLIBC_2.25\nGLIBC_2.26\nGLIBC_2.27\nGLIBC_2.28\nGLIBC_2.29\nGLIBC_2.30\nGLIBC_2.32\nGLIBC_2.33\nGLIBC_PRIVATE\nGLIBC_2.29\nGLIBC_2.26\nGLIBC_2.25\nGLIBC_2.23\nGLIBC_2.8\nGLIBC_2.33\nGLIBC_2.30\nGLIBC_2.5\nGLIBC_2.9\nGLIBC_2.7\nGLIBC_2.6\nGLIBC_2.18\nGLIBC_2.14\nGLIBC_2.11\nGLIBC_2.16\nGLIBC_2.13\n```\n\n通常 libc.so 会支持多个版本，即向前兼容，查看该文件中包含的字符串可以看到其支持的版本，通常是连续的。\n\n对于目标平台，同样在相关的 `lib` 库目录上找到 `libc.so.6` 文件，然后通过执行或查看软链接：\n\n```bash command:(\"[root@localhost] $\":1,17)\n/lib/lib.so.6\nGNU C Library (GNU libc) stable release version 2.21, by Roland McGrath et al.\nCopyright (C) 2015 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\nCompiled by GNU CC version 5.3.1 20160113.\nAvailable extensions:\n        crypt add-on version 2.1 by Michael Glad and others\n        GNU Libidn by Simon Josefsson\n        Native POSIX Threads Library by Ulrich Drepper et al\n        BIND-8.2.3-T5B\nlibc ABIs: UNIQUE\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/libc/bugs.html>.\n\nls -al /lib/lib.so.6\nlrwxrwxrwx    1 root     root            12 Mar 8  2023 /lib/libc.so.6 -> libc-2.21.so\n```\n\n\n\n## bosybox 版本获取\n\n主要是获取目标平台上的版本，然后下载相应的 bosybox 版本进行拓展编译。关于获取目标平台上的版本，可以通过执行：\n\n```bash command:(\"[root@localhost] $\":1)\nbosybox\n```\n\n然后下载相应版本进行编译，在这里需要 `make menuconfig` 把静态编译勾上：\n\n```text\n-> Settings\n  -> [*] Build static binary (no shared libs)\n```\n\n因为如果用动态编译的话，需要调用 `lib` 库，这样就会使得需要确保交叉编译器得尽可能一致，使用的 `lib` 库也要尽可能一致，而利用静态编译就不用调用 `lib` 库了。\n\n\n\n## 实现合并\n\n当你编译好一个新的 busybox 后，在 rootfs 上找个目录存放，或者取一个busybox1 之类的名字存放至 `/bin` 目录上，然后把生成软链接拓展命令，替换链接到新的 busybox1 即可。\n\n\n\n# 参考\n\nhttps://fuzidage.github.io/2024/07/20/Linux内核-rootfs构建移植/#3-gou-jian-gen-wen-jian-xi-tong\n\nhttp://www.lujun.org.cn/?p=3574\n\nhttps://www.cnblogs.com/linfeng-learning/p/9285543.html\n\nhttp://blog.chinaunix.net/uid-20564848-id-73954.html","tags":["Linux","arm_linux"]},{"title":"imx-6ULL kernel 移植","url":"/6ull-kernel-transplant/","content":"\n\n\n> 开发平台：Ubuntu 18.04.6\n>\n> 目标平台：imx-6ull\n>\n> kernel 版本：[linux-imx-imx_5.4.70_2.3.0](https://github.com/nxp-imx/linux-imx/tree/imx_5.4.70_2.3.0)\n>\n> 编译工具链：gcc versions 10.3.1 20210621 (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29))\n\n\n\n# 环境搭建\n\n## 交叉编译器\n\n关于 arm linux 交叉编译工具链的搭建，这里就再不展开说明了，毕竟在此之前如果有移植过 uboot，那么这里就可以省略了，对于没有搭过交叉编译工具链的，可以查看上一篇 [imx-6ULL uboot 移植](https://arachnid.cc/6ull-uboot-transplant/) 的交叉编译搭建的环节。\n\n## kernel 源码\n\nNXP 维护的 kernel 仓库地址：https://github.com/nxp-imx/linux-imx\n\n获取 NXP kernel 5.4.70_2.3.0 版本的源码：\n\n```bash\n# 直接拉取 5.4.70_2.3.0 版本源码文件\ngit clone -b imx_5.4.70_2.3.0 https://github.com/nxp-imx/linux-imx\n```\n\n\n\n# 编译验证\n\n```bash command:(\"[user@localhost] $\":1||\"[root@localhost] #\":2-6)\nsudo -s\nexport ARCH=arm\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\nmake distclean\nmake imx_v7_defconfig\nmake\n```\n\n第一次编译可能不会通过，如果出现以下报错：\n\n```bash\n  HOSTCC  scripts/extract-cert\nscripts/extract-cert.c:21:10: fatal error: openssl/bio.h: 没有那个文件或目录\n #include <openssl/bio.h>\n          ^~~~~~~~~~~~~~~\n```\n\n则需要安装相应的依赖库：\n\n```bash command:(\"[user@localhost] $\":1)\nsudo apt install libssl-dev\n```\n\n出现：\n\n```bash\n/bin/sh: 1: lzop: not found\n```\n\n安装：\n\n```bash command:(\"[user@localhost] $\":1)\nsudo apt install lzop\n```\n\n最后再次编译验证，最后得到 `arch/arm/boot` 目录下的 `zImage` 内核文件以及 `arch/arm/boot/dts` 目录下所需的 `.dtb` 设备树文件。\n\n\n\n# 移植\n\n## 设备树文件\n\n1、`imx6ull-14x14-lanjut-emmc.dts` 文件：\n\n```bash command:(\"[root@localhost] #\":1,16-17)\nls arch/arm/boot/dts/*6ull*.dts\narch/arm/boot/dts/imx6ull-14x14-evk-btwifi.dts\narch/arm/boot/dts/imx6ull-14x14-evk-btwifi-oob.dts\narch/arm/boot/dts/imx6ull-14x14-evk.dts\narch/arm/boot/dts/imx6ull-14x14-evk-emmc.dts\narch/arm/boot/dts/imx6ull-14x14-evk-gpmi-weim.dts\narch/arm/boot/dts/imx6ull-9x9-evk-btwifi.dts\narch/arm/boot/dts/imx6ull-9x9-evk-btwifi-oob.dts\narch/arm/boot/dts/imx6ull-9x9-evk.dts\narch/arm/boot/dts/imx6ull-9x9-evk-ldo.dts\narch/arm/boot/dts/imx6ull-colibri-eval-v3.dts\narch/arm/boot/dts/imx6ull-colibri-wifi-eval-v3.dts\narch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts\narch/arm/boot/dts/imx6ull-phytec-segin-ff-rdk-nand.dts\narch/arm/boot/dts/imx6ull-phytec-segin-lc-rdk-nand.dts\ncp arch/arm/boot/dts/imx6ull-14x14-evk-emmc.dts arch/arm/boot/dts/imx6ull-14x14-lanjut-emmc.dts\nvim arch/arm/boot/dts/imx6ull-14x14-lanjut-emmc.dts\n```\n\n**修改：**\n\n把 `#include \"imx6ull-14x14-evk.dts\"` 更改为 `#include \"imx6ull-14x14-lanjut.dts\"` 。\n\n2、`imx6ull-14x14-lanjut.dts` 文件：\n\n```bash command:(\"[root@localhost] #\":1-2)\ncp arch/arm/boot/dts/imx6ull-14x14-evk.dts arch/arm/boot/dts/imx6ull-14x14-lanjut.dts\nvim arch/arm/boot/dts/imx6ull-14x14-lanjut.dts\n```\n\n**修改：**\n\n把 `#include \"imx6ul-14x14-evk.dtsi\"` 更改为 `#include \"imx6ull-14x14-lanjut.dtsi\"` ；\n\n同时更改以下内容：\n\n```text\n/ {\n\tmodel = \"i.MX6 ULL 14x14 EVK Board\";\n\tcompatible = \"fsl,imx6ull-14x14-evk\", \"fsl,imx6ull\";\n};\n\n改为\n\n/ {\n\tmodel = \"i.MX6 ULL 14x14 LANJUT Board\";\n\tcompatible = \"fsl,imx6ull-14x14-lanjut\", \"fsl,imx6ull\";\n};\n```\n\n把两个 `status = \"okay\";` 改为 `status = \"disabled\";` ，这里暂不需要摄像头驱动。\n\n3、 `imx6ull-14x14-lanjut.dtsi` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\ncp arch/arm/boot/dts/imx6ul-14x14-evk.dtsi arch/arm/boot/dts/imx6ull-14x14-lanjut.dtsi\n```\n\n## 配置文件\n\n在这里，imx6ull 的 kernel 默认配置文件为 `imx_v7_defconfig` ，因此，我们独立一个专属自己的配置文件：\n\n```bash command:(\"[root@localhost] #\":1)\ncp arch/arm/configs/imx_v7_defconfig arch/arm/configs/imx_v7_lanjut_defconfig\n```\n\n**修改：**\n\n```text\n去除其它芯片类型的设备树的生成\n\nCONFIG_SOC_IMX50=y\nCONFIG_SOC_IMX51=y\nCONFIG_SOC_IMX53=y\nCONFIG_SOC_IMX6Q=y\nCONFIG_SOC_IMX6SL=y\nCONFIG_SOC_IMX6SLL=y\nCONFIG_SOC_IMX6SX=y\nCONFIG_SOC_IMX6UL=y\nCONFIG_SOC_IMX7D=y\nCONFIG_SOC_IMX7ULP=y\nCONFIG_SOC_VF610=y\n\n改为\n\n# CONFIG_SOC_IMX50 is not set\n# CONFIG_SOC_IMX51 is not set\n# CONFIG_SOC_IMX53 is not set\nCONFIG_SOC_IMX6Q=y\n# CONFIG_SOC_IMX6SL is not set\n# CONFIG_SOC_IMX6SLL is not set\nCONFIG_SOC_IMX6SX=y\nCONFIG_SOC_IMX6UL=y\nCONFIG_SOC_IMX7D=y\nCONFIG_SOC_IMX7ULP=y\n# CONFIG_SOC_VF610 is not set\n```\n\n这里除了 `CONFIG_SOC_IMX6UL` 还有几个是必须的，否则编译不过，还有其它关联的直接屏蔽：\n\n```text\n# CONFIG_MTD_NAND_VF610_NFC=y\n# CONFIG_NVMEM_VF610_OCOTP=y\n```\n\n最后，添加一个热插拔管理：\n\n```text\nCONFIG_UEVENT_HELPER=y\n```\n\n然后，这个配置文件其它东西我们就先不去更改了，因为内核配置太多太复杂了，它们之间的功能关系也很难分清，后面我们使用图形配置操作对需要的功能进行增删。\n\n## 其它文件\n\n为 `Makefile` 添加新增的文件编译：\n\n```bash command:(\"[root@localhost] #\":1)\nvim arch/arm/boot/dts/Makefile\n```\n\n**修改：**\n\n```makefile\ndtb-$(CONFIG_SOC_IMX6UL) += \\\n\timx6ul-14x14-evk.dtb \\\n\timx6ul-14x14-evk-csi.dtb \\\n\timx6ul-14x14-evk-emmc.dtb \\\n\timx6ul-14x14-evk-btwifi.dtb \\\n\timx6ul-14x14-evk-btwifi-oob.dtb \\\n\timx6ul-14x14-evk-ecspi-slave.dtb \\\n\timx6ul-14x14-evk-ecspi.dtb \\\n\timx6ul-14x14-evk-gpmi-weim.dtb \\\n\timx6ul-9x9-evk.dtb \\\n\timx6ul-9x9-evk-ldo.dtb \\\n\timx6ul-9x9-evk-btwifi.dtb \\\n\timx6ul-9x9-evk-btwifi-oob.dtb \\\n\timx6ul-ccimx6ulsbcexpress.dtb \\\n\timx6ul-ccimx6ulsbcpro.dtb \\\n\timx6ul-geam.dtb \\\n\timx6ul-isiot-emmc.dtb \\\n\timx6ul-isiot-nand.dtb \\\n\timx6ul-kontron-n6310-s.dtb \\\n\timx6ul-kontron-n6310-s-43.dtb \\\n\timx6ul-liteboard.dtb \\\n\timx6ul-opos6uldev.dtb \\\n\timx6ul-pico-hobbit.dtb \\\n\timx6ul-pico-pi.dtb \\\n\timx6ul-phytec-segin-ff-rdk-nand.dtb \\\n\timx6ul-tx6ul-0010.dtb \\\n\timx6ul-tx6ul-0011.dtb \\\n\timx6ul-tx6ul-mainboard.dtb \\\n\timx6ull-14x14-evk.dtb \\\n\timx6ull-14x14-evk-emmc.dtb \\\n\timx6ull-14x14-evk-btwifi.dtb \\\n\timx6ull-14x14-evk-btwifi-oob.dtb \\\n\timx6ull-14x14-evk-gpmi-weim.dtb \\\n\timx6ull-14x14-lanjut-emmc.dtb \\  # 将设备树文件添加进编译项\n\timx6ull-9x9-evk.dtb \\\n\timx6ull-9x9-evk-ldo.dtb \\\n\timx6ull-9x9-evk-btwifi.dtb \\\n\timx6ull-9x9-evk-btwifi-oob.dtb \\\n\timx6ull-colibri-eval-v3.dtb \\\n\timx6ull-colibri-wifi-eval-v3.dtb \\\n\timx6ull-phytec-segin-ff-rdk-nand.dtb \\\n\timx6ull-phytec-segin-ff-rdk-emmc.dtb \\\n\timx6ull-phytec-segin-lc-rdk-nand.dtb \\\n\timx6ulz-14x14-evk.dtb \\\n\timx6ulz-14x14-evk-btwifi.dtb \\\n\timx6ulz-14x14-evk-gpmi-weim.dtb \\\n\timx6ulz-14x14-evk-emmc.dtb\n```\n\n# 外设配置\n\n这里不多阐述了，主要是根据你的硬件进行修改，是对设备树、功能配置、函数修改的操作。\n\n\n\n# 配置内核\n\n## 图形配置\n\n需要先 `make xxx_config` 生成 `.config` 。\n\n使用 `make menuconfig` 调出图形配置界面进行配置；如果 `make menuconfig` 失败，说明缺少 `ncurses` 库 ，需要安装 `libncurses-dev` ，在安装前则需要加载 `libncurses-dev` 的[源镜像](https://packages.ubuntu.com/focal/amd64/libncurses-dev/download)，然后通过 `apt update` 更新，然后再次使用命令 `apt install libncurses-dev ` 安装，若安装后还不行，可能是由于某些库可能没安装好，或者被 `auto remove` 掉了，可以尝试以下安装：\n\n```bash\napt install lib32ncurses5 lib32ncurses5-dev lib32ncursesw5 lib32ncursesw5-dev lib32tinfo-dev lib32tinfo5 libcunit1-ncurses libcunit1-ncurses-dev libncurses5 libncurses5-dbg libncurses5-dev libncursesw5 libncursesw5-dbg libncursesw5-dev\n```\n\n当进入图形菜单后，可以通过以下热键进行选择：\n\n-  `Y` 显示为 [*] 。模块驱动编译到内核中，启动时自动加载。\n-  `N` 显示为 [ ] 。移除该模块驱动。\n-  `M` 显示为 [M] 。模块会被编译，但是不会被编译到内核中，只是生成 `.o` / `.ko` 文件，通过 `insmod` 命令实现动态加载。\n\nnote：如果想要 Load 加载原有的配置信息，那么需要先 `make zImage` 才能获取回来。\n\n# 添加编译脚本\n\n```bash command:(\"[root@localhost] #\":1-2)\ntouch build.sh\nvim build.sh\n```\n\n**写入：**\n\n```bash\n#!/bin/bash\n\n# 若之前已经导入到环境变量则不需要\nexport PATH=$PATH:/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport ARCH=arm\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\n\nmake distclean\n\nmake mx6ull_14x14_lanjut_emmc_defconfig\n\nmake zImage -j$(nproc)\nmake dtbs -j$(nproc)\nmake modules -j$(nproc)\n```\n\n\n\n# 附\n\nkernel 文件结构：\n\n|  类型  |     名称      |                   说明                    |\n| :----: | :-----------: | :---------------------------------------: |\n| 文件夹 |     arch      |              与架构体系相关               |\n|   ^^   |     block     |                块设备相关                 |\n|   ^^   |     certs     |               内核签名相关                |\n|   ^^   |    crypto     |                 加密相关                  |\n|   ^^   | Documentation |                各说明文档                 |\n|   ^^   |    drivers    |                 驱动相关                  |\n|   ^^   |      fs       |               文件系统相关                |\n|   ^^   |    include    |                头文件相关                 |\n|   ^^   |     init      |                初始化相关                 |\n|   ^^   |      ipc      |              进程间通信相关               |\n|   ^^   |    kernel     |                 内核相关                  |\n|   ^^   |      lib      |                lib 库文件                 |\n|   ^^   |   LICENSES    |                许可证相关                 |\n|   ^^   |      mm       |               内存管理相关                |\n|   ^^   |      net      |                 网络相关                  |\n|   ^^   |    samples    |                 例程相关                  |\n|   ^^   |    scripts    |                 相关脚本                  |\n|   ^^   |   security    |             内核安全模型相关              |\n|   ^^   |     sound     |               音频处理相关                |\n|   ^^   |     tools     |            kernel 构建工具相关            |\n|   ^^   |      usr      | 早期用户空间代码（与 initramfs 文件相关） |\n|   ^^   |     virt      |              内核虚拟机 KVM               |\n|  文件  |    COPYING    |                 版权声明                  |\n|   ^^   |    CREDITS    |                贡献者名单                 |\n|   ^^   |    Kbuild     |             Makefile 引用文件             |\n|   ^^   |    Kconfig    |           图形配置界面相关文件            |\n|   ^^   |  MAINTAINERS  |              开发及维护记录               |\n|   ^^   |   Makefile    |             主 Makefile 脚本              |\n|   ^^   |    README     |                 工程说明                  |\n\n","tags":["Linux","arm_linux","imx6ull"]},{"title":"imx-6ULL uboot 移植","url":"/6ull-uboot-transplant/","content":"\n\n\n> 开发平台：Ubuntu 18.04.6\n>\n> 目标平台：imx-6ull\n>\n> uboot 版本：[uboot-imx-imx_v2020.04_5.4.70_2.3.0](https://github.com/nxp-imx/uboot-imx/tree/imx_v2020.04_5.4.70_2.3.0)\n>\n> 编译工具链：gcc versions 10.3.1 20210621 (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29))\n\n\n\n# 环境搭建\n\n## 交叉编译器\n\n在 ARM [官方链接](https://developer.arm.com/downloads/-/gnu-a)下载 Arm A-profile architecture 编译工具链，选择自己相应的平台，这里的话是：`gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf` 。\n\n解压添加至本地：\n\n```bash command:(\"[user@localhost] $\":2,4,6)\n# 创建存放编译工具链的文件夹\nsudo mkdir /usr/local/arm\n# 移动文件\nsudo mv gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf.tar.xz /usr/local/arm/\n# 解压文件\nsudo tar -xvf /usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf.tar.xz \n```\n\n添加环境变量：\n\n```bash command:(\"[user@localhost] $\":2,5)\n# 添加到系统环境变量(对所有用户有效)\nsudo vim /etc/profile\nexport PATH=$PATH:/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin\n# 添加到用户环境变量(仅对当前用户有效)\nsudo vim ~/.bashrc \nexport PATH=$PATH:/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin\n\n# 以上二选一\n```\n\n测试命令：\n\n```bash command:(\"[user@localhost] $\":2)\n# 成功打印版本信息则为通过\narm-none-linux-gnueabihf-gcc -v\n```\n\n\n\n## uboot 源码\n\nNXP 维护的 uboot 仓库地址：https://github.com/nxp-imx/uboot-imx\n\n获取 NXP uboot 5.4.70_2.3.0 版本的源码：\n\n```bash\n# 拉取源码文件\ngit clone https://github.com/nxp-imx/uboot-imx.git\n# 切换到\ngit checkout imx_v2020.04_5.4.70_2.3.0\n```\n\n上面的 clone 操作会拉取所有分支文件及历史提交信息下来，文件比较大，如果网络不太好，可以尝试打开 https://github.com/nxp-imx/uboot-imx/tree/imx_v2020.04_5.4.70_2.3.0 只下载 ZIP 压缩包下来，然后利用 `unzip` 命令解压。\n\n或者使用 `git clone -b imx_v2020.04_5.4.70_2.3.0 https://github.com/nxp-imx/uboot-imx.git` 直接下载指定版本。\n\nnote：对于不同分支，有 `fslc` 和 `imx` 关键字的区分，以下摘录解释：\n\n```text\nThere are two BSPs, the BSP Releases which are supported by NXP and their documentation can be found on the Linux i.MX webpage, and the Community BSP.\n\nA BSP Release roadmap is not publicly available, but as you may see there are new BSPs every several months. However, it usually lags in respect to the Linux Mainline Kernel as a lot of work is done to ensure that the kernel works correctly on the NXP hardware. The kernel from these BSP Releases (linux-imx) can be found on the following repository and it is indeed an upstream from the Community BSP Kernel.\n\nhttps://source.codeaurora.org/external/imx/linux-imx/\n\nAs for the Community BSP, it’s constantly being updated by the Community but due to its nature is hard to predict how fast each branch will be developed.\n\nYou can find more information about the Community BSP on the link below:\n\nhttp://freescale.github.io/\n\nThe Kernel recipes of the community BSP (linux-fslc) would be on the meta-freescale layer:\n\nhttp://git.yoctoproject.org/cgit/cgit.cgi/meta-freescale\n```\n\n简单的来讲，就是 `imx` 是官方发行版，而 `fslc` 是社区发行版。\n\n来源：https://community.nxp.com/t5/i-MX-Processors/what-is-the-purpose-of-linux-fslc-git/m-p/1047602\n\n\n\n关于 uboot 版本选择：\n\n随着时间的变化，uboot 的更新也出现了多个的版本，那么到底应该选择哪一个呢？有些人可能会说当然是越新越好啦。其实呢不是这个样子的，虽然 uboot 本身是在不断的开发和进化当中，但对于新版本来说，可能开发者们在某一个版本中加入了一些新的特性，然后呢过了一段时间又发现这个新功能不是很稳定，就有可能会把它删掉或者需要后期继续更新迭代修复；这样一来就会对我们所移植的 uboot 来说就会增加很多不必要的复杂性，因为不排除是否会影响到所使用的功能，所以一般的原则就是够用就可以了，不需要频繁更新。\n\n那如何选择属于自己的版本呢：\n\n1. 打开下载的 uboot 目录下的：`arch/arm/cpu` 目录，确认使用的 cpu 型号是否支持及对应。\n\n2. 打开 uboot 目录下的：`board` 目录，查看相对应的外设是否都支持。eq：`board/freescale/mx6ull_board/` 。\n\n一般来说，uboot 版本越新支持的开发板和 cpu 就越多，代码量就越多，如果我们的 cpu 和开发板的并没有这么多东西，那我们可以不用新的。而用适合自己产品外设的，通常是根据开发板发行的日期和 uboot 的更新日期来找到合适的 uboot。\n\n\n\n# 编译验证\n\n```bash command:(\"[user@localhost] $\":1||\"[root@localhost] #\":2-6)\nsudo -s\nexport ARCH=arm\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\nmake distclean\nmake mx6ull_14x14_evk_emmc_defconfig\nmake\n```\n\n编译源码这一步的目的：\n\n- 一是为了验证编译环境是否正常；\n- 二是为了下一步移植过程中的代码分析（一些文件只有在编译后才会生成）。\n\nnote：\n\n`make clean` - 清除了目标机器上可以运行的 bin 文件以及目录，还有中间的过程文件和编译日志，但是会保留内核的配置文件 .config 以及编译支持的扩展模块；\n\n`make mrproper` - 在 clean 的基础上，清除了交叉编译工具链、menuconfig 的内容；\n\n`make distclean` - 在 mrproper 的基础上，删除编辑器备份和补丁文件。\n\n删除的文件范围从小到大依次为： `make clean` < `make mrproper` < `make distclean` 。\n\n注意：\n\n若是提示 `make: 未找到命令` ，则需要安装 `make` 工具：\n\n```bash command:(\"[user@localhost] $\":1)\nsudo apt install make\n```\n\n若是出现 `/bin/sh: 1: cc: not found` ，需要安装 gcc 依赖，因为 `HOSTCC  scripts/basic/fixdep` 强制定义使用了 gcc，`HOSTCC=gcc` ：\n\n```bash command:(\"[user@localhost] $\":1)\nsudo apt install gcc\n```\n\n若是在系统上第一次编译 uboot 源码可能会遇到缺少  `bison`、`flex` 的报错信息导致编译失败，只需安装相应的工具包后重新执行编译即可：\n\n```bash command:(\"[user@localhost] $\":2,4)\n# 语法分析工具\nsudo apt install bison\n# 词法分析工具\nsudo apt install flex\n```\n\n最后再次编译验证，最后得到主目录下的 `u-boot-dtb.imx` 镜像文件。\n\n\n\n# 移植\n\n下面以命名为 `lanjut` 的板子为例。\n\n## 开发板文件夹\n\n```bash command:(\"[root@localhost] #\":1,3-5)\nls -d board/freescale/*6ull*\nboard/freescale/mx6ullevk     board/freescale/mx6ull_ddr3_val\ncp -r board/freescale/mx6ullevk/ board/freescale/mx6ull_lanjut/\nmv board/freescale/mx6ull_lanjut/mx6ullevk.c board/freescale/mx6ull_lanjut/mx6ull_lanjut.c\nls board/freescale/mx6ull_lanjut/\nimximage.cfg         Kconfig      Makefile        plugin.S\nimximage_lpddr2.cfg  MAINTAINERS  mx6ull_lanjut.c  README\n```\n\n**修改：**\n\n1、`Kconfig` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim board/freescale/mx6ull_lanjut/Kconfig\n```\n\n更改内容为（注意该文件 `endif` 后面必须有换行）：\n\n```text\nif TARGET_MX6ULL_14X14_LANJUT\n\nconfig SYS_BOARD\n\tdefault \"mx6ull_lanjut\"\n\nconfig SYS_VENDOR\n\tdefault \"freescale\"\n\nconfig SYS_CONFIG_NAME\n\tdefault \"mx6ull_lanjut\"\n\nconfig SYS_TEXT_BASE\n\tdefault 0x87800000\nendif\n\n```\n\n2、`Makefile` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim board/freescale/mx6ull_lanjut/Makefile\n```\n\n把 `obj-y  := mx6ullevk.o` 改为 `obj-y  := mx6ull_lanjut.o` 。\n\n3、`imximage_lpddr2.cfg` 和 `imximage.cfg` 文件：\n\n```bash command:(\"[root@localhost] #\":1-2)\nvim board/freescale/mx6ull_lanjut/imximage_lpddr2.cfg\nvim board/freescale/mx6ull_lanjut/imximage.cfg\n```\n\n该更改受控于 `CONFIG_USE_IMXIMG_PLUGIN` 宏定义，在配置文件中是没有使能的，改不改都无所谓，但为了统一，把 `PLUGIN\tboard/freescale/mx6ullevk/plugin.bin 0x00907000` 改为 `PLUGIN\tboard/freescale/mx6ull_lanjut/plugin.bin 0x00907000` 。\n\n4、`MAINTAINERS` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim board/freescale/mx6ull_lanjut/MAINTAINERS\n```\n\n是维护者记录文件，作为个人使用，改不改都无所谓；如果是作为 uboot 项目维护者，则需要完整记录好详细的信息，以便更好的发展维护。\n\n```text\nMX6ULL_LANJUT BOARD\nM:\tArachnid <xxxx@qq.com>\nS:\tMaintained\nF:\tboard/freescale/mx6ull_lanjut/\nF:\tinclude/configs/mx6ull_lanjut.h\nF:\tconfigs/mx6ull_14x14_lanjut_defconfig\nF:\tconfigs/mx6ull_14x14_lanjut_plugin_defconfig\nF:\tconfigs/mx6ulz_14x14_lanjut_defconfig\n```\n\n5、`mx6ull_lanjut.c` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim board/freescale/mx6ull_lanjut/mx6ull_lanjut.c\n```\n\n- `board_late_init` 函数\n\n  ```c\n  int board_late_init(void)\n  {\n  #ifdef CONFIG_CMD_BMODE\n  \tadd_board_boot_modes(board_boot_modes);\n  #endif\n  \n  \tenv_set(\"tee\", \"no\");\n  #ifdef CONFIG_IMX_OPTEE\n  \tenv_set(\"tee\", \"yes\");\n  #endif\n  \n  #ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG\n  \tenv_set(\"board_name\", \"LANJUT\");\t// 决定了后面 findfdt 和 findtee 环境变量的选择\n  \n  \tif (is_mx6ull_9x9_evk())\n  \t\tenv_set(\"board_rev\", \"9X9\");\n  \telse\n  \t\tenv_set(\"board_rev\", \"14X14\");\n  \n  \tif (is_cpu_type(MXC_CPU_MX6ULZ)) {\n  \t\tenv_set(\"board_name\", \"ULZ-EVK\");\n  \t\tenv_set(\"usb_net_cmd\", \"usb start\");\n      }\n  #endif\n  \n  \tsetup_lcd();\n  \n  #ifdef CONFIG_ENV_IS_IN_MMC\n  \tboard_late_mmc_env_init();\n  #endif\n  \n  \tset_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);\n  \n  \treturn 0;\n  }\n  ```\n\n- `checkboard` 函数\n\n  ```c\n  int checkboard(void)\n  {\n  \tif (is_mx6ull_9x9_evk())\n  \t\tputs(\"Board: MX6ULL 9x9 EVK\\n\");\n  \telse if (is_cpu_type(MXC_CPU_MX6ULZ))\n  \t\tputs(\"Board: MX6ULZ 14x14 EVK\\n\");\n  \telse\n  \t\tputs(\"Board: MX6ULL 14x14 LANJUT\\n\");\t// uboot 板载信息显示\n  \n  \treturn 0;\n  }\n  ```\n\n\n\n## 设备树文件\n\n在新版本 uboot 中，参考 Linux 内核引入了[设备树](https://www.devicetree.org/)和[驱动模型(Driver Model)](https://u-boot.readthedocs.io/en/latest/develop/driver-model/index.html)。\n\n1、`imx6ull-14x14-lanjut-emmc.dts` 文件：\n\n```bash command:(\"[root@localhost] #\":1,16-17)\nls arch/arm/dts/*6ull*.dts\narch/arm/dts/imx6ull-14x14-ddr3-val.dts\narch/arm/dts/imx6ull-14x14-ddr3-val-emmc.dts\narch/arm/dts/imx6ull-14x14-ddr3-val-epdc.dts\narch/arm/dts/imx6ull-14x14-ddr3-val-gpmi-weim.dts\narch/arm/dts/imx6ull-14x14-ddr3-val-lcdif.dts\narch/arm/dts/imx6ull-14x14-ddr3-val-tsc.dts\narch/arm/dts/imx6ull-14x14-evk.dts\narch/arm/dts/imx6ull-14x14-evk-emmc.dts\narch/arm/dts/imx6ull-14x14-evk-gpmi-weim.dts\narch/arm/dts/imx6ull-9x9-evk.dts\narch/arm/dts/imx6ull-colibri.dts\narch/arm/dts/imx6ull-dart-6ul.dts\narch/arm/dts/imx6ull-phytec-segin-ff-rdk-emmc.dts\narch/arm/dts/imx6ull-somlabs-visionsom.dts\ncp arch/arm/dts/imx6ull-14x14-evk-emmc.dts arch/arm/dts/imx6ull-14x14-lanjut-emmc.dts\nvim arch/arm/dts/imx6ull-14x14-lanjut-emmc.dts\n```\n\n**修改：**\n\n把 `#include \"imx6ull-14x14-evk.dts\"` 更改为 `#include \"imx6ull-14x14-lanjut.dts\"` 。\n\n2、`imx6ull-14x14-lanjut.dts` 文件：\n\n```bash command:(\"[root@localhost] #\":1-2)\ncp arch/arm/dts/imx6ull-14x14-evk.dts arch/arm/dts/imx6ull-14x14-lanjut.dts\nvim arch/arm/dts/imx6ull-14x14-lanjut.dts\n```\n\n**修改：**\n\n把 `#include \"imx6ul-14x14-evk.dtsi\"` 更改为 `#include \"imx6ul-14x14-lanjut.dtsi\"` ；\n\n把 `#include \"imx6ul-14x14-evk-u-boot.dtsi\"` 更改为 `#include \"imx6ul-14x14-lanjut-u-boot.dtsi\"` 。\n\n同时更改以下内容：\n\n```text\n/ {\n\tmodel = \"i.MX6 ULL 14x14 EVK Board\";\n\tcompatible = \"fsl,imx6ull-14x14-evk\", \"fsl,imx6ull\";\n};\n\n改为\n\n/ {\n\tmodel = \"i.MX6 ULL 14x14 LANJUT Board\";\n\tcompatible = \"fsl,imx6ull-14x14-lanjut\", \"fsl,imx6ull\";\n};\n```\n\n3、`imx6ul-14x14-lanjut.dtsi` 和 `imx6ul-14x14-lanjut-u-boot.dtsi` 文件：\n\n根据 `imx6ull-14x14-lanjut.dts` 文件的 `#include` 包含文件，分别添加文件。\n\n```bash command:(\"[root@localhost] #\":1-2)\ncp arch/arm/dts/imx6ul-14x14-evk.dtsi arch/arm/dts/imx6ul-14x14-lanjut.dtsi\ncp arch/arm/dts/imx6ul-14x14-evk-u-boot.dtsi arch/arm/dts/imx6ul-14x14-lanjut-u-boot.dtsi\n```\n\n\n\n## 配置文件\n\n1、`mx6ull_14x14_lanjut_emmc_defconfig` 文件：\n\n```bash command:(\"[root@localhost] #\":1,21-22)\nls configs/*6ull*\nconfigs/colibri-imx6ull_defconfig\nconfigs/mx6ull_14x14_ddr3_val_defconfig\nconfigs/mx6ull_14x14_ddr3_val_emmc_defconfig\nconfigs/mx6ull_14x14_ddr3_val_epdc_defconfig\nconfigs/mx6ull_14x14_ddr3_val_nand_defconfig\nconfigs/mx6ull_14x14_ddr3_val_plugin_defconfig\nconfigs/mx6ull_14x14_ddr3_val_qspi1_defconfig\nconfigs/mx6ull_14x14_ddr3_val_spinor_defconfig\nconfigs/mx6ull_14x14_ddr3_val_tsc_defconfig\nconfigs/mx6ull_14x14_evk_defconfig\nconfigs/mx6ull_14x14_evk_emmc_defconfig\nconfigs/mx6ull_14x14_evk_nand_defconfig\nconfigs/mx6ull_14x14_evk_optee_defconfig\nconfigs/mx6ull_14x14_evk_plugin_defconfig\nconfigs/mx6ull_14x14_evk_qspi1_defconfig\nconfigs/mx6ull_9x9_evk_defconfig\nconfigs/mx6ull_9x9_evk_plugin_defconfig\nconfigs/mx6ull_9x9_evk_qspi1_defconfig\nconfigs/somlabs_visionsom_6ull_defconfig\ncp configs/mx6ull_14x14_evk_emmc_defconfig configs/mx6ull_14x14_lanjut_emmc_defconfig\nvim configs/mx6ull_14x14_lanjut_emmc_defconfig\n```\n\n**修改：**\n\n把 `CONFIG_TARGET_MX6ULL_14X14_EVK=y` 改为 `CONFIG_TARGET_MX6ULL_14X14_LANJUT=y` ；\n\n把 `CONFIG_SYS_EXTRA_OPTIONS=\"IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg\"` 改为 `CONFIG_SYS_EXTRA_OPTIONS=\"IMX_CONFIG=board/freescale/mx6ull_lanjut/imximage.cfg\"` ；\n\n把 `CONFIG_DEFAULT_DEVICE_TREE=\"imx6ull-14x14-evk-emmc\"` 改为 `CONFIG_DEFAULT_DEVICE_TREE=\"imx6ull-14x14-lanjut-emmc\"` 。\n\n2、`include/configs/mx6ull_lanjut.h` 文件：\n\n```bash command:(\"[root@localhost] #\":1,4-5)\nls include/configs/*6ull*\ninclude/configs/colibri-imx6ull.h  include/configs/mx6ullevk.h\ninclude/configs/mx6ull_ddr3_val.h  include/configs/somlabs_visionsom_6ull.h\ncp include/configs/mx6ullevk.h include/configs/mx6ull_lanjut.h\nvim include/configs/mx6ull_lanjut.h\n```\n\n**修改：**\n\n把 `#ifndef __MX6ULLEVK_CONFIG_H` 和 `#define __MX6ULLEVK_CONFIG_H` 改为 `#ifndef __MX6ULL_LANJUT_CONFIG_H` 和 `#define __MX6ULL_LANJUT_CONFIG_H` 。\n\n更改 uboot 默认命令配置值：\n\n- findfdt（用于设置 `fdt_file` 变量，根据 `board_name` 来指定**传递给内核的设备树**文件名）\n\n  ```text\n  \t\t\"findfdt=\"\\\n  \t\t\t\"if test $fdt_file = undefined; then \" \\\n  \t\t\t\t\"if test $board_name = ULZ-EVK && test $board_rev = 14X14; then \" \\\n  \t\t\t\t\t\"setenv fdt_file imx6ulz-14x14-evk.dtb; fi; \" \\\n  \t\t\t\t\"if test $board_name = EVK && test $board_rev = 9X9; then \" \\\n  \t\t\t\t\t\"setenv fdt_file imx6ull-9x9-evk.dtb; fi; \" \\\n  \t\t\t\t\"if test $board_name = EVK && test $board_rev = 14X14; then \" \\\n  \t\t\t\t\t\"setenv fdt_file imx6ull-14x14-evk.dtb; fi; \" \\\n  \t\t\t\t\"if test $board_name = LANJUT && test $board_rev = 14X14; then \" \\\n  \t\t\t\t\t\"setenv fdt_file imx6ull-14x14-lanjut.dtb; fi; \" \\\n  \t\t\t\t\"if test $fdt_file = undefined; then \" \\\n  \t\t\t\t\t\"echo WARNING: Could not determine dtb to use; \" \\\n  \t\t\t\t\"fi; \" \\\n  \t\t\t\"fi;\\0\" \\\n  ```\n\n- findtee（用于设置 `tee_file` 变量，根据 `board_name` 来指定 uboot 设备树文件名）\n\n  ```text\n  \t\t\"findtee=\"\\\n  \t\t\t\"if test $tee_file = undefined; then \" \\\n  \t\t\t\t\"if test $board_name = ULZ-EVK && test $board_rev = 14X14; then \" \\\n  \t\t\t\t\t\"setenv tee_file uTee-6ulzevk; fi; \" \\\n  \t\t\t\t\"if test $board_name = EVK && test $board_rev = 9X9; then \" \\\n  \t\t\t\t\t\"setenv tee_file uTee-6ullevk; fi; \" \\\n  \t\t\t\t\"if test $board_name = EVK && test $board_rev = 14X14; then \" \\\n  \t\t\t\t\t\"setenv tee_file uTee-6ullevk; fi; \" \\\n  \t\t\t\t\"if test $board_name = LANJUT && test $board_rev = 14X14; then \" \\\n  \t\t\t\t\t\"setenv tee_file uTee-6ull_lanjut; fi; \" \\\n  \t\t\t\t\"if test $tee_file = undefined; then \" \\\n  \t\t\t\t\t\"echo WARNING: Could not determine tee to use; \" \\\n  \t\t\t\t\"fi; \" \\\n  \t\t\t\"fi;\\0\" \\\n  ```\n\n\n\n## 其它文件\n\n1、`Makefile` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim arch/arm/dts/Makefile\n```\n\n**修改：**\n\n```makefile\ndtb-$(CONFIG_MX6ULL) += \\\n\timx6ull-14x14-ddr3-val.dtb \\\n\timx6ull-14x14-ddr3-val-epdc.dtb \\\n\timx6ull-14x14-ddr3-val-emmc.dtb \\\n\timx6ull-14x14-ddr3-val-gpmi-weim.dtb \\\n\timx6ull-14x14-ddr3-val-tsc.dtb \\\n\timx6ull-14x14-evk.dtb \\\n\timx6ull-14x14-evk-emmc.dtb \\\n\timx6ull-14x14-evk-gpmi-weim.dtb \\\n\timx6ull-14x14-lanjut-emmc.dtb \\  # 将设备树文件添加进编译项\n\timx6ull-9x9-evk.dtb \\\n\timx6ull-colibri.dtb \\\n\timx6ull-phytec-segin-ff-rdk-emmc.dtb \\\n\timx6ull-dart-6ul.dtb \\\n\timx6ull-somlabs-visionsom.dtb \\\n\timx6ulz-14x14-evk.dtb \\\n\timx6ulz-14x14-evk-emmc.dtb \\\n\timx6ulz-14x14-evk-gpmi-weim.dtb\n```\n\n2、`Kconfig` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim arch/arm/mach-imx/mx6/Kconfig\n```\n\n**修改：**\n\n在 `config TARGET_MX6ULL_14X14_EVK` 配置的下方添加：\n\n```text\nconfig TARGET_MX6ULL_14X14_LANJUT\n\tbool \"Support mx6ull_14x14_lanjut\"\n\tselect BOARD_LATE_INIT\n\tselect DM\n\tselect DM_THERMAL\n\tselect MX6ULL\n\timply CMD_DM\n```\n\n在 `source \"board/freescale/mx6ullevk/Kconfig\"` 配置的下方添加：\n\n```text\nsource \"board/freescale/mx6ull_lanjut/Kconfig\"\n```\n\n\n\n# 定制外设\n\n## 移除 74lv595 芯片相关配置\n\n1、`mx6ull_14x14_lanjut_emmc_defconfig` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim configs/mx6ull_14x14_lanjut_emmc_defconfig\n```\n\n由于开发板上不需要用到 74lv595 芯片，因此取消与其相关的配置：\n\n- 找到 `CONFIG_DM_74X164=y` 改为 `# CONFIG_DM_74X164 is not used` ，官网 EVK 开发板使用了一个 74LV594，这里没有使用所以屏蔽掉。\n- 找到 `CONFIG_SOFT_SPI=y` 改为 `# CONFIG_SOFT_SPI is not used` ，屏蔽掉软件模拟的 SPI，这是官方驱动 74LV594 用的，同样也是用不到。\n\n2、`imx6ul-14x14-lanjut.dtsi` 文件：\n\n```bash command:(\"[root@localhost] #\":1)\nvim arch/arm/dts/imx6ul-14x14-lanjut.dtsi\n```\n\n在 `configs/mx6ull_14x14_lanjut_emmc_defconfig` 文件中，我们有屏蔽掉 `74LV594` 和 `软件模拟的 SPI` 的定义使用，因此在设备树操作这里同样把其相关的配置屏蔽掉，从它们的调用关系可以得到以下需要屏蔽：\n\n```text\n/ {\n\t// aliases {\n\t// \tspi5 = &{/spi4};\n\t// };\n\n\t// reg_can_3v3: regulator-can-3v3 {\n\t// \tcompatible = \"regulator-fixed\";\n\t// \tregulator-name = \"can-3v3\";\n\t// \tregulator-min-microvolt = <3300000>;\n\t// \tregulator-max-microvolt = <3300000>;\n\t// \tgpios = <&gpio_spi 3 GPIO_ACTIVE_LOW>;\n\t// };\n\n\t// spi4 {\n\t// \tcompatible = \"spi-gpio\";\n\t// \tpinctrl-names = \"default\";\n\t// \tpinctrl-0 = <&pinctrl_spi4>;\n\t// \tstatus = \"okay\";\n\t// \tpinctrl-assert-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;\n\t// \tgpio-sck = <&gpio5 11 0>;\n\t// \tgpio-mosi = <&gpio5 10 0>;\n\t// \tcs-gpios = <&gpio5 7 0>;\n\t// \tnum-chipselects = <1>;\n\t// \t#address-cells = <1>;\n\t// \t#size-cells = <0>;\n\n\t// \tgpio_spi: gpio@0 {\n\t// \t\tcompatible = \"fairchild,74hc595\";\n\t// \t\tgpio-controller;\n\t// \t\t#gpio-cells = <2>;\n\t// \t\treg = <0>;\n\t// \t\tregisters-number = <1>;\n\t// \t\tregisters-default = /bits/ 8 <0x57>;\n\t// \t\tspi-max-frequency = <100000>;\n\t// \t};\n\t// };\n};\n\n&can1 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_flexcan1>;\n\t// xceiver-supply = <&reg_can_3v3>;\n\tstatus = \"okay\";\n};\n\n&can2 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_flexcan2>;\n\t// xceiver-supply = <&reg_can_3v3>;\n\tstatus = \"okay\";\n};\n\n&iomuxc {\n\tpinctrl-names = \"default\";\n\n\t// pinctrl_spi4: spi4grp {\n\t// \tfsl,pins = <\n\t// \t\tMX6UL_PAD_BOOT_MODE0__GPIO5_IO10\t0x70a1\n\t// \t\tMX6UL_PAD_BOOT_MODE1__GPIO5_IO11\t0x70a1\n\t// \t\tMX6UL_PAD_SNVS_TAMPER7__GPIO5_IO07\t0x70a1\n\t// \t\tMX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08\t0x80000000\n\t// \t>;\n\t// };\n};\n```\n\n\n\n## 修改网络接口配置\n\n打开你的设备树文件 `arch/arm/dts/imx6ull-14x14-lanjut-emmc.dts` ，可以看到相应的引用关系：`imx6ull-14x14-lanjut-emmc.dts` -> `imx6ull-14x14-lanjut.dts` -> `imx6ull.dtsi` -> `imx6ul-14x14-lanjut.dtsi` -> `imx6ul-14x14-lanjut-u-boot.dtsi` 。而一般来说， `.dtsi` 是系列芯片的公共部分，如同 C 语言上的头文件一般， `.dts` 则用于定义特定部分；同样的，对于已经在 `.dtsi` 定义过的节点，可以在 `.dts` 中重新定义并覆盖。\n\n在 imx6ull 中，共提供了两组 ETH 网络接口引脚，在这里只需要配置一组就好了，多了没必要；可能你也会觉得 uboot 阶段只是为了引导 kernel 启动，何必多此一举呢，毕竟真正执行的配置是在 kernel 中的属性配置，但你是否想过后期如果需要修改 kernel，那么在此操作前，你能进行的 kernel 更新就只有 OTG 烧录及 SD Card 更新，并且需要拨码，相对于网络更新，稍微复杂一点，而且像 SD Card 你也未必携带有；因此，既然在 uboot 中存在一个如此便捷的升级方式，为何不好好应用起来呢？\n\n前面讲了 imx6ull 提供了两组 ETH 网络接口引脚，因此，只要有引出 ETH 接口，那么它们必定成组配置，所以无论你是用 `eth0` 或是 `eth1` 或想两组都用，在官方 demo 中一般都存在着对应组的设备树节点，可能唯一区别是 `eth0` 或 `eth1` 对应哪一组、PHY 地址不一样及网络芯片复位引脚所关联 GPIO 之类的；而且，对于用户设计来讲，一般都是跟官方的设计大同小异，没必要大改动以至于重新适配调试整个设备树配置及驱动修改，对此在这里以 `eth1`、PHY 地址为 0x01 为例：\n\n**1、查阅关联信息**\n\n翻看芯片参考手册，找到与网络相关的章节，可以看到官方主要命名为 ENET；接下来在设备树中，包括引用的设备树头文件 `.dtsi` 里面搜索 `enet` ，能找到名为 `&fecx` 的设备树节点，这些节点信息就是对网络接口的配置。\n\n**2、节点属性**\n\n网络设备树节点属性，在这里可以根据自己所使用的 uboot 版本日期，去 [https://www.devicetree.org/specifications](https://www.devicetree.org/specifications) 里找附近时期的文档查看；还有一种方式是在 `doc/device-tree-bindings/net/` 路径下查找相关的信息；不过不管是以上哪种方式，大部分也只是给出参考，实际需根据设备树函数处理来分析具体参数效果。\n\n**3、功能配置修改**\n\n在简单了解相关的信息后，然后就可以开始操刀修改配置了。\n\n```text\n...\n\n&fec1 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet1>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy0>;\n\tstatus = \"okay\";\n};\n\n&fec2 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet2>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy1>;\n\tstatus = \"okay\";\n\n\tmdio {\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t\tethphy0: ethernet-phy@2 {\n\t\t\treg = <2>;\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\n\t\tethphy1: ethernet-phy@1 {\n\t\t\treg = <1>;\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET2_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\t};\n};\n\n...\n```\n\n以上是相关的原有功能配置，然后 `eth0` 对应 `&fec1` 、 `eth1` 对应 `&fec2` ，在这里只应用 `eth1` ，因此在 `&fec1` 中把 `status` 参数改成 `disable` 以关闭该项功能；紧接着如果你的 PHY 芯片复位引脚是引接到芯片上控制而非复位按键上，那么你应该需要添加对 PHY 芯片复位的控制：\n\n```text\n&fec2 {\n\tpinctrl-names = \"default\";\n\tpinctrl-0 = <&pinctrl_enet2>;\n\tphy-mode = \"rmii\";\n\tphy-handle = <&ethphy1>;\n\tphy-reset-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;\n\tphy-reset-duration = <10>;\n\tphy-reset-post-delay = <10>;\n\tstatus = \"okay\";\n\n\t...\n};\n```\n\n在 `&fec2` 节点中，加入 `phy-reset-gpios` 参数指定 PHY 的复位引脚且说明低电平复位，`phy-reset-duration` 指定复位的持续时间，`phy-reset-post-delay` 指定复位延迟时间。\n\n在官方设备树里面，`eth0` 的 PHY 地址配置为 2、 `eth` 的 PHY 地址配置为 1，如果需要修改 PHY 地址，则可以在 `mdio` 里的 `ethphyx` 中的 `reg` 属性里更改为硬件设计上的 PHY 地址，然后为了统一标准，把 `ethernet-phy@x` 中 `@x` 的 `x` 改为 `reg` 上的数值（当然，你也可以选择不改，这并不会影响什么功能，只是设备树作为一份适合人类阅读的文本文件，影响到的是后期的阅读分析），在这里因为设计地址跟官方一样，`eth1` 的 PHY 地址为 1，因此不需要修改：\n\n```text\n&fec2 {\n\t...\n\n\tmdio {\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t\tethphy0: ethernet-phy@2 {\n\t\t\treg = <2>;\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\n\t\tethphy1: ethernet-phy@1 {\t// 标识 PHY 地址为 1\n\t\t\treg = <1>;\t// PHY 地址设置为 1\n\t\t\tmicrel,led-mode = <1>;\n\t\t\tclocks = <&clks IMX6UL_CLK_ENET2_REF>;\n\t\t\tclock-names = \"rmii-ref\";\n\t\t};\n\t};\n};\n```\n\n**4、复位引脚配置**\n\nA、配置分析\n\n```text\n...\n\n&iomuxc {\n\tpinctrl-names = \"default\";\n\n\t...\n\n\tpinctrl_enet1: enet1grp {\n\t\tfsl,pins = <\n\t\t\tMX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1\t0x4001b031\n\t\t>;\n\t};\n\n\tpinctrl_enet2: enet2grp {\n\t\tfsl,pins = <\n\t\t\tMX6UL_PAD_GPIO1_IO07__ENET2_MDC\t\t0x1b0b0\n\t\t\tMX6UL_PAD_GPIO1_IO06__ENET2_MDIO\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01\t0x1b0b0\n\t\t\tMX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2\t0x4001b031\n\t\t>;\n\t};\n\t\n\t...\n};\n\n...\n```\n\n在功能配置里为 `eth1` 的 PHY 芯片添加了复位引脚的操作，因此我们必须对其 IO 进行初始化配置；由于以下修改主要涉及到设备树的引脚配置，因此在修改前先了解一下该芯片设备树中引脚定义规则和解析：\n\n在手册上，一个引脚一般支持 n 个可选功能（Alternate 缩写为 ALT）， 通过 IOMUX Controller 的控制器进行选择，IOMUX Controller 由两个子模块组成：\n\n- IOMUXC_REGISTERS 包括所有的 IOMUXC 寄存器。\n- IOMUXC_LOGIC 包括所有的 IOMUXC 组合逻辑（IP 接口控制、地址解码器、可观察性互斥器）。\n\n而 IOMUXC_REGISTERS 主要通过两个寄存器进行引脚的配置（note：XXX 表示为某一个 PAD 的名称，eg：GPIO1_IO07）：\n\n- IOMUXC_SW_MUX_CTL_PAD_XXX：用于配置引脚 MUX 的输入功能，包括 UART，GPIO，CSI 等功能。\n\n  ![image-20240728182215737](image-20240728182215737.png)\n\n- IOMUXC_SW_PAD_CTL_PAD__XXX：用于配置具体功能的特性，包括上拉 / 下拉，速度，等特性。\n\n  ![image-20240728182843672](image-20240728182843672.png)\n\n在设备树上 imx6u 系列的引脚定义在 `arch/arm/dts/imx6ul-pinfunc.h` ，6ull 在此基础上追加 `imx6ull-pinfunc.h` 和 `imx6ull-pinfunc-snvs.h` 定义的扩展性功能引脚，而对于 GPIO1_IO07 的定义涵盖以下几项：\n\n```c\n#define MX6UL_PAD_GPIO1_IO07__ENET1_MDC\t\t\t0x0078 0x0304 0x0000 0 0\n#define MX6UL_PAD_GPIO1_IO07__ENET2_MDC\t\t\t0x0078 0x0304 0x0000 1 0\n#define MX6UL_PAD_GPIO1_IO07__USB_OTG_HOST_MODE\t\t0x0078 0x0304 0x0000 2 0\n#define MX6UL_PAD_GPIO1_IO07__CSI_PIXCLK\t\t0x0078 0x0304 0x0528 3 0\n#define MX6UL_PAD_GPIO1_IO07__USDHC2_CD_B\t\t0x0078 0x0304 0x0674 4 1\n#define MX6UL_PAD_GPIO1_IO07__GPIO1_IO07\t\t0x0078 0x0304 0x0000 5 0\n#define MX6UL_PAD_GPIO1_IO07__CCM_STOP\t\t\t0x0078 0x0304 0x0000 6 0\n#define MX6UL_PAD_GPIO1_IO07__UART1_DCE_RTS\t\t0x0078 0x0304 0x0620 8 1\n#define MX6UL_PAD_GPIO1_IO07__UART1_DTE_CTS\t\t0x0078 0x0304 0x0000 8 0\n```\n\n可以看到 MX6UL_PAD_GPIO1_IO07 是这个引脚的寄存器名称，后面 ENET1_MDC 部分则是对应这个引脚的可选功能（ALTn），然后所定义的参数有 4 个值，而这 4 个值可以在该头文件顶部看到说明：\n\n```c\n/*\n * The pin function ID is a tuple of\n * <mux_reg conf_reg input_reg mux_mode input_val>\n */\n```\n\n因此，像 `MX6UL_PAD_GPIO1_IO07__ENET2_MDC` 这个宏，其定义数值分别表示：\n\n- mux_reg：IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07 - 偏移地址 **0x0078**\n- conf_reg：IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO07 - 偏移地址 **0x0304**\n- input_reg：无寄存器（若有一般为 xxx_SELECT_INPUT） - 偏移地址 **0x0000**\n- mux_reg：IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07[3:0] - **1**（配置成 ALT0 - ENET2_MDC）\n- input_val：由 input_reg 决定是否存在，依据 mux_reg 选择复用 - **0**（无 input_reg，此处为 0）\n\n而对于在 `dts` 中的 `MX6UL_PAD_GPIO1_IO07__ENET2_MDC 0x1b0b0` 主要是对 conf_reg 的配置，即 IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO07 的值为 `0x1b0b0` 。这些数据的处理可以在 `drivers/pinctrl/nxp/pinctrl-imx.c` 中查到。至此，得到这样的一个配置关系：\n\n| mux_reg_ofs | conf_reg_ofs | input_reg_ofs | mux_mode | input_val | config_val |\n| :---------: | :----------: | :-----------: | :------: | :-------: | :--------: |\n|   0x0078    |    0x0304    |    0x0000     |    1     |     0     |  0x1b0b0   |\n\nB、追加配置\n\n在了解完如何配置后，然后来配置一个 `GPIO5_IO08` 引脚的复位操作，草鸡简单，在 `pinctrl_enet2` 节点上追加 `MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08` 引脚的配置：\n\n```text\n...\n\n&iomuxc {\n\tpinctrl-names = \"default\";\n\n\t...\n\n\tpinctrl_enet2: enet2grp {\n\t\tfsl,pins = <\n\t\t\t...\n\t\t\t\n\t\t\tMX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08\t0x898\t/* ENET2 NRST */\n\t\t>;\n\t};\n\t\n\t...\n};\n\n...\n```\n\n\n\n# uboot 裁剪\n\n不管是购买的板子还是自己设计的板子，基本都是参考半导体厂商的 demo 板，而半导体厂商会在他们自己的开发板上移植好 uboot、linux kernel 和 rootfs 等，最终制作好 BSP 包提供给用户。我们只需在官方提供的 BSP 包的基础上，修改适应于自己的板子的外设配置，也就是俗称的移植。\n\n一般对 uboot 的移植裁剪。只需要解决串口、NAND、EMMC 或 SD 卡、网络和 LCD 驱动，因为 uboot 的主要目的就是启动 Linux 内核，所以不需要考虑太多的外设驱动，剩下的交给 linux kernel 进行详细配置。\n\n如果以单片机思维来讲，Linux 的 uboot 类似于 bootloader ，因此，在 uboot 上不需要过多的配置，只需要确保能正常进入 linux kernel 即可，毕竟进入到 linux kernel 后将会重新根据 linux kernel 的配置再次初始化一遍。\n\n前面讲了，除非必要的外设，把其余的功能移除掉，这便是裁剪；因此像 IIC、SPI、USB 这些等都可以屏蔽掉（或者确认以存储介质启动把网络也禁掉都是可以的），以减少编译生成使得缩少文件大小。\n\n裁剪方式很简单：\n\n1、在 `configs/` 文件夹中，找到你的板子配置文件，eg： `mx6ull_14x14_lanjut_emmc_defconfig` 对不需要的功能进行屏蔽操作：\n\n```text\nCONFIG_ARM=y\nCONFIG_ARCH_MX6=y\nCONFIG_TARGET_MX6ULL_14X14_LANJUT=y\nCONFIG_ENV_SIZE=0x2000\nCONFIG_ENV_OFFSET=0xE0000\nCONFIG_DM_GPIO=y\nCONFIG_NR_DRAM_BANKS=1\nCONFIG_SYS_EXTRA_OPTIONS=\"IMX_CONFIG=board/freescale/mx6ull_lanjut/imximage.cfg\"\nCONFIG_BOOTDELAY=1\n# CONFIG_CONSOLE_MUX is not set\nCONFIG_SYS_CONSOLE_IS_IN_ENV=y\nCONFIG_SUPPORT_RAW_INITRD=y\nCONFIG_BOUNCE_BUFFER=y\nCONFIG_BOARD_EARLY_INIT_F=y\nCONFIG_HUSH_PARSER=y\nCONFIG_CMD_BOOTZ=y\n# CONFIG_CMD_IMLS is not set\nCONFIG_CMD_MEMTEST=y\n# CONFIG_CMD_GPIO=y\n# CONFIG_CMD_I2C=y\nCONFIG_CMD_MMC=y\n# CONFIG_CMD_SF=y\n# CONFIG_CMD_USB=y\n# CONFIG_CMD_DHCP=y\nCONFIG_CMD_PING=y\n# CONFIG_CMD_BMP=y\nCONFIG_CMD_CACHE=y\nCONFIG_CMD_NET=y\n# CONFIG_CMD_EXT2=y\nCONFIG_CMD_EXT4=y\nCONFIG_CMD_EXT4_WRITE=y\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_OF_CONTROL=y\nCONFIG_DEFAULT_DEVICE_TREE=\"imx6ull-14x14-lanjut-emmc\"\nCONFIG_ENV_IS_IN_MMC=y\nCONFIG_SYS_RELOC_GD_ENV_ADDR=y\nCONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y\nCONFIG_NET_RANDOM_ETHADDR=y\n\n# CONFIG_DM_74X164 is not used\n# CONFIG_DM_I2C=y\nCONFIG_DM_MMC=y\nCONFIG_FSL_USDHC=y\nCONFIG_MTD=y\n# CONFIG_DM_SPI_FLASH=y\n# CONFIG_SF_DEFAULT_MODE=0\n# CONFIG_SF_DEFAULT_SPEED=40000000\n# CONFIG_SPI_FLASH_STMICRO=y\nCONFIG_PHYLIB=y\n# CONFIG_PHY_MICREL=y\n# CONFIG_PHY_MICREL_KSZ8XXX=y\nCONFIG_DM_ETH=y\nCONFIG_DM_ETH_PHY=y\nCONFIG_FEC_MXC=y\nCONFIG_MII=y\nCONFIG_PINCTRL=y\nCONFIG_PINCTRL_IMX6=y\nCONFIG_DM_REGULATOR=y\nCONFIG_DM_REGULATOR_FIXED=y\nCONFIG_DM_REGULATOR_GPIO=y\n# CONFIG_SPI=y\n# CONFIG_DM_SPI=y\n# CONFIG_SOFT_SPI is not used\n# CONFIG_FSL_QSPI=y\n# CONFIG_USB=y\n# CONFIG_DM_USB=y\n# CONFIG_USB_STORAGE=y\n# CONFIG_USB_HOST_ETHER=y\n# CONFIG_USB_ETHER_ASIX=y\n# CONFIG_DM_VIDEO=y\nCONFIG_SYS_WHITE_ON_BLACK=y\n\n# CONFIG_USB_GADGET=y\n# CONFIG_USB_GADGET_DOWNLOAD=y\n# CONFIG_USB_GADGET_MANUFACTURER=\"FSL\"\n# CONFIG_USB_GADGET_VENDOR_NUM=0x0525\n# CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5\n# CONFIG_CI_UDC=y\n\n# CONFIG_CMD_FASTBOOT=y\n# CONFIG_USB_FUNCTION_FASTBOOT=y\n# CONFIG_FASTBOOT_UUU_SUPPORT=y\n# CONFIG_FASTBOOT=y\n# CONFIG_FASTBOOT_BUF_ADDR=0x83800000\n# CONFIG_FASTBOOT_BUF_SIZE=0x40000000\n# CONFIG_FASTBOOT_FLASH=y\n# CONFIG_EFI_PARTITION=y\n\n```\n\n以上操作主要是裁切不需要的命令行、USB 操作、IIC 功能、SPI 功能、video  功能；当然你也可以通过先 `make xxx_defconfig` 生成 `.config` 文件，然后进行 `make meunconfig` 进入图型交互界面，对不需要的配置进行移除，在这里修改的目的是为了通过执行 `make xxx_defconfig` 后生成的默认 `.config` 文件即为裁剪好的配置，而不需要再进行 `make meunconfig` 选择移除。\n\n2、修改单板配置文件，eg： `include/configs/mx6ull_lanjut.h` ；该文件主要是配置 uboot env 环境及启动初始化。\n\n```c\n/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Copyright (C) 2016 Freescale Semiconductor, Inc.\n * Copyright 2017 NXP\n *\n * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.\n */\n#ifndef __MX6ULL_LANJUT_CONFIG_H\n#define __MX6ULL_LANJUT_CONFIG_H\n\n\n#include <asm/arch/imx-regs.h>\n#include <linux/sizes.h>\n#include \"mx6_common.h\"\n#include <asm/mach-imx/gpio.h>\n#include \"imx_env.h\"\n\n#define is_mx6ull_9x9_evk()\tCONFIG_IS_ENABLED(TARGET_MX6ULL_9X9_EVK)\n\n#ifdef CONFIG_TARGET_MX6ULL_9X9_EVK\n#define PHYS_SDRAM_SIZE\t\tSZ_256M\n#define BOOTARGS_CMA_SIZE   \"cma=96M \"\n#else\n#define PHYS_SDRAM_SIZE\t\tSZ_512M\n#define BOOTARGS_CMA_SIZE   \"\"\n/* DCDC used on 14x14 EVK, no PMIC */\n#undef CONFIG_LDO_BYPASS_CHECK\n#endif\n\n/* Size of malloc() pool */\n#define CONFIG_SYS_MALLOC_LEN\t\t(16 * SZ_1M)\n\n#define CONFIG_MXC_UART\n#define CONFIG_MXC_UART_BASE\t\tUART1_BASE\n\n/* MMC Configs */\n#ifdef CONFIG_FSL_USDHC\n#define CONFIG_SYS_FSL_ESDHC_ADDR\tUSDHC2_BASE_ADDR\n\n/* NAND pin conflicts with usdhc2 */\n#ifdef CONFIG_NAND_MXS\n#define CONFIG_SYS_FSL_USDHC_NUM\t1\n#else\n#define CONFIG_SYS_FSL_USDHC_NUM\t2\n#endif\n#endif\n\n/* I2C configs */\n#ifdef CONFIG_CMD_I2C\n#define CONFIG_SYS_I2C_MXC\n#define CONFIG_SYS_I2C_MXC_I2C1\t\t/* enable I2C bus 1 */\n#define CONFIG_SYS_I2C_MXC_I2C2\t\t/* enable I2C bus 2 */\n#define CONFIG_SYS_I2C_SPEED\t\t100000\n#endif\n\n#define CONFIG_SYS_MMC_IMG_LOAD_PART\t1\n\n#ifdef CONFIG_NAND_BOOT\n#define MFG_NAND_PARTITION \"mtdparts=gpmi-nand:64m(nandboot),16m(nandkernel),16m(nanddtb),16m(nandtee),-(nandrootfs)\"\n#else\n#define MFG_NAND_PARTITION \"\"\n#endif\n\n#define CONFIG_CMD_READ\n#define CONFIG_SERIAL_TAG\n#define CONFIG_FASTBOOT_USB_DEV 0\n\n#define CONFIG_MFG_ENV_SETTINGS \\\n\tCONFIG_MFG_ENV_SETTINGS_DEFAULT \\\n\t\"initrd_addr=0x86800000\\0\" \\\n\t\"initrd_high=0xffffffff\\0\" \\\n\t\"emmc_dev=1\\0\"\\\n\t\"emmc_ack=1\\0\"\\\n\t\"sd_dev=1\\0\" \\\n\t\"mtdparts=\" MFG_NAND_PARTITION \\\n\t\"\\0\"\\\n\n#if defined(CONFIG_NAND_BOOT)\n#define CONFIG_EXTRA_ENV_SETTINGS \\\n\tCONFIG_MFG_ENV_SETTINGS \\\n\tTEE_ENV \\\n\t\"splashimage=0x8c000000\\0\" \\\n\t\"fdt_addr=0x83000000\\0\" \\\n\t\"fdt_high=0xffffffff\\0\"\t  \\\n\t\"tee_addr=0x84000000\\0\" \\\n\t\"console=ttymxc0\\0\" \\\n\t\"bootargs=console=ttymxc0,115200 ubi.mtd=nandrootfs \"  \\\n\t\t\"root=ubi0:rootfs rootfstype=ubifs \"\t\t     \\\n\t\tBOOTARGS_CMA_SIZE \\\n\t\tMFG_NAND_PARTITION \\\n\t\t\"\\0\" \\\n\t\"bootcmd=nand read ${loadaddr} 0x4000000 0xc00000;\"\\\n\t\t\"nand read ${fdt_addr} 0x5000000 0x100000;\"\\\n\t\t\"if test ${tee} = yes; then \" \\\n\t\t\t\"nand read ${tee_addr} 0x6000000 0x400000;\"\\\n\t\t\t\"bootm ${tee_addr} - ${fdt_addr};\" \\\n\t\t\"else \" \\\n\t\t\t\"bootz ${loadaddr} - ${fdt_addr};\" \\\n\t\t\"fi\\0\"\n\n#else\n#define CONFIG_EXTRA_ENV_SETTINGS \\\n\tCONFIG_MFG_ENV_SETTINGS \\\n\tTEE_ENV \\\n\t\"script=boot.scr\\0\" \\\n\t\"image=zImage\\0\" \\\n\t\"console=ttymxc0\\0\" \\\n\t\"fdt_high=0xffffffff\\0\" \\\n\t\"initrd_high=0xffffffff\\0\" \\\n\t\"fdt_file=undefined\\0\" \\\n\t\"fdt_addr=0x83000000\\0\" \\\n\t\"tee_addr=0x84000000\\0\" \\\n\t\"tee_file=undefined\\0\" \\\n\t\"boot_fdt=try\\0\" \\\n\t\"ip_dyn=no\\0\" \\\n\t\"splashimage=0x8c000000\\0\" \\\n\t\"mmcdev=\"__stringify(CONFIG_SYS_MMC_ENV_DEV)\"\\0\" \\\n\t\"mmcpart=\" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) \"\\0\" \\\n\t\"mmcroot=\" CONFIG_MMCROOT \" rootwait rw\\0\" \\\n\t\"mmcautodetect=yes\\0\" \\\n\t\"mmcargs=setenv bootargs console=${console},${baudrate} \" \\\n\t\tBOOTARGS_CMA_SIZE \\\n\t\t\"root=${mmcroot}\\0\" \\\n\t\"loadbootscript=\" \\\n\t\t\"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\\0\" \\\n\t\"bootscript=echo Running bootscript from mmc ...; \" \\\n\t\t\"source\\0\" \\\n\t\"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\\0\" \\\n\t\"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\\0\" \\\n\t\"loadtee=fatload mmc ${mmcdev}:${mmcpart} ${tee_addr} ${tee_file}\\0\" \\\n\t\"mmcboot=echo Booting from mmc ...; \" \\\n\t\t\"run mmcargs; \" \\\n\t\t\"if test ${tee} = yes; then \" \\\n\t\t\t\"run loadfdt; run loadtee; bootm ${tee_addr} - ${fdt_addr}; \" \\\n\t\t\"else \" \\\n\t\t\t\"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then \" \\\n\t\t\t\t\"if run loadfdt; then \" \\\n\t\t\t\t\t\"bootz ${loadaddr} - ${fdt_addr}; \" \\\n\t\t\t\t\"else \" \\\n\t\t\t\t\t\"if test ${boot_fdt} = try; then \" \\\n\t\t\t\t\t\t\"bootz; \" \\\n\t\t\t\t\t\"else \" \\\n\t\t\t\t\t\t\"echo WARN: Cannot load the DT; \" \\\n\t\t\t\t\t\"fi; \" \\\n\t\t\t\t\"fi; \" \\\n\t\t\t\"else \" \\\n\t\t\t\t\"bootz; \" \\\n\t\t\t\"fi; \" \\\n\t\t\"fi;\\0\" \\\n\t\"netargs=setenv bootargs console=${console},${baudrate} \" \\\n\t\tBOOTARGS_CMA_SIZE \\\n\t\t\"root=/dev/nfs \" \\\n\t\t\"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\\0\" \\\n\t\"netboot=echo Booting from net ...; \" \\\n\t\t\"${usb_net_cmd}; \" \\\n\t\t\"run netargs; \" \\\n\t\t\"if test ${ip_dyn} = yes; then \" \\\n\t\t\t\"setenv get_cmd dhcp; \" \\\n\t\t\"else \" \\\n\t\t\t\"setenv get_cmd tftp; \" \\\n\t\t\"fi; \" \\\n\t\t\"${get_cmd} ${image}; \" \\\n\t\t\"if test ${tee} = yes; then \" \\\n\t\t\t\"${get_cmd} ${tee_addr} ${tee_file}; \" \\\n\t\t\t\"${get_cmd} ${fdt_addr} ${fdt_file}; \" \\\n\t\t\t\"bootm ${tee_addr} - ${fdt_addr}; \" \\\n\t\t\"else \" \\\n\t\t\t\"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then \" \\\n\t\t\t\t\"if ${get_cmd} ${fdt_addr} ${fdt_file}; then \" \\\n\t\t\t\t\t\"bootz ${loadaddr} - ${fdt_addr}; \" \\\n\t\t\t\t\"else \" \\\n\t\t\t\t\t\"if test ${boot_fdt} = try; then \" \\\n\t\t\t\t\t\t\"bootz; \" \\\n\t\t\t\t\t\"else \" \\\n\t\t\t\t\t\t\"echo WARN: Cannot load the DT; \" \\\n\t\t\t\t\t\"fi; \" \\\n\t\t\t\t\"fi; \" \\\n\t\t\t\"else \" \\\n\t\t\t\t\"bootz; \" \\\n\t\t\t\"fi; \" \\\n\t\t\"fi;\\0\" \\\n\t\t\"findfdt=\"\\\n\t\t\t\"if test $fdt_file = undefined; then \" \\\n\t\t\t\t\"if test $board_name = ULZ-EVK && test $board_rev = 14X14; then \" \\\n\t\t\t\t\t\"setenv fdt_file imx6ulz-14x14-evk.dtb; fi; \" \\\n\t\t\t\t\"if test $board_name = EVK && test $board_rev = 9X9; then \" \\\n\t\t\t\t\t\"setenv fdt_file imx6ull-9x9-evk.dtb; fi; \" \\\n\t\t\t\t\"if test $board_name = EVK && test $board_rev = 14X14; then \" \\\n\t\t\t\t\t\"setenv fdt_file imx6ull-14x14-evk.dtb; fi; \" \\\n\t\t\t\t\"if test $board_name = LANJUT && test $board_rev = 14X14; then \" \\\n\t\t\t\t\t\"setenv fdt_file imx6ull-14x14-lanjut.dtb; fi; \" \\\n\t\t\t\t\"if test $fdt_file = undefined; then \" \\\n\t\t\t\t\t\"echo WARNING: Could not determine dtb to use; \" \\\n\t\t\t\t\"fi; \" \\\n\t\t\t\"fi;\\0\" \\\n\t\t\"findtee=\"\\\n\t\t\t\"if test $tee_file = undefined; then \" \\\n\t\t\t\t\"if test $board_name = ULZ-EVK && test $board_rev = 14X14; then \" \\\n\t\t\t\t\t\"setenv tee_file uTee-6ulzevk; fi; \" \\\n\t\t\t\t\"if test $board_name = EVK && test $board_rev = 9X9; then \" \\\n\t\t\t\t\t\"setenv tee_file uTee-6ullevk; fi; \" \\\n\t\t\t\t\"if test $board_name = EVK && test $board_rev = 14X14; then \" \\\n\t\t\t\t\t\"setenv tee_file uTee-6ullevk; fi; \" \\\n\t\t\t\t\"if test $board_name = LANJUT && test $board_rev = 14X14; then \" \\\n\t\t\t\t\t\"setenv tee_file uTee-6ull_lanjut; fi; \" \\\n\t\t\t\t\"if test $tee_file = undefined; then \" \\\n\t\t\t\t\t\"echo WARNING: Could not determine tee to use; \" \\\n\t\t\t\t\"fi; \" \\\n\t\t\t\"fi;\\0\" \\\n\n#define CONFIG_BOOTCOMMAND \\\n\t   \"run findfdt;\" \\\n\t   \"run findtee;\" \\\n\t   \"mmc dev ${mmcdev};\" \\\n\t   \"mmc dev ${mmcdev}; if mmc rescan; then \" \\\n\t\t   \"if run loadbootscript; then \" \\\n\t\t\t   \"run bootscript; \" \\\n\t\t   \"else \" \\\n\t\t\t   \"if run loadimage; then \" \\\n\t\t\t\t   \"run mmcboot; \" \\\n\t\t\t   \"else run netboot; \" \\\n\t\t\t   \"fi; \" \\\n\t\t   \"fi; \" \\\n\t   \"else run netboot; fi\"\n#endif\n\n/* Miscellaneous configurable options */\n#define CONFIG_SYS_MEMTEST_START\t0x80000000\n#define CONFIG_SYS_MEMTEST_END\t\t(CONFIG_SYS_MEMTEST_START + 0x8000000)\n\n#define CONFIG_SYS_LOAD_ADDR\t\tCONFIG_LOADADDR\n#define CONFIG_SYS_HZ\t\t\t1000\n\n/* Physical Memory Map */\n#define PHYS_SDRAM\t\t\tMMDC0_ARB_BASE_ADDR\n\n#define CONFIG_SYS_SDRAM_BASE\t\tPHYS_SDRAM\n#define CONFIG_SYS_INIT_RAM_ADDR\tIRAM_BASE_ADDR\n#define CONFIG_SYS_INIT_RAM_SIZE\tIRAM_SIZE\n\n#define CONFIG_SYS_INIT_SP_OFFSET \\\n\t(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)\n#define CONFIG_SYS_INIT_SP_ADDR \\\n\t(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)\n\n/* environment organization */\n#define CONFIG_SYS_MMC_ENV_DEV\t\t1\t/* USDHC2 */\n#define CONFIG_SYS_MMC_ENV_PART\t\t0\t/* user area */\n#define CONFIG_MMCROOT\t\t\t\"/dev/mmcblk1p2\"  /* USDHC2 */\n\n#define CONFIG_IOMUX_LPSR\n\n#ifdef CONFIG_FSL_QSPI\n#define CONFIG_SYS_FSL_QSPI_AHB\n#define FSL_QSPI_FLASH_NUM\t\t1\n#define FSL_QSPI_FLASH_SIZE\t\tSZ_32M\n#endif\n\n/* NAND stuff */\n#ifdef CONFIG_NAND_MXS\n#define CONFIG_SYS_MAX_NAND_DEVICE\t1\n#define CONFIG_SYS_NAND_BASE\t\t0x40000000\n#define CONFIG_SYS_NAND_5_ADDR_CYCLE\n#define CONFIG_SYS_NAND_ONFI_DETECTION\n#define CONFIG_SYS_NAND_USE_FLASH_BBT\n\n/* DMA stuff, needed for GPMI/MXS NAND support */\n#endif\n\n#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)\n#define CONFIG_ENV_SPI_BUS\t\tCONFIG_SF_DEFAULT_BUS\n#define CONFIG_ENV_SPI_CS\t\tCONFIG_SF_DEFAULT_CS\n#define CONFIG_ENV_SPI_MODE\t\tCONFIG_SF_DEFAULT_MODE\n#define CONFIG_ENV_SPI_MAX_HZ\t\tCONFIG_SF_DEFAULT_SPEED\n#endif\n\n/* USB Configs */\n#ifdef CONFIG_CMD_USB\n#define CONFIG_EHCI_HCD_INIT_AFTER_RESET\n#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)\n#define CONFIG_MXC_USB_FLAGS   0\n#define CONFIG_USB_MAX_CONTROLLER_COUNT 2\n#endif\n\n#define CONFIG_FEC_XCV_TYPE             RMII\n#define CONFIG_ETHPRIME\t\t\t\"eth1\"\n\n#define CONFIG_IMX_THERMAL\n\n#ifndef CONFIG_SPL_BUILD\n#if defined(CONFIG_DM_VIDEO)\n#define CONFIG_VIDEO_MXS\n#define CONFIG_VIDEO_LINK\n#define CONFIG_VIDEO_LOGO\n#define CONFIG_SPLASH_SCREEN\n#define CONFIG_SPLASH_SCREEN_ALIGN\n#define CONFIG_BMP_16BPP\n#define CONFIG_VIDEO_BMP_RLE8\n#define CONFIG_VIDEO_BMP_LOGO\n#endif\n#endif\n\n#define CONFIG_MODULE_FUSE\n#define CONFIG_OF_SYSTEM_SETUP\n\n/* Network Configs */\n#define CONFIG_IPADDR          192.168.137.234      /* board ip */\n#define CONFIG_SERVERIP     192.168.137.1      /* server ip */\n#define CONFIG_GATEWAYIP    192.168.137.1        /* board gateway ip */\n#define CONFIG_NETMASK      255.255.255.0       /* board netmask */\n\n#endif\n\n```\n\n以上添加了网络信息配置，因为在 `mx6ull_14x14_lanjut_emmc_defconfig` 中，我们有移除 DHCP 命令操作，因此如果使用到网络，那么必然需要配置静态网络 `setenv ipaddr` 这些，而在这里我们直接先配置好默认 ip（即 `/* Network Configs */` 下的操作）。同样，在这里可以找到与 NAND、IIC、SPI、VIDEO 这些不需要的功能，部分通过 `#ifdef` 宏来启用，那么如果在 `mx6ull_14x14_lanjut_emmc_defconfig` 中有屏蔽相应的宏则不要处理，否则对于一些没有在 `mx6ull_14x14_lanjut_emmc_defconfig` 中出现的并且想要裁切的功能，可以直接屏蔽对应的宏（例如是对 `board/freescale/mx6ull_lanjut/mx6ull_lanjut.c` 中的操作选择）。\n\n\n\n# 添加编译脚本\n\n```bash command:(\"[root@localhost] #\":1-2)\ntouch build.sh\nvim build.sh\n```\n\n**写入：**\n\n```bash\n#!/bin/bash\n\n# 若之前已经导入到环境变量则不需要\nexport PATH=$PATH:/usr/local/arm/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport ARCH=arm\n# 若已经在顶层 Makefile 文件中指定则不需要\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\n\nexport LCPU=`grep -c processor /proc/cpuinfo`\n\nmake clean\n\nmake mx6ull_14x14_lanjut_emmc_defconfig\n\nmake -j${LCPU}\n```\n\n\n\n# 附\n\nuboot 文件结构：\n\n|  类型  |    名称     |             说明             |\n| :----: | :---------: | :--------------------------: |\n| 文件夹 |     api     |     通用的 API 函数相关      |\n|   ^^   |    arch     |        与芯片架构相关        |\n|   ^^   |    board    |         板级相关信息         |\n|   ^^   |     cmd     |        uboot 命令相关        |\n|   ^^   |   common    |           通用代码           |\n|   ^^   |   configs   |        uboot 配置内容        |\n|   ^^   |    disk     |           磁盘相关           |\n|   ^^   |     doc     |          各说明文档          |\n|   ^^   |   drivers   |         驱动代码相关         |\n|   ^^   |     dts     |          设备树相关          |\n|   ^^   |     env     |        uboot 环境相关        |\n|   ^^   |  examples   |           示例代码           |\n|   ^^   |     fs      |         文件系统相关         |\n|   ^^   |   include   |          头文件相关          |\n|   ^^   |     lib     |          lib 库文件          |\n|   ^^   |  Licenses   |          许可证相关          |\n|   ^^   |     net     |           网络相关           |\n|   ^^   |    post     |         上电自检相关         |\n|   ^^   |   scripts   |           相关脚本           |\n|   ^^   |    test     |           测试代码           |\n|   ^^   |    tools    |      uboot 构建工具相关      |\n|  文件  |  config.mk  | 某个 Makefile 需要调用此文件 |\n|   ^^   |   Kbuild    |    用于生成汇编相关的文件    |\n|   ^^   |   Kconfig   |     图形配置界面相关文件     |\n|   ^^   | MAINTAINERS |        开发及维护记录        |\n|   ^^   |  Makefile   |       主 Makefile 脚本       |\n|   ^^   |   README    |           工程说明           |\n\n","tags":["Linux","arm_linux","imx6ull"]},{"title":"mfgtool 工具烧写使用","url":"/mfgtool-is-used/","content":"\n\n\n> 这里以基于 IMX6_L4.1.15_2.1.0_MFG_TOOL 修改后的文件为说明，官方下载可以去 NXP 官网直接搜。\n\n\n\n# mfgtool 工具\n\nmfgtool 工具是 freescale 为 i.MX 系列处理器打造的 Linux Firmware(uboot/kernel) 烧录工具，被收购后由 NXP 维护，其工具支持单独烧录某一系统分区，支持烧录 spi flash、 nor flash、sd card、nand flash、emmc等存储介质，只需简单的配置，即可将编译好的镜像文件和文件系统烧录到完整的板上。同时 mfgtool 工具也作为一个可量产性的工具，它支持多通道的烧录。\n\n最新版的 mfgtool 工具可看：https://github.com/nxp-imx/mfgtools\n\n对于官方 L4.1.15_2.1.0 版本，解压后里面有两个压缩包，两个压缩包的区别在名字上已经写的很详细了。 “without-rootfs” 和 “with-rootfs”，一个是没有文件系统和一个是具有文件系统，对比可以看到 without-rootfs 中的 rootfs 是个空的包。\n\n\n\n# 配置文件\n\n在该版本中，主要用到的配置 UICfg.ini、cfg.ini 以及 ucl2.xml。\n\n## UICfg.ini\n\nUICfg.ini 文件用于配置端口数量，表示同时支持多少个单板。\n\nUICfg.ini 文件的格式如下：\n\n```ini\n[UICfg]\nPortMgrDlg=1\n```\n\n例如，如果一次只支持一个单板，则应该设置 `PortMgrDlg=1`。目前最多支持 4 块单板，所以 `PortMgrDlg` 可以设置为 1 - 4，默认为 1。\n\n## cfg.ini\n\ncfg.ini 文件用于配置目标芯片配置文件和目标操作列表。\n\n该文件的格式如下所示：\n\n```ini\n[profiles]\nchip = Linux\n\n[platform]\nboard = SabreSD\n\n[LIST]\nname = SDCard\n\n[variable]\nboard = sabresd\nmmc = 0\nbootimx = 14x14evk\nbootdtb = 14x14-evk\n6uluboot = 14x14ddr3arm2\n6uldtb = 14x14-ddr3-arm2\nlite = l\ninitramfs = fsl-image-mfgtool-initramfs-imx_mfgtools.cpio.gz.u-boot\nseek = 1\nrootfs = rootfs\n6ulnor = qspi1\npart_nor = 0\npart_uboot = 0\npart_kernel = 1\npart_dtb = 2\npart_rootfs = 3\n```\n\n- `profiles/chip` 为目标配置文件名称（不区分大小写）。\n\n- `LIST/name` 为目标操作列表名称（区分大小写），可在 `profiles/CHIP_PROFILE/OS Firmware/ucl2.xml` 文件中找到。`ucl2.xml` 内容在后续说明。\n\n- `platform/board` 目前预留，未使用，请忽略。\n\n- `variable` 为 `ucl2.xml` 文件中的引用变量，其引用的方式为 `%…%`。\n\n## ucl2.xml\n\n以下为个人自用修改后的版本，适用于 6UL 和 6ULL：\n\n```xml\n<!--\n* Copyright (C) 2012, Freescale Semiconductor, Inc. All Rights Reserved.\n* The CFG element contains a list of recognized usb devices.\n*  DEV elements provide a name, class, vid and pid for each device.\n*\n* Each LIST element contains a list of update instructions.\n*  \"Install\" - Erase media and install firmware.\n*  \"Update\" - Update firmware only.\n*\n* Each CMD element contains one update instruction of attribute type.\n*  \"pull\" - Does UtpRead(body, file) transaction.\n*  \"push\" - Does UtpWrite(body, file) transaction.\n*  \"drop\" - Does UtpCommand(body) then waits for device to disconnect.\n*  \"boot\" - Finds configured device, forces it to \"body\" device and downloads \"file\".\n*  \"find\" - Waits for \"timeout\" seconds for the \"body\" device to connect.\n*  \"show\" - Parse and show device info in \"file\".  \n-->\n\n\n<UCL>\n  <CFG>\n    <STATE name=\"BootStrap\" dev=\"MX6UL\" vid=\"15A2\" pid=\"007D\"/>\n    <STATE name=\"BootStrap\" dev=\"MX6ULL\" vid=\"15A2\" pid=\"0080\"/>\n    <STATE name=\"Updater\"   dev=\"MSC\" vid=\"066F\" pid=\"37FF\"/>\n  </CFG>\n\n  \n\n  <LIST name=\"eMMC\" desc=\"Choose eMMC as media\">\n\t<CMD state=\"BootStrap\" type=\"boot\" body=\"BootStrap\" file =\"firmware/u-boot-imx6ul%lite%%bootimx%_emmc.imx\" ifdev=\"MX6UL MX6ULL\">Loading U-boot</CMD>\n\t\t\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage\" address=\"0x80800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Kernel.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/%initramfs%\" address=\"0x83800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Initramfs.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage-imx6ul%lite%-%bootdtb%-emmc.dtb\" address=\"0x83000000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading device tree.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"jump\" > Jumping to OS image. </CMD>\n\n\n\t<!-- create partition -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"mksdcard.sh.tar\">Sending partition shell</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ tar xf $FILE \"> Partitioning...</CMD>\n\t<!-- 使用 mksdcard.sh 脚本为设备 \"/dev/mmcblk%mmc%\" 创建分区 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ sh mksdcard.sh /dev/mmcblk%mmc%\"> Partitioning...</CMD>\n\n\t<!-- burn uboot -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ while [ ! -e /dev/mmcblk%mmc% ]; do sleep 1; echo \\\"waiting...\\\"; done \">Waiting for the partition ready</CMD>\n\t<!-- 清除 uboot env, 总大小 8*1K，并且跳过了前面 768 blocks, 这里是 User Data Area（UDA） 区域，并不是 Boot Area Patition（boot） 区域 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ dd if=/dev/zero of=/dev/mmcblk%mmc% bs=1k seek=768 conv=fsync count=8\">clear u-boot arg</CMD>\n\t<!-- access boot partition -->\n\t<!-- 使 emmc 的 boot0 分区变为可读写 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ echo 0 > /sys/block/mmcblk%mmc%boot0/force_ro\">access boot partition 1</CMD>\n\t<!-- 将 uboot 烧录到 emmc 的 boot0 分区，在系统盘符里分区的序号是从 0 开始，也就是 boot0 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/u-boot-imx6ul%lite%%6uluboot%_emmc%board%.imx\" ifdev=\"MX6UL MX6ULL\">Sending u-boot.bin</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ dd if=$FILE of=/dev/mmcblk%mmc%boot0 bs=512 seek=2\">write U-Boot to sd card</CMD>\n\t<!-- 使 emmc 的 boot0 分区变为只读 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ echo 1 > /sys/block/mmcblk%mmc%boot0/force_ro\"> re-enable read-only access </CMD>\n\t<!-- 将 boot0 分区使能，那么启动的时候就会从 emmc 的 boot1 区域启动。\n\temmc boot 序号是从 1 开始的，这里的 enable 1 指的是选择 emmc boot 分区的第一个分区进行引导，是针对 emmc 的 PARTITION_CONFIG 寄存器而言的。\n\t而上面的 /sys/block/mmcblk%mmc%boot0 指是针对 linux 系统而言的，其实指的都是统一个分区，就是 emmc boot 的最开始的分区。 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mmc bootpart enable 1 1 /dev/mmcblk%mmc%\">enable boot partion 1 to boot</CMD>\n\n\t<!-- create fat partition -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ while [ ! -e /dev/mmcblk%mmc%p1 ]; do sleep 1; echo \\\"waiting...\\\"; done \">Waiting for the partition ready</CMD>\n\t<!-- 对 /dev/mmcblk%mmc%p1 分区 1 进行格式化 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mkfs.vfat -F 32 /dev/mmcblk%mmc%p1\">Formatting rootfs partition</CMD>\n\t<!-- 挂载 /dev/mmcblk%mmc%p1 分区 1 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mkdir -p /mnt/mmcblk%mmc%p1\"/>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mount -t vfat /dev/mmcblk%mmc%p1 /mnt/mmcblk%mmc%p1\"/>\n\n\t<!-- burn kernel -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/zImage\">Sending kernel zImage</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ cp $FILE /mnt/mmcblk%mmc%p1/zImage\">write kernel image to sd card</CMD>\n\n\t<!-- burn dtb -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/zImage-imx6ul%lite%-%6uldtb%%board%-emmc.dtb\" ifdev=\"MX6UL MX6ULL\">Sending Device Tree file</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ cp $FILE /mnt/mmcblk%mmc%p1/imx6ul%lite%-%6uldtb%%board%.dtb\" ifdev=\"MX6UL MX6ULL\">write device tree to sd card</CMD>\n\n\t<!-- 取消对 /dev/mmcblk%mmc%p1 分区的挂载 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ umount /mnt/mmcblk%mmc%p1\">Unmounting fat partition</CMD>\n\n\t<!-- create rootfs partition -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ while [ ! -e /dev/mmcblk%mmc%p2 ]; do sleep 1; echo \\\"waiting...\\\"; done \">Waiting for the partition ready</CMD>\n\t<!-- 对 /dev/mmcblk%mmc%p2 分区 2 进行格式化 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mkfs.ext3 -F -E nodiscard /dev/mmcblk%mmc%p2\">Formatting rootfs partition</CMD>\n\t<!-- 挂载 /dev/mmcblk%mmc%p2 分区 2 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mkdir -p /mnt/mmcblk%mmc%p2\"/>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mount -t ext3 /dev/mmcblk%mmc%p2 /mnt/mmcblk%mmc%p2\"/>\n\n\t<!-- burn rootfs -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"pipe tar -jxv -C /mnt/mmcblk%mmc%p2\" file=\"files/%rootfs%.tar.bz2\" ifdev=\"MX6UL MX6ULL\">Sending and writting rootfs</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"frf\">Finishing rootfs write</CMD>\n\n\t<!-- 取消对 /dev/mmcblk%mmc%p2 分区的挂载 -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ umount /mnt/mmcblk%mmc%p2\">Unmounting rootfs partition</CMD>\n\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ echo Update Complete!\">Done</CMD>\n  </LIST>\n\n\n\n  <!-- burn uboot only because spi-nor flash is small (4M). kernel is beyond 5M now -->\n  <LIST name=\"Nor Flash\" desc=\"Choose Nor flash as media\">\n\t<CMD state=\"BootStrap\" type=\"boot\" body=\"BootStrap\" file =\"firmware/u-boot-imx6ul%lite%%bootimx%_sd.imx\" ifdev=\"MX6UL MX6ULL\">Loading U-boot</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage\" address=\"0x80800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Kernel.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/%initramfs%\" address=\"0x83800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Initramfs.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage-imx6ul%lite%-%bootdtb%.dtb\" address=\"0x83000000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading device tree.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"jump\" > Jumping to OS image. </CMD>\n\n\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ flash_erase /dev/mtd%part_nor% 0 0\">Erasing Boot partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/u-boot-imx6ul%lite%%6uluboot%_%nor%.imx\" ifdev=\"MX6UL MX6ULL\">Sending u-boot.bin</CMD>\n\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ dd if=$FILE of=/dev/mtd%part_nor% bs=1k seek=%seek%\" ifdev=\"MX6UL MX6ULL\">write U-Boot to NOR flash</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ echo Update Complete!\">Done</CMD>\n  </LIST>\n\n\n\n  <LIST name=\"Quad Nor Flash\" desc=\"Choose Quad Nor flash as media\">\n\t<CMD state=\"BootStrap\" type=\"boot\" body=\"BootStrap\" file =\"firmware/u-boot-imx6ul%lite%%bootimx%_%6ulnor%.imx\" ifdev=\"MX6UL MX6ULL\">Loading U-boot</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage\" address=\"0x80800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Kernel.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/%initramfs%\" address=\"0x83800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Initramfs.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage-imx6ul%lite%-%bootdtb%.dtb\" address=\"0x83000000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading device tree.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"jump\" > Jumping to OS image. </CMD>\n\n\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ flash_erase /dev/mtd0 0 20\">Erasing Boot partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/u-boot-imx6ul%lite%%6uluboot%_%6ulnor%.imx\" ifdev=\"MX6UL MX6ULL\">Sending u-boot.bin</CMD>\n\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ dd if=$FILE of=/dev/mtd0 bs=1k seek=4\" ifdev=\"MX6UL MX6ULL\">write U-Boot to NOR flash</CMD>\n\n\t<!--QSPI header-->\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"qspi-header.sh.tar\">Sending qspi header shell</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ tar xf $FILE \"> Extracting...</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/%norconfig%\">Sending QSPI header config file</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ sh qspi-header.sh $FILE\"> Generating the ascii value header</CMD>\n\t<!--hexdump to convert ascii value to hex file-->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ busybox hexdump -R qspi-tmp > qspi-header\">Converting ascii value to hex file</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ dd if=qspi-header of=/dev/mtd0 bs=1k seek=1\" ifdev=\"MX6UL MX6ULL\">Writing header to NOR flash</CMD>\n\t<!--delete temporary files-->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ rm qspi-tmp\">Deleting temporary file</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ rm qspi-header\">Deleting temporary file</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ echo Update Complete!\">Done</CMD>\n  </LIST>\n\n\n\n  <LIST name=\"NAND Flash\" desc=\"Choose NAND as media\">\n\t<CMD state=\"BootStrap\" type=\"boot\" body=\"BootStrap\" file =\"firmware/u-boot-imx6ul%lite%%bootimx%_%nand%.imx\" ifdev=\"MX6UL MX6ULL\">Loading U-boot</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage\" address=\"0x80800000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Kernel.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/%initramfs%\" address=\"0x83800000\"\n\t\t\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading Initramfs.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"load\" file=\"firmware/zImage-imx6ul%lite%-%bootdtb%-%nanddtb%.dtb\" address=\"0x83000000\"\n\t\tloadSection=\"OTH\" setSection=\"OTH\" HasFlashHeader=\"FALSE\" ifdev=\"MX6UL MX6ULL\">Loading device tree.</CMD>\n\n\t<CMD state=\"BootStrap\" type=\"jump\" > Jumping to OS image. </CMD>\n\n\n\t<!--burn the uboot to NAND: -->\t\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mount -t debugfs debugfs /sys/kernel/debug\">Mounting debugfs</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ flash_erase /dev/mtd%part_uboot% 0 0\">Erasing Boot partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/u-boot-imx6ul%lite%%6uluboot%_%nand%.imx\" ifdev=\"MX6UL MX6ULL\">Sending u-boot.bin</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ kobs-ng init -x -v --chip_0_device_path=/dev/mtd%part_uboot% $FILE\">Flashing Bootloader</CMD>\n\n\t<!--burn the kernel to NAND: -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ flash_erase /dev/mtd%part_kernel% 0 0\">Erasing Kernel partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/zImage\">Sending kernel zImage</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ nandwrite -p /dev/mtd%part_kernel% -p $FILE\">Flashing Kernel</CMD>\n\n\t<!--burn the dtb to NAND: -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ flash_erase /dev/mtd%part_dtb% 0 0\">Erasing dtb partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"files/zImage-imx6ul%lite%-%6uldtb%-%nanddtb%.dtb\" ifdev=\"MX6UL MX6ULL\">Sending Device Tree file</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ nandwrite -p /dev/mtd%part_dtb% -p $FILE\">Flashing dtb</CMD>\n\n\t<!--burn the rootfs to NAND: -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ flash_erase /dev/mtd%part_rootfs% 0 0\">Erasing rootfs partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ ubiformat /dev/mtd%part_rootfs%\"/>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ ubiattach /dev/ubi_ctrl -m %part_rootfs%\">Attaching UBI partition</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ ubimkvol /dev/ubi0 -Nrootfs -m\"/>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mkdir -p /mnt/mtd%part_rootfs%\"/>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ mount -t ubifs ubi0:rootfs /mnt/mtd%part_rootfs%\"/>\n\t<CMD state=\"Updater\" type=\"push\" body=\"pipe tar -jxv -C /mnt/mtd%part_rootfs%\" file=\"files/%rootfs%.tar.bz2\" ifdev=\"MX6UL MX6ULL\">Sending and writting rootfs</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"frf\">Finishing rootfs write</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ umount /mnt/mtd%part_rootfs%\">Unmounting rootfs partition</CMD>\n\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ echo Update Complete!\">Done</CMD>\n  </LIST>\n\n</UCL>\n```\n\n这是一个 xml 文件，所以遵循 xml 语法，根元素 `<UCL> <UCL/>`，它表示更新命令列表（Update Command List，UCL）；标签 `<CFG> </CFG>`，元素中包含可识别 usb 设备的列表；标签 `<LIST> </LIST>`，元素 `name` 用于匹配 `cfg.ini` 文件中的 `LIST/name` 参数或脚本输入参数，元素 `desc` 用于描述说明；标签 `<CMD> </CMD>` 嵌套于 `<LIST> </LIST>` 下，属于命令标签，在不同的阶段下命令是不一样的（大致分为两个阶段 BootStrap 和 Updater），mfgtool 工具的命令分为主机特定命令（Host Specific Commands）与固件特定命令（Firmware Specific Commands），其中主机特定命令是由 mfgtool 工具解析和执行，而固件特定命令由目标设备上的固件运行解析和执行。\n\nnote：拓展一下，关于 `mmc bootpart enable 1 1 <device>` 命令，是用于修改 emmc 启动使能位 `BOOT_PARTITION_ENABLE` ：\n\n![img](1083701-20190424104619529-166617225.png)\n\n关于该命令的解释：\n\n```text\nmmc bootpart enable <boot_partition> <send_ack> <device>\n    Enable the boot partition for the <device>.\n    Disable the boot partition for the <device> if <boot_partition> is set to 0.\n    To receive acknowledgment of boot from the card set <send_ack>\n    to 1, else set it to 0\n```\n\n即第一个数值用于选定所引导的分区，第二个数值是决定是否要接收来自卡的引导确认。\n\n\n\n# 分区处理\n\n## mksdcard.sh.tar\n\n该文件主要是用于烧录前对存储介质进行分区，在 `ucl2.xml` 上可以找到如下操作：\n\n```xml\n\t<!-- create partition -->\n\t<CMD state=\"Updater\" type=\"push\" body=\"send\" file=\"mksdcard.sh.tar\">Sending partition shell</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ tar xf $FILE \"> Partitioning...</CMD>\n\t<CMD state=\"Updater\" type=\"push\" body=\"$ sh mksdcard.sh /dev/mmcblk%mmc%\"> Partitioning...</CMD>\n```\n\n从上面可以看到它的处理流程：\n\n1. 先发送该文件到 RAM 运行中；\n2. 解压该文件；\n3. 利用 shell 命令执行解压出来的文件。\n\n然后我们打开压缩包，查看里面的 shell 脚本：\n\n```shell\n#!/bin/sh\n\n# partition size in MB\nBOOT_ROM_SIZE=10\n\n# wait for the SD/MMC device node ready\nwhile [ ! -e $1 ]\ndo\nsleep 1\necho “wait for $1 appear”\ndone\n\n# call sfdisk to create partition table\n# destroy the partition table\nnode=$1\ndd if=/dev/zero of=${node} bs=1024 count=1\n\nsfdisk --force ${node} << EOF\n${BOOT_ROM_SIZE}M,120M,0c\n200M,,83\nEOF\n```\n\n接着根据里面的分段，把它分为 4 个处理分析：\n\n```shell\nBOOT_ROM_SIZE=10\n\n# note：这里定义的是启动 ROM 10MB，给后面引用。\n```\n\n``` shell\nwhile [ ! -e $1 ]\ndo\nsleep 1\necho “wait for $1 appear”\ndone\n\n# note：$1 - 为命令行第一个传递的参数，结合 \"$ sh mksdcard.sh /dev/mmcblk%mmc%\"，所以 $1 实际为 /dev/mmcblk%mmc% 。\n```\n\n```shell\nnode=$1\ndd if=/dev/zero of=${node} bs=1024 count=1\n\n# note：将 /dev/mmcblk%mmc% 分区的前导 1024(1KB) 字节大小设 0，也就是擦除。\n```\n\n```shell\nsfdisk --force ${node} << EOF\n${BOOT_ROM_SIZE}M,120M,0c\n200M,,83\nEOF\n\n# note：利用 sfdisk 对 /dev/mmcblk%mmc% 进行分区，共划分为两部分：从起始地址 10MB 开始至 120M 为一个分区，文件类型为 0c（W95 FAT32 (LBA)）；从地址 200MB 以后为一个分区，文件类型为 83（Linux）。关于对应的文件类型码，可以使用 \"sfdisk -T\" 查看。\n```\n\n这里的分区信息，可以在 uboot 引导中，使用 `mmc part` 命令查看分区信息（更多具体 uboot 启动信息可看 [uboot 引导启动分析](https://arachnid.cc/uboot-starting/) ），例如以上的分区操作，可以得到：\n\n```shell\n=> mmc part\n\nPartition Map for MMC device 1  --   Partition Type: DOS\n\nPart    Start Sector    Num Sectors     UUID            Type\n  1     20480           245760          00000000-01     0c\n  2     409600          14860288        00000000-02     83\n\n=> ls mmc 1:1\n  6577568   zImage\n    36093   imx6ull-14x14-lanjut.dtb\n\n=> ls mmc 1:2\n<DIR>       4096 .\n<DIR>       4096 ..\n<DIR>      16384 lost+found\n<DIR>       4096 bin\n<DIR>       4096 dev\n<DIR>       4096 etc\n<DIR>       4096 home\n<DIR>       4096 lib\n<DIR>       4096 media\n<DIR>       4096 mnt\n<DIR>       4096 proc\n<DIR>       4096 run\n<DIR>       4096 sbin\n<DIR>       4096 sys\n<SYM>          8 tmp\n<DIR>       4096 usr\n<DIR>       4096 var\n\n=> mmc info\nDevice: FSL_SDHC\nManufacturer ID: 15\nOEM: 100\nName: 8GTF4 \nBus Speed: 52000000\nMode: MMC High Speed (52MHz)\nRd Block Len: 512\nMMC version 5.1\nHigh Capacity: Yes\nCapacity: 7.3 GiB\nBus Width: 8-bit\nErase Group Size: 512 KiB\nHC WP Group Size: 8 MiB\nUser Capacity: 7.3 GiB WRREL\nBoot Capacity: 4 MiB ENH\nRPMB Capacity: 512 KiB ENH\n```\n\n可以看到 emmc 有 2 个分区\n\n分区 1 是扇区：20480 ~ 245760 =>  第 1 个分区存放 Linux 镜像文件和设备树，容量为 `245760*512/1024/1025 = 120MB` ，从  `20480*512/1024/1025 = 10MB` 开始。\n\n分区 2 是扇区：409600 ~ 14860288 =>  第 2 个分区存放根文件系统容量为 `14860288*512/1024/1025 = 7256MB` ，从 `409600*512/1024/1025 = 200MB` 开始。\n\n因此总大小为：10MB（预留） + 120MB + 80MB（分割预留） + 7256MB = 7466 MB = 7.291015625 GB，而在这里实际使用的是 8G emmc 内存，所以除去 BOOT、RPMB 和 GPP（如果厂商设有 GPP）的分区，实际 UDA 分区的容量跟现在算出的差不多，具体以 datasheet 为准。\n\n![分区示例](21.1分区示例.png)\n\n\n\n# 烧录文件\n\nmfgtool 文件目录下的文件夹和文件非常多，除了上面的配置文件外，还有烧录脚本文件（.vbs）和烧录所需文件（uboot、kernel、dtb、rootfs）\n\n## 烧录脚本文件\n\n在 win 平台下，目录下的 `MfgTool2.exe` 就是烧写工具，以 `.vbs` 结尾的文件就是烧写的配置文件；而在 Linux 平台下，`mfgtoolcli` 是该平台的烧写工具，可以通过执行 `linux-cvbs.sh` 脚本转换 `.vbs` 文件为 Linux 平台下的脚本。\n\n该烧写工具能支持多款 i.MX 系统的 SoC 系统烧写，还能支持 Nand Flash、eMMC 和 SD卡等存储介质的烧写；因此，在对每一款 SoC 进行系统烧写之前，需要进行配置并指定好需要烧写的芯片以及存储介质等，然后通过执行相应的脚本文件运行；一般常用的脚本有如下几个：\n\n| 脚本文件名                              | 描述                                 |\n| --------------------------------------- | ------------------------------------ |\n| mfgtool2-yocto-mx-evk-emmc              | EMMC 烧写脚本                        |\n| mfgtool2-yocto-mx-evk-nand              | Nand 烧写脚本                        |\n| mfgtool2-yocto-mx-evk-qspi-nor-n25q256a | QSPI Flash 烧写脚本，型号为 n25q256a |\n\n关于烧写脚本命令参数，其烧写工具命令行的格式如下：\n\n`MfgTool2.exe [-c] [chip profile folder name] [-l] [list name] [-p] [number] [-s] [variable=value]`\n\n一般我们只用到：\n\n- -c：指定目标配置文件的名称。如果不指定则读取 `cfg.ini` 中 `profiles/chip` 的值。\n- -l：指示目标操作列表名称。如果不指定则读取 `cfg.ini` 中 `LIST/name` 的值。\n- -p：表示同时支持的单板数量。如果不指定则读取 `UICfg.ini` 中 `UICfg/PortMgrDlg` 的值。\n- -s：设置 `ucl2.xml` 中的变量值；支持多变量配置。如果不指定则读取 `cfg.ini` 中所需的 `variable` 引用变量值。\n\n更多格式可看目录下的 `~\\Document\\V2\\Manufacturing Tool V2 Quick Start Guide.docx` 文档。\n\n例如，自定义一个烧录脚本：\n\n```\nSet wshShell = CreateObject(\"WScript.shell\")\nwshShell.run \"mfgtool2.exe -c \"\"linux\"\" -l \"\"eMMC\"\" -s \"\"board=-lanjut\"\" -s \"\"mmc=1\"\" -s \"\"6uluboot=14x14\"\" -s \"\"6uldtb=14x14\"\"\"\nSet wshShell = Nothing\n```\n\nnote：\n\n可能会想，为什么没有列出 SD Card 烧写脚本，是因为用 SD Card 作烧写，用命令操作会好一点。\n\n## 烧录所需文件\n\n前面说到，在执行 `ucl2.xml` 的一系列操作中，存在两个阶段：\n\n- 第一阶段（把系统烧写到 DRAM 中，然后 Jumping to OS image，以此为运行平台）\n\n  其所需的文件有：（以 `ucl2.xml` 中 `eMMC` 标签为例）\n\n  | 运行固件  | 下载文件                                        |\n  | --------- | ----------------------------------------------- |\n  | uboot     | firmware/u-boot-imx6ul%lite%%bootimx%_emmc.imx  |\n  | kernel    | firmware/zImage                                 |\n  | initramfs | firmware/%initramfs%                            |\n  | dtb       | firmware/zImage-imx6ul%lite%-%bootdtb%-emmc.dtb |\n\n  结合上面图表中可以看出来，存放第一阶段所需的固件路径是 `profiles/CHIP_PROFILE/OS Firmware/firmware` ，`CHIP_PROFILE` 是由 `cfg.ini` 中的 `profiles/chip` 参数或 `mfgtool2-yocto-mx-evk-emmc` 脚本里 `-c` 所带参数决定，不区分大小写；对应的文件也依据 `ucl2.xml` 中 `BootStrap` 状态下的 `file` 元素定义的文件名为基准。\n\n  tips：一般这里是不需要改动了，因为只是为了引导实际烧写而提供一个运行平台而已。\n\n- 第二阶段（通过从 DRAM 中启动的运行平台将目标镜像固化到存储介质中）\n\n  其所需的文件有：（以 `ucl2.xml` 中 `eMMC` 标签为例）\n\n  | 目标固件 | 下载文件                                     |\n  | -------- | -------------------------------------------- |\n  | uboot    | files/u-boot-imx6ul%lite%%6uluboot%_emmc.imx |\n  | kernel   | files/zImage                                 |\n  | dtb      | files/zImage-imx6ul%lite%-%6uldtb%-emmc.dtb  |\n  | rootfs   | files/%rootfs%.tar.bz2                       |\n\n  同样的，在第二阶段存放所需的固件路径是 `profiles/CHIP_PROFILE/OS Firmware/files`，对应的文件则依据 `ucl2.xml` 中 `Updater` 状态下的 `file` 元素定义的文件名为基准。\n\n总结一下烧录流程：\n\n第一步：烧录 `profiles/CHIP_PROFILE/OS Firmware/firmware` 路径下的 uboot、kernel、initramfs、dtb 到 DRAM 中；然后执行 Jumping to OS image，这时候在已运行的系统中去执行第二个步骤。\n\n第二步：通过从 DRAM 中已经启动的系统上，将 `profiles/CHIP_PROFILE/OS Firmware/files` 路径下的目标固件 uboot、kernel、dtb、rootfs 烧写到存储介质中上，如 eMMC、Nand 等。因此在实际使用中，当需要更新系统或设备树时，真正需要更改的是这几个文件。\n\n"},{"title":"vmware 下 Ubuntu 双网卡设置","url":"/virtual-network-setup/","content":"\n\n\n> 背景：主机电脑通过 WiFi 上网，网口用于跟开发板等设备有线连接；为此需要实现虚拟机内对系统可以进行外网访问网页或下载工具包等（避免切换主机操作），同时具备通过网线访问内网设备机器进行控制调试等操作。\n>\n> 环境：VMware® Workstation 15 Pro\n>\n> 平台：Ubuntu 18.04.6\n\n\n\n# step 1：添加网卡\n\n在虚拟机窗口栏，依次点击 `编辑` -> `虚拟网络编辑器` ，可以看到原有默认的 VMnet 接口：\n\n![image-20230225172822709](image-20230225172822709.png)\n\n它们分别对应主机 ip 地址。\n\n然后我们建立一个桥接模式的 VMnet 虚拟网络，并指定响应网卡（如出现灰屏无法设置，需要**以管理员身份打开** VMware，或在当前窗口点击 `更改设置` 来赋予权限），然后选择对应需要进行桥接的网卡（即网口网卡）：\n\n![image-20230225193931835](image-20230225193931835.png)\n\n\n\n# setp 2：配置网络设备器\n\n在 ubuntu 虚拟机右键点击 `设置` -> `添加` -> `网络适配器` ，然后指定上面配置为桥接模式的  VMnet 虚拟网络：\n\n![image-20230225194908857](image-20230225194908857.png)\n\n\n\n## 拓展\n\n关于 NAT（网络地址转换模式）、Host-only（主机模式）及 bridged（桥接模式）：\n\n![Perbedaan NAT Bridge Dan Host Only](Perbedaan-NAT-Bridge-Dan-Host-Only-Di-Vmware-Dan-Virtualbox-1170x731.jpg)\n\n- NAT 模式：使用 NAT 模式，就是让虚拟机借助 NAT （网络地址转换）功能，通过宿主机器所在的网络来访问外部网络，即：使用 NAT 模式可以实现在虚拟系统里访问互联网。\n\n  优点：是从虚拟机访问外部网络的最简单方法；通常，它会自动设置网络地址转换到虚拟机上，不需要在宿主机器的网络信息上配置或通过访客操作系统上进行配置。\n\n  缺点：就像路由器后面的专用网络一样，虚拟机是不可见的，无法从外部网络访问。\n\n  ![vmware-network-nat](Virtual_network_switch_in_nat_mode.png)\n\n- Host-only 模式：构建一个与外界断开连接的内部网络，只允许使用 host-only 方法的虚拟机才能通信，因此无法与外部网络或其他 PC 主机通信，只能相互通信。\n\n  优点：与内部网络一样，其不需要存在物理网络接口，相当于使用 host-only 方法的虚拟机通过双绞线直连形成网络节点进行通讯；由于无法访问外部网络，因此对于安全性来讲，比其余两种相对要高。\n\n  缺点：如其名，无法与主机外部的网络通信，同时外部网络设备也无法与其通讯。\n\n  ![vmware-network-hostonly](Virtual_network_switch_in_host-only_mode.png)\n\n- bridged 模式：在这种模式下，虚拟系统就像是局域网中的一台独立的主机，具有自己的 MAC 和 IP 地址；由于虚拟机和宿主机器分配了相同网段的 IP，因此宿主机器和虚拟机被识别为同一级别的物理主机。\n\n  优点：虚拟机就像是一台独立的主机，拥有正常主机的网络功能，可以对外部网络进行访问，而外部网络也可以访问进来。\n\n  缺点：由于外部网络可以访问，其安全性比其余两种相对要低；因与宿主机器平等的存在于网络中，需要进行分配网络地址、子网掩码、网关等操作。\n\n  ![vmware-network-bridged](Virtual_network_switch_in_bridged_mode.png)\n\n  \n\n示例：\n\n一些 VMnet 虚拟机具有特定功能：VMnet0 专用于 bridged 模式，VMnet1 专用于 host-only 模式，而 VMnet8 专用于 NAT 模式；其他的 VMnet2 等，可供虚拟机使用自定义网络模式。如图分析各模式作用：\n\n![工作站网络](workstation-networking_thumb1.jpg)\n\n- VM-1 可以与 host PC 通信，并连接到外部 LAN or internet，但不能与 NAT 和 host-only 网络通信。\n\n- VM-2 和 VM-3 可以相互通信，也可以与 NAT 网络中的其他 VM 通信，也可以与 host PC 通信。\n\n- VM-5 和 VM-4 可以相互通信，但不能与主机操作系统和 host-only 网络中的其他 VM 通信。\n\n- VM-6 和 VM-7 无法相互通信。\n\n\n\n参考：\n\n[What is the difference between NAT / Bridged / Host-Only networking?](https://superuser.com/questions/227505/what-is-the-difference-between-nat-bridged-host-only-networking)\n\n[VMware Workstation Networking Basics](https://pibytes.wordpress.com/2012/11/16/vmware-workstation-networking-basics/)\n\n[VMWare Networking Concept [Bridged, NAT, Host Only, LAN Segment]](https://agussas.wordpress.com/2015/10/28/vmware-networking-concept-bridged-nat-host-only-lan-segment/)\n\n[Perbedaan NAT Bridge Dan Host Only Di VMware Dan VirtualBox](https://www.monitorteknologi.com/perbedaan-nat-bridge-dan-host-only/)\n\n[Virtual Networking](https://wiki.libvirt.org/VirtualNetworking.html)\n\n[Vmware Host-Only, NAT, Bridge 차이](https://www.uname.in/60)\n\n[Intro to Virtual Machine Networking](https://diarmuidmccarthy.wordpress.com/2011/02/15/hello-world/)\n\n[VMware虛擬機器上網路連線(Network type)的三種模式](https://ryanisagoodguy.blogspot.com/2019/06/vmwarenetwork-typebridgedhost-only-nat.html)\n\n\n\n# setp 3：网络信息配置\n\n从上一步可以知道我们目前有两个网络适配器，分别是 NAT 和 桥接模式，然后针对这几个模式的作用也在上面作了介绍了；因此在这里，实际只需要在虚拟机系统中配置桥接模式对应的网卡网络信息就好了；至于 NAT 模式对应的网卡网络信息将由虚拟机借助 NAT （网络地址转换）功能实现自动配置即可实现访问外网功能。\n\n1. 查看所有网卡信息：\n\n   ```bash command:(\"[root@localhost] $\":1)\n   ifconfig -a\n   ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n           inet 192.168.154.133  netmask 255.255.255.0  broadcast 192.168.154.255\n           inet6 fe80::b52c:a0e6:1419:116b  prefixlen 64  scopeid 0x20<link>\n           ether 00:0c:29:f0:76:35  txqueuelen 1000  (以太网)\n           RX packets 102259  bytes 150687397 (150.6 MB)\n           RX errors 0  dropped 0  overruns 0  frame 0\n           TX packets 13950  bytes 938511 (938.5 KB)\n           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n   \n   ens36: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n           inet 192.168.17.218  netmask 255.255.255.0  broadcast 192.168.17.255\n           inet6 240e:47c:680:2899:56c0:dff:d5fe:b1aa  prefixlen 64  scopeid 0x0<global>\n           inet6 240e:47c:680:2899:18e7:3cfa:5fad:bbe  prefixlen 64  scopeid 0x0<global>\n           inet6 fe80::a25b:a66f:67e7:3e67  prefixlen 64  scopeid 0x20<link>\n           ether 00:0c:29:f0:76:3f  txqueuelen 1000  (以太网)\n           RX packets 426  bytes 474569 (474.5 KB)\n           RX errors 0  dropped 0  overruns 0  frame 0\n           TX packets 403  bytes 44762 (44.7 KB)\n           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n   \n   lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n           inet 127.0.0.1  netmask 255.0.0.0\n           inet6 ::1  prefixlen 128  scopeid 0x10<host>\n           loop  txqueuelen 1000  (本地环回)\n           RX packets 308  bytes 26853 (26.8 KB)\n           RX errors 0  dropped 0  overruns 0  frame 0\n           TX packets 308  bytes 26853 (26.8 KB)\n           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n   ```\n\n2. 启用网卡（如已启用则跳过该步骤），其中 `ens36` 是设置 bridged 模式的网卡。\n\n   ```bash command:(\"[root@localhost] $\":1)\n   sudo ifconfig ens36 up\n   ```\n\n3. 修改网络信息配置\n\n   ```bash command:(\"[root@localhost] $\":1-2,37-38)\n   cp /etc/netplan/01-network-manager-all.yaml /etc/netplan/01-network-manager-all.yaml.back # 备份\n   vim /etc/netplan/01-network-manager-all.yaml\n   # Let NetworkManager manage all devices on this system\n   network:\n     ethernets:\n       ens33:\n         dhcp4: true\n         dhcp4-overrides:\n           route-metric: 100\n         # addresses: [192.168.1.110/24]\n         # gateway4: 192.168.1.1\n         # nameservers:\n          # addresses: [192.168.1.1]\n       ens36:\n         dhcp4: true\n     version: 2\n   \n     bridges:\n       br0:\n        interfaces: [ens36]\n        dhcp4: no\n        addresses:\n         - 192.168.1.110/24\n        nameservers:\n          addresses: [8.8.8.8]\n        routes:\n         - to: 0.0.0.0/0\n           via: 192.168.1.1\n           metric: 1000\n   \n   #  renderer: NetworkManager\n   \n   netplan apply\n   reboot\n   ```\n   \n4. 重启后查看验证网路\n\n   ```bash command:(\"[root@localhost] $\":1,9-10,12-13)\n   route -n\n   内核 IP 路由表\n   目标            网关            子网掩码        标志  跃点   引用  使用 接口\n   0.0.0.0         192.168.154.2   0.0.0.0         UG    100    0        0 ens33\n   0.0.0.0         192.168.1.1     0.0.0.0         UG    1000   0        0 br0\n   192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 br0\n   192.168.154.0   0.0.0.0         255.255.255.0   U     0      0        0 ens33\n   192.168.154.2   0.0.0.0         255.255.255.255 UH    100    0        0 ens33\n   \n   ping baidu.com\n   ...\n   \n   ping host ip\n   ...\n   ```\n\n   \n\n# 关于双网卡无法上网问题\n\n当在虚拟机网络中设置完 VMnet0 桥接的 IP 地址等信息，打开网络后，发现网络不通。\n\n但如果关闭 VMnet0，只保留 VMnet8，网络又是可行的，由此考虑到可能是网卡优先级的配置问题。\n\n通过上面可以发现 `br0` 的跃点比 `ens33` 的 metric 要高，而 metric 越低，其优先级越高，因此按上面操作来一般没问题的；如果这两个网卡的 metric 值反过来，那么会造成无法上网的问题，因为本身我们的有线网口是没有联网的，但优先级又比联网的网卡优先级高，所以会出现 ping 不通外网的情况。\n\n假设需要临时调整 ip / gateway / metric 等，可以使用 `route` 命令，而避免更改网络配置表文件，关于 `route` 命令使用可看 [Linux 路由表说明](http://arachnid.cc/linux-routing-table) 。","tags":["Ubuntu","Linux"]},{"title":"uboot 引导启动分析","url":"/uboot-starting/","content":"\n\n\n# uboot 命令\n\n## 命令支持\n\n当不清楚 uboot 支持什么命令时， 可输入 `help` 或 `?` 可查看 uboot 支持的命令列表；当需要具体使用哪个命令时，可使用 `help [命令]` 或 `? [命令]` 的方式查看具体命令的使用说明，eg：`help printenv` 。\n\n具体可以使用什么命令，实际跟 uboot 中的 `CONFIG_CMD_xxx` 宏的使能有关，因此，如果无法使用某些命令，可能是因为把特定的 `CONFIG_CMD_xxx` 宏去掉了；而对于这些命令的开关，可以在 `configs/xxx_defconfig` 中定义，或者使用 `make menuconfig` 选择使能相应命令的支持。\n\n## 常用命令行命令\n\n**A、环境变量操作**\n\n1. printenv\n\n   功能：打印环境变量。\n\n   用法：`printenv <name>` ，其中 name 为相应的环境变量名，不填则打印所有环境变量配置。\n\n2. setenv\n\n   功能：设置环境变量。\n\n   用法：`setenv <key> <value>` ，其中 key 是变量名，value 是变量值。如果 value 为空，则表示删除对应的环境变量。\n\n3. saveenv\n\n   功能：保存环境变量修改，使用 setenv 设置环境变量后不会掉电保存，需要保存后才不会丢失。\n\n   用法：`saveenv` 。\n\n3. run\n\n   功能：执行指定的环境变量里的语句。\n\n   用法：`run <var>` ，其中 key 是指定的环境变量。\n\n**B、存储介质操作**\n\n1. mmc & SD\n\n   功能：对 mmc 存储介质进行操作，包括 EMMC 和 SD 卡。\n\n   用法：\n   - `mmc list` ，用于查看板子上 mmc 设备。\n   - `mmc dev <dev> <part>` ，用于切换当前 mmc 设备，其中 dev 用来设置要切换的 mmc 设备号，part 是分区号（可以不写，默认为分区 0）。\n   - `mmc info` ，查看当前 mmc 设备信息。\n   - `mmc part` ，查看当前 mmc 设备分区。\n   - `mmc read / write <addr> <blk#> <cnt>` ，读取/写入当前 mmc 设备数据，其中 addr 是数据写入/读取到 DRAM 中的地址(十六进制)， blk# 是要读取/写入到 emmc 的块起始地址(十六进制)，一个块是 512 字节，这里的块和扇区是一个意思，在 mmc 设备中我们通常说扇区， cnt 是要读取/写入的块数量(十六进制)。\n   - `mmc erase <blk#> <cnt>` ，擦除当前 mmc 设备数据，其中 blk# 为要擦除的起始块(十六进制)， cnt 是要擦除的数量(十六进制)。\n   - `mmc rescan` ，令用于扫描设备上所有的 mmc 设备，包括 EMMC 和 SD 卡。\n   \n2. nand\n\n   功能：对 nand flash 存储介质进行操作。\n\n   用法：\n\n   - `nand info` ，查看当前 nand flash 信息。\n   - `nand dev <dev> <part>` ，用于切换当前 nand flash 设备，其中 dev 用来设置要切换的 nand 设备号，part 是分区号（可以不写，默认为分区 0）。\n   - `nand read / write <addr> <off> <size>` ，读取/写入当前 nand flash 设备数据，其中 addr 是数据写入/读取到 DRAM 中的地址(十六进制)， off 是要读取/写入 nand flash 的起始地址(十六进制)，size 是要读取/写入的数据大小(十六进制)。\n   - `mmc erase <addr> <size>` ，擦除当前 nand flash 设备数据，其中 addr 为要擦除的起始地址(十六进制)， size 是要擦除的数据大小(十六进制)。\n\n**C、网络操作**\n\n1. ping\n\n   功能：发送 ICMP_ECHO 请求到网络主机。\n\n   用法：`ping <hostaddr>` ，其中 hostaddr 是目标发送请求主机 IP。\n\n2. dhcp\n\n   功能：获取 ip 地址及通过 tftp 下载到内存。\n\n   用法：\n   - `dhcp` ，单纯用于自动获取 ip 地址。\n   - `dhcp <loadaddr> <[hostIPaddr:]filename>` ，其中 loadaddr 是加载内存地址，hostIPaddr 是获取链接的主机 IP，filename 是要下载的文件名。\n\n3. nfs\n\n   功能：通过 nfs(Network File System) 下载到内存。\n\n   用法：`nfs <loadaddr> <[hostIPaddr:]filename>` ，其中 loadaddr 是加载内存地址，hostIPaddr 是获取链接的主机 ip，filename 是要下载的文件名。\n\n4. tftp / tftpboot\n\n   功能：通过 tftp 下载到内存。\n\n   用法：`tftp / tftpboot <loadaddr> <[hostIPaddr:]filename>` ，其中 loadaddr 是加载内存地址，hostIPaddr 是获取链接的主机 ip，filename 是要下载的文件名。\n\n**D、文件系统操作**\n\n1. fatinfo\n\n   功能：查询指定 mmc 设置指定分区的文件系统信息。\n\n   用法：`fatinfo <interface> <dev>:<part>` ，其中 interface 表示接口（mmc 等），dev 是查询的设备号， part 是要查询的分区。\n\n2. fatls / ext4ls\n\n   功能：查询 FAT / ext4 格式设备的目录和文件信息。\n\n   用法：`fatls / ext4ls <interface> <dev>:<part> <directory>` ，其中 interface 表示接口（mmc 等），dev 是查询的设备号， part 是要查询的分区，directory是要查询的目录（默认为根目录 `/` ）。\n\n3. fatload / ext4load\n\n   功能：查询 FAT / ext4 格式设备的目录和文件信息。\n\n   用法：`fatload / ext4load <interface> <dev>:<part> <addr> <filename> <bytes> <pos>` ，其中 interface 表示接口（mmc 等），dev 是查询的设备号， part 是要查询的分区，addr 是保存在 DRAM 中的起始地址， filename 是要读取的文件名字，bytes 表示读取多少字节的数据（0 或者省略表示读取整个文件），pos 是要读的文件相对于文件首地址的偏移（0 或者省略表示从文件首地址开始读取）。\n\n**E、内存操作**\n\n1. md\n\n   功能：用于显示内存值。\n\n   用法：`md[.b, .w, .l] address [# of objects]` ，其中，[.b, .w, .l] 对应 byte、word 和 long，也就是分别以 1 个字节、2 个字节、4 个字节来显示内存值。address 就是要查看的内存起始地址，[# of objects] 表示要查看的数据长度，这个数据长度单位不是字节，而是跟你所选择的显示格式有关；其数值皆为十六进制。\n\n2. nm\n\n   功能：用于修改指定地址的内存值。\n\n   用法：`mw [.b, .w, .l] address value [count]` ，同样以 [.b, .w, .l] 对应 byte、word 和 long，也就是分别以 1 个字节、2 个字节、4 个字节来指定操作格式，ddress 表示要填充的内存起始地址，value 为要填充的数据，count 是填充的长度（与选择的操作格式有关）；其数值皆为十六进制。\n\n3. cp\n\n   功能：用于将数据从一段内存拷贝到另一段内存中。\n\n   用法：`cp [.b, .w, .l] source target count` ，[.b, .w, .l] 对应 byte、word 和 long 来指定操作格式，source 为源地址，target 为目的地址，count 为拷贝的长度（与选择的操作格式有关）；其数值皆为十六进制。\n\n4. cmp\n\n   功能：用于将数据从一段内存拷贝到另一段内存中。\n\n   用法：`cmp [.b, .w, .l] addr1 addr2 count` ，[.b, .w, .l] 对应 byte、word 和 long 来指定操作格式，addr1 为第一段内存首地址，addr2 为第二段内存首地址，count 为要比较的长度（与选择的操作格式有关）；其数值皆为十六进制。\n\n**F、启动内核**\n\n1. bootz\n\n   功能：从指定内存位置加载启动 **zImage 镜像文件** 。\n\n   用法：`bootm <zImageaddr> - <fdtaddr>` ，其中，kerneladdr 是 zImage 镜像地址，fdtaddr 是设备树文件地址。\n\n2. bootm\n\n   功能：从指定内存位置加载启动 **uImage 镜像文件** 。\n\n   用法：`bootm <uImageaddr> <- arg...>` ，其中，kerneladdr 是 uImage 镜像地址，arg 是为可选子命令，具体可看 `? bootm` 。\n\n3. boot\n\n   功能：通过读取环境变量 `bootcmd` 来启动 linux 系统。\n\n   用法：`boot` 。\n\n**G、other**\n\n1. reset\n\n   功能：重启 uboot。\n\n2. env default -a\n\n   功能：获取默认 env 环境变量，即 `include/env_default.h` 中 `default_environment` 数组中的变量。\n   \n3. ls\n\n   功能：查看当前 mmc 介质里的文件。eg：`ls mmc 1:1` 可以获取到设备 1 的分区 1 中存放着内核和设备树；`ls mmc 1:2` 可以获取到系统中的文件系统根目录所存在的文件及文件夹；如果 `ls mmc 1:0` ，你会发现提示文件系统未知或错误，这是因为分区 0 存放的是 uboot，并且分区 0 没有格式化，所以文件系统格式未知。\n\n\n\n\n# 环境变量\n\n需要注意的是，环境变量的名字并不是统一的，除部分重要变量名外，主要是由芯片厂商或开发者自行协定的。\n\n## 默认环境变量\n\n默认环境变量可以在 `include/configs/` 文件夹中找到对应的芯片配置头文件及在 `include/env_default.h` 文件中查看定义。一般其主要环境变量参数整体被定义在 `CONFIG_EXTRA_ENV_SETTINGS` 宏参数中，在 README 文件中可找到说明：\n\n```markdown README\n- Default Environment:\n\t\tCONFIG_EXTRA_ENV_SETTINGS\n\n\t\tDefine this to contain any number of null terminated\n\t\tstrings (variable = value pairs) that will be part of\n\t\tthe default environment compiled into the boot image.\n\n\t\tFor example, place something like this in your\n\t\tboard's config file:\n\n\t\t#define CONFIG_EXTRA_ENV_SETTINGS \\\n\t\t\t\"myvar1=value1\\0\" \\\n\t\t\t\"myvar2=value2\\0\"\n\n\t\tWarning: This method is based on knowledge about the\n\t\tinternal format how the environment is stored by the\n\t\tU-Boot code. This is NOT an official, exported\n\t\tinterface! Although it is unlikely that this format\n\t\twill change soon, there is no guarantee either.\n\t\tYou better know what you are doing here.\n\n\t\tNote: overly (ab)use of the default environment is\n\t\tdiscouraged. Make sure to check other ways to preset\n\t\tthe environment like the \"source\" command or the\n\t\tboot command first.\n\n\t\tCONFIG_DELAY_ENVIRONMENT\n\n\t\tNormally the environment is loaded when the board is\n\t\tinitialised so that it is available to U-Boot. This inhibits\n\t\tthat so that the environment is not available until\n\t\texplicitly loaded later by U-Boot code. With CONFIG_OF_CONTROL\n\t\tthis is instead controlled by the value of\n\t\t/config/load-environment.\n```\n\n## 常用环境变量\n\n在 `include/env_default.h` 文件定义的环境变量，可通过读取宏来配置相应值，及从 `CONFIG_EXTRA_ENV_SETTINGS` 宏参数追加自定义环境变量，其中有几个变量是比较重要，这里结合 NXP 厂商的定义进行如下参考分析：\n\n**1、console 变量（固有）**\n\n功能：表示控制台输出设备。\n\n**2、baudrate 变量（固有）**\n\n功能：指定 linux 系统启动过程中串口控制台打印的波特率。\n\n**3、bootdelay 变量（固有）**\n\n功能：设置 uboot 启动时等待用户输入的延时，单位是秒。\n\n**4、fdt_addr 变量（私人）**\n\n功能：设备树加载启动的地址。\n\n**5、fdt_file 变量（私人）**\n\n功能：设备树加载显示的名称，如果 uboot 中配置的名称对应不上获取的设备树文件，将显示 undefined。\n\n**6、image 变量（私人）**\n\n功能：内核加载启动读取的文件名。\n\n**7、loadaddr 变量（固有）**\n\n功能：内核加载启动的地址。\n\n**8、ipaddr/serverip/gatewayip/netmask 变量（固有）**\n\n功能：用于设置网络信息，分别对应开发板 ip、服务器 ip、网关、子网掩码；设置完成后可用 ping 命令测试网络连通性。\n\n**9、bootcmd 变量（固有）**\n\n功能：`bootcmd` 变量是用来存储启动命令的环境变量，它定义了 uboot 启动 linux 系统的具体步骤。当 uboot 倒计时结束以后就会执行 `bootcmd` 中的命令。这些命令一般都是用来启动 linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 linux 内核。\n\n也可以在 uboot 启动以后进入命令行设置 `bootcmd` 环境变量的值。如果 EMMC 或者 NAND 中没有保存 `bootcmd` 的值，那么 uboot 就会使用默认的值。\n\n应用：`bootcmd` 变量的内容通常是一系列 uboot 命令和参数的组合，例如：\n\n```bash\nbootcmd=run load_kernel; run load_dtb; bootz ${kernel_addr_r} - ${fdt_addr_r}\n```\n\n上述 `bootcmd` 变量定义了两个命令：`load_kernel` 和 `load_dtb`，并最后执行了 `bootz` 命令来启动 linux 内核。这里的 `run` 命令表示执行一个之前定义好的环境变量，例如：\n\n```bash\nload_kernel=mmc dev ${mmc_dev}; fatload mmc ${mmc_dev}:${mmc_part} ${kernel_addr} zImage\nload_dtb=fatload mmc ${mmc_dev}:${mmc_part} ${fdt_addr} devicetree.dtb\n```\n\n在上述命令中，`load_kernel` 和 `load_dtb` 分别使用 `fatload` 命令从 mmc 设备 `${mmc_dev}` 的 `${mmc_part}` 分区（`mmc ${mmc_dev}:${mmc_part}`）中加载内核和设备树；`${kernel_addr}` 和 `${fdt_addr}` 是在 uboot 中预定义的环境变量，分别表示内核和设备树在内存中的地址。\n\n在实际应用中，`bootcmd` 变量的内容需要根据硬件平台和具体应用场景来设置，以确保系统能够正确启动。可以使用 `printenv bootcmd` 命令来查看当前的 `bootcmd` 命令，使用 `setenv bootcmd <cmd>` 命令来手动设置 `bootcmd` 变量，例如，把上述命令定义并保存到 `bootcmd` 变量中：\n\n```bash\nsetenv bootcmd 'run load_kernel; run load_dtb; run load_rootfs; bootm'\nsaveenv\n```\n\n**10、bootargs 变量（固有）**\n\n功能：`bootargs` 变量是用来存储内核启动参数的环境变量，它在启动 linux 内核时会被传递给内核。bootargs 变量可以在 uboot 命令行中手动设置，也可以通过脚本自动设置。下面是一些常见的 `bootargs` 参数：\n\n- console：指定内核输出信息的终端设备，可以是串口、LCD 显示屏等。\n\n- root：指定根文件系统所在的设备和分区。\n\n- rootfstype：指定根文件系统的文件系统类型，例如 `ext4`、`jffs2`、`nfs` 等。\n\n- ip：指定 IP 地址和网络参数，用于网络启动。\n\n- mem：指定系统可用内存的大小，用于系统启动时内存的自适应分配。\n\n- quiet：设置内核启动时不显示冗长的信息。\n\n- debug：开启内核调试模式，用于调试内核代码。\n\n应用：在设置 `bootargs` 变量时，需要根据硬件平台和具体应用场景来选择合适的参数，并确保参数的正确性。例如，`console` 参数需要根据硬件平台的串口地址和波特率来设置，`root` 参数需要根据具体的文件系统类型和分区来设置。例如：\n\n```bash\nsetenv bootargs console=${console},${baudrate} root=${mmc_root}\nsaveenv\n```\n\n## 环境变量设置\n\n环境变量的设置有两种方法，一种方法是通过修改静态配置，即通过修改 uboot 的文件中相关环境变量的配置。不过此类方法在实际中显然非常不实际，每次需要修改一次环境变量都需要重新编译整个 uboot。\n\n另一种方法是利用 uboot 提供的 `setenv` 动态修改环境变量的设置，当设置完成后再通过 `saveenv` 把相应的环境变量设置保存到 Flash 等非易失性存储设备上。\n\n在更改多次环境变量后，如果想恢复成 uboot 的文件中默认环境变量的配置，可以通过 `env default -a` 重新读取，最后通过 `saveenv` 保存。\n\nuboot 的环境参数，在 uboot 启动过程中，会去校验 CRC 存放环境变量的一段空间，若 CRC 有效则使用该空间里的环境变量，无效则用默认的环境变量；因此在初次移植烧录 uboot 的时候，由于没有使用 `saveenv` 存储过，所以读不出 CRC 校验，而使用的默认环境变量（可通过 `printenv` 输出对比文件里环境变量的配置），同样的在信息打印中也会输出 `*** Warning - bad CRC, using default environment` 。\n\n\n\n# 启动方式\n\nuboot 有两种启动 linux 内核和 rootfs 的方法，一种是直接从 flash(nand 或 emmc) 启动，一种是从网络启动。这里面用到了两个非常重要的环境变量 `bootcmd` 和 `bootargs` 。\n\n## 从 EMMC 启动\n\n从 EMMC 启动也就是将编译出来的 linux 镜像文件 zImage 和设备树文件保存在 EMMC中， uboot 从 EMMC 中读取这两个文件并启动。\n\n以 NXP 的 imx-6ull 为例：\n\n```bash\nsetenv bootargs 'console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw' # 设置控制台输出设备为 ttymxc0、波特率为 115200；指明根文件系统存放在 mmcblk1 设备的分区 2 中，EMMC 版本的核心板启动 linux 以后会存在/dev/mmcblk0、/dev/mmcblk1、 /dev/mmcblk0p1、/dev/mmcblk0p2、 /dev/mmcblk1p1 和/dev/mmcblk1p2 这样的文件，其中/dev/mmcblkx(x=0~ n)表示 mmc 设备，而/dev/mmcblkxpy(x=0~ n,y=1~ n)表示 mmc 设备 x 的分区 y；rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话 mmc 设备还没初始化完成就挂载根文件系统会出错的，rw 表示根文件系统是可以读写的，不加 rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。\nmmc dev 1 # 切换到 EMMC\nfatload mmc 1:1 0x80800000 zImage # 读取 zImage 到 0x80800000 处\nfatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb # 读取设备树到 0x83000000 处\nbootz 0x80800000 - 0x83000000 # 启动内核\n```\n\n## 从网络启动\n\n从网络启动最主要的是用来调试，试想，假设你更改了部分 linux kernel 驱动或 rootfs，如果是使用 EMMC 进行烧录下载，那么就得每次都对其镜像或文件系统烧写到 EMMC 中，这样就太麻烦，因此我们可以使用网络对其进行烧写替换。其前提条件是必须配置好网络设备及 uboot 设备树，能正常连通，否者一切都是扯淡。\n\n以 NXP 的 imx-6ull 为例：\n\n```bash\nsetenv ethaddr 8e:14:c8:bc:02:49\nsetenv ipaddr 192.168.1.2\nsetenv gatewayip 192.168.1.1\nsetenv netmask 255.255.255.0\nsetenv serverip 192.168.1.100\n\nsetenv nfsroot /home/user/nfs_rootfs\n\nsetenv netargs setenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=${serverip}:${nfsroot},proto=tcp rw ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}::eth0:off'\ntftp 80800000 zImage\ntftp 83000000 imx6ull-14x14-evk.dtb\nbootz 80800000 - 83000000\n```\n\nnote：网络获取设备树及镜像需要 tftp 服务的支持，网络挂载文件系统需要 nfs 服务的支持。","tags":["Linux","arm_linux"]},{"title":"GCC 编译器套件说明","url":"/gcc-compiler-collection/","content":"\n\n\n# GCC 简述\n\nThe GNU Compiler Collection，通常简称 [GCC](https://gcc.gnu.org/) ，是一套由 [GNU](https://www.gnu.org/) 开发的编译器集合。\n\n为什么是编辑器集合而不是编译器呢？\n\n那是因为 GNU 编译器集合包括 C、C++、Objective-C，Fortran，Ada、Go 和 D 等，以及这些语言的库 （libstdc++,...）。 GCC 最初是作为 GNU 操作系统的编译器编写的。 GNU 系统被开发为 100% 的[自由软件](https://www.gnu.org/philosophy/free-sw.html) ，即从某种意义上说它是自由的，尊重用户的自由。另外 GCC 对硬件平台的支持，可以说无所不在，它不仅支持 x86 处理器架构, 还支持 ARM, Motorola 68000, Motorola 8800，AtmelAVR，MIPS 等处理器架构。\n\n\n\n# GCC 主要构成\n\n1. gcc-core：顾明之意是 GCC 的核心部分，这部分是只包含 c 的编译器及公共部分，而对其他语言（C++、Ada 等）的支持包需要另外安装，这也是 GCC 为何如此强大的重要原因 。gcc-core 依赖于 Binutils。\n2. Binutils：它是一组开发工具，包括连接器，汇编器和其他用于目标文件和档案的工具。关于 Binutils 的介绍可以参考官方的 [Binutils](https://www.gnu.org/software/binutils/) 介绍。这个软件包依赖于不同的目标机平台，因为不同目标机的指令集是不一样的，比如 arm 跟 x86 就不一样。\n常用的工具有：\n   - as：汇编器，把汇编语言代码转换为机器码（目标文件）。\n   - ld：链接器，把编译生成的多个目标文件组织成最终的可执行程序文件。\n   - readelf：可用于查看目标文件或可执行程序文件的信息。\n   - objcopy： 可用于目标文件格式转换，如 `.elf` 转换成 `.bin` 。\n   - objdump：可用于查看目标文件的信息，最主要的作用是反汇编。\n   - addr2line：可用于将程序指令地址转换为所对应的函数名、以及函数所在的源文件名和行号。\n3. Glibc：包含了主要的 c 库，这个库提供了基本的例程，用于分配内存，搜索目录，读写文件，字符串处理等等。\n\n\n\n# ARM 编译工具链\n\n编译器主要用来编译源文件，而在编译一个源文件时需要经过以下 4 步：\n\n1. 预处理：为把头文件的代码、宏之类的内容转换成生成的 `.i` 文件，还是 C 代码。\n2. 编译：把预处理后的 `.i` 文件通过编译成 `.s` 文件，汇编语言。\n3. 汇编：将汇编语言文件生成目标文件 `.o` 文件，机器码。\n4. 链接：将每个源文件对应的 `.o` 文件链接起来，就生成一个可执行程序文件。\n\n交叉编译器：如果我们希望编译器运行在 x86 架构平台上，然后编译生成 ARM 架构的可执行程序，这种编译器和目标程序运行在不同架构的编译过程，被称为 “交叉编译”，而对应使用的编译工具就成为交叉编译器。\n\nGNU 交叉编译器的命名规则：\n\n`arch [-vendor] [-os] [-(gnu)abi] [-language]`\n\n- arch：体系架构，如 `arm` 、 `aarch64` 或者 `mips` 等；\n- vendor：工具链提供商，没有 vendor 时，用 `none` 代替；\n- os：目标操作系统，没有 os 支持时，用 `none` 代替；\n- abi：应用二进制接口（Application Binary Interface），对于嵌入式平台命名为 `eabi` ， `e` 表示 Embedded；\n- language：编译器支持的语言，如：`gcc` 、 `g++` 。\n\nnote：如果同时没有 vendor 和 os 支持，则只用一个 none 代替。例如 arm-none-eabi 中的 none 表示既没有 vendor 也没有 os 支持。\n\n**关于 ABI 和 EABI 的区别**\n\nABI：应用二进制接口（Application Binary Interface）。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。\n\nEABI：嵌入式应用二进制接口（Embedded Application Binary Interface）。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。\n\n两者主要区别是：ABI 是计算机上的，EABI 是嵌入式平台上（如 ARM，MIPS 等）的；EABI 去掉了用户代码和系统内核之间的抽象，可以让用户代码直接访问硬件，提高了性能。\n\n**关于 gcc 和 g++ 的区别**\n\n实际上，只要是 gcc 编译器支持的语言都可以使用 gcc 编译器完成编译，而 g++ 编译器只会按照 C++ 的风格编译代码。虽然很多情况下我们都认为 C++ 是对 C 语言兼容的，但是实际上在一些具体的语法规则上，C++ 在编译过程中的语法检查会更加严格。此外，C++ 语言本身在编译 过程中也会引入 C++ 的标准库，如果使用 gcc 编译器直接编译 C++ 语言会在编译过程中添加额外的参数，这样会显得编译过程较为繁琐（因为大部分情况下我们希望标准库可以直接引入，而不是再需要手动指定，否则对于初级使用者会带来额外的学习负担）。为了更方便使用编译器，我们选择 g++ 来编译 C++ 代码。总结一下，gcc 可以完成 C++ 语言的编译，但是使用过程会较为繁琐，而 g++ 就是简化后的编译指令。\n\n**与 gnueabi 相关的 gnueabi 和 gnueabihf 的区别**\n\n`gcc-arm-linux-gnueabi – The GNU C compiler for armel architecture`\n\nAND\n\n`gcc-arm-linux-gnueabihf – The GNU C compiler for armhf architecture`\n\n这两个交叉编译器分别适用于 armel 和 armhf 两个不同的架构，armel 和 armhf 这两种架构在对待浮点运算采取了不同的策略（有 fpu 的 ARM 才能支持这两种浮点运算策略）。\n\n这两个交叉编译器是 gcc 的选项 `-mfloat-abi` 的默认值不同；该选项有三种值 soft、softfp、hard（其中后两者都要求 ARM 里有 fpu 浮点运算单元，soft 与后两者是兼容的，但 softfp 和 hard 两种模式互不兼容）：\n\n- soft： 不用 fpu 进行浮点计算，即使有 fpu 浮点运算单元也不用，而是使用软件模式。\n\n- softfp： armel 架构（对应的编译器为 arm-linux-gnueabi-gcc ）采用的默认值，用 fpu 计算，但是传参数用普通寄存器传，这样中断的时候，只需要保存普通寄存器，中断负荷小，但是参数需要转换成浮点的再计算。\n\n- hard： armhf架构（对应的编译器 arm-linux-gnueabihf-gcc ）采用的默认值，用 fpu 计算，传参数也用 fpu 中的浮点寄存器传，省去了转换，性能最好，但是中断负荷高。\n\n几种常见的编译 ARM 的交叉编译器：\n\narm-none-eabi：用于编译裸机程序或系统，这个是没有操作系统的，不支持那些系统调用等系列接口，可调用 `newlib` 库，适用于 ARM7/Cortex-M/Cortex-R。\n\narm-none-linux-gnueabi：用于编译 ARM 架构的 u-boot、Linux 内核、Linux 应用等，使用 `glibc` 库，适用于 ARM9/ARM11/Cortex-A。\n\narm-eabi： 用于安卓程序编译。\n\narmcc：早期 Keil 软件公司（现已被 ARM 公司收购）出品的支持[相应器件](https://www.keil.com/dd/)的编译工具，可以编译裸机程序，一般和 ARM 开发工具一起，Keil MDK 内置。\n\n\n\n# 基于 GCC 的 ARM 编译工具链提供商\n\n目前，为 ARM 平台提供交叉编译工具链的提供商，本人所找到的只有两家：ARM 官方和 Linaro 公司。\n\n## Arm GNU Toolchain\n\nARM 除了有自己的专用编译器之外，还维护了一套基于 GCC 的交叉编译工具链，被称为 Arm GNU Toolchain。截至于 2022 年，[Arm GNU Toolchain](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads) 被分为了 [A family](https://developer.arm.com/downloads/-/gnu-a)（GNU Toolchain for the Cortex-A Family） 和 [R & M family](https://developer.arm.com/downloads/-/gnu-rm)（GNU Arm Embedded Toolchain）两大类，但是自 2022 年开始，ARM 对其进行了统一。\n\n编译器的目标平台：\n\n- AArch32 bare-metal target：32 位纯裸机平台\n- AArch64 ELF bare-metal target：64 位纯裸机平台\n- AArch64 ELF bare-metal, big-endian target：64 位纯裸机平台（大端模式）\n- AArch64 GNU/Linux target：64 位 Linux 平台\n- AArch64 GNU/Linux big-endian target：64 位 Linux 平台（大端模式）\n- AArch32 target with soft float：32 位带软件模式浮点运算\n- AArch32 target with hard float：32 位带硬件模式浮点运算\n\n## Linaro Toolchain\n\nLinaro 是一间非营利性质的开放源代码软件工程公司，主要的目标在于开发不同半导体公司系统单片机（SoC）平台的共通软件。其维护的工具链下载地址为：https://snapshots.linaro.org/gnu-toolchain/ 。另外，从 https://www.linaro.org/downloads/ 的描述上看，目前 Linaro 仅针对于 Cortex-A 内核的编译工具链进行维护，而对用于 ARM 嵌入式处理器的 Cortex-R 和 Cortex-M 的最新裸机编译工具链，则需要去 ARM 官网下载！旧版可以在 http://releases.linaro.org/components/toolchain/binaries/ 中下载。\n\n\n\n## Yocto Toolchain\n\nYocto 为构建定制化的嵌入式 Linux 发行版提供一系列模板、工具和方法来简化定制 Linux 开发，允许更换软件配置和构建，避免重复工作 以及不必要的维护。Yocto鼓励跨各种应用程序和设备类型的创新，支持多种硬件架构，包括 X86(32 bit 和 64 bit)、ARM(32 bit 和 64 bit) 、RISC-V、PPC 和 MIPS 等。\n\nYocto 构建的交叉编译工具，蕴含了众多的第三方组件，因此在构建完整的系统的中，不需要花太多的时间去编译添加第三方组件；像 NXP 的 i.MX 系列的 SDK 固件包，就推荐使用 Yocto 搭建，同时给出基于 Yocto 定制的 i.MX 搭建环境。除此如果想用 Yocto 原生 Toolchain 可以到 http://downloads.yoctoproject.org/releases/yocto/?C=M&O=D 进行下载，先选择需要版本，在 `./toolchain/` 路径下选择相应的平台，一般后缀 `.sh` 文件为 Yocto Toolchain 的安装脚本。\n\n\n\n# Reference\n\nhttps://www.cnblogs.com/xiaotlili/p/3306100.html\n\nhttps://blog.csdn.net/ZCShouCSDN/article/details/89553323\n\nhttps://community.arm.com/arm-community-blogs/b/embedded-blog/posts/shrink-your-mcu-code-size-with-gcc-arm-embedded-4-7\n\nhttps://stackoverflow.com/questions/14737104/what-is-the-default-c-std-standard-version-for-the-current-gcc-especially-on-u\n\nhttps://ubuntuqa.com/article/10432.html\n\nhttps://www.amobbs.com/forum.php?mod=viewthread&tid=5709400\n\n\n\n# 附\n\nGNU win：https://gnuwin32.sourceforge.net/\n\nGNU software：https://www.gnu.org/software/software.zh-cn.html","tags":["gcc"]},{"title":"Linux 路由表说明","url":"/linux-routing-table/","content":"\n\n\n# route 命令\n\n选项：\n\n- `-v` ：显示详细信息。\n- `-n` ：不执行 DNS 反向查找（即不解析名称），直接显示数字形式的 IP 地址。\n- `-e` ：netstat 格式显示路由表。\n- `-C` ：打印 Linux 内核的路由缓存。\n\n- `add` ：增加路由记录 / `del` ：删除路由记录\n  - `-net` ：目的地址是一个网络。\n  - `-host` ：目的地址是一台主机。\n  - `netmask` ：目的地址的网络掩码。\n  - `gw` ：路由数据包通过的网关。\n  - `metric` ：设置路由跃点。\n\neg：\n\n1、添加主机路由\n\n```bash 添加主机路由 command:(\"[root@localhost] $\":1-2)\nroute add -net 10.0.0.10 netmask 255.255.255.255 gw 10.139.128.1 dev eth0\nroute -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n10.0.0.10       10.139.128.1    255.255.255.255 UGH   0      0        0 eth0\n...\n```\n\n2、添加网络路由\n\n```bash 添加网络路由 command:(\"[root@localhost] $\":1-2)\nroute add -net 10.0.0.0 netmask 255.255.255.0 gw 10.139.128.1 dev eth0\nroute -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n10.0.0.0        10.139.128.1    255.255.255.0   UG    0      0        0 eth0\n...\n```\n\n3、添加设置默认网关跃点为 80\n\n```bash 添加设置默认网关 command:(\"[root@localhost] $\":1-2)\nroute add default gw 192.168.1.1 metric 80\nroute -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0\n...\n```\n\n4、删除路由\n\n```bash 删除路由 command:(\"[root@localhost] $\":1)\nroute del default gw 192.168.1.1 metric 80\n```\n\n\n\n# 字段分析\n\n使用 `route` or `route -n` 命令查看内核路由表：\n\n```bash 命令行提示符 command:(\"[root@localhost] $\":1,8-9,16)\nroute\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         _gateway        0.0.0.0         UG    100    0        0 ens33\ndefault         _gateway        0.0.0.0         UG    1000   0        0 br0\n192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 br0\n192.168.29.0    0.0.0.0         255.255.255.0   U     0      0        0 ens33\n_gateway        0.0.0.0         255.255.255.255 UH    100    0        0 ens33\n\nroute -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         192.168.29.2    0.0.0.0         UG    100    0        0 ens33\n0.0.0.0         192.168.10.1    0.0.0.0         UG    1000   0        0 br0\n192.168.10.0    0.0.0.0         255.255.255.0   U     0      0        0 br0\n192.168.29.0    0.0.0.0         255.255.255.0   U     0      0        0 ens33\n192.168.29.2    0.0.0.0         255.255.255.255 UH    100    0        0 ens33\n\n```\n\n字段分类说明：\n\n| 字段        | 说明                                                         |\n| :---------- | :----------------------------------------------------------- |\n| Destination | 目标网络或目标主机。Destination 为 default（`0.0.0.0`）时，表示这个是默认网关，所有数据都发到这个网关（这里是 `10.139.128.1`）。 |\n| Gateway     | 网关地址，`0.0.0.0` 表示当前记录对应的 Destination 跟本机在同一个网段，通信时不需要经过网关（同一个局域网内2台主机通信不需要经过网关）。 |\n| Genmask     | Destination 字段的网络掩码，Destination 是主机时需要设置为 `255.255.255.255` ，是默认路由时会设置为 `0.0.0.0` 。 |\n| Flags       | 见下文说明。                                                 |\n| Metric      | 跃点，指到达指定网络所需的中转数，是大型局域网和广域网设置所必需的 （不在 Linux 内核中使用）。 |\n| Ref         | 路由项引用次数 （不在 Linux 内核中使用）。                   |\n| Use         | 此路由项被路由软件查找的次数。                               |\n| Iface       | 网卡名字，例如 `eth0` ；要去往这个网段需要使用哪一个网络接口。也就是 `eth0` 这张网卡。 |\n\n可以看到 Flags 下面有许多字母组合，他们分别的含义是：\n\n- **U (route is up)** ：该路由处于活跃；\n\n- **H (target is a host)** ：目标是一部主机 (IP) 而非网域（子网掩码是 255.255.255.255）；\n\n- **G (use gateway)** ：需要透过外部的主机 (gateway) 来转递封包（一般指向默认网关）；\n\n- **R (reinstate route for dynamic routing)** ：使用动态路由时，恢复路由资讯的旗标；\n\n- **D (dynamically installed by daemon or redirect)** ：已经由服务或转 port 功能设定为动态路由\n\n- **M (modified from routing daemon or redirect)** ：路由已经被修改了；\n\n- **! (reject route)** ：这个路由将不会被接受（用来抵挡不安全的网域）。\n\n\n\n# 路由种类\n\n| 路由类型 | 子网掩码        | Flag字段 | 描述                                                         |\n| :------- | :-------------- | :------- | :----------------------------------------------------------- |\n| 主机路由 | 255.255.255.255 | UH       | 指向单个 IP 地址或主机名的路由记录                           |\n| 网络路由 | 255.255.255.0   | U        | 代表主机可以到达的网络，比如说目的地址是 `192.168.10.xxx`    |\n| 默认路由 | 0.0.0.0         | UG       | 当主机不能在路由表中查找到目标主机的 IP 时，数据包就发到默认路由上 |\n\n","tags":["Linux"]},{"title":"SQLite 知识整理","url":"/sqlite-summarize/","content":"\n\n\n# SQLite 类型\n\n**1、存储类**\n\nSQLite 存储类属性划分为以下几种类型：\n\n| 类型    | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| NULL    | 表示该值为 NULL 值。                                         |\n| INTEGER | 无符号整型值，根据值的大小存储在 1、2、3、4、6 或 8 字节中。 |\n| REAL    | 浮点值，存储为 8 字节的 IEEE 浮点数字。                      |\n| TEXT    | 文本字符串，使用 UTF-8、UTF-16BE 或 UTF-16LE 编码方式存储。  |\n| BLOB    | 存储 Blob 数据，该类型数据和输入数据完全相同。               |\n\n**2、数据类型**\n\n- 布尔数据类型：\n  SQLite 并没有提供专门的布尔存储类型，取而代之的是存储整型 1 表示 true，0 表示 false。\n\n- 日期和时间数据类型：\n  和布尔类型一样，SQLite 也同样没有提供专门的日期时间存储类型，而是以 TEXT、REAL 和 INTEGER 类型分别不同的格式表示该类型，如：\n  **TEXT** : \"YYYY-MM-DD HH:MM:SS.SSS\"。\n  **REAL** ：以 Julian 日期格式存储。\n  **INTEGER** ：以 Unix 时间形式保存数据值，即从 1970-01-01 00:00:00 到当前时间所流经的秒数。\n\n**3、类型亲缘性（Type Affinity）**\n\n为了最大限度地提高 SQLite 和其他数据库引擎之间的兼容性，SQLite 支持 “类型亲缘性” 的概念。使其它 SQL 数据库引擎能在 SQLite 上运行；在表字段被声明之后，SQLite 都会根据该字段声明时的类型为其选择一种亲缘类型，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式，除非亲缘类型不匹配或无法转换当前数据到该亲缘类型，这样 SQLite 才会考虑其它更适合该值的类型存储该值。\n\nSQLite 3 数据库中支持分配的类型关联：\n\n- TEXT\n- NUMERIC\n- INTEGER\n- REAL\n- BLOB\n\n决定规则：\n\n1. 如果声明的类型包含字符串 “INT”，则它分配为 `INTEGER` 。\n2. 如果声明的类型包含任意字符串 “CHAR”、“CLOB” 或 “TEXT” 的关键字，则被分配为 `TEXT` 。请注意，VARCHAR 类型包含字符串 “CHAR”，因此被分配为 `TEXT` 。\n3. 如果声明的类型包含字符串 “BLOB”，或者如果未指定类型，则被分配为 `BLOB` 。\n4. 如果声明的类型包含任意字符串 “REAL”、“FLOA” 或 “DOUB” 的关键字，则被分配为 `REAL` 。\n5. 其余情况下，归类为 `NUMERIC` 。\n\nnote：请注意，确定类型亲缘性的规则顺序很重要。声明类型为 “CHARINT” 的字段将同时匹配规则 1 和 2，但第一条规则采用优先权，所以会被分配为 `INTEGER` 。\n\n示例：\n\n| 声明的类型                                                   | 类型亲缘性 | 规则优先级 |\n| :----------------------------------------------------------- | :--------- | ---------- |\n| INT <br/>INTEGER <br/>TINYINT <br/>SMALLINT <br/>MEDIUMINT <br/>BIGINT <br/>UNSIGNED <br/>BIG <br/>INT <br/>INT2 <br/>INT8 | INTEGER    | 1          |\n| CHARACTER(20) <br/>VARCHAR(255) <br/>VARYING <br/>CHARACTER(255) <br/>NCHAR(55) <br/>NATIVE <br/>CHARACTER(70) <br/>NVARCHAR(100) <br/>TEXT <br/>CLOB | TEXT       | 2          |\n| BLOB <br/>*no datatype specified*                            | BLOB       | 3          |\n| REAL <br/>DOUBLE <br/>DOUBLE <br/>PRECISION <br/>FLOAT       | REAL       | 4          |\n| NUMERIC <br/>DECIMAL(10,5) <br/>BOOLEAN <br/>DATE <br/>DATETIME | NUMERIC    | 5          |\n\n\n\n# 数据表查询\n\n**1、查看所有表名**\n\n`SELECT * FROM sqlite_master WHERE type='table' ORDER BY name;`\n\nsqlite_master 是一个特殊表, 属于系统表；存放在根页中，每一个数据库的 `.db` 文件都有一个 sqlite_master 表。该表存放了 `.db` 中所有表的相关信息，并只有只读权限，写操作由系统自动执行，使用者没有写的执行权限；其结构如下：\n\n```c\nCREATE TABLE sqlite_master (\n    type TEXT, // 记录项目的类型，如：表(table), 索引(index), 视图(view), 触发器(trigger)\n    name TEXT, // 记录项目的名称，如表名、索引名等\n    tbl_name TEXT, // 记录所从属的表名，如索引所在的表名。对于表来说，该列就是表名本身\n    rootpage INTEGER, // 记录项目在数据库页中存储的编号。对于视图和触发器，该列值为 0 或者 NULL\n    sql TEXT // 记录创建该项目的 SQL 语句\n);\n```\n\n**2、查看表的字段**\n\n`PRAGMA table_info(table_name);`\n\n其中 [table_name] 为待查数据表名。\n\n**3、查看整表数据**\n\n`SELECT * FROM table_name;`\n\n其中 [table_name] 为待查数据表名。\n\n\n\nnote：参数传入，字符串用单引号包括。\n\n\n\n# C / C++ 接口函数\n\n## Errors 码\n\n```c\n#define SQLITE_OK           0   /* 成功 */\n/* 错误码 */\n#define SQLITE_ERROR        1   /* sql错误或丢失的数据库，SQL error or missing database */\n#define SQLITE_INTERNAL     2   /* sqlite内部逻辑错误，Internal logic error in SQLite */\n#define SQLITE_PERM         3   /* 拒绝访问，Access permission denied */\n#define SQLITE_ABORT        4   /* 回调函数请求取消操作，Callback routine requested an abort */\n#define SQLITE_BUSY         5   /* 数据库文件被锁定，The database file is locked */\n#define SQLITE_LOCKED       6   /* 数据库的一个表被锁定，A table in the database is locked */\n#define SQLITE_NOMEM        7   /* 某次malloc函数调用失败，A malloc() failed */\n#define SQLITE_READONLY     8   /* 尝试写入一个只读数据库，Attempt to write a readonly database */\n#define SQLITE_INTERRUPT    9   /* 操作sqlite3_interrupt函数被中断，Operation terminated by sqlite3_interrupt()*/\n#define SQLITE_IOERR       10   /* 发生磁盘I/O错误，Some kind of disk I/O error occurred */\n#define SQLITE_CORRUPT     11   /* 数据库磁盘映像不正确，The database disk image is malformed */\n#define SQLITE_NOTFOUND    12   /* 找不到表或记录，NOT USED. Table or record not found */\n#define SQLITE_FULL        13   /* 数据库满而插入失败，Insertion failed because database is full */\n#define SQLITE_CANTOPEN    14   /* 无法打开数据库，Unable to open the database file */\n#define SQLITE_PROTOCOL    15   /* 数据库锁定协议错误，NOT USED. Database lock protocol error */\n#define SQLITE_EMPTY       16   /* 数据库为空，Database is empty */\n#define SQLITE_SCHEMA      17   /* 数据库结构发生改变，The database schema changed */\n#define SQLITE_TOOBIG      18   /* 数据大小超限，String or BLOB exceeds size limit */\n#define SQLITE_CONSTRAINT  19   /* 约束违反，Abort due to constraint violation */\n#define SQLITE_MISMATCH    20   /* 数据类型不匹配，Data type mismatch */\n#define SQLITE_MISUSE      21   /* 库使用不正确，Library used incorrectly */\n#define SQLITE_NOLFS       22   /* 使用了操作系统不支持的功能，Uses OS features not supported on host */\n#define SQLITE_AUTH        23   /* 授权失败，Authorization denied */\n#define SQLITE_FORMAT      24   /* 附加数据库格式错误，Auxiliary database format error */\n#define SQLITE_RANGE       25   /* sqlite3_bind的第2给参数超出范围，2nd parameter to sqlite3_bind out of range */\n#define SQLITE_NOTADB      26   /* 不是数据库文件，File opened that is not a database file */\n#define SQLITE_NOTICE      27   /* Notifications from sqlite3_log() */\n#define SQLITE_WARNING     28   /* Warnings from sqlite3_log() */\n#define SQLITE_ROW         100  /* sqlite3_step产生一个就绪行，sqlite3_step() has another row ready */\n#define SQLITE_DONE        101  /* sqlite3_step执行完成，sqlite3_step() has finished executing */\n```\n\n\n\n## API 函数\n\n以下只列举嵌入式环境下常用的 API：\n\n### sqlite3_open\n\n```c\nSQLITE_API int sqlite3_open(\n  const char *filename,   /* Database filename (UTF-8) */\n  sqlite3 **ppDb          /* OUT: SQLite db handle */\n);\n```\n\n该函数用于打开由 `filename` 参数指定的 SQLite 数据库文件，并返回一个 `*ppDb` 数据库连接句柄，即使发生错误；`filename` 为 UTF-8 编码，如果 SQLite 无法分配内存来保存 sqlite3 对象，则会在 `*ppDb` 中写入一个 NULL，而不是指向 sqlite3 对象的指针。如果数据库成功打开，则返回 SQLITE_OK。否则返回错误代码。sqlite3_errmsg() 可用于获取任何 sqlite3_open() 执行失败后错误的英文描述。\n\n如果 `filename` 参数是 `':memory:'` ，那么 sqlite3_open() 将会在 RAM 中创建一个内存数据库，这只会在数据库连接关闭前持续。\n\n如果 `filename` 参数是 `''` （空字符串），则将创建一个专用的临时磁盘数据库；一旦数据库连接关闭，此专用数据库将被自动删除。\n\n### sqlite3_close\n\n```c\nSQLITE_API int sqlite3_close(sqlite3*);\n```\n\n该函数与 sqlite3_open 函数相对应，用于关闭之前调用 sqlite3_open() 打开的数据库连接，此时所有与连接相关的语句都应在连接关闭之前完成。\n\n如果还有查询没有完成，sqlite3_close() 将返回 SQLITE_BUSY 禁止关闭的错误消息；当成功执行，将销毁 sqlite3 对象并释放所有关联资源时返回 SQLITE_OK。\n\n### sqlite3_exec\n\n```c\nSQLITE_API int sqlite3_exec(\n  sqlite3*,                                  /* An open database */\n  const char *sql,                           /* SQL to be evaluated */\n  int (*callback)(void*,int,char**,char**),  /* Callback function */\n  void *,                                    /* 1st argument to callback */\n  char **errmsg                              /* Error msg written here */\n);\n```\n\nsqlite3_exec() 提供了一个执行 SQL 命令的快捷方式，SQL 命令由 `*sql` 参数提供；它是 sqlite3_prepare_v2() 、sqlite3_step() 和 sqlite3_finalize() 的包装函数，允许应用程序运行多个 SQL 语句，而无需编写大量 C 代码。\n\nsqlite3_exec() 程序解析并执行由 `*sql` 参数所给的每个命令，直到字符串结束或者遇到错误为止。此参数等同于使用 shell 实现所有的 sqlite 功能命令，所以这个 `*sql` 就是对应 sqlite 功能命令的 “字符串”。\n\n`callback` 是执行 `*sql` 对应的功能命令后，所调取的函数，即回调函数；用于将执行结果进行分析处理。其原型如下：\n\n`typedef int (*sqlite3_callback)(void *data, int argc, char **argv, char **azColName);`\n\n**sqlite3_callback** 参数：\n\n- data：由 sqlite3_exec 传入的参数 `void*` ，或者说是指针参数。\n- argc：查询到的这一条记录由多少个字段（多少列）。\n- argv：该参数是双指针，查询出来的数据都保存在这里，它是一个一维数组，每一个元素都是一个 `char*`  ,是一个字段内容，所以这个参数就可以不是单字节，而是可以为字符串等不定长度的数值，用字符串表示，以 `'\\0'` 结尾。\n- azColName：该参数是双指针，与 `argv` 是对应的，表示这个字段的字段名称。\n\nnote：除 `data` 传入参数外，回调函数的其它参数一定是 SQL 命令执行结果的进一步处理；此外，需要特别注意的是：回调函数多数时候不是执行 1 次，而是会循环执行 n 次，例如当我们执行 SELECT 命令时，往往输出的结果会是多行，假设有 n 行，那么就会执行 n 次回调函数。\n\n实例：\n\n```c\n#include <stdio.h>\n#include <sqlite3.h>\n\nstatic int callback(void *NotUsed, int argc, char **argv, char **azColName){\n  int i;\n  for(i=0; i<argc; i++){\n    printf(\"%s = %s\\n\", azColName[i], argv[i] ? argv[i] : \"NULL\");\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\nint main(int argc, char **argv){\n  sqlite3 *db;\n  char *zErrMsg = 0;\n  int rc;\n\n  if( argc!=3 ){\n    fprintf(stderr, \"Usage: %s DATABASE SQL-STATEMENT\\n\", argv[0]);\n    return(1);\n  }\n  rc = sqlite3_open(argv[1], &db);\n  if( rc ){\n    fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n    sqlite3_close(db);\n    return(1);\n  }\n  rc = sqlite3_exec(db, argv[2], callback, NULL, &zErrMsg);\n  if( rc!=SQLITE_OK ){\n    fprintf(stderr, \"SQL error: %s\\n\", zErrMsg);\n    sqlite3_free(zErrMsg);\n  }\n  sqlite3_close(db);\n  return 0;\n}\n```\n\n### sqlite3_get_table\n\n```c\nSQLITE_API int sqlite3_get_table(\n  sqlite3 *db,          /* An open database */\n  const char *zSql,     /* SQL to be evaluated */\n  char ***pazResult,    /* Results of the query */\n  int *pnRow,           /* Number of result rows written here */\n  int *pnColumn,        /* Number of result columns written here */\n  char **pzErrmsg       /* Error msg written here */\n);\n```\n\n在最新的文档中，表明这该函数是一个传统的 API，保留该 API 是为了向后兼容；因此，不建议使用此接口。\n\n输入参数：\n\n- db：打开数据库文件后返回的句柄。\n\n- zSql：需要执行的 SQL 命令字符串。\n- pazResult：对字符串数组的引用。使用此引用传回查询结果。传回的值必须通过调用 `sqlite3_free_table()` 。\n- pnRow：查询返回的行数，不包括列名。\n- pnColumn：查询返回的列数。\n- pzErrmsg：对字符串的可选引用。如果发生错误，引用将被设置为一条错误消息。该应用程序负责 释放的消息 `sqlite3_free()` 。如果没有错误发生，引用将被设置为 NULL。引用可能为 NULL。\n\n和 sqlite3_exec() 这种使用回调函数的方式不同，sqlite3_get_table() 的功能要显得更加简便。它通过控制语句的传入，直接将参数赋值给指针传出。\n\nnote：虽然 sqlite3_get_table() 的使用较于 sqlite3_exec() 更为简便，但官方不推荐使用的，在实际当中它更趋于用作测试 API，并且根据官方建议，推荐使用 sqlite3_prepare_v2()、sqlite3_column_xxx() 这些 API 组合。\n\n### sqlite3_free_table\n\n```c\nSQLITE_API void sqlite3_free_table(char **result);\n```\n\n该函数与 sqlite3_get_table 函数相对应，在应用程序完成 sqlite3_get_table 的结果使用后，它必须将查询结果的指针 `pazResult` 传递给 sqlite3_free_table() 以释放分配的内存。\n\n### sqlite3_prepare_v2\n\n```c\nSQLITE_API int sqlite3_prepare_v2(\n  sqlite3 *db,            /* Database handle */\n  const char *zSql,       /* SQL statement, UTF-8 encoded */\n  int nByte,              /* Maximum length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */\n  const char **pzTail     /* OUT: Pointer to unused portion of zSql */\n);\n```\n\n输入参数：\n\n- db：从先前成功调用 sqlite3_open（）、sqlite3_open v2（）或sqlite3_open16（）获得的 SQLite 数据库。\n- zSql：要执行的 SQL 语句（可以包含未赋值的变量）\n- nByte：如果 `nByte` 参数为负，则 `zSql` 被读取到第一个空结束终止符。如果 `nByte` 为正，则它是从 `zSql` 读取的字节数。\n- ppStmt：解析编译出的 SQL 语句实例。\n- pzTail：如果 `pzTail` 不为空，那么 `*pzTail` 将指向 `zSql` 中第一个 SQL 语句结束后的第一个字节。\n\n### sqlite3_bind_xxx\n\n```c\nSQLITE_API int sqlite3_bind_blob(      sqlite3_stmt* stmt, int pidx, const void*          val, int            bytes, mem_callback);\nSQLITE_API int sqlite3_bind_blob64(    sqlite3_stmt* stmt, int pidx, const void*          val, sqlite3_uint64 bytes, mem_callback);\nSQLITE_API int sqlite3_bind_double(    sqlite3_stmt* stmt, int pidx, double               val);\nSQLITE_API int sqlite3_bind_int(       sqlite3_stmt* stmt, int pidx, int                  val);\nSQLITE_API int sqlite3_bind_int64(     sqlite3_stmt* stmt, int pidx, sqlite3_int64        val);\nSQLITE_API int sqlite3_bind_null(      sqlite3_stmt* stmt, int pidx);\nSQLITE_API int sqlite3_bind_text(      sqlite3_stmt* stmt, int pidx, const char*          val, int            bytes, mem_callback);\nSQLITE_API int sqlite3_bind_text16(    sqlite3_stmt* stmt, int pidx, const void*          val, int            bytes, mem_callback);\nSQLITE_API int sqlite3_bind_text64(    sqlite3_stmt* stmt, int pidx, const char*          val, sqlite3_uint64 bytes, mem_callback, unsigned char encoding);\nSQLITE_API int sqlite3_bind_value(     sqlite3_stmt* stmt, int pidx, const sqlite3_value* val);\n// SQLITE_API int sqlite3_bind_pointer(   sqlite3_stmt*, int, void*, const char*,void(*)(void*));\nSQLITE_API int sqlite3_bind_zeroblob(  sqlite3_stmt* stmt, int pidx,                           int            bytes);\nSQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt* stmt, int pidx,                           sqlite3_uint64 bytes);\n\n\nvoid mem_callback( void* ptr );\n```\n\n用于绑定任何参数值。\n\n- stmt：指向一个被 sqlite3_prepare_v2() 等接口编译的语句句柄，它可被 sqlite3_step() 执行。最后用 sqlite3_finalize() 来释放它。\n- pidx：SQL 参数（每列元素）的索引值，参数索引值从 1 开始。\n- val：要绑定的数据值。\n- bytes：数据值的大小，以字节（不是字符）为单位。通常，长度不包括任何空结束符。如果 `val` 是一个以空结束的字符串，把该值设为为负值（-1），则会自动计算长度。\n- mem_callback：一个指向内存释放函数的函数指针。此函数用于在 SQLite 处理完BLOB 或 string 之后对其进行处理，主要用来释放 `val` 的内存缓冲区；如果缓冲区是用 sqlite3_malloc() 分配的，则可以直接传递对 sqlite3_free() 的引用。也可以使用特殊标志 `SQLITE_STATIC` 和 `SQLITE_TRANSIENT` ；`SQLITE_STATIC` 说明数据值为常量，位于静态的非托管空间中，不需要释放，而 `SQLITE_TRANSIENT` 会使得对  `val` 数据做一份拷贝。\n\n### sqlite3_step\n\n```c\nSQLITE_API int sqlite3_step(sqlite3_stmt*);\n```\n\n在调用 sqlite3_prepare_v2() 等接口编译的语句句柄后，必须调用此函数一次或多次以计算语句。\n\n返回值：\n\n- SQLITE_BUSY：忙碌，数据库引擎无法锁定数据去完成其工作。可以重试该语句。\n- SQLITE_DONE：意味着 SQL 语句执行完成且成功。一旦执行成功后，sqlite3_step() 就不应该被再次调用执行，除非我们使用 sqlite3_reset() 重置 `sqlite3_stmt` 数据。\n- SQLITE_ROW：当返回的行数据较多时会出现，代表获得了一条有效数据行，此时可以通过 sqlite3_column_xxx 函数来取得数据；再次调用 sqlite3_step() 可取得下一条查询结果，直至返回 `SQLITE_DONE` 。\n\n- SQLITE_ERROR：表示发生了运行时错误（例如约束冲突），此时可以通过 sqlite3_errmmsg() 取得相关的错误信息，并且不应再次调用 sqlite3_step() 。\n\n- SQLITE_MISUSE：意味着这个例程被不适当地调用。可能是在已完成的准备好的语句上调用的，也可能是在以前返回 `SQLITE_ERROR` 或 `SQLITE_DONE` 的语句上调用的。或者可能是同一数据库连接同时被两个或多个线程使用。\n\n### sqlite3_column_xxx\n\n```c\nSQLITE_API const void*          sqlite3_column_blob(  sqlite3_stmt* stmt, int cidx);\nSQLITE_API double               sqlite3_column_double( sqlite3_stmt* stmt, int cidx);\nSQLITE_API int                  sqlite3_column_int(    sqlite3_stmt* stmt, int cidx);\nSQLITE_API sqlite3_int64        sqlite3_column_int64(  sqlite3_stmt* stmt, int cidx);\nSQLITE_API const unsigned char* sqlite3_column_text(  sqlite3_stmt* stmt, int cidx);\nSQLITE_API const void*          sqlite3_column_text16(sqlite3_stmt* stmt, int cidx);\nSQLITE_API sqlite3_value*       sqlite3_column_value( sqlite3_stmt* stmt, int cidx);\nSQLITE_API int                  sqlite3_column_bytes(  sqlite3_stmt* stmt, int cidx);\nSQLITE_API int                  sqlite3_column_bytes16(sqlite3_stmt* stmt, int cidx);\nSQLITE_API int                  sqlite3_column_type(   sqlite3_stmt* stmt, int cidx);\n```\n\n用于从当前结果行中提取列值。\n\n- stmt：指向一个被 sqlite3_prepare_v2() 等接口编译的语句句柄，它可被 sqlite3_step() 执行。最后用 sqlite3_finalize() 来释放它。\n- cidx：SQL 参数（每列元素）的索引值，参数索引值从 0 开始。\n\n返回结果：\n\n| API 函数                   |      | 结果值                                                       |\n| :------------------------- | :--: | :----------------------------------------------------------- |\n| **sqlite3_column_blob**    |  →   | BLOB                                                         |\n| **sqlite3_column_double**  |  →   | REAL                                                         |\n| **sqlite3_column_int**     |  →   | 32 位 INTEGER                                                |\n| **sqlite3_column_int64**   |  →   | 64 位 INTEGER                                                |\n| **sqlite3_column_text**    |  →   | UTF-8 TEXT                                                   |\n| **sqlite3_column_text16**  |  →   | UTF-16 TEXT                                                  |\n| **sqlite3_column_value**   |  →   | 作为 [未受保护的 sqlite3_value](https://www.sqlite.org/c3ref/value.html) 对象 |\n|                            |      |                                                              |\n| **sqlite3_column_bytes**   |  →   | BLOB 或 UTF-8 TEXT 的字节大小                                |\n| **sqlite3_column_bytes16** |  →   | UTF-16 TEXT 的字节大小                                       |\n| **sqlite3_column_type**    |  →   | 默认数据的类型                                               |\n\n### sqlite3_reset\n\n```c\nSQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);\n```\n\n用于重置 `sqlite3_stmt` 数据，然后准备被重新执行。任何使用 sqlite3_bind_xxx 函数将值绑定到它们的 SQL 语句变量都将保留它们的值。使用 sqlite3_clear_bindings() 重置绑定。\n\n返回值：\n\n- SQLITE_BUSY\n- SQLITE_DONE\n- SQLITE_ROW\n\n\n\n## 操作流程\n\n使用 SQLite 数据库，最典型的函数操作流程（伪代码）：\n\n```c 伪代码\n/* create a statement from an SQL string */\nsqlite3_stmt *stmt = NULL;\n\nif ( sqlite3_prepare_v2( db, sql_str, sql_str_len, &stmt, NULL ) == SQLITE_OK )\n{\n    /* use the statement as many times as required */\n    while( ... )\n    {\n        /* bind any parameter values */\n        sqlite3_bind_xxx( stmt, param_idx, param_value... );\n        ...\n        /* execute statement and step over each row of the result set */\n        while ( sqlite3_step( stmt ) == SQLITE_ROW )\n        {\n            /* extract column values from the current result row */\n            col_val = sqlite3_column_xxx( stmt, col_index );\n            ...\n        }\n    \n        /* reset the statement so it may be used again */\n        sqlite3_reset( stmt );\n        sqlite3_clear_bindings( stmt );  /* optional */\n    }\n}\n\n/* destroy and release the statement */\nsqlite3_finalize( stmt );\n```\n\na、`sqlite3_prepare` 创建一个预处理对象。\n\nb、`sqlite3_bind_xxx` 绑定参数。\n\nc、循环执行 `sqlite3_step` 获取数据。\n\nd、`sqlite3_column` 从数据中取出每一段。\n\ne、释放 `sqlite3_finalize` 。\n\n**1、插入**\n\n`sqlite3_open` -> `sqlite3_prepare_v2` -> `sqlite3_bind_xxx` -> `sqlite3_step` -> `sqlite3_reset` -> `sqlite3_finalize` -> `sqlite3_close`\n\n**2、查询**\n\n`sqlite3_open` -> `sqlite3_prepare_v2` -> `sqlite3_step` -> `sqlite3_column_xxx` -> `sqlite3_finalize` -> `sqlite3_close`\n\n**3、例子**\n\n略略略\n\n\n\n# 常用命令\n\n**1、筛选删除最早的 n 项记录，或留下最新的 n 项记录**\n\n\nIf you use an auto-increment field, you can easily write this to delete the oldest 100 records:\n\n```\nDELETE FROM mytable WHERE id IN (SELECT id FROM mytable ORDER BY id ASC LIMIT 100)\n```\n\nOr, if no such field is present, use `ROWID` :\n\n```\nDELETE FROM mytable WHERE ROWID IN (SELECT ROWID FROM mytable ORDER BY ROWID ASC LIMIT 100)\n```\n\nOr, to leave only the latest 1000 records:\n\n```\nDELETE FROM mytable WHERE ROWID IN (SELECT ROWID FROM mytable ORDER BY ROWID DESC LIMIT -1 OFFSET 1000)\n```\n\n**2、字符串中特殊字符自动转义处理**\n\nFor example, assume the string variable zText contains text as follows:\n\n```\nchar *zText = \"It's a happy day!\";\n```\n\nOne can use this text in an SQL statement as follows:\n\n```\nchar *zSQL = sqlite3_mprintf(\"INSERT INTO table VALUES('%q')\", zText);\nsqlite3_exec(db, zSQL, 0, 0, 0);\nsqlite3_free(zSQL);\n```\n\nBecause the %q format string is used, the '\\'' character in zText is escaped and the SQL generated is as follows:\n\n```\nINSERT INTO table1 VALUES('It''s a happy day!')\n```\n\nThis is correct. Had we used %s instead of %q, the generated SQL would have looked like this:\n\n```\nINSERT INTO table1 VALUES('It's a happy day!');\n```\n\nThis second example is an SQL syntax error. As a general rule you should always use %q instead of %s when inserting text into a string literal.\n\n\n\n# 参考\n\n[An Introduction To The SQLite C/C++ Interface](https://sqlite.org/cintro.html)\n\n[C-language Interface Specification for SQLite](https://sqlite.org/capi3ref.html)\n\n[Datatypes In SQLite](https://www.sqlite.org/datatype3.html)\n\n[Using sqlite3_bind_xxx()](https://www.oreilly.com/library/view/using-sqlite/9781449394592/re229.html)\n\n[Using sqlite3_column_xxx()](https://www.oreilly.com/library/view/using-sqlite/9781449394592/re244.html)\n\n[Write Programs That Use SQLite](https://sqlite.org/quickstart.html)\n\n[SQLite常用API(C)](https://juejin.cn/post/6912699613812097031#heading-21)\n\n[Delete oldest records from database](https://stackoverflow.com/questions/3667085/delete-oldest-records-from-database)\n\n[Formatted String Printing Functions](https://devdoc.net/database/sqlite-3.0.7.2/c3ref/mprintf.html)","tags":["SQL"]},{"title":"Linux 系统构成：bootloader、kernel、rootfs","url":"/linux-system-constitute/","content":"\n\n\n# 前言\n\n完整的 linux 系統需要以下部分：\n+ Bootloader\n  + boot.img\n+ Linux Kernel（Linux内核）\n  - Device tree blob\n+ Root Filesystem（根目录文件系統）\n\n\n\n# bootloader\nbootloader（引导装载程序）就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境设置成一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。\n\n常见的 bootloader 有 PC 平台的 Grub；嵌入式平台的 vivi, RedBoot, u-boot 等，其中 u-boot 在使用上最广泛，因此在嵌入式中又常称 linux 系统构成为 u-boot、kernel、rootfs。\n\nbootloader 是严重地依赖于硬件而实现的，特别是在嵌入式系统。因此，在嵌入式系统里建立一个通用的 bootloader 几乎是不可能的。尽管如此，我们仍然可以对 bootloader 归纳出一些通用的概念来，以指导用户进行特定的 bootloader 设计与实现。\n\n在嵌入式系统中，bootloader 的意义与作用相当于 PC 平台中的 BIOS + Grub，它对开发板上的主要部件如 CPU、SDRAM、FLASH、串口等进行了初始化，可以使用 bootloader 下载文件到开发板，可以浏览目录，可以烧录 flash，可以启动系统等，实际上，一个功能比较强大的 bootloader 已经相当于一个微型的操作系统了。\n\n总体上 bootloader 需要完成以下工作：\n\n+ 初始化 CPU 速度；\n\n+ 初始化内存，包括初始化内存配置寄存器等；\n\n+ 初始化中断控制器，在系统启动时，关闭中断，关闭看门狗；\n\n+ 初始化串行端口（如果在目标上有的话）；\n\n+ 启用指令/数据高速缓存；\n\n+ 设置堆栈指针；\n\n+ 设置参数区域并构造参数结构和标记（这是重要的一步，因为内核在标识根设备、页面大小、内存大小以及更多内容时可能需要使用引导参数）；\n\n+ 执行 POST（加电自检）来标识存在的设备并报告有何问题；\n\n+ 为电源管理提供挂起/恢复支持；\n\n+ 传输操作系统内核镜像文件到目标机。也可以将操作系统内核镜像文件事先存放在 Flash 中，这样就不需要 bootLoader 和主机传输操作系统内核镜像文件，这通常是在做成产品的情况下使用。而一般在开发过程中，为了调试内核的方便，不将操作系统内核镜像文件固化在 Flash 中，这就需要主机和目标机进行文件传输；\n\n+ 跳转到内核的开始，在此又分为 ROM 启动和 RAM 启动。所谓 ROM启动就是用 XIP 技术直接在 Flash 中执行操作系统镜像文件；所谓RAM启动就是指把内核镜像从 Flash 复制到 RAM 中，然后再将 PC 指针跳转到 RAM 中的操作系统启动地址。\n\n目前使用的主流**嵌入式平台**，几乎都是用 u-boot 作为启动引导，u-boot 有哪些突出的优点呢？\n\n① 开放源码：https://github.com/u-boot/u-boot；\n\n② 支持多种嵌入式操作系统内核，如 Linux、NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android；\n\n③ 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS；\n\n④ 较高的可靠性和稳定性；\n\n⑤ 高度灵活的功能设置，适合 u-boot 调试、操作系统不同引导要求、产品发布等；\n\n⑥ 丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等；\n\n⑦ 较为丰富的开发调试文档与强大的网络技术支持。\n\n\n\n\n# kernel\nkernel 即 linux 内核。内核源代码可以免费从[官网](https://www.kernel.org/)获取，这是一个通用的内核，里面包含着内核支持的所有的硬件平台及驱动的所有代码，是一个大而全的内核源代码。\n\n在使用层面上，当嵌入式平台使用 linux 系统，那么最重要的就是 kernel 中驱动的移植；一般都不会从一个纯净的 kernel 中去进行移植操作，而是根据芯片厂商提供的 kernel 对特定的硬件平台及设备进行各种外设驱动相关的适配工作。\n\n\n\n## Device Tree\n设备树（Device Tree）是描述计算机的特定硬件设备信息的数据结构，以便于操作系统的内核可以管理和使用这些硬件，包括 CPU 或 CPU，内存，总线和其他一些外设。\n\n老版本的 linux kernel 是没有设备树概念的，后来因为 SOC 的发展，kernel 中需要对这些新增的 SOC 进行支持，而这些代码都会编译到 kernel 中，会导致 kernel 日渐臃肿，于是后面就引入了在 PowerPC 等架构就已经采用的设备树。\n\n**1、dts(device tree source 设备树源文件)**\ndts文件是一种 ASCII 文本格式的设备树描述文件，此文件适合人类阅读主要是给用户看的。一个 `.dts` 文件对应一个 ARM 的设备，一般放置在 `arch/arm/boot/dts/` 中。\n\n**2、dtsi(device tree source include 设备树头文件)**\n由于 `.dts` 中包含了很多公共部分，linux 内核为了简化，将 Soc 公共部分提炼为 `.dtsi` 文件，类似 c 语言中的 `.h` 文件。当然，和C语言的头文件类似，.dtsi也可以 include 其他的 `.dtsi` ，譬如几乎所有的 ARM SoC 的 `.dtsi` 都引用了`skeleton.dtsi` 。对于同一个节点的设置情况，`.dts` 中的配置会覆盖 `.dtsi` 中的配置；因此，`.dtsi` 一般写 Soc 共性部分，而 `.dts` 一般写目标单板特性部分，所以一般 `.dts` 包含并重写部分 `.dtsi`。\n\n**3、dtb(device tree blob 设备树二进制文件)**\n`.dts` 通过 dtc 编译工具编译成 `.dtb` 文件，被编译后的设备树文件与内核一同放入到存储介质中，当内核启动时读取设备树文件，就可以动态的将板级信息写入到内核中。\n\n\n\n# rootfs\nrootfs（Root Filesystem）即根目录文件系统，是 kernel 启动后挂载的第一个文件系统。rootfs 和 kernel 是分开的，但单独的 kernel 没有 rootfs 是没法正常工作的。在系统终端执行 `cd /` 即可看到当前的文件系统内容了。\n\n现在有许多制作 rootfs 的工具，如 busybox，buildroot，Yocto 等。其中 buildroot 中包含了 busybox 的功能，只需要简单的操作就可以生成一个 rootfs 了。\n\n\n\n# 参考\n[完整的linux系統：bootloader、linux kernel（linux內核）、rootfile（根文件系統）](https://q248269673.pixnet.net/blog/post/69570279)\n\n[嵌入式linux应用开发](http://www.embeddedlinux.org.cn/emblinuxappdev/)\n\n[Linux 筆記 2](https://hackmd.io/@a29654068/HJ1uUYE8r)\n\n[What is the difference between .dts file and .dtsi file?](https://stackoverflow.com/questions/48420126/what-is-the-difference-between-dts-file-and-dtsi-file)","tags":["Linux","arm_linux"]},{"title":"Linux 命令简述总结","url":"/linux-command-summary/","content":"\n\n\n# 系统\n\n## 信息\n\n- `uname -m` 显示处理器架构\n- `uname -r` 显示正在使用的内核版本\n- `cat /proc/cpuinfo` 查看详细 CPU 信息\n- date 显示系统日期\n\n## 查询\n\n- man 查看命令或函数的详细信息。eg：`man <info>`\n- which 查找命令。eg：`which <cmd>`\n- pwd 显示当前工作的操作路径\n- grep 查找内容里符合条件的字符串或正则表达式\n- du 用于显示目录或文件的大小。eg：`du -sh <path>`\n\n## 进程\n\n- ps 显示当前进程的状态\n\n  - `-aux` 输出格式：`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`\n    - USER: 行程拥有者\n    - PID: pid\n    - %CPU: 占用的 CPU 使用率\n    - %MEM: 占用的记忆体使用率\n    - VSZ: 占用的虚拟记忆体大小\n    - RSS: 占用的记忆体大小\n    - TTY: 终端的次要装置号码 (minor device number of tty)\n    - STAT: 该行程的状态:\n      - D: 无法中断的休眠状态 (通常 IO 的进程)\n      - R: 正在执行中\n      - S: 静止状态\n      - T: 暂停执行\n      - Z: 不存在但暂时无法消除\n      - W: 没有足够的记忆体分页可分配\n      - <: 高优先序的行程\n      - N: 低优先序的行程\n      - L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\n    - START: 行程开始时间\n    - TIME: 执行的时间\n    - COMMAND:所执行的指令\n\n- top 实时显示系统的整体性能信息以及正在运行的进程的相关信息\n\n  - `-d <number>` 指定 top 命令的刷新时间间隔，单位为秒\n  - `-n <number>` 指定 top 命令运行的次数后自动退出\n  - `-p <pid>` 仅显示指定进程 PID 的信息\n  - `-u <user>` 仅显示指定用户名的进程信息\n\n  **整体性能信息：**\n\n  - us, user：运行不需要的用户进程的时间\n\n  - sy, system：运行内核进程的时间\n\n  - ni, nice：运行 nice 用户进程的时间\n\n  - id, idle：内核空闲处理程序花费的时间\n\n  - wa, IO-wait：等待 I/O 完成的时间\n\n  - hi：用于维护硬件中断的时间\n\n  - si：用于处理软件中断的时间\n\n  - st：虚拟化环境从该虚拟机窃取的时间\n\n  **进程信息：**\n\n  - PID：进程的标识符。\n  - USER：运行进程的用户名。\n  - PR（优先级）：进程的优先级。\n  - NI（Nice值）：进程的优先级调整值。\n  - VIRT（虚拟内存）：进程使用的虚拟内存大小。\n  - RES（常驻内存）：进程实际使用的物理内存大小。\n  - SHR（共享内存）：进程共享的内存大小。\n  - %CPU：进程占用 CPU 的使用率。\n  - %MEM：进程占用内存的使用率。\n  - TIME+：进程的累计 CPU 时间。\n\n- kill 终止正在运行的进程。eg：`kill <pid>`\n\n  - `-9` 表示无条件退出，但由进程自行决定是否退出\n\n## 控制\n\n- halt 关闭系统\n- reboot 重启系统\n- poweroff 关机\n\n\n\n# 操作目录\n\n- ls 列出目录内容\n\n  - `-a` 显示所有文件和目录包括隐藏的\n  - `-l` 显示详细列表\n\n- cd 切换目录路径。eg：`cd <path>`\n\n  ```shell\n  cd / --> 跳转到根目录\n  cd ~ --> 跳转到家目录\n  cd .. --> 跳转到上级目录\n  cd ./home --> 跳转到当前目录的 home 目录下\n  cd /home --> 跳转到根目录下的 home 目录下\n  cd --> 不添加任何参数，也是回到家目录\n  ```\n\n\n\n# 操作文件/文件夹\n\n## 浏览\n\n- cat 一次性显示文件所有内容，更适合查看小的文件。eg：`cat <file>`\n  - `-n` 显示行号\n\n- less 分页显示文件内容，更适合查看大的文件。eg：`less <file>`\n\n- head 显示文件的开头几行（默认是10行）。eg：`head <file>`\n- tail 显示文件的结尾几行（默认是10行）。eg：`tail <file>`\n\n## 更改\n\n- touch 创建文件。eg：`touch <name>`\n- mkdir 创建文件夹。eg：`mkdir <name>`\n  - `-m` 配置文件权限，无视默认权限（umask）\n  - `-p` 递归创建所需目录，无论是否有上一级目录路径\n- cp 拷贝文件/文件夹。eg：`cp <source> <dest>`\n  - `-r` 递归复制文件夹及其子文件\n  - `-i` 在复制前提示确认，如果目标文件已存在，则会询问是否覆盖\n  - `-p` 保留源文件的权限、所有者和时间戳信息\n  - `-f` 强制复制，即使目标文件已存在也会覆盖，而且不给出提示\n- mv 移动文件/文件夹。eg：`mv -v <source> <dest>`\n- rm 删除文件。eg：`rm <name>`\n  - `-r` 递归删除文件夹文件夹及其子文件\n  - `-i` 向用户确认是否删除\n  - `-f` 强制删除，不给出提示\n- ln 创建链接（硬链接 or 软链接）。硬链接：等同于复制多一个文件，但共享同一块数据内容（即修改任何一个文件，修改的都是同一块内容）；软链接：类似 `windows` 平台下的快捷方式，`ln` 出来的文件指向源文件，当源文件丢失，将会变成死链接。。eg：`ln <source> <dest>`\n  - `-sv` 创建软链接，并显示处理过程\n  - 软链接删除使用 `rm -rf` 命令操作，跟正常的删除命令一样\n  - `-snf` 修改指向新的源地址\n\n\n\n# 压缩\n\n- tar 压缩\n  - `-v` 表示详细输出，列出被解压的文件\n  - `-f` 指定文件的名称\n  - `-c` 表示创建新的归档文件\n  - `-x` 表示解压操作\n  - `-r` 向已存在的归档中追加文件\n  - `-t` 列出归档文件中的内容\n  - `-z` 表示使用 gzip 压缩程序，得到 `.tar.gz` 后缀\n  - `-j` 表示使用 bzip2 压缩程序，得到 `.tar.bz2` 后缀\n  - `-J` 表示使用 xz 压缩程序，得到 `.tar.xz` 后缀\n\n## 文件夹压缩\n\n| 格式     | 压缩                             | 显示                   | 解压                    |\n| -------- | -------------------------------- | ---------------------- | ----------------------- |\n| .tar.gz  | `tar -zcvf xxx.tar.gz <folder>`  | `tar -tvf xxx.tar.gz`  | `tar -zxvf xxx.tar.gz`  |\n| .tar.xz  | `tar -Jcvf xxx.tar.xz <folder>`  | `tar -tvf xxx.tar.xz`  | `tar -Jxvf xxx.tar.xz`  |\n| .tar.bz2 | `tar -jcvf xxx.tar.bz2 <folder>` | `tar -tvf xxx.tar.bz2` | `tar -jxvf xxx.tar.bz2` |\n| .zip     | `zip xxx.zip <folder>`           | `zip -sf xxx.zip`      | `unzip xxx.zip`         |\n| .rar     | `rar -a xxx.rar <folder>`        | `rar -v xxx.rar`       | `unrar -x xxx.rar`      |\n\n## 文件压缩\n\n| 格式 | 压缩              | 显示 | 解压               |\n| ---- | ----------------- | ---- | ------------------ |\n| .Z   | `compress <file>` | 无   | `uncompress xxx.Z` |\n| .bz2 | `bzip2 -z <file>` | 无   | `bzip2 -d xxx.bz2` |\n| .gz  | `gzip <file>`     | 无   | `gzip -d xxx.gz`   |\n\n\n\n# 用户和群组\n\n## 用户\n\n- sudo 以 `root` 身份运行命令，使用当前用户密码解锁\n\n  一般来说，`sudo` 命令用来临时提升权限并运行单行命令，但也有几个特殊的命令切换至超级管理员权限：\n\n  ```shell\n  sudo -s # 使用当前用户的环境变量，不跳转目录，拥有超级管理员权限\n  sudo -i # 使用 root 用户的环境变量，跳转到 /root，拥有超级管理员权限\n  sudo su # 使用 root 用户的环境变量，不跳转目录，拥有超级管理员权限\n  ```\n\n- su 切换用户，需要 `root` 用户权限，使用 root 用户密码解锁\n\n    ```shell\n    su <user> # 切换 <user> 后，不改变原用户的工作目录，及其他环境变量目录\n    su - <user> # 切换 <user> 后，同时切换到新用户的工作环境中\n    ```\n    \n    note：当 `<user>` 缺省时，切换成 root 身份。\n\n- `sudo` VS `su` 拥有超级管理员权限\n\n  |      | sudo                         | su                                       |\n  | ---- | ---------------------------- | ---------------------------------------- |\n  | 密码 | 需要输入当前用户的密码       | 需要输入 root 用户的密码                 |\n  | 行为 | 临时使用超管权限运行单行命令 | 允许多条命令以超管权限运行，直至退出登录 |\n  | 记录 | 执行的操作都会被记录下       | 无法直接跟踪记录执行了什么操作           |\n\n  note：\n\n  大概是因为使用 `su` 命令或直接以 root 用户身份登录有风险，所以，一些 Linux 发行版（如 Ubuntu）默认禁用 root 用户帐户。鼓励用户在需要 root 权限时使用 `sudo` 命令。如果你想在系统中启用 root 用户帐户（强烈反对，因为你可以使用 `sudo` 命令或 `sudo su` 命令），你必须手动设置 root 用户密码，可以使用命令：`sudo passwd root` 。\n\n- useradd 添加新用户。eg：`useradd <user>`\n\n- passwd 修改用户密码。eg： `passwd <user>`\n\n    - `-d` 删除 user 帐号的密码\n    - `-l` 禁用锁定 user 帐号\n    - `-u` 解锁启用 user 帐号\n    - `-S` 显示 user 帐号密码信息\n\n- userdel 删除用户。eg：`userdel <user>`\n\n- `cat /etc/passwd` 列出 linux 上的所有用户。eg：可以用 ` cat /etc/passwd | cut -d: -f 1,3,7` 指定输出 1，3，7 项信息\n\n    - 第一项：对应的用户名\n    - 第二项：加密密码（ `x` 代表已存储密码）\n\n    - 第三项：用户 ID 号 (UID)\n    - 第四项：用户的组 ID 号 (GID)\n    - 第五项：全名\n    - 第六项：用户的主目录\n    - 第七项：用户的登录 shell（默认为 bash shell）\n\n    note：该列表显示的用户比您预期的要多得多，因为它还列出了所有系统用户，现在如果你想区分普通用户和系统用户，你可以参考用户标识符（UID）号。\n\n    一般来说，普通用户的 UID 大于或等于 1000，这会提示您 UID>=1000 的用户是普通用户，UID < 1000 的用户是系统用户（具体看 `/etc/login.defs` 文件配置）；您还会注意到，一些用户的最后一项使用 “nologin shell”，这意味着这些用户无法登录系统，这些用户也称为伪用户。\n\n## 群组\n\n- groupadd 创建群组（默认为普通组）。eg：`groupadd <group>`\n  - `-g <GID>` 指定新群组的标识号（GID）\n  - `-o` 表示新群组的 GID 可以与系统已有群组的 GID 相同\n  - `-r` 创建的为系统组\n- groupdel 删除一个已存在的群组。eg：`groupdel <group>`\n- groups 查看某个用户属于哪些组。eg： `groups <user>`\n- `getent group` 列出 linux 上的所有组\n- `usermod -a -G <group> <user>` 将 user 用户追加到 group 组中\n- `gpasswd -d <user> <group>` 将 user 用户从 group 组中移除\n\n## 权限\n\nLinux 下权限的属组有 **拥有者 、群组 、其它组** 三种，权限类型一般包括读，写，执行。对应字母为 r、w、x。\n\n- id 查看所属权限\n\n- chmod 改变文件 / 文件夹权限\n\n  - `-R` 递归应用权限\n\n  - 十位权限设定表示：\n\n    ```text\n    rwx = 111 = 7\n    rw- = 110 = 6\n    r-x = 101 = 5\n    r-- = 100 = 4\n    -wx = 011 = 3\n    -w- = 010 = 2\n    --x = 001 = 1\n    --- = 000 = 0\n    \n    常见的权限表示形式有：\n    -rw------- (600)    只有拥有者有读写权限。\n    -rw-r--r-- (644)    只有拥有者有读写权限；所属组用户和其他用户只有读权限。\n    -rwx------ (700)    只有拥有者有读、写、执行权限。\n    -rwxr-xr-x (755)    拥有者有读、写、执行权限；所属组用户和其他用户只有读、执行权限。\n    -rwx--x--x (711)    拥有者有读、写、执行权限；所属组用户和其他用户只有执行权限。\n    -rw-rw-rw- (666)    所有用户都有文件读、写权限。\n    -rwxrwxrwx (777)    所有用户都有读、写、执行权限。\n    ```\n\n  - 字串权限设定表示：\n\n    ```text\n    [ugoa...][[+-=][rwxX]...]\n    u：用户权限\n    g：组用户权限\n    o：其他用户权限\n    \n    chmod ugo+r    所有用户追加读权限\n    chmod u+rw     拥有者追加读、写权限\n    chmod g+rx     所属组用户追加读、执行权限\n    chmod o-rwx    其他用户无读、写、执行权限\n    ```\n\n\n\n# 磁盘\n\n- df -h 参看文件系统容量及挂载情况\n- lsblk 查看磁盘挂载情况\n- fdisk 交互式磁盘分区\n    - `-l` 查看分区表参数\n    - `/dev/sdx`\n      - `m` 查看命令操作\n        - `d` 删除已有分区\n        - `n` 创建新的分区\n        - `p` 查看创建分区\n        - `w` 应用分区信息\n- sfdisk 命令式磁盘分区\n    - `-T` 查看分区类型码\n- mount 挂载磁盘\n- umount 取消挂载\n- blkid 查看 disk 设备名\n\n\n\n# 数据\n\n- dd 数据转换\n\n  通用语法：\n\n  ```bash\n  dd if=path/to/input_file of=/path/to/output_file bs=block_size count=number_of_blocks\n  ```\n\n  命令简介：\n\n  ```text\n  if=file 　　　　　　　　　　　　　　　　输入文件名，缺省为标准输入。 \n  of=file 　　　　　　　　　　　　　　　　输出文件名，缺省为标准输出。 \n  ibs=bytes 　　　　　　　　　　　　　　　一次读入 bytes 个字节(即一个块大小为 bytes 个字节)。 \n  obs=bytes 　　　　　　　　　　　　　　　一次写 bytes 个字节(即一个块大小为 bytes 个字节)。 \n  bs=bytes 　　　　　　　　　　　　　　　 同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。 \n  cbs=bytes 　　　　　　　　　　　　　　　一次转换 bytes 个字节，即转换缓冲区大小。 \n  skip=blocks 　　　　　　　　　　　　　 从输入文件开头跳过 blocks 个块后再开始复制。 \n  seek=blocks      　　　　　　　　　　 从输出文件开头跳过 blocks 个块后再开始复制。(通常只有当输出文件是磁盘或磁带时才有效)。 \n  count=blocks 　　　　　　　　　　　　　仅拷贝 blocks 个块，块大小等于 ibs 指定的字节数。 \n  conv=conversion[,conversion...]    用指定的参数转换文件。 \n  ```\n\n  - conv 符号参数：\n\n    ```text\n    ascii 　　　　　　　　　　　　　　　　　转换 EBCDIC 为 ASCII。 \n    ebcdic 　　　　　　　　　　　　     　 转换 ASCII 为 EBCDIC。 \n    ibm 　　　　　　　　　　　　　　　　　　转换 ASCII 为 alternate EBCDIC. \n    block 　　　　　　　　　　　　　　　　 把每一行转换为长度为 cbs 的记录，不足部分用空格填充。 \n    unblock 　　　　　　　　　　　　　　　 使每一行的长度都为 cbs ，不足部分用空格填充。 \n    lcase 　　　　　　　　　　　　　　　　 把大写字符转换为小写字符。 \n    ucase 　　　　　　　　　　　　　　　　 把小写字符转换为大写字符。 \n    swab 　　　　　　　　　　　　　　　　  交换输入的每对字节。 \n    noerror 　　　　　　　　　　　　　　　 出错时不停止。 \n    notrunc 　　　　　　　　　　　　　　　 不截短输出文件。\n    sync 　　　　　　　　　　　　　　　　　 把每个输入块填充到ibs个字节，不足部分用空(NUL)字符补齐。\n    fsync 　　　　　　　　　　　　　　　　 在完成之前同步输出数据和元数据，这强制对输出数据和元数据进行物理写入。\n    ```\n  ```\n  \n  ```\n  \n- `/dev/zero` 和 `/dev/null`\n  \n    - `/dev/zero` （产生字符）不产生 IO，主要的用处是用来创建一个指定长度用于初始化的空文件，向设备或文件无穷尽地写入空字符流；\n    - `/dev/null` （回收站、无底洞）不产生IO，你可以向它输出任何数据，它通吃，并且不会撑着！\n    \n  - `conv=fsync` 用途：一些设备使用缓冲区和缓存来提高吞吐量和延迟性能。此命令使设备刷新其缓冲区和缓存，以便如果删除设备，则在操作标记为完成之前将数据写入设备，并将控制传递回终端提示。\n\n\n\n# 补丁\n\n补丁操作一般为已有文件的修改操作，通过新旧文件对比进行修改，对于新文件的增删，目前是无法通过该操作来进行的。\n\n**1、补丁生成**\n\n补丁文件是通过 `diff` 命令生成的，生成补丁文件的命令使用格式如下：\n\n```bash\ndiff -uNr <src> <modify> > xxx.patch\n```\n\n- src：源文件（目录），未进行修改的。\n- modify：基于 src，根据需求对里面的文件内容修改之后结果。\n\n命令选项：\n\n- `-u` 选项以统一格式创建补丁文件，这种格式比缺省格式更紧凑些\n- `-N` 选项确保补丁文件将正确地处理已经创建和删除文件的情况\n- `-r` 递归选项，设置了这个选项，diff 会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，包括子目录文件\n\n\">\" 是重定向符号，表示将 diff 比较的结果重定向输入到 `xxx.patch` 文件中（如不指定重定向，diff 的结果将打印到标准输出）， `xxx.patch` 文件一般指定以 `.patch` 为后缀。\n\n上述的补丁命令的功能就是逐个比较源文件（夹）和目标文件（夹）的所有文件，将差异信息记录到 `xxx.patch` 中， `xxx.patch` 文件也就是我们所谓的补丁文件。\n\n**2、打补丁**\n\n有了补丁文件那么就可以来进行打补丁操作了，打补丁是通过patch命令完成的。一般情况下，打补丁命令使用格式如下（这里只介绍了对源文件 / 文件夹进行打补丁操作）：\n\n```bash\npatch -pN < xxx.patch\n```\n\n`xxx.patch` 文件是上面 diff 命令生成的补丁文件，打补丁就是 patch 利用 diff 制作的补丁来实现源文件（夹）和目的文件（夹）的转换。这样说就意味着你可以从源文件 / 文件夹到目的文件 / 文件夹，也可以目的文件 / 文件夹到源文件 / 文件夹。一般情况下，我们都是将源文件 / 文件夹打补丁到我们修改后的目的文件 / 文件夹。\n\n命令选项：\n\n- `-pN` 选项打补丁时要忽略掉第 N 层目录。\n\n\n\n# 驱动模块加载\n\n- lsmod 查看已加载模块\n- insmod 动态加载模块\n- rmmod 卸载模块\n\n\n\n# 网络\n\n- ping 测试网络。eg：`ping <ip/host>`\n\n其它具体网络配置使用命令，根据不同的网络工具，所使用的命令不一样，可以参考：\n\n[Linux 网络管理套件](https://arachnid.cc/net-tools-vs-proute2/)\n\n[Linux 路由表说明](https://arachnid.cc/linux-routing-table/)\n\n[Linux 网络一探究竟](https://arachnid.cc/linux-network-config-tool/)\n\n\n\n# other\n\n- lsusb -tv 显示 USB 设备\n\n- clear 清屏\n\n- ftpget / ftpput 文件传输的 get 及 put 操作。eg：\n\n  `ftpget -u <username> -p <password> [server ip] <remote file> <local file>`\n\n  `ftpput  -u <username> -p <password> [server ip] <local file> <remote file>`\n\n  - `-u` 指定登录名称\n  - `-p` 输入登录密码\n\n\n\n通过 APT（高级软件包工具）在基于 Debian 的 Linux 系统上进行管理\n\n1. 从存储库安装软件包：`sudo apt install package-name`\n2. 删除已安装的软件包：`sudo apt purge package-name`\n3. 查看系统当前配置使用哪些存储库：`cat /etc/apt/sources.list`\n4. 更新存储库的软件包：`sudo apt update`\n5. 处理依赖：`sudo apt install -f` or 用 `aptitude` 来代替 `apt`\n6. 获取已安装软件包：`sudo apt list --installed` or `sudo dpkg -l`\n\n- **sudo add-apt-repository** 添加新存储库\n  - 添加 PPA 源文件：`sudo add-apt-repository ppa:xxx`\n  - 删除 PPA 源文件：`sudo add-apt-repository -r ppa:xxx`\n\n","tags":["Linux"]},{"title":"Ubuntu 搭建 tftp 及 NFS 服务","url":"/ubuntu-tftp-nfs-create/","content":"\n\n\n\n> 平台：Ubuntu 18.04.6\n\n\n\n# tftp 服务端搭建\n\n## 安装\n\n```bash command:(\"[user@localhost] #\":1-2)\nsudo apt update\nsudo apt install tftpd-hpa\n```\n\n## 配置\n\n```bash command:(\"[user@localhost] #\":1-4)\nsudo mkdir /home/user/tftp_share\nsudo chmod -R 777 /home/user/tftp_share\n\nsudo vim /etc/default/tftpd-hpa\n```\n\n更改 `TFTP_DIRECTORY` 字段，填写配置 tftp 服务共享的路径，eg：\n\n```text\nTFTP_USERNAME=\"tftp\"\nTFTP_DIRECTORY=\"/home/user/tftp_share\"\nTFTP_ADDRESS=\":69\"\nTFTP_OPTIONS=\"-l -c -s\"\n```\n\n## 启动服务\n\n在加载完后，重启服务器：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl restart tftpd-hpa\n```\n\n查看服务启动状态：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl status tftpd-hpa\n```\n\n## 测试传输\n\n如果本机没有安装 tftp 客户端，可以使用以下命令安装：\n\n```bash command:(\"[user@localhost] #\":1-2)\nsudo apt update\nsudo apt install tftp-hpa\n```\n\n然后连接 tftp 服务器，通过 get 和 put 读写文件：\n\n```bash command:(\"[user@localhost] #\":1)\ntftp 127.0.0.1 #连接服务器\n> get a.txt # 获取 a.txt\n> put b.txt # 上传 b.txt\n> q # 断开连接\n```\n\n\n\n\n\n# NFS 服务端搭建\n\n## 安装\n\n```bash command:(\"[user@localhost] #\":1-2)\nsudo apt update\nsudo apt install nfs-kernel-server\n```\n\n## 配置\n\n```bash command:(\"[user@localhost] #\":1-4)\nsudo mkdir /home/user/nfs_share\nsudo chmod -R 777 /home/user/nfs_share\n\nsudo vim /etc/exports\n```\n\n在最后一行添加自己的共享路径，如：\n\n```text\n/home/user/nfs_share *(rw,sync,no_root_squash,no_subtree_check)\n```\n\n**note：**\n\n`/home/nfs_share` 是 NFS 服务端的共享路径。\n\n`*` 表示所有网段都可以访问（可以指定具体的 ip ）。\n\n| 参数               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `ro`               | 只读访问                                                     |\n| `rw`               | 读写访问                                                     |\n| `sync`             | 所有数据在请求时写入共享                                     |\n| `async`            | nfs 在写入数据前可以响应请求                                 |\n| `secure`           | nfs 通过 1024 以下的安全 TCP/IP 端口发送                     |\n| `insecure`         | nfs 通过 1024 以上的端口发送                                 |\n| `wdelay`           | 如果多个用户要写入 nfs 目录，则归组写入（默认）              |\n| `no_wdelay`        | 如果多个用户要写入 nfs 目录，则立即写入，当使用 async 时，无需此设置 |\n| `hide`             | 在 nfs 共享目录中不共享其子目录                              |\n| `no_hide`          | 共享 nfs 目录的子目录                                        |\n| `subtree_check`    | 如果共享 /usr/bin 之类的子目录时，强制 nfs 检查父目录的权限（默认） |\n| `no_subtree_check` | 不检查父目录权限                                             |\n| `all_squash`       | 共享文件的 UID 和 GID 映射匿名用户 anonymous，适合公用目录   |\n| `no_all_squash`    | 保留共享文件的 UID 和 GID（默认）                            |\n| `root_squash`      | root 用户的所有请求映射成如 anonymous 用户一样的权限（默认） |\n| `no_root_squash`   | root 用户具有根目录的完全管理访问权限                        |\n| `anonuid=xxx`      | 指定 nfs 服务器 /etc/passwd 文件中匿名用户的 UID             |\n| `anongid=xxx`      | 指定 nfs 服务器 /etc/passwd 文件中匿名用户的 GID             |\n\n## 启动服务\n\n在加载完后，重启服务器：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl restart nfs-kernel-server\n```\n\n查看服务启动状态：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl status nfs-kernel-server\n```\n\n## 测试挂载\n\n如果本机没有安装 NFS 客户端，可以使用以下命令安装：\n\n```bash command:(\"[user@localhost] #\":1-2)\nsudo apt update\nsudo apt install nfs-common\n```\n\n然后执行本地挂载测试：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo mount -t nfs -o nolock localhost:/home/user/nfs_share /mnt\n```\n\n## 添加对 version 2 的支持\n\n使用如下命令查看对 NFS 版本的支持：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo cat /proc/fs/nfsd/versions\n-2 +3 +4 +4.1 +4.2\n```\n\n可以看出来 `-2` 说明目前是对 NFS 的 version 2 并不支持的，因此需要稍作修改才可完成兼容工作：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo vim /etc/default/nfs-kernel-server\n```\n\n通过修改 `RPCNFSDCOUNT` 、`RPCMOUNTDOPTS` 、`RPCSVCGSSDOPTS` 的字段得到：\n\n```text\n# Number of servers to start up\nRPCNFSDCOUNT=\"-V 2 8\"\n\n# Runtime priority of server (see nice(1))\nRPCNFSDPRIORITY=0\n\n# Options for rpc.mountd.\n# If you have a port-based firewall, you might want to set up\n# a fixed port here using the --port option. For more information, \n# see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS\n# To disable NFSv4 on the server, specify '--no-nfs-version 4' here\nRPCMOUNTDOPTS=\"-V 2 --manage-gids\"\n\n# Do you want to start the svcgssd daemon? It is only required for Kerberos\n# exports. Valid alternatives are \"yes\" and \"no\"; the default is \"no\".\nNEED_SVCGSSD=\"\"\n\n# Options for rpc.svcgssd.\nRPCSVCGSSDOPTS=\"--nfs-version 2,3,4 --debug --syslog\"\n```\n\n然后重启一下服务，再次查看版本支持：\n\n```bash command:(\"[user@localhost] #\":1-2)\nsudo systemctl restart nfs-kernel-server\nsudo cat /proc/fs/nfsd/versions\n+2 +3 +4 +4.1 +4.2\n```\n\n","tags":["history","Ubuntu","Linux"]},{"title":"Ubuntu 下 FTP 的搭建配置","url":"/ubuntu-ftp-create/","content":"\n\n\n\n> 平台：Ubuntu 18.04.6\n>\n> vsftpd官网：https://security.appspot.com/vsftpd.html\n\n\n\n# 安装\n\n安装 FTP服务，命令行输入：\n\n```bash command:(\"[user@localhost] #\":1-2)\nsudo apt update\nsudo apt install vsftpd\n```\n\n\n\n# 配置\n\n先备份配置文件：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo cp /etc/vsftpd.conf /etc/vsftpd.conf.back\n```\n\nvim进入编辑信息：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo vim /etc/vsftpd.conf\n```\n\n然后增加或修改以下信息：\n\n```text\n# Example config file /etc/vsftpd.conf\n#\n# The default compiled in settings are fairly paranoid. This sample file\n# loosens things up a bit, to make the ftp daemon more usable.\n# Please see vsftpd.conf.5 for all compiled in defaults.\n#\n# READ THIS: This example file is NOT an exhaustive list of vsftpd options.\n# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's\n# capabilities.\n#\n#\n# Run standalone?  vsftpd can run either from an inetd or as a standalone\n# daemon started from an initscript.\nlisten=NO #是否开启侦听状态\n\n# This directive enables listening on IPv6 sockets. By default, listening\n# on the IPv6 \"any\" address (::) will accept connections from both IPv6\n# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6\n# sockets. If you want that (perhaps because you want to listen on specific\n# addresses) then you must run two copies of vsftpd with two configuration\n# files.\nlisten_ipv6=YES #如果能使用 ipv6的可以打开使用；只能用 ipv4的必须注释掉，不然重启不了\n\n# Allow anonymous FTP? (Disabled by default).\nanonymous_enable=YES #允许匿名用户登录\n\n# Uncomment this to allow local users to log in.\nlocal_enable=YES #允许实名登录\n\n# Uncomment this to enable any form of FTP write command.\nwrite_enable=YES #允许实名用户进行写操作\n\n# Default umask for local users is 077. You may wish to change this to 022,\n# if your users expect that (022 is used by most other ftpd's)\n#local_umask=022\n\n# Uncomment this to allow the anonymous FTP user to upload files. This only\n# has an effect if the above global write enable is activated. Also, you will\n# obviously need to create a directory writable by the FTP user.\nanon_upload_enable=YES #允许匿名用户上传文件\n\n# Uncomment this if you want the anonymous FTP user to be able to create\n# new directories.\nanon_mkdir_write_enable=YES #允许匿名用户创建目录\n\n# Activate directory messages - messages given to remote users when they\n# go into a certain directory.\ndirmessage_enable=YES\n\n# If enabled, vsftpd will display directory listings with the time\n# in  your  local  time  zone.  The default is to display GMT. The\n# times returned by the MDTM FTP command are also affected by this\n# option.\nuse_localtime=YES\n\n# Activate logging of uploads/downloads.\nxferlog_enable=YES\n\n# Make sure PORT transfer connections originate from port 20 (ftp-data).\nconnect_from_port_20=YES\n\n# If you want, you can arrange for uploaded anonymous files to be owned by\n# a different user. Note! Using \"root\" for uploaded files is not\n# recommended!\n#chown_uploads=YES\n#chown_username=whoever\n\n# You may override where the log file goes if you like. The default is shown\n# below.\n#xferlog_file=/var/log/vsftpd.log\n\n# If you want, you can have your log file in standard ftpd xferlog format.\n# Note that the default log file location is /var/log/xferlog in this case.\n#xferlog_std_format=YES\n\n# You may change the default value for timing out an idle session.\n#idle_session_timeout=600\n\n# You may change the default value for timing out a data connection.\n#data_connection_timeout=120\n\n# It is recommended that you define on your system a unique user which the\n# ftp server can use as a totally isolated and unprivileged user.\n#nopriv_user=ftpsecure\n\n# Enable this and the server will recognise asynchronous ABOR requests. Not\n# recommended for security (the code is non-trivial). Not enabling it,\n# however, may confuse older FTP clients.\n#async_abor_enable=YES\n\n# By default the server will pretend to allow ASCII mode but in fact ignore\n# the request. Turn on the below options to have the server actually do ASCII\n# mangling on files when in ASCII mode.\n# Beware that on some FTP servers, ASCII support allows a denial of service\n# attack (DoS) via the command \"SIZE /big/file\" in ASCII mode. vsftpd\n# predicted this attack and has always been safe, reporting the size of the\n# raw file.\n# ASCII mangling is a horrible feature of the protocol.\n#ascii_upload_enable=YES\n#ascii_download_enable=YES\n\n# You may fully customise the login banner string:\n#ftpd_banner=Welcome to blah FTP service.\n\n# You may specify a file of disallowed anonymous e-mail addresses. Apparently\n# useful for combatting certain DoS attacks.\n#deny_email_enable=YES\n# (default follows)\n#banned_email_file=/etc/vsftpd.banned_emails\n\n# You may restrict local users to their home directories.  See the FAQ for\n# the possible risks in this before using chroot_local_user or\n# chroot_list_enable below.\nchroot_local_user=YES #用户访问将被限制在当前目录\n\n# You may specify an explicit list of local users to chroot() to their home\n# directory. If chroot_local_user is YES, then this list becomes a list of\n# users to NOT chroot().\n# (Warning! chroot'ing can be very dangerous. If using chroot, make sure that\n# the user does not have write access to the top level directory within the\n# chroot)\n#chroot_local_user=YES\n#chroot_list_enable=YES\n# (default follows)\n#chroot_list_file=/etc/vsftpd.chroot_list\n\n# You may activate the \"-R\" option to the builtin ls. This is disabled by\n# default to avoid remote users being able to cause excessive I/O on large\n# sites. However, some broken FTP clients such as \"ncftp\" and \"mirror\" assume\n# the presence of the \"-R\" option, so there is a strong case for enabling it.\n#ls_recurse_enable=YES\n\n# Customization\n#\n# Some of vsftpd's settings don't fit the filesystem layout by\n# default.\n#\n# This option should be the name of a directory which is empty.  Also, the\n# directory should not be writable by the ftp user. This directory is used\n# as a secure chroot() jail at times vsftpd does not require filesystem\n# access.\nsecure_chroot_dir=/var/run/vsftpd/empty\n\n# This string is the name of the PAM service vsftpd will use.\npam_service_name=vsftpd\n\n# This option specifies the location of the RSA certificate to use for SSL\n# encrypted connections.\nrsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem\nrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key\nssl_enable=NO\n\n\n# Uncomment this to indicate that vsftpd use a utf8 filesystem.\nutf8_filesystem=YES\n\n\nno_anon_password=YES #匿名登录是否需要密码\nanon_root=/home/user/ftp_dir #匿名登录访问的文件路径\n\nlocal_root=/ftp_share #实名登录访问的文件路径\n\nallow_writeable_chroot=YES\n\n```\n\n编辑完成后，`:wq` 保存退出。\n\n\n\n# 重新加载配置文件\n\n```bash command:(\"[user@localhost] #\":1)\nsudo /etc/init.d/vsftpd restart\n```\n\n\n\n# 启动服务\n\n在加载完后，重启服务器：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl restart vsftpd\n```\n\n查看服务启动状态：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl status vsftpd\n```\n\n![image-20221106152005206](image-20221106152005206.png)\n\n设置开机启动：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl enable vsftpd\n```\n\n如果想关闭开机启动：\n\n```bash command:(\"[user@localhost] #\":1)\nsudo systemctl disable vsftpd\n```\n\n\n\n# FTP连接\n\n本机连接：\n\n```bash command:(\"[user@localhost] #\":1)\nftp 127.0.0.1\n```\n\n其它电脑连接：\n\n```shell\nftp ip\n# eg:ftp 192.168.0.3\n```\n\n1、输入用户名：（1）匿名：anonymous 或 ftp （2）主机用户名：即你当前主机名。\n\n2、回车。\n\n3、如果需要密码则进行相应输入，这里上面配置设了匿名登录不需要密码，所以以匿名登录时没有提示输入密码。\n\n4、进入到相应的用户访问根目录里（ps：即进入到配置文件中设置的登录访问的文件路径，可以用 `ls` 查看是否对应上访问的文件目录），这样就可以愉快的玩耍了；输入： `quit` 退出。\n\neg：本地连接并退出，如下图：\n\n![image-20221106164252568](image-20221106164252568.png)\n\nwindows下可视化文件访问：按 `Win` + `E` 快捷键，调用文件资源管理器，输入访问地址，回车：\n\n![image-20221106160826118](image-20221106160826118.png)\n\nwindows下命令行文件访问：同样按 `Win` + `E` 快捷键，调用文件资源管理器，然后在输写框跟上面 linux访问连接一样输入 `ftp ip` ，即可跳到 ftp操作控制台中：\n\n![image-20221106161411644](image-20221106161411644.png)\n\n\n\n# FTP客户端常用命令\n\n在登录进入 ftp后，可以使用 `help` 查看可以使用哪些指令操作：\n\n![image-20221106163512272](image-20221106163512272.png)\n\n- ls：和linux上的ls命令类似\n\n- Ctrl+Shift + L：清屏\n\n- put：使用 `put [本地文件路径+名称]` 上传\n- get：使用 `get [远程文件路径+名称]` 下载\n- mput：批量上传多个文件 `mput 文件名1 文件名2` \n- mget：批量获取多个文件 `mget 文件名1 文件名2`\n- prompt：屏蔽批量输出信息，批量上传下载文件就不需要一直回车确认了\n- quit：退出 ftp访问\n\n","tags":["history","Ubuntu","Linux"]},{"title":"wireshark 使用","url":"/using-wireshark/","content":"\n\n\n官方说明：\n\nhttps://wiki.wireshark.org/Home\n\nhttps://www.wireshark.org/docs/wsug_html_chunked/\n\n# 着色规则\n\n在 wireshark监控界面上，不同的报文会显示不一样样的颜色，它们分别表示不同的含义；而这些颜色，都是是由着色规则设置的：\n\n![image-20221006162351042](image-20221006162351042.png)\n\n在默认的着色规则中，一般黑色背景代表报文的各类错误，红色背景代表各类异常情景，其它颜色代表正常。\n\n官方的说明可以看：https://www.wireshark.org/docs/wsug_html_chunked/ChCustColorizationSection.html\n\n着色规则分析：\n\n**1、Bad TCP：** tcp.analysis.flags && !tcp.analysis.window_update && !tcp.analysis.keep_alive && !tcp.analysis.keep_alive_ack\n\n即 TCP包损坏，通常表示为重传，乱序，丢包，重复响应等都在此条规则的范围内。具体看第三大点。\n\n参看：https://www.wireshark.org/docs/wsug_html_chunked/ChAdvTCPAnalysis.html\n\n**2、HSRP State Change：** hsrp.state != 8 && hsrp.state != 16\n\nHSRP即热备份路由协议（Hot Standby Router Protocol），这条规则表明当前报文状态非 Standby和 Active。\n\nHSRP的状态值可以是以下几种：\n\n- 0 - Initial\n- 1 - Learn\n- 2 - Listen\n- 4 - Speak\n- 8 - Standby\n- 16 - Active\n\n参考：https://www.rfc-editor.org/rfc/rfc2281\n\n**3、Spanning Tree Topology  Change：** stp.type == 0x80\n\n当生成树协议的状态标记为 `0x80`，表示着生成树拓扑发生变化。即 STP协议数据单元 (BPDU) 的 `flag` 字段发生变化（使用 IEEE-802.1d）：\n\n![img](bpdu.png)\n\n参考：https://techhub.hpe.com/eginfolib/networking/docs/switches/5980/5200-3921_l2-lan_cg/content/499036672.htm\n\n**4、OSPF State Change：** ospf.msg != 1\n\nOSPF（Open Shortest Path First，开放式最短路径优先协议）的 msg类型不是Hello报文。\n\nOSPF报文的类型，有下面几种类型：\n\n- 1：Hello报文；\n- 2：DD报文；\n- 3：LSR报文；\n- 4：LSU报文；\n- 5：LSAck报文。\n\n参考：http://www.023wg.com/message/message/cd_feature_ospf_message.html\n\n**5、ICMP errors：** icmp.type eq 3 || icmp.type eq 4 || icmp.type eq 5 || icmp.type eq 11 || icmpv6.type eq 1 || icmpv6.type eq 2 || icmpv6.type eq 3 || icmpv6.type eq 4\n\nICMP协议错误，协议的 type字段值错误。\n\n**6、ARP：** arp\n\n即 ARP协议。\n\n**7、ICMP：** icmp || icmpv6\n\n即 ICMP协议。\n\n**8、TCP RST：** tcp.flags.reset eq 1\n\nTCP流产生 reset。\n\n**9、SCTP ABORT：** sctp.chunk_type eq ABORT\n\nSCTP（即流控制传输协议）发生中止。\n\n参考：https://www.rfc-editor.org/rfc/rfc4960#section-3.3.7\n\n**10、TTL low or unexpected：** ( ! ip.dst == 224.0.0.0/4 && ip.ttl < 5 && !pim && !ospf) || (ip.dst == 224.0.0.0/24 && ip.dst != 224.0.0.251 && ip.ttl != 1 && !(vrrp || carp))\n\nTTL (Time-To-Live) 指解析记录在本地 DNS服务器中的缓存时间。该规则表示 TTL产生异常。\n\n在 IP组播中，通过 TTL控件来管理转发数据包的范围，按照惯例：\n\n- 0 - 仅限于同一主机上\n- 1 - 被限制在同一个子网内\n- 32 仅限于同一站点\n- 64 - 仅限于同一区域\n- 128 - 仅限于同一大陆\n- 255 - 不受限制\n\n参考：https://www.techtarget.com/searchnetworking/definition/time-to-live\n\n**11、Checksum Errors：** eth.fcs.status == \"Bad\" || ip.checksum.status == \"Bad\" || tcp.checksum.status == \"Bad\" || udp.checksum.status == \"Bad\" || sctp.checksum.status == \"Bad\" || mstp.checksum.status == \"Bad\" || cdp.checksum.status == \"Bad\" || edp.checksum.status == \"Bad\" || wlan.fcs.status == \"Bad\" || stt.checksum.status == \"Bad\"\n\n条件中的各类协议的 checksum出现异常。\n\n**12、SMB：** smb || nbss || nbns || netbios\n\nServer Message Block类协议。\n\n**13、HTTP：** http || tcp.port == 80 || http2\n\nHyper Text Transfer Protocol（超文本传输协议），这是很简陋的识别方法。\n\n**14、DCERPC：** dcerpc\n\n即 DCE/RPC，分散式运算环境/远端过程调用（Distributed Computing Environment / Remote Procedure Calls）协议。\n\n**15、Routing：** hsrp || eigrp || ospf || bgp || cdp || vrrp || carp || gvrp || igmp || ismp\n\n路由类协议。\n\n**16、TCP SYN/FIN： ** tcp.flags & 0x02 || tcp.flags.fin == 1\n\nTCP连接的起始和关闭。\n\n**17、TCP：** tcp\n\nTCP协议。\n\n**18、UDP：** udp\n\nUDP协议。\n\n**19、Broadcast：** eth[0] & 1\n\n广播数据。\n\n**20、System Event：** systemd_journal || sysdig\n\n系统调用及系统事件等系统活动。\n\n\n\n# 专家信息\n\n在报文的信息栏中，通常也有颜色限定，如下图：\n\n![image-20221006185352059](image-20221006185352059.png)\n\n而这次的颜色区别是属于对应的信息条目的：\n\n![image-20221006185105048](image-20221006185105048.png)\n\n每个专家信息项都有一个严重性级别。使用以下级别，从最低到最高。Wireshark 使用不同的颜色标记它们：\n\n- 聊天（蓝色）\n\n  有关常用的工作流程信息，例如设置了 SYN 标志的 TCP 数据包；数据包都符合常规流量的特征，包括 SYN、FIN、RST以及各种状态码的HTTP事件。\n\n- 注意（青色）\n\n  值得注意的事件，例如应用程序返回了一个常见的错误代码，例如 HTTP 404；数据包中有可能会引发故障的异常现象，例如TCP重传、重复确认、快速重传等现象。\n\n- 警告（黄色）\n\n  警告，例如应用程序返回异常错误代码，如连接问题。\n\n  与 TCP窗口有关的事件 TCP window full或TCP zero window，一般是连接设备忙不过来所致。\n\n  与 TCP报文段丢失或失序有关的事件，丢失是因为未抓全某个 TCP数据流的所有 TCP报文段；失序是因其感知到了TCP报文段未按发出的顺序到达接收主机。\n\n- 错误（红色）\n\n  严重的问题。\n\n  校验和错误：Ethernet及IP校验和错误。\n\n  伪造的数据包：一般涉及具体的应用层协议。\n\n参看：https://www.wireshark.org/docs/wsug_html_chunked/ChAdvExpert.html\n\n\n\n# TCP Info\n\n参看：https://wiki.wireshark.org/TCP_Analyze_Sequence_Numbers\n\n## A、ACK信息\n\n**1、TCP ACKed unseen segment**\n\n表示 Wireshark发现该条 ACK在整个网络包中找不到所对应的 Seq（排除了乱序），就会提示。\n\n![image-20221012210009741](image-20221012210009741.png)\n\n如图，在这组网络中，第 296号包出现这种情况，然后在上面的包中是找不到它所对应的 Seq的。\n\n**2、TCP Dup ACK *<frame>* #*<acknowledgement number>***\n\n重复 ACK包，当收发不稳定时，会出现重复响应的情况；而这种情况就是响应端会向请求端回复重复 ACK。`#` 符号前面的数字表示对应的重复包号，后面的数字表示确认次数，也可以说是出现的次数。\n\n![image-20221012221850769](image-20221012221850769.png)\n\n如图，在第 31191号包的信息中可以看到提示是说跟第 31188号包出现重复，通过查看第 31188号包，而这一包其实是为了响应第 31187号的。\n\n**3、TCP Fast Retransmission**\n\n标志着前面接收到重复的 ACK包（即出现了 [TCP Dup ACK] ）达 3个或 3个以上，进而触发了 TCP的快速重传（这是 RFC的规定）。\n\n![image-20221012224854822](image-20221012224854822.png)\n\n如图， [TCP Dup ACK] 出现了 3次，而且都是对应第 1309号包，因此触发快速重传包第 1330号包，重传了第 1309号包所响应的请求包第 1245号包，如下图：\n\n![image-20221012230828693](image-20221012230828693.png)\n\n然后通过对比原包第 1245号包和快速重传包第 1330号包，你会发现并不相同，实际上原始数据应该是相同的，只不过数据加密了，才出现不同的现象。\n\n## B、保活探测\n\n**4、TCP Keep-Alive**\n\n这个应该不陌生，一般 TCP长链接时，如果启用保活功能，则在特定时间段没有数据交互，那么将会传输一条保活字段，如下图：\n\n![image-20221012233735152](image-20221012233735152.png)\n\n**5、TCP Keep-Alive ACK**\n\n作为上一点 [TCP Keep-Alive] 的响应包，例图看上一张。\n\n## C、乱序 or 丢包\n\n**6、TCP Out-Of-Order**\n\n标志着 TCP传输出现乱序。\n\n![image-20221013201521709](image-20221013201521709.png)\n\n如图，在 TCP传输过程中（不包括三次握手和四次挥手），同一台主机发出的数据包应该是连续的，即后一个包的 Seq号等于前一个包的 Seq + Len；也可以说，后一个包的 Seq会大于或等于前一个包的 Seq。当 Wireshark发现后一个包的 Seq值小于前一个包的 Seq + Len时，就会认为是乱序了，因此标志 [TCP Out-of-Order]。\n\n在连续传输数据过程中，可以看到从第 330号包一直到第 337包被标志为乱序这几个包，应当是连续的，但是可以发现第 336号包跟第 337号包调转了，因此第 336号包被标志为上一包未捕获，而第 337号包则被标志为乱序。\n\n然后来分析一下，例如第 337号包的 Seq = 83518，Len = 1380，那么 Seq + Len = 84898，可以发现其实该包列栏中 `Sequence Number` 的 `83518` 数据对应 Seq，`NextSequence Number` 的 `84898` 数据对应 Seq + Len。根据上面的结论，在发生错误前的第 335号包它的 `NextSequence Number` 表明下一包第 336号包的 Seq值应当是 `83518` ，但是实际上第 336号包的 Seq值为 `84898` ，当到了第 337号包的时候，才出现理应对应的值 `83518` ，这时 Wireshark通过对比在发生错误前的第 335号包至理论连续的第 337号包之间看是否有出现调转包，有则标志 [TCP Out-of-Order]。一般出现 [TCP Out-of-Order] 时都会伴随出现 [TCP Previous segment not captured] 。\n\n**7、TCP Previous segment not captured**\n\n在 TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 Seq号等于前一个包的 Seq + Len（三次握手和四次挥手是例外）。如果 Wireshark发现后一个包的 Seq值大于前一个包的 Seq + Len，就知道中间缺失了一段数据。\n\n依然沿用上一张图，在发生错误前的第 335号包 Seq + Len 值为 `83518` ，但下一包的 Seq值为 `84898` ，因此出现后一个包的 Seq值大于前一个包的 Seq + Len，而非等于，所以预示着该数据包的上一个包未捕获到，但后面我们也有发现虽然显示上一个包未捕获到，实际紧随它的后一个包就是它们之间的数据包，只是调转了包而已。\n\n## D、端口\n\n**8、TCP Port numbers reused**\n\n这个死活没捕捉出来，就简单说一下吧。\n\n当发送 SYN 标志时（不是 SYN + ACK），如果已经存在一个使用相同地址和端口的现有会话，那么将会被 Wireshark标记 [TCP Port numbers reused]。\n\n## E、重传\n\n**9、TCP Spurious Retransmission**\n\nTCP虚假重传，意味着发送端认为发送的包已经丢失了，然后就重传了，尽管此时接收端已经发送了对这些包的确认（确认还没收到或者已经丢失了）。\n\n![image-20221013232224434](image-20221013232224434.png)\n\n如图，第 459号包出现虚拟重传现象，实际为第 453号包的重传，可从显示来看第 453号包是已经是得到接收端的 ACK响应了，理论来讲是不会重传的，但前面也有说到了，可能会出现接收端确认了请求（已经发出去了），发送端却还没收到或者已经丢失了，那么发送端将会重传数据，而由于这时这段数据包在初包发送后接收端有回一次请求，这次重传相当于接收端又回了一次请求（即重复了两次响应，可以看到第 460号包标志为 [TCP Dup ACK] 了），所以对于这种有回 ACK还重传的数据包将被标志为 [TCP Spurious Retransmission] 。然后至于为什么是重传了第 453号包，可以看到第 460号包的信息提示，这是 ACK响应第 459号包的，但同时也是跟第 454号包重复，而第 454号包对应响应第 453号包的，那自然而然地得到第 459号包为第 453号包的重传。\n\n**10、TCP Retransmission**\n\nTCP重传，与上面不同的是如果一个包不确定是否丢了，但它又没有像上面 [TCP Spurious Retransmission] 那样得到接收端的 ACK响应，那它大概率就是丢包了，就不会快速重传；而针对这种情况，发送方也就只好等到超时了再重传，此类重传包就会被 Wireshark标志 [TCP Retransmission] 。\n\n![image-20221014221501852](image-20221014221501852.png)\n\n如图，第 33号包被标志为 [TCP Previous segment not captured]，预示着有可能出现丢包，并且在后面一段时间内也没有像前面那样有标志 [TCP Out-Of-Order]提示的包，排除了乱序情况，最终等待超时，重传数据包，于是第 33号重传包就有了 [TCP Retransmission]标志。TCP重传是 TCP通讯中常有的事情，有时候看到一大堆黑漆漆一片的 error事件，可能就是这种情况。\n\n## F、TCP Window\n\n**11、TCP Window Full**\n\n顾名思义，就是窗口已满，指的发送端发送的数据已经达到的接受窗口的上限；那么发送端暂停发送，等待新的接收窗口的通告。\n\n![image-20221014235639055](image-20221014235639055.png)\n\n如图，在这组数据中，从第 526323号包开始，出现了 [TCP Window Full] 表明发送数据达到上限了，同时还有另一个 [TCP Spurious Retransmission] 表明了虚假重传，但可惜的是接收端后续都没有响应，最终导致在发送 RST 报文后，关闭 TCP连接。\n\n**12、TCP Window Update**\n\nTCP协议允许随时改变窗口的大小，并且通过发送标识有 WindowUpdate 的报文通知对端；或者当接收端的应用程序消耗完了已经从 RX 缓冲区接收到的数据时，也会发生 WindowUpdate，以指示缓冲区中现在有更多可用空间；以上这些数据包将被标志 [TCP Window Update]。[TCP Window Update] 是 TCP通信中的一个状态，它可以发生的原因还有有很多，通常在 TCP ZeroWindow 条件发生后看到。\n\n![image-20221014234941548](image-20221014234941548.png)\n\n**13、TCP ZeroWindow**\n\n如图，当接收窗口值大小为零（Win = 0）且非 SYN、FIN 或 RST 数据时设置。\n\n![image-20221014223515008](image-20221014223515008.png)\n\n在每个 TCP报头中的窗口字段表明着接收端可以接受的数据量大小；如果接收端不能接受任何数据，它将把窗口值设置为零，这告诉发送端暂停其传输。在某些特定情况下，这是正常的，例如，打印机可能会在加载或翻转一张纸时使用零窗口暂停打印作业的传输；然而，在大多数情况下，这表明接收端存在性能或容量问题。恢复暂停的连接可能需要很长时间(有时需要几分钟)，即使导致零窗口的底层条件很快就会清除。\n\n**14、TCP ZeroWindowProbe**\n\n当通信的一方接收到 TCP ZeroWindow 报文后，会定时发送 TCP ZeroWindowProbe 报文进行探测；探测报文是需要发送下一字节数据，然后通过接收端的响应，由此来判断接收端窗口值是否仍然为 0，如果接收方回复窗口大小仍然为零，则发送端继续探测。ZeroWindowProbe 它有助于证明发送端已经确认到接收端其 TCP 窗口大小为零，但仍试图让数据继续交互而非关闭通讯。\n\n![img](windows-3.png)\n\n**15、TCP ZeroWindowProbeAck**\n\n作为 [TCP ZeroWindowProbe] 的 ACK应答，结合 TCP ZeroWindowProbe 理解。ZeroWindowProbeAck 数据包的存在也表明网络正在传递数据包并且设备没有关闭。\n\n## G、交互\n\n**16、TCP Conversation Completeness**\n\n- SYN\n- SYN-ACK\n- ACK\n- DATA\n- FIN\n- RST\n\n![img](0.jpg)\n\n\n\n# 常见表达式\n\n**1、运算符**\n\n| 英文写法 |  别名  | C-like |              描述              |         例子          |\n| :------: | :----: | :----: | :----------------------------: | :-------------------: |\n|    eq    | any_eq |   ==   |      相等（如果超过一个）      | `ip.src == 10.0.0.5`  |\n|    ne    | all_ne |   !=   | 不相等（如果多于一个，则全部） | `ip.src != 10.0.0.5`  |\n|          | all_eq |  ===   |  相等（如果多于一个，则全部）  | `ip.src === 10.0.0.5` |\n|          | any_ne |  !==   | 不相等（如果多于一个，则任意） | `ip.src !== 10.0.0.5` |\n|    gt    |        |   >    |              大于              |   `frame.len > 10`    |\n|    lt    |        |   <    |              小于              |   `frame.len < 128`   |\n|    ge    |        |   >=   |           大于或等于           | `frame.len ge 0x100`  |\n|    le    |        |   <=   |           小于或等于           |  `frame.len <= 0x20`  |\n\n**2、逻辑符**\n\n| 英文写法 | C-like |  描述  |                       例子                        |\n| :------: | :----: | :----: | :-----------------------------------------------: |\n|   and    |   &&   | 逻辑与 |       `ip.src==10.0.0.5 and tcp.flags.fin`        |\n|    or    |  \\|\\|  | 逻辑或 |      `ip.src==10.0.0.5 or ip.src==192.1.1.1`      |\n|   xor    |   ^^   |  异或  | `tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29` |\n|   not    |   !    | 逻辑非 |                     `not llc`                     |\n\n**3、协议过滤**\n\n```\nip.proto == xxx\n\nnote: xxx表示为对应的协议，如 TCP：ip.proto == TCP\n```\n\n- **TCP：** 只显示 TCP协议的数据流\n- **UDP：** 只显示 UDP协议的数据流\n- **HTTP：** 只显示 HTTP协议的数据流\n- **ICMP：** 只显示 ICMP协议的数据流\n- **ARP：** 只显示 ARP协议的数据流\n- **DNS：** 只显示 DNS协议的数据流\n\n**4、IP过滤**\n\n- `ip.addr == 192.168.116.138` ，只显示 **IP地址**为 `192.168.116.138` 有关的数据流\n- `ip.src == 192.168.116.138` ，只显示**源 IP地址**为 `192.168.116.138` 的数据流\n- `ip.dst == 192.168.116.138` ，只显示**目标 IP地址**为 `192.168.116.138` 的数据流\n\n**5、端口过滤**\n\n- `tcp.port == 80` ，只显示 80端口 TCP数据流\n- `udp.prot == 67` ，只显示 67端口 UDP数据流\n- `tcp.srcport == 80` , 只显示源地址的 80端口数据流\n- `tcp.dstport == 80` ，只显示目的地址 80端口数据流\n\n**6、过滤HTTP协议**\n\n- `http.request.method == \"GET\"` ，显示 GET请求\n- `http.request.method == \"POST\"` ，显示 POST请求\n- `http.request.code == 404` ，显示状态码为 404\n\n\n\n参看：https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html\n\n\n\n# 列信息增删\n\n**1、增加列信息**\n\n在报文的信息栏，选着想要显示的信息，右键点击添加：\n\n![image-20221006221325561](image-20221006221325561.png)\n\n**2、删除列信息**\n\n在监控报文栏，选择不需要的列，右键选中：\n\n![image-20221006221434994](image-20221006221434994.png)\n\n**3、隐藏列信息**\n\n同样在监控报文栏操作，随便选择一列，右键选中，然后把想要隐藏的列去掉勾选，这里就不放图了。","tags":["history","工具"]},{"title":"vscode 常用配置","url":"/vscode-config/","content":"\n\n\n# Windows下\n\n**1、写入右键打开 vscode注册表**\n\n前言：有时候在安装的时候，会忘记勾选 `把 vscode添加到右键` 的选项，导致后面无法方便的从右键中选着文件 or 文件夹打开。\n\n解决：编辑以下文件，另存为 `xxx.reg` 文件，注意：把 `D:\\\\Microsoft VS Code\\\\Code.exe` 搜索替换更改为自己 vscode的安装路径；不知道安装在哪里的，可以右键应用图标查看 \"打开文件所在位置\" 。\n\n```reg\nWindows Registry Editor Version 5.00\n\t\n[HKEY_CLASSES_ROOT\\*\\shell\\VSCode]\n@=\"Open with Code\"\n\"Icon\"=\"D:\\\\Microsoft VS Code\\\\Code.exe\"\n\t\n[HKEY_CLASSES_ROOT\\*\\shell\\VSCode\\command]\n@=\"\\\"D:\\\\Microsoft VS Code\\\\Code.exe\\\" \\\"%1\\\"\"\n\t\nWindows Registry Editor Version 5.00\n\t\n[HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode]\n@=\"Open with Code\"\n\"Icon\"=\"D:\\\\Microsoft VS Code\\\\Code.exe\"\n\t\n[HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode\\command]\n@=\"\\\"D:\\\\Microsoft VS Code\\\\Code.exe\\\" \\\"%V\\\"\"\n\t\nWindows Registry Editor Version 5.00\n\t\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode]\n@=\"Open with Code\"\n\"Icon\"=\"D:\\\\Microsoft VS Code\\\\Code.exe\"\n\t\n[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode\\command]\n@=\"\\\"D:\\\\Microsoft VS Code\\\\Code.exe\\\" \\\"%V\\\"\"\n\n```\n\n\n\n# ubuntu下\n\n**1、vscode超管模式执行**\n\n前言：很多时候，在 root用户下无法打开 \" Visual Studio Code 开发环境 \"，导致无法编辑保存文件或者使用一些插件，虽说可以用 `chmod 777` 改变文件权限，但是这样子有点不安全，那么有没有一个办法，只有在 root用户才能使用，正常用户下还是原有的权限呢？\n\n解决：vscode最好在官网上下载（https://code.visualstudio.com/updates/），从应用管理器或者利用 `apt-get install` 安装，目前是不支持中文编写的，可能是因为下载的是阉割版；还有值得注意的是，好像下载 V1.70版本以上的（目前只测过 1.64 和 1.65），以管理者执行会出现白屏现象。\n\n在安装好从官网下的包后，在 `~/.bashrc` 文件中添加 `alias code='/usr/share/code/code . --no-sandbox --unity-launch'` 配置；然后执行 `source ~/.bashrc` 命令刷新配置。\n\n最后，想要以超管执行 vscode，只需切换到 root 用户后，在命令行中执行 `code` ，从图标应用上打开或者在非 root用户下执行 `code` 命令则皆是普通模式。\n\n\n\n# 设置\n\n1、差异编辑\n\n- Code Lens\n\n  选择显示 CodeLens\n\n- ignore Trim Whitespace\n\n  取消忽略前导或尾随空格更改\n\n2、编辑管理\n\n- Enable Preview\n\n  取消预览编辑，使得打开新文件时不会替换关闭已打开文件\n\n3、资源管理器\n\n- Auto Reveal\n\n  关闭取消侧边栏文件定位跳转\n\n4、搜索\n\n- Show Line Numbers\n\n  选择显示搜索结果所在行号\n\n5、终端\n\n- Cursor Blinking\n\n  控制终端光标闪烁\n\n6、自动换行\n\n- Word Wrap\n- 直接通过快捷键 `alt + z` 临时进行换行与不换行之间的切换\n\n\n\n# 常用插件\n\n`.vscode\\extensions.json`\n\n```json\n{\n\t// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.\n\t// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp\n\n\t// List of extensions which should be recommended for users of this workspace.\n\t\"recommendations\": [\n\t\t\"CodeInChinese.EnglishChineseDictionary\",\n\t\t\"mqycn.huile8\",\n\t\t\"dan-c-underwood.arm\",\n\t\t\"alefragnani.Bookmarks\",\n\t\t\"ms-vscode.cpptools\",\n\t\t\"MS-CEINTL.vscode-language-pack-zh-hans\",\n\t\t\"twxs.cmake\",\n\t\t\"intellsmi.comment-translate\",\n\t\t\"marus25.cortex-debug\",\n\t\t\"plorefice.devicetree\",\n\t\t\"mhutchie.git-graph\",\n\t\t\"eamodio.gitlens\",\n\t\t\"trond-snekvik.gnu-mapfiles\",\n\t\t\"ms-vscode.hexeditor\",\n\t\t\"keroc.hex-fmt\",\n\t\t\"ZixuanWang.linkerscript\",\n\t\t\"yzhang.markdown-all-in-one\",\n\t\t\"blindtiger.masm\",\n\t\t\"mcu-debug.memory-view\",\n\t\t\"eseom.nunjucks-template\",\n\t\t\"ms-python.python\",\n\t\t\"kaiyi.qwerty-learner\",\n\t\t\"Wscats.eno\",\n        \"vscode-icons-team.vscode-icons\"\n\t],\n\t// List of extensions recommended by VS Code that should not be recommended for users of this workspace.\n\t\"unwantedRecommendations\": [\n\t\t\n\t]\n}\n```\n\n"},{"title":"博客搭建笔记之功能扩展","url":"/shoka-function-expansion/","content":"\n\n\n# 搜索功能\n\n## algolia搜索功能\n\n{% links %}\n\n- site: algolia 官网\n  url: https://www.algolia.com/\n  desc: algolia官方地址\n  image: https://upload.wikimedia.org/wikipedia/commons/6/69/Algolia-logo.svg\n  color: \"#5468FF\"\n\n{% endlinks %}\n\n**需要安装 `hexo-algoliasearch` 插件。**\n\n1. 注册 algolia，创建 Index：\n\n   ![image-20220530210920658](image-20220530210920658.png)\n\n2. 获取 Key，修改站点配置：\n\n   - 新建 API Key：![image-20220530212532566](image-20220530212532566.png)\n\n   - 获取相应的 Key，并填入配置信息：\n\n     ![image-20220530212807371](image-20220530212807371.png)\n\n3. 在配置完 Key后，回到终端控制台，键入以下命令上传数据到 `algolia` ：\n\n   ```bash\n   hexo algolia\n   ```\n\n\n\n配置参考：\n\n```yaml\nalgolia:\n   appId: \"Application ID对应码\"\n   apiKey: \"API Keys页面的All API Keys中刚刚新建的API key的对应码\"\n   adminApiKey: \"Admin API Key对应码\"\n   chunkSize: 5000\n   indexName: \"你填写的Indices部分\"\n   fields:\n     - title #必须配置\n     - path #必须配置\n     - categories #推荐配置\n     - content:strip:truncate,0,4000\n     - gallery\n     - photos\n     - tags\n```\n\n注：每次更新修改文章后还需要执行 `hexo algolia` 的指令，否则，搜索数据没有或者对不上。\n\n\n\n## 本地搜索功能\n\n奈何本人对前端不熟悉，主要~~参考~~应用了该博主的[教程](https://linn-ylz.com/Hexo/blog-search-config/)。\n\n**需要安装 `hexo-generator-search` 插件。**\n\n1. 修改主题文件夹下的 `themes\\shoka\\scripts\\generaters\\script.js` 文件，定位到 `if(config.algolia)` 判断的位置，然后追加配置赋值：\n\n   ```js\n     if(config.search.enable) {\n       siteConfig.search = {\n         path : config.search.path,\n         field : config.search.post,\n         format: config.search.format,\n         limit: config.search.limit,\n         content: config.search.content,\n         unescape: config.search.unescape,\n         preload: config.search.preload,\n         trigger: config.search.trigger,\n         top_n_per_article: config.search.top_n_per_article,\n         article_per_page: config.search.article_per_page,\n       }\n     }\n   ```\n\n2. 在路径 `themes\\shoka\\source\\js\\_app\\` 下，找到 `pjax.js` 搜索 `algoliaSearch()` 函数，该函数是用来实现 algolia 搜索的，由于现在要实现本地搜索，因此屏蔽掉该函数，添加并使用实现本地搜索的函数 `localSearch()` 。\n\n3. 实现 `localSearch()` 函数需要在 `themes\\shoka\\source\\js\\_app\\page.js` 文件下找个地方定义如下内容：\n\n   ```js\n   function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n   function _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n   function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n   function _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n   function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n   function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n   var localSearch = function localSearch(pjax) {\n     // 参考 hexo next 主题的配置方法\n     if (CONFIG.search === null) return;\n     if (!siteSearch) {\n       siteSearch = BODY.createChild('div', {\n         id: 'search',\n         innerHTML: \"<div class=\\\"inner\\\"><div class=\\\"header\\\"><span class=\\\"icon\\\"><i class=\\\"ic i-search\\\"></i></span><div class=\\\"search-input-container\\\"><input  class=\\\"search-input\\\"\\nautocomplete=\\\"off\\\"\\nplaceholder=\\\"\".concat(LOCAL.search.placeholder, \"\\\"\\nspellcheck=\\\"false\\\"\\ntype=\\\"text\\\"\\nid=\\\"local-search-input\\\"></div><span class=\\\"close-btn\\\"><i class=\\\"ic i-times-circle\\\"></i></span></div><div class=\\\"results\\\" id=\\\"search-results\\\"><div class=\\\"inner\\\"><div id=\\\"search-stats\\\"></div><div id=\\\"search-hits\\\"></div><div id=\\\"search-pagination\\\"></div></div></div></div></div>\")\n       });\n     }\n     var isFetched = false;\n     var datas;\n     var isXml = true;\n     var current_page = 0;\n     var article_per_page = parseInt(CONFIG.search.article_per_page, 10);\n     var total_pages = 0;\n     var max_page_on_show = 7; // 一次最多显示 7 个页码\n     var start_page = 0;\n     var end_page = 0;\n     var resultItems = [];\n   \n     // search DB path\n     var searchPath = CONFIG.search.path;\n     if (searchPath.length === 0) {\n       searchPath = 'search.xml';\n     } else if (searchPath.endsWith('json')) {\n       isXml = false;\n     }\n     var input = $('.search-input'); // document.querySelector('.search-input');\n     var resultContent = document.getElementById('search-hits');\n     var paginationContent = document.getElementById('search-pagination');\n     var getIndexByWord = function getIndexByWord(word, text, caseSensitive) {\n       if (CONFIG.search.unescape) {\n         var div = document.createElement('div');\n         div.innerText = word;\n         word = div.innerHTML;\n       }\n       var wordLen = word.length;\n       if (wordLen === 0) {\n         return [];\n       }\n       var startPosition = 0;\n       var position = [];\n       var index = [];\n       if (!caseSensitive) {\n         text = text.toLowerCase();\n         word = word.toLowerCase();\n       }\n       while ((position = text.indexOf(word, startPosition)) > -1) {\n         index.push({\n           position: position,\n           word: word\n         });\n         startPosition = position + wordLen;\n       }\n       return index;\n     };\n   \n     // Merge hits into slices\n     var mergeIntoSlice = function mergeIntoSlice(start, end, index, searchText) {\n       var item = index[index.length - 1];\n       var _item = item,\n         position = _item.position,\n         word = _item.word;\n       var hits = [];\n       var searchTextCountInSlice = 0;\n       while (position + word.length <= end && index.length !== 0) {\n         if (word === searchText) {\n           searchTextCountInSlice++;\n         }\n         hits.push({\n           position: position,\n           length: word.length\n         });\n         var wordEnd = position + word.length;\n   \n         // Move to next position of hit\n         index.pop();\n         while (index.length !== 0) {\n           item = index[index.length - 1];\n           position = item.position;\n           word = item.word;\n           if (wordEnd > position) {\n             index.pop();\n           } else {\n             break;\n           }\n         }\n       }\n       return {\n         hits: hits,\n         start: start,\n         end: end,\n         searchTextCount: searchTextCountInSlice\n       };\n     };\n   \n     // Highlight title and content\n     var highlightKeyword = function highlightKeyword(text, slice) {\n       var result = '';\n       var prevEnd = slice.start;\n       slice.hits.forEach(function (hit) {\n         result += text.substring(prevEnd, hit.position);\n         var end = hit.position + hit.length;\n         result += \"<mark>\".concat(text.substring(hit.position, end), \"</mark>\");\n         prevEnd = end;\n       });\n       result += text.substring(prevEnd, slice.end);\n       return result;\n     };\n     var pagination = function pagination() {\n       var addPrevPage = function addPrevPage(current_page) {\n         var classContent = '';\n         var numberContent = '';\n         if (current_page === 0) {\n           classContent = '#search-pagination pagination-item disabled-item';\n           numberContent = '<span class=\"#search-pagination page-number\"><i class=\"ic i-angle-left\"></i></span>';\n         } else {\n           classContent = '#search-pagination pagination-item';\n           numberContent = \"<a class=\\\"#search-pagination page-number\\\" aria-label=\\\"Prev\\\" href=\\\"#\\\"><i class=\\\"ic i-angle-left\\\"></i></a>\";\n         }\n         var prevPage = \"<li class=\\\"\".concat(classContent, \"\\\" id=\\\"prev-page\\\">\").concat(numberContent, \" </li>\");\n         return prevPage;\n       };\n       var addNextPage = function addNextPage(current_page) {\n         var classContent = '';\n         var numberContent = '';\n         if (current_page + 1 === total_pages) {\n           classContent = '#search-pagination pagination-item disabled-item';\n           numberContent = '<span class=\"#search-pagination page-number\"><i class=\"ic i-angle-right\"></i></span>';\n         } else {\n           classContent = '#search-pagination pagination-item';\n           numberContent = \"<a class=\\\"#search-pagination page-number\\\" aria-label=\\\"Next\\\" href=\\\"#\\\"><i class=\\\"ic i-angle-right\\\"></i></a>\";\n         }\n         var nextPage = \"<li class=\\\"\".concat(classContent, \"\\\" id=\\\"next-page\\\">\").concat(numberContent, \" </li>\");\n         return nextPage;\n       };\n       var addPage = function addPage(index, current_page) {\n         var classContent = '';\n         var numberContent = \"<a class=\\\"#search-pagination page-number\\\" aria-label=\\\"\".concat(index + 1, \"\\\" href=\\\"#\\\">\").concat(index + 1, \"</a>\");\n         if (index === current_page) {\n           classContent = '#search-pagination pagination-item current';\n         } else {\n           classContent = '#search-pagination pagination-item';\n         }\n         var page = \"<li class=\\\"\".concat(classContent, \"\\\" id=\\\"page-\").concat(index + 1, \"\\\">\").concat(numberContent, \" </li>\");\n         return page;\n       };\n       var addPaginationEvents = function addPaginationEvents(start_page, end_page) {\n         if (total_pages <= 0) {\n           return;\n         }\n         var onPrevPageClick = function onPrevPageClick(event) {\n           if (current_page > 0) {\n             current_page -= 1;\n           }\n           if (current_page < start_page) {\n             start_page = current_page;\n             end_page = Math.min(end_page, start_page + max_page_on_show);\n           }\n           pagination();\n         };\n         var onNextPageClick = function onNextPageClick(event) {\n           if (current_page + 1 < total_pages) {\n             current_page += 1;\n           }\n           if (current_page > end_page) {\n             end_page = current_page;\n             start_page = Math.max(0, end_page - max_page_on_show);\n           }\n           pagination();\n         };\n         var onPageClick = function onPageClick(event) {\n           var page_number = parseInt(event.target.ariaLabel);\n           current_page = page_number - 1; // note minus 1 here\n           pagination();\n         };\n         var prevPage = document.getElementById('prev-page');\n         prevPage.addEventListener('click', onPrevPageClick);\n         var nextPage = document.getElementById('next-page');\n         nextPage.addEventListener('click', onNextPageClick);\n         for (var i = start_page; i < end_page; i += 1) {\n           var page = document.getElementById(\"page-\".concat(i + 1));\n           page.addEventListener('click', onPageClick);\n         }\n       };\n       paginationContent.innerHTML = ''; // clear\n       var begin_index = Math.min(current_page * article_per_page, resultItems.length);\n       var end_index = Math.min(begin_index + article_per_page, resultItems.length);\n       resultContent.innerHTML = \"\".concat(resultItems.slice(begin_index, end_index).map(function (result) {\n         return result.item;\n       }).join(''));\n   \n       start_page = Math.max(0, total_pages - max_page_on_show);\n       end_page = start_page + Math.min(total_pages, max_page_on_show);\n       var pageContent = '<div class=\"#search-pagination\">';\n       pageContent += '<div class=\"#search-pagination pagination\">';\n       pageContent += '<ul>';\n       if (total_pages > 0) {\n         // add prev page arrow, when no prev page not selectable\n         pageContent += addPrevPage(current_page);\n         for (var i = start_page; i < end_page; i += 1) {\n           pageContent += addPage(i, current_page);\n         }\n         // add next page arrow, when no next page not selectable\n         pageContent += addNextPage(current_page);\n       }\n       pageContent += '</ul>';\n       pageContent += '</div>';\n       pageContent += '</div>';\n       paginationContent.innerHTML = pageContent;\n       addPaginationEvents(start_page, end_page);\n       resultContent.scrollTop = 0; // scroll to top\n       window.pjax && window.pjax.refresh(resultContent);\n     };\n     var inputEventFunction = function inputEventFunction() {\n       if (!isFetched) {\n         console.log(\"Data not fetched.\");\n         return;\n       }\n       var searchText = input.value.trim().toLowerCase();\n       var keywords = searchText.split(/[-\\s]+/);\n       if (keywords.length > 1) {\n         keywords.push(searchText);\n       }\n       resultItems = [];\n       if (searchText.length > 0) {\n         // Perform local searching\n         datas.forEach(function (_ref, index) {\n           var categories = _ref.categories,\n             title = _ref.title,\n             content = _ref.content,\n             url = _ref.url;\n           var titleInLowerCase = title.toLowerCase();\n           var contentInLowerCase = content.toLowerCase();\n           var indexOfTitle = [];\n           var indexOfContent = [];\n           var searchTextCount = 0;\n           keywords.forEach(function (keyword) {\n             indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));\n             indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));\n           });\n   \n           // Show search results\n           if (indexOfTitle.length > 0 || indexOfContent.length > 0) {\n             var hitCount = indexOfTitle.length + indexOfContent.length;\n             // Sort index by position of keyword\n             [indexOfTitle, indexOfContent].forEach(function (index) {\n               index.sort(function (itemLeft, itemRight) {\n                 if (itemRight.position !== itemLeft.position) {\n                   return itemRight.position - itemLeft.position;\n                 }\n                 return itemLeft.word.length - item.word.length;\n               });\n             });\n             var slicesOfTitle = [];\n             if (indexOfTitle.length !== 0) {\n               var tmp = mergeIntoSlice(0, title.length, indexOfTitle, searchText);\n               searchTextCount += tmp.searchTextCountInSlice;\n               slicesOfTitle.push(tmp);\n             }\n             var slicesOfContent = [];\n             while (indexOfContent.length !== 0) {\n               var _item2 = indexOfContent[indexOfContent.length - 1];\n               var position = _item2.position,\n                 word = _item2.word;\n               // Cut out 100 characters\n               var start = position - 20;\n               var end = position + 30;\n               if (start < 0) {\n                 start = 0;\n               }\n               if (end < position + word.length) {\n                 end = position + word.length;\n               }\n               if (end > content.length) {\n                 end = content.length;\n               }\n               var _tmp = mergeIntoSlice(start, end, indexOfContent, searchText);\n               searchTextCount += _tmp.searchTextCountInSlice;\n               slicesOfContent.push(_tmp);\n             }\n   \n             // Sort slices in content by search text's count and hits' count\n             slicesOfContent.sort(function (sliceLeft, sliceRight) {\n               if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {\n                 return sliceRight.searchTextCount - sliceLeft.searchTextCount;\n               } else if (sliceLeft.hits.length !== sliceRight.hits.length) {\n                 return sliceRight.hits.length - sliceLeft.hits.length;\n               }\n               return sliceLeft.start - sliceRight.start;\n             });\n   \n             // Select top N slices in content\n             var upperBound = parseInt(CONFIG.search.top_n_per_article, 10);\n             if (upperBound >= 0) {\n               slicesOfContent = slicesOfContent.slice(0, upperBound);\n             }\n             var resultItem = '';\n             resultItem += '<div class=\"#search-hits item\">';\n             resultItem += '<li>';\n             var cats = categories !== undefined ? '<span>' + categories.join('<i class=\"ic i-angle-right\"></i>') + '</span>' : '<span>No categories</span>';\n             resultItem += \"<a href=\\\"\".concat(url, \"\\\">\") + cats;\n             if (slicesOfTitle.length !== 0) {\n               resultItem += \"<b>\".concat(highlightKeyword(title, slicesOfTitle[0]), \"</b><br>\");\n             } else {\n               resultItem += \"<b>\".concat(title, \"</b><br>\");\n             }\n             slicesOfContent.forEach(function (slice) {\n               resultItem += \"<li class=\\\"#search-hits subitem\\\">\".concat(highlightKeyword(content, slice), \" ...</li>\");\n             });\n   \n             resultItem += '</a>';\n             resultItem += '</li>';\n             resultItem += '</div>';\n             resultItems.push({\n               item: resultItem,\n               id: resultItems.length,\n               hitCount: hitCount,\n               searchTextCount: searchTextCount\n             });\n           }\n         });\n       }\n       if (keywords.length === 1 && keywords[0] === '') {\n         resultContent.innerHTML = '<div id=\"no-result\"><i></i></div>';\n       } else if (resultItems.length === 0) {\n         resultContent.innerHTML = '<div id=\"no-result\"><i></i></div>';\n       } else {\n         resultItems.sort(function (resultLeft, resultRight) {\n           if (resultLeft.searchTextCount !== resultRight.searchTextCount) {\n             return resultRight.searchTextCount - resultLeft.searchTextCount;\n           } else if (resultLeft.hitCount !== resultRight.hitCount) {\n             return resultRight.hitCount - resultLeft.hitCount;\n           }\n           return resultRight.id - resultLeft.id;\n         });\n       }\n       // Do pagination\n       total_pages = Math.ceil(resultItems.length / article_per_page);\n       pagination();\n     };\n     var fetchData = function fetchData() {\n       fetch(CONFIG.root + searchPath).then(function (response) {\n         return response.text();\n       }).then(function (res) {\n         // Get the contents from search data\n         isFetched = true;\n         datas = isXml ? _toConsumableArray(new DOMParser().parseFromString(res, 'text/xml').querySelectorAll('entry')).map(function (element) {\n           return {\n             title: element.querySelector('title').textContent,\n             content: element.querySelector('content').textContent,\n             url: element.querySelector('url').textContent\n           };\n         }) : JSON.parse(res);\n         // Only match articles with not empty titles\n         datas = datas.filter(function (data) {\n           return data.title;\n         }).map(function (data) {\n           data.title = data.title.trim();\n           data.content = data.content ? data.content.trim().replace(/<[^>]+>/g, '') : '';\n           data.url = decodeURIComponent(data.url).replace(/\\/{2,}/g, '/');\n           return data;\n         });\n         // Remove loading animation\n         document.getElementById('search-hits').innerHTML = '<i></i>';\n         inputEventFunction();\n       });\n     };\n     if (CONFIG.search.preload) {\n       console.log(\"fetch data.\");\n       fetchData();\n     }\n     if (CONFIG.search.trigger === 'auto') {\n       input.addEventListener('input', inputEventFunction);\n     } else {\n       document.querySelector('.search-icon').addEventListener('click', inputEventFunction);\n       input.addEventListener('keypress', function (event) {\n         if (event.key === 'Enter') {\n           inputEventFunction();\n         }\n       });\n     }\n   \n     // Handle and trigger popup window\n     document.querySelectorAll('.popup-trigger').forEach(function (element) {\n       element.addEventListener('click', function () {\n         document.body.style.overflow = 'hidden';\n         document.querySelector('.search-pop-overlay').classList.add('search-active');\n         input.focus();\n         if (!isFetched) fetchData();\n       });\n     });\n   \n     // Handle and trigger popup window\n     $.each('.search', function (element) {\n       element.addEventListener('click', function () {\n         document.body.style.overflow = 'hidden';\n         transition(siteSearch, 'shrinkIn', function () {\n           $('.search-input').focus();\n         }); // transition.shrinkIn\n       });\n     });\n   \n     // Monitor main search box\n     var onPopupClose = function onPopupClose() {\n       document.body.style.overflow = ' ';\n       transition(siteSearch, 0); // \"transition.shrinkOut\"\n     };\n   \n     siteSearch.addEventListener('click', function (event) {\n       if (event.target === siteSearch) {\n         onPopupClose();\n       }\n     });\n     $('.close-btn').addEventListener('click', onPopupClose);\n     window.addEventListener('pjax:success', onPopupClose);\n     window.addEventListener('keyup', function (event) {\n       if (event.key === 'Escape') {\n         onPopupClose();\n       }\n     });\n   }\n   \n   ```\n\n4. 配置信息添加参考：https://www.npmjs.com/package/hexo-generator-search\n\n\n\n# valine 评价功能\n\n## leancloud 配置\n\n{% links %}\n\n- site: leancloud 官网\n  url: https://leancloud.app/\n  desc: leancloud官方地址\n  image: https://www.leancloud.cn/assets/imgs/press/Logo%20-%20Normal%20Padding.0fd4f628.png\n  color: \"#2C97E8\"\n\n{% endlinks %}\n\n1、[获取 LeanCloud 的 appld 和 appkey](https://valine.js.org/quickstart.html) 。\n\n```yaml\nvaline:\n  appId: #Your_appId\n  appKey: #Your_appkey\n  placeholder: ヽ(○´∀`)ﾉ♪ # Comment box placeholder\n  avatar: mp # Gravatar style : mp, identicon, monsterid, wavatar, robohash, retro\n  pageSize: 10 # Pagination size\n  lang: zh-CN\n  visitor: true # 文章访问量统计\n  NoRecordIP: false # 不记录 IP\n  serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)；当使用 LeanCloud 共享域名时填入 LeanCloud 服务器地址 (REST API 服务器地址)\n  powerMode: true # 默认打开评论框输入特效\n  tagMeta:\n    visitor: 新朋友\n    master: 主人\n    friend: 小伙伴\n    investor: 金主粑粑\n  tagColor:\n    master: \"var(--color-orange)\"\n    friend: \"var(--color-aqua)\"\n    investor: \"var(--color-pink)\"\n  tagMember:\n    master:\n      # - hash of master@email.com\n      # - hash of master2@email.com\n    friend:\n      # - hash of friend@email.com\n      # - hash of friend2@email.com\n    investor:\n      # - hash of investor1@email.com\n```\n\n2、tagMeta 标签\n\ntag 标签显示在评论者名字的后面，默认是 `tagMeta.visitor` 对应的值。\n在 `tagMeta` 和 `tagColor` 中，除了 `visitor` 这个 key 不能修改外，其他 key 都可以换一换，但需要保证一致性。\n\n```yaml 举个栗子\ntagMeta:\n  visitor: 游客\n  admin: 管理员\n  waifu: 我老婆\ntagColor:\n  visitor: \"#855194\"\n  admin: \"#a77c59\"\n  waifu: \"#ed6ea0\"\ntagMember:\n  admin:\n    # - hash of admin@email.com\n  waifu:\n    # - hash of waifu@email.com\n```\n\n3、单篇文章评价配置\n\n在文章 Front Matter 中也可以配置上述参数，访问该文章页面时，将覆盖全局配置。\n尤其可以用来配置一个特殊的 `placeholder` ：\n\n```markdown\n---\nvaline:\n  placeholder: \"💪请遵守评价礼仪, 禁止恶意评价\\n🤣一起来玩啊, 留下你的足迹吧\\n⚠️公开网络, 注意隐私信息\"\n---\n```\n\n如果某一篇文章需要关闭评论功能，则在文章 Front Matter 中配置：\n\n```markdown\n---\ntitle: 关闭评论\ncomment: false\n---\n```\n\n\n\n## Valine Admin 配置\n\n{% links %}\n\n- site: Valine Admin 主站\n  url: https://github.com/DesertsP/Valine-Admin\n  desc: Valine-Admin网页地址\n  image: https://valine.js.org/images/valine.png\n  color: \"#0E9FCF\"\n\n{% endlinks %}\n\n评论通知与管理工具建议使用这个[ Valine-Admin](https://github.com/DesertsP/Valine-Admin) ；大致教程可参考：[Valine Admin 配置手册](https://deserts.io/valine-admin-document/) 。\n\n**以下作相关重要部分补充，以 LeanCloud 国际版为准。**\n\n### 自定义环境变量\n\n点击 `云引擎` - `-WEB` - `设置` - `添加`， 添加一些如下变量， 可以用来自定义一些邮件通知、通知模板、消息回复等个性化的设置。\n\n| 变量                | 示例                                                         | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| ADMIN_URL           | https://xxx.example.com/                                     | [建议] Web 主机二级域名（云引擎域名），用于自动唤醒          |\n| AKISMET_KEY         | xxxxxxx                                                      | [可选] [Akismet](https://akismet.com/) Key 用于垃圾评论检测，设为 MANUAL_REVIEW 开启人工审核，留空不使用反垃圾 |\n| BLOGGER_EMAIL       | `${SENDER_EMAIL}`                                            | [可选]博主通知收件地址，默认使用 SENDER_EMAIL                |\n| MAIL_SUBJECT        | `${PARENT_NICK}` ，您在 ​`${SITE_NAME}` 上的评论收到了回复    | [可选] 访客邮件接收主题                                      |\n| MAIL_SUBJECT_ADMIN  | `${SITE_NAME}` 上有新评论了                                  | [可选] 管理员邮件接收主题                                    |\n| MAIL_TEMPLATE       | [代码块_1](#MAIL_TEMPLATE)                                   | [可选] 访客邮件内容模板                                      |\n| MAIL_TEMPLATE_ADMIN | [代码块_2](#MAIL_TEMPLATE_ADMIN)                             | [可选] 管理员邮件内容模板                                    |\n| SENDER_EMAIL        | xxxxxx@qq.com                                                | [必填] 发件邮箱                                              |\n| SENDER_NAME         | user_name                                                    | [必填] 发件人                                                |\n| SITE_NAME           | xxx's blog                                                   | [必填] 博客名称                                              |\n| SITE_URL            | https://example.com/                                         | [必填] 博客首页地址                                          |\n| SMTP_HOST           | smtp.qq.com                                                  | [可选] SMTP_SERVICE留空时，自定义SMTP服务器地址              |\n| SMTP_PASS           | xxxxxxx                                                      | [必填] SMTP 登录密码（QQ 邮箱需要获取 SMTP 授权码，参照[客户端设置](https://service.mail.qq.com/cgi-bin/help?subtype=1&id=28&no=1001256)） |\n| SMTP_PORT           | 465 或 587，参照 [POP3 与 SMTP](https://service.mail.qq.com/cgi-bin/help?id=28&no=167&subtype=1) | [可选] SMTP_SERVICE 留空时，自定义 SMTP 端口                 |\n| SMTP_SECURE         | true                                                         | [可选] 使用 TLS                                              |\n| SMTP_SERVICE        | QQ                                                           | [新版支持] 邮件服务提供商，支持 QQ、163、126、Gmail 以及 [更多](https://nodemailer.com/smtp/well-known/#supported-services) |\n| SMTP_USER           | xxxxxx@qq.com                                                | [必填] SMTP 用户名                                           |\n\n注意 `SITE_URL` 需要以 `/` 结尾，否则在评价后台的`查看评价`的链接会对不上文章链接（缺 `/` 分割符）。\n\n#### MAIL_TEMPLATE\n\n变量实现：\n\n```html\n<div style=\"border-radius: 10px 10px 10px 10px;font-size:13px;    color: #555555;width: 666px;font-family:'Century Gothic','Trebuchet MS','Hiragino Sans GB',微软雅黑,'Microsoft Yahei',Tahoma,Helvetica,Arial,'SimSun',sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);\"><div style=\"width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;\"><p style=\"font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;\">您在<a style=\"text-decoration:none;color: #ffffff;\" href=\"${SITE_URL}\"> ${SITE_NAME}</a>上的留言有新回复啦！</p></div><div style=\"margin:40px auto;width:90%\"><p>${PARENT_NICK} 同学，您曾在文章上发表评论：</p><div style=\"background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;\">${PARENT_COMMENT}</div><p>${NICK} 给您的回复如下：</p><div style=\"background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;\">${COMMENT}</div><p>您可以点击<a style=\"text-decoration:none; color:#12addb\" href=\"${POST_URL}#comments\">查看回复的完整內容</a>，欢迎再次光临<a style=\"text-decoration:none; color:#12addb\"                href=\"${SITE_URL}\"> ${SITE_NAME}</a>。</p><style type=\"text/css\">a:link{text-decoration:none}a:visited{text-decoration:none}a:hover{text-decoration:none}a:active{text-decoration:none}</style></div></div>\n```\n\n#### MAIL_TEMPLATE_ADMIN\n\n变量实现：\n\n```html\n<div style=\"border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;\"><h2 style=\"border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;\">您在<a style=\"text-decoration:none;color: #12ADDB;\" href=\"${SITE_URL}\" target=\"_blank\">${SITE_NAME}</a>上的文章有了新的评论</h2><p><strong>${NICK}</strong>回复说：</p><div style=\"background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;\"> ${COMMENT}</div><p>您可以点击<a style=\"text-decoration:none; color:#12addb\" href=\"${POST_URL}\" target=\"_blank\">查看回复的完整內容</a><br></p></div></div>\n```\n\n### 访问域名设置\n\n在配置环境变量的下方，有以下两个的配置：\n\n- 使用共享域名（目前国际版需要自定义域名才运作）\n\n  这里可以自己定义，使用一个容易记忆的名称即可。在填写 `ADMIN_URL` 时，需要注意在域名前添加 `stg` 前缀。例如，我自己定义的名称为 `xxxblog` ，此时完整的域名包含了固定的后缀 `.avosapps.us` ，即完整的域名是 `https://xxxblog.avosapps.us` 。而 `ADMIN_URL` 中需要填写 `https://stg-xxxblog.avosapps.us` 。\n\n- 自定义域名\n\n  该域名需要二级域名，然后按正常的配置 DNS 解析，等通过就行了；如果绑定了域名，那么在变量中的 `ADMIN_URL` 则填写该域名。\n\n### 管理后台\n\n当部署完成后，首先需要设置管理员信息。访问管理员注册页面 `https://云引擎域名/sign-up` ，注册管理员登录信息，如：https://xxx.example.com//sign-up 。\n\n### 解决跨域问题\n\n在非国际版中，他们的 API 链接是会自动检测的；但当你使用的是国际版，它并不会自动检测。并且由于 us.avoscloud.com 这个域名被弃用了，因而会发生报错提示遇到跨域访问的问题。\n\n解决方法：\n\n1. 前往 https://console.leancloud.app/\n2. 选择并点击你的应用\n3. 前往 `设置` > `应用凭证`\n4. 然后你会看到一个 `REST API 服务器地址` 把那个链接复制起来\n5. 最后把它放入配置档案 `valine` 的 `serverURLs`\n   `serverURLs` 通常是这样的 `https://[appId 前八位].api.lncldglobal.com` ；或者对其进行域名绑定： `设置` -> `域名绑定` -> `API 访问域名` -> `绑定新域名` ，然后使用该域名配置到 `serverURLs` 中。\n\n最后提醒：\n\n请确保你的 `appKey` 和 `appId` 是正确的，这样你的评论功能就能正常使用了。\n\n### 定时唤醒\n\n关于自动休眠的官方说法：[点击查看](https://leancloud.cn/docs/leanengine_plan.html#hash633315134)。由于目前 leancloud 发布了 [[关于对体验版云引擎定时任务进行适当流控的说明](https://forum.leancloud.cn/t/topic/22595)](https://forum.leancloud.cn/t/topic/22595) 一则文章，导致 leancloud 的定时任务使用需要升级至标准版云引擎才能避免休眠；因此，在这里放弃 leancloud 的定时任务，利用 github actions 中的 workflow 定时执行命令访问 leancloud 的 web 域名，即可解决 leancloud 平台因为流控原因无法激活定时唤醒任务的问题：\n\n1. 主分支上创建 github actions 的 workflow 任务。\n\n2. 在 `xxx.yml` 文件中修改如下代码：\n\n   ```yaml\n   name: 'wake comment system'\n   on:\n     push:\n     schedule:\n       - cron: '7,33,53 0-15,23 * * *'\n       \n   jobs:\n     bot:\n       runs-on: ubuntu-latest\n       steps:\n         - run: curl -sLo /dev/null ${{ secrets.DOMAIN }}\n   ```\n\n3. 添加私钥 `DOMAIN` （域名）：\n\n   `仓库` -> `settings` -> `Secrets and variabled` -> `Actions` -> `New repository secret`\n\n   - Name：DOMAIN\n   - Value：你的 web 域名\n\n\n\n## 评价头像\n\n{% links %}\n\n- site: Gravatar 官网\n  url: https://cn.gravatar.com/\n  desc: Gravatar官方地址\n  image: https://upload.wikimedia.org/wikipedia/commons/5/5f/Gravatar-default-logo.jpg\n  color: \"#0A76B7\"\n\n{% endlinks %}\n\n1. 注册：进入 Gravatar 网站，点击左上角菜单里的 Sign In 进行登录 / 注册。\n2. 绑定邮箱及头像：点击 My Gravatar -> [Add email address](https://en.gravatar.com/emails/new) -> [Add a new image](https://en.gravatar.com/gravatars/new)\n\n3. 点击 `View rating` 可查看邮箱的 `hash` 码。hash 码可填入 shoka 主题的 `_config.yml` 文件中的 `valine.tagMember` 其中一处（评论区对应显示的 tag 标签）。配置好后，有缓冲时间，最慢有 7 天缓冲时间。\n\n\n\n# 字数及阅读时间统计\n\n**需要安装 `hexo-symbols-count-time` 插件。**\n\n安装后不需要修改站点配置文件，直接使用插件默认配置就行，如需进行配置，可参考：\n\n```yaml\n# hexo-symbols-count-time\n## shoka 主题默认采取了默认的配置，所以覆盖相应配置就行了\nsymbols_count_time:\n  symbols: true\n  time: true\n  total_symbols: true\n  total_time: true\n  exclude_codeblock: false\n  awl: 4\n  wpm: 245\n  suffix: \"mins.\"\n#exclude_codeblock: 是否排除代码块区域的字数统计\n#awl: 平均字符长度 (多少符字算一个中文或英文) 中文约是 2，英文约是 5，其他约是 6\n#wpm: 每分钟阅读字数  正常值约为 275 字，较小值约为 200 字，较快值约 350 字\n#suffix: 当总字数小于每分钟阅读字数时，默认采取的时间类型，不填写默认类型采取 \"mins.\"\n\n```\n\n启用则需要找到 `footer` 和 `post` 的两处 `count` ，修改为 `true` ：\n\n```yaml\n# 页尾全站统计\nfooter:\n  since: 2010\n  count: true\n\n# 文章界面统计\npost:\n  count: true\n```\n\n\n\n# 访问及阅读统计\n\nLeanCloud评价里面是有阅读访问统计，但是，目前由于 LeanCloud国际版不对国内用户提供服务了，因此改用其它记录统计，这里可以使用简单的[不蒜子](http://busuanzi.ibruce.info/)计数，操作更改也比较简单： **引脚本 + 写标签**\n\n1、调用不蒜子的官方脚本，这个比较简单，在你需要的地方调用如下代码\n\n```javascript\n# 引脚本\n<script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n\n# 写标签\n<span id=\"busuanzi_value_page_pv\"> # 当前访问页面次数\n\n<span id=\"busuanzi_container_site_uv\"> # 站点访客次数\n\n<span id=\"busuanzi_container_site_pv\"> # 站点访问总量\n```\n\n2、静态部署调用，这个需要在 `<root>/source/js` 路径下创建 `busuanzi.pure.min.js` 文件，如果 `js` 目录不存在则自己新建，并且把如下代码添加进去，并保存：\n\n```js\nvar bszCaller,bszTag;!function(){var c,d,e,a=!1,b=[];ready=function(c){return a||\"interactive\"===document.readyState||\"complete\"===document.readyState?c.call(document):b.push(function(){return c.call(this)}),this},d=function(){for(var a=0,c=b.length;c>a;a++)b[a].apply(document);b=[]},e=function(){a||(a=!0,d.call(window),document.removeEventListener?document.removeEventListener(\"DOMContentLoaded\",e,!1):document.attachEvent&&(document.detachEvent(\"onreadystatechange\",e),window==window.top&&(clearInterval(c),c=null)))},document.addEventListener?document.addEventListener(\"DOMContentLoaded\",e,!1):document.attachEvent&&(document.attachEvent(\"onreadystatechange\",function(){/loaded|complete/.test(document.readyState)&&e()}),window==window.top&&(c=setInterval(function(){try{a||document.documentElement.doScroll(\"left\")}catch(b){return}e()},5)))}(),bszCaller={fetch:function(a,b){var c=\"BusuanziCallback_\"+Math.floor(1099511627776*Math.random());window[c]=this.evalCall(b),a=a.replace(\"=BusuanziCallback\",\"=\"+c),scriptTag=document.createElement(\"SCRIPT\"),scriptTag.type=\"text/javascript\",scriptTag.defer=!0,scriptTag.src=a,scriptTag.referrerPolicy=\"no-referrer-when-downgrade\",document.getElementsByTagName(\"HEAD\")[0].appendChild(scriptTag)},evalCall:function(a){return function(b){ready(function(){try{a(b),scriptTag.parentElement.removeChild(scriptTag)}catch(c){bszTag.hides()}})}}},bszCaller.fetch(\"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback\",function(a){bszTag.texts(a),bszTag.shows()}),bszTag={bszs:[\"site_pv\",\"page_pv\",\"site_uv\"],texts:function(a){this.bszs.map(function(b){var c=document.getElementById(\"busuanzi_value_\"+b);c&&(c.innerHTML=a[b])})},hides:function(){this.bszs.map(function(a){var b=document.getElementById(\"busuanzi_container_\"+a);b&&(b.style.display=\"none\")})},shows:function(){this.bszs.map(function(a){var b=document.getElementById(\"busuanzi_container_\"+a);b&&(b.style.display=\"inline\")})}};\n```\n\n然后更改上面第一条代码的引用路径为本地路径，例如：`<script async src=\"https://xxx.example.com/js/busuanzi.pure.min.js\"></script>` ，`xxx.example.com` 为你的部署网站。后面三行的代码的 `<span id=\"xxx\">` 不用变动，只需在合适的地方调用想用的计数代码即可。\n\n3、举个例子，替换 shoka 主题原有的页面访问计数。在 `<root>/themes/shoka/layout/_partials/post/footer.njk` 文件中，添加并替换即可。如下图：\n\n![image-20221115121446459](image-20221115121446459.png)\n\n\n\n# RSS订阅\n\n**需要安装 `hexo-generator-feed` 插件。**\n\n安装完成后，需要在 `<root>/_config.yml` 配置中添加如下信息，并填写自己需要的信息：\n\n```yaml\nfeed:\n  enable: true\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n  content_limit: 140\n  content_limit_delim: ' '\n  order_by: -date\n  icon: icon.png\n  autodiscovery: true\n  template:\n```\n\n具体内容可参看：https://github.com/hexojs/hexo-generator-feed\n\n当然，如果有能力的，可以自建 rss 模板，shoka主题上也有提供，只需要如下调用模板即可：\n\n![image-20221115164425176](image-20221115164425176.png)\n\n最后，在需要获取 RSS 链接的地方添加 `/atom.xml` 即可。\n\n\n\n# 站点运行时间\n\n在配置站点页脚的 `<root>/themes/shoka/layout/_partials/footer.njk` 文件上，选择合适的地方添加如下代码：\n\n```javascript\n  {%- if theme.running_time.enable and theme.running_time.create_time %}\n  <div class=\"create_time\">\n    <span id=\"timeDate\">加载日期...</span>\n    <span id=\"times\">加载时间...</span>\n    <script>\n      var now = new Date();\n      function createtime() {\n        var grt = new Date('{{ theme.running_time.create_time }}');\n        now.setTime(now.getTime() + 250);\n        days = (now - grt) / 1000 / 60 / 60 / 24;\n        dnum = Math.floor(days);\n        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);\n        hnum = Math.floor(hours);\n        if (String(hnum).length == 1) {\n          hnum = \"0\" + hnum;\n        }\n        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);\n        mnum = Math.floor(minutes);\n        if (String(mnum).length == 1) {\n          mnum = \"0\" + mnum;\n        }\n        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n        snum = Math.round(seconds);\n        if (String(snum).length == 1) {\n          snum = \"0\" + snum;\n        }\n        document.getElementById(\"timeDate\").innerHTML = \" 本站存活 \" + dnum + \" 天 \";\n        document.getElementById(\"times\").innerHTML = hnum + \" 小时 \" + mnum + \" 分 \" + snum + \" 秒\";\n      }\n      setInterval(\"createtime()\", 250);\n    </script>\n  </div>\n  {%- endif %}\n```\n\n再在主题配置文件 `<root>/themes/shoka/_config.yml` 中添加：\n\n```yaml\n# Runing Time\nrunning_time:\n  enable: true\n  create_time: \"01/01/1945 19:00:00\" #此处修改你的建站时间或者网站上线时间\n```\n\n\n\n# SEO 优化及站点收录\n\n辛辛苦苦搭好网站，当然是想跟其他人一起分享博文啦；但是，对于个人博客，如果没有被搜索引擎收录的话，别人在搜索引擎基本上是看不到的。那么如何查看个人博客网站是否被收录？只需要在对应的搜索引擎搜索框上输入：\n\n```http\nsite:your_website\n```\n\neg:\n\n![image-20221126231952585](image-20221126231952585.png)\n\n## Google收录\n\n谷歌收录相对简单，只需要准备一个谷歌账号，然后访问 [Google Search Console](https://search.google.com/search-console/welcome) 如下图：\n\n![image-20221126232456573](image-20221126232456573.png)\n\n先登录账号，然后再输入个人博客网站域名。然后弹出验证网站所有权窗口，这里一般选择 `CNAME验证` ，接着根据提示操作即可，这里就不贴图，并且在你的网站管理那里添加给出来的 DNS 解析；最后等 DNS 更改生效，验证通过即可。完成后进入配置，添加站点地图链接，可能添加完后刷新会显示 `无法获取` 的状态，但其实是已经配置完成了。\n\n## Bing收录\n\n进入 [Bing Webmaster Tools](https://www.bing.com/webmasters/about) ，这个可以选择使用 GSC 导入网站，只需要授权一下即可；或者手动添加通过 `CNAME验证` 添加，如下图：\n\n![image-20221126234903144](image-20221126234903144.png)\n\n通过后，同样的添加站点地图链接。\n\n## Baidu收录\n\n访问 [百度搜索资源平台](https://ziyuan.baidu.com/) ，点击 `用户中心` -> `站点管理` ，然后添加网站，一路到验证通过，这里同样的使用 `CNAME验证` 即可，当然选择其他的也行，哪种方便用哪种：\n\n![image-20221127000022983](image-20221127000022983.png)\n\n验证完毕后，找到 `普通收录` ，选择 `sitemap` ，接着添加站点地图链接：\n\n![image-20221127000321081](image-20221127000321081.png)\n\n\n\n# 看板卡通模型\n\n这里使用 `live2d模块` ，比较简单。\n\n安装插件 `npm install --save hexo-helper-live2d` ，选则安装所需的卡通模型：https://github.com/xiazeyu/live2d-widget-models ，例如，安装名为 **unitychan** 的模型：\n\n```bash\nnpm install live2d-widget-model-unitychan\n```\n\n配置插件，在 `<root>/_config.yml` 中添加及更改如下信息：\n\n```yaml\nlive2d:\n  enable: true\n  scriptFrom: local # 默认\n  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径)\n  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径\n  pluginModelPath: assets/ # 模型文件相对与插件根目录路径\n  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中\n  debug: false # 调试, 是否在控制台输出日志\n  model:\n    use: live2d-widget-model-unitychan\n  display:\n    position: right #动画位置\n    width: 210\n    height: 380\n    # 位置配置，这个在左侧边栏位置很居中\n    hOffset: 50  # 调节水平位置\n    vOffset: -25  # 调节垂直位置\n  mobile:\n    show: false # 是否在移动设备上显示\n    scale: 0.5 # 移动设备上的缩放\n  react:\n    opacityDefault: 0.7\n    opacityOnHover: 0.8\n```\n\n","tags":["hexo"],"categories":["Hexo-shoka"]},{"title":"博客搭建笔记之 shoka 配置","url":"/shoka-config/","content":"\n\n\n\n\n> 以下配置皆在文件  `<root>/_config.shoka.yml` 修改。大部分摘录自：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/\n\n\n\n# 站点名称\n\n```yaml\nalternate: Yume Shoka\n```\n\n这里设置的名称代替 Logo，显示在页面顶部，以及页尾 ©️ 处。\n\n\n\n# 资源文件\n\n支持本地静态文件跟 cdn加速，默认值是 `/` ，指使用本地静态文件。\n\n```yaml\n# local static\nstatics: /\n\nor\n\n# jsdelivr cdn\nstatics: //cdn.jsdelivr.net/gh/Arachnid-97/arachnid@latest/\n```\n\n当然，也可以修改成 `//cdn.jsdelivr.net/gh/您的github用户名/您的项目名@latest/` 这种形式，以使用 jsDelivr 进行加速。\n\nPS：jsDelivr 并不是实时更新，重新生成文件后需要耐心等待（更新于 2022.05.25），目前 jsDelivr对于大陆已经失效，部署后需要使用魔法才能访问，至于为啥，就不多说了。\n\n```yaml\ncss: css\njs: js\nimages: images\n```\n\n静态文件所处目录的实际目录名，这些一般不改。\n\n\n\n# 夜间模式\n\n```yaml\ndarkmode: # true\n```\n\n默认情况下，是否开启夜间模式取决于（优先级从高到低）：\n\n1. 访客点击页面头部切换按钮的自行选择\n2. 访客切换了浏览设备的主题色调\n3. 您的 `darkmode` 配置项\n\n\n\n# 自动定位\n\n```yaml\nauto_scroll: true\n```\n\n默认情况下，再次打开页面时，会自动滚动到上次浏览的位置。\n这个选项设为 `false` 时将停用此功能。\n\n\n\n# 加载动画\n\n```\n# 是否显示页面加载动画 loading-cat\nloader:\n  start: true # 当初次打开页面时，显示加载动画\n  switch: true # tab 切换到其他页面时，显示加载动画\n```\n\n注：tab 切换后只是显示 loading 动画，实际并未重新加载页面。\n\n## 动画替换\n\nCSS 样式对应修改的文件位置： `<root>/themes/shoka/source/css/_common/components/third-party` 中的 `loading.styl` 文件。\n\n```stylus\n//css\n//\\themes\\shoka\\source\\css\\_common\\components\\third-party\\loading.styl\n//保留下面这几行,其余删除后写入新样式\n#loading {\n  @extend $fix-fullscreen;\n  background-color: var(--grey-1);\n  if(!hexo-config('loader.start')) {\n    display: none;\n  }\n  // 样式修改（可选）\n}\n\n// 你的CSS样式代码\n\n```\n\nhtml 对应修改的文件位置： `<root>/themes/shoka/layout/_partials` 中的 `layout.njk` 文件。\n\n```html\n//HTML\n//\\themes\\shoka\\layout\\_partials\\layout.njk\n<body itemscope itemtype=\"https://schema.org/WebPage\">\n  <div id=\"loading\">\n\t\t// 此处删除并重新写入 css 样式对应的 html 代码\n  </div>\n  <div id=\"container\">\n```\n\n\n\neg：仓鼠跑轮\n\n文件： `<root>/themes/shoka/source/css/_common/components/third-party/loading.styl`\n\n```stylus\n#loading {\n  @extend $fix-fullscreen;\n  background-color: var(--grey-1);\n  if(!hexo-config('loader.start')) {\n    display: none;\n  }\n  // 居中样式\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.loader-state { // 加载动画\n  .wheel-and-hamster {\n    --dur: 1s;\n    position: relative;\n    width: 12em;\n    height: 12em;\n    font-size: 14px;\n  }\n\n  .wheel,\n  .hamster,\n  .hamster div,\n  .spoke {\n    position: absolute;\n  }\n\n  .wheel,\n  .spoke {\n    border-radius: 50%;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  .wheel {\n    background: radial-gradient(100% 100% at center,hsla(0,0%,60%,0) 47.8%,hsl(0,0%,60%) 48%);\n    z-index: 2;\n  }\n\n  .hamster {\n    animation: hamster var(--dur) ease-in-out infinite;\n    top: 50%;\n    left: calc(50% - 3.5em);\n    width: 7em;\n    height: 3.75em;\n    transform: rotate(4deg) translate(-0.8em,1.85em);\n    transform-origin: 50% 0;\n    z-index: 1;\n  }\n\n  .hamster__head {\n    animation: hamsterHead var(--dur) ease-in-out infinite;\n    background: hsl(30,90%,55%);\n    border-radius: 70% 30% 0 100% / 40% 25% 25% 60%;\n    box-shadow: 0 -0.25em 0 hsl(30,90%,80%) inset,\n      0.75em -1.55em 0 hsl(30,90%,90%) inset;\n    top: 0;\n    left: -2em;\n    width: 2.75em;\n    height: 2.5em;\n    transform-origin: 100% 50%;\n  }\n\n  .hamster__ear {\n    animation: hamsterEar var(--dur) ease-in-out infinite;\n    background: hsl(0,90%,85%);\n    border-radius: 50%;\n    box-shadow: -0.25em 0 hsl(30,90%,55%) inset;\n    top: -0.25em;\n    right: -0.25em;\n    width: 0.75em;\n    height: 0.75em;\n    transform-origin: 50% 75%;\n  }\n\n  .hamster__eye {\n    animation: hamsterEye var(--dur) linear infinite;\n    background-color: hsl(0,0%,0%);\n    border-radius: 50%;\n    top: 0.375em;\n    left: 1.25em;\n    width: 0.5em;\n    height: 0.5em;\n  }\n\n  .hamster__nose {\n    background: hsl(0,90%,75%);\n    border-radius: 35% 65% 85% 15% / 70% 50% 50% 30%;\n    top: 0.75em;\n    left: 0;\n    width: 0.2em;\n    height: 0.25em;\n  }\n\n  .hamster__body {\n    animation: hamsterBody var(--dur) ease-in-out infinite;\n    background: hsl(30,90%,90%);\n    border-radius: 50% 30% 50% 30% / 15% 60% 40% 40%;\n    box-shadow: 0.1em 0.75em 0 hsl(30,90%,55%) inset,\n      0.15em -0.5em 0 hsl(30,90%,80%) inset;\n    top: 0.25em;\n    left: 2em;\n    width: 4.5em;\n    height: 3em;\n    transform-origin: 17% 50%;\n    transform-style: preserve-3d;\n  }\n\n  .hamster__limb--fr,\n  .hamster__limb--fl {\n    clip-path: polygon(0 0,100% 0,70% 80%,60% 100%,0% 100%,40% 80%);\n    top: 2em;\n    left: 0.5em;\n    width: 1em;\n    height: 1.5em;\n    transform-origin: 50% 0;\n  }\n\n  .hamster__limb--fr {\n    animation: hamsterFRLimb var(--dur) linear infinite;\n    background: linear-gradient(hsl(30,90%,80%) 80%,hsl(0,90%,75%) 80%);\n    transform: rotate(15deg) translateZ(-1px);\n  }\n\n  .hamster__limb--fl {\n    animation: hamsterFLLimb var(--dur) linear infinite;\n    background: linear-gradient(hsl(30,90%,90%) 80%,hsl(0,90%,85%) 80%);\n    transform: rotate(15deg);\n  }\n\n  .hamster__limb--br,\n  .hamster__limb--bl {\n    border-radius: 0.75em 0.75em 0 0;\n    clip-path: polygon(0 0,100% 0,100% 30%,70% 90%,70% 100%,30% 100%,40% 90%,0% 30%);\n    top: 1em;\n    left: 2.8em;\n    width: 1.5em;\n    height: 2.5em;\n    transform-origin: 50% 30%;\n  }\n\n  .hamster__limb--br {\n    animation: hamsterBRLimb var(--dur) linear infinite;\n    background: linear-gradient(hsl(30,90%,80%) 90%,hsl(0,90%,75%) 90%);\n    transform: rotate(-25deg) translateZ(-1px);\n  }\n\n  .hamster__limb--bl {\n    animation: hamsterBLLimb var(--dur) linear infinite;\n    background: linear-gradient(hsl(30,90%,90%) 90%,hsl(0,90%,85%) 90%);\n    transform: rotate(-25deg);\n  }\n\n  .hamster__tail {\n    animation: hamsterTail var(--dur) linear infinite;\n    background: hsl(0,90%,85%);\n    border-radius: 0.25em 50% 50% 0.25em;\n    box-shadow: 0 -0.2em 0 hsl(0,90%,75%) inset;\n    top: 1.5em;\n    right: -0.5em;\n    width: 1em;\n    height: 0.5em;\n    transform: rotate(30deg) translateZ(-1px);\n    transform-origin: 0.25em 0.25em;\n  }\n\n  .spoke {\n    animation: spoke var(--dur) linear infinite;\n    background: radial-gradient(100% 100% at center,hsl(0,0%,60%) 4.8%,hsla(0,0%,60%,0) 5%),\n      linear-gradient(hsla(0,0%,55%,0) 46.9%,hsl(0,0%,65%) 47% 52.9%,hsla(0,0%,65%,0) 53%) 50% 50% / 99% 99% no-repeat;\n  }\n\n  /* Animations */\n  @keyframes hamster {\n    from, to {\n      transform: rotate(4deg) translate(-0.8em,1.85em);\n    }\n\n    50% {\n      transform: rotate(0) translate(-0.8em,1.85em);\n    }\n  }\n\n  @keyframes hamsterHead {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(0);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(8deg);\n    }\n  }\n\n  @keyframes hamsterEye {\n    from, 90%, to {\n      transform: scaleY(1);\n    }\n\n    95% {\n      transform: scaleY(0);\n    }\n  }\n\n  @keyframes hamsterEar {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(0);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(12deg);\n    }\n  }\n\n  @keyframes hamsterBody {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(0);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(-2deg);\n    }\n  }\n\n  @keyframes hamsterFRLimb {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(50deg) translateZ(-1px);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(-30deg) translateZ(-1px);\n    }\n  }\n\n  @keyframes hamsterFLLimb {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(-30deg);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(50deg);\n    }\n  }\n\n  @keyframes hamsterBRLimb {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(-60deg) translateZ(-1px);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(20deg) translateZ(-1px);\n    }\n  }\n\n  @keyframes hamsterBLLimb {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(20deg);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(-60deg);\n    }\n  }\n\n  @keyframes hamsterTail {\n    from, 25%, 50%, 75%, to {\n      transform: rotate(30deg) translateZ(-1px);\n    }\n\n    12.5%, 37.5%, 62.5%, 87.5% {\n      transform: rotate(10deg) translateZ(-1px);\n    }\n  }\n\n  @keyframes spoke {\n    from {\n      transform: rotate(0);\n    }\n\n    to {\n      transform: rotate(-1turn);\n    }\n  }\n}\n\n```\n\n修改 `<root>/themes/shoka/layout/_partials/layout.njk` 中的 html 代码：\n\n```html\n...\n\n    <div class=\"loader-state\">\n      <div aria-label=\"Orange and tan hamster running in a metal wheel\" role=\"img\" class=\"wheel-and-hamster\">\n        <div class=\"wheel\"></div>\n        <div class=\"hamster\">\n          <div class=\"hamster__body\">\n            <div class=\"hamster__head\">\n              <div class=\"hamster__ear\"></div>\n              <div class=\"hamster__eye\"></div>\n              <div class=\"hamster__nose\"></div>\n            </div>\n            <div class=\"hamster__limb hamster__limb--fr\"></div>\n            <div class=\"hamster__limb hamster__limb--fl\"></div>\n            <div class=\"hamster__limb hamster__limb--br\"></div>\n            <div class=\"hamster__limb hamster__limb--bl\"></div>\n            <div class=\"hamster__tail\"></div>\n          </div>\n        </div>\n        <div class=\"spoke\"></div>\n      </div>\n    </div>\n\n...\n```\n\n为防止页面内加载动画位置偏移的问题，对 `<root>/themes/shoka/source/css\\_common/outline/outline.styl` 进行偏移补偿：\n\n在文件里，大约 38 line 左右找到 `\\#main {` 的块，然后仿写添加 `.cat` 的写法\n\n```stylus\n  .cat {\n    margin-top: 10rem;\n  }\n\n  // 新添加的，对应 <div class=\"loader-state\"> 加载类\n  .loader-state {\n    margin-top: 20rem;\n    margin-left: 15rem;\n  }\n```\n\n附：\n\nhttps://codepen.io/\n\nhttps://uiverse.io/\n\n\n\n# 烟花效果\n\n单击页面的烟花效果配置如下：\n\n```yaml\nfireworks:\n  enable: true # 是否启用\n  color: # 烟花颜色\n    - \"rgba(255,182,185,.9)\"\n    - \"rgba(250,227,217,.9)\"\n    - \"rgba(187,222,214,.9)\"\n    - \"rgba(138,198,209,.9)\"\n```\n\n\n\n# 加载谷歌字体\n\n```yaml\nfont:\n  enable: true\n  # Font options:\n  # `external: true` will load this font family from `host` above.\n  # `family: Times New Roman`. Without any quotes.\n  # `size: x.x`. Use `em` as unit. Default: 1 (16px)\n\n  # Global font settings used for all elements inside <body>.\n  global:\n    external: true\n    family: Mulish\n    size:\n\n  # Font settings for alternate title.\n  logo:\n    external: true\n    family: Fredericka the Great\n    size: 3.5\n\n  # Font settings for site title.\n  title:\n    external: true\n    family: Noto Serif JP\n    size: 2.5\n\n  # Font settings for headlines (<h1> to <h6>).\n  headings:\n    external: true\n    family: Noto Serif SC\n    size:\n\n  # Font settings for posts.\n  posts:\n    external: true\n    family:\n\n  # Font settings for <code> and code blocks.\n  codes:\n    external: true\n    family: Inconsolata\n```\n\n此功能基本参考 NexT。\n加粗标题的字体总是使用 `Noto Serif` ，为了正确友好的显示日文中的汉字，会先后加载 `headings` 和 `title` 的字体设置。\n\n\n\n# iconfont 图标\n\n对应文件位置： `<root>/themes/shoka/source/css` 中的 `_iconfont.styl` 文件。\n\n`font-family` 设为 `ic` ，所有字体样式前缀为 `i-` ；具体参见 `<root>/themes/shoka/source/css/_iconfont.styl` 。\n\n## 自定义图标\n\n如果需要添加或修改，需要找 shoka 主题的博主姐姐添加您的[ Iconfont](https://www.iconfont.cn/) 用户名到项目中，此后您可以任意全选项目文件，批量保存到购物车中，添加至您自己的项目里，并将主题配置文件中的 `iconfont` 值改为您的项目。\n\n注意，您的项目应设置 `FontClass/Symbol` 前缀 为 `i-` 。\n\n在 `<root>/source/_data/` 目录新建文件 `iconfont.styl` ，把新增或修改的图标样式复制到这个文件中。\n\n> 自定义 `iconfont.styl` 文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。\n\n最后，在配置文件中更改你的 `iconfont` 项目名：\n\n```yaml\n# project of https://www.iconfont.cn/\n# //at.alicdn.com/t/font_1832207_c8i9n1ulxlt.css => 1832207_c8i9n1ulxlt\niconfont: \"1832207_igi8uaupcus\"\n```\n\n\n\n# 菜单\n\n```yaml\nmenu:\n  home: / || home\n  posts:\n    default: / || feather\n    archives: /archives/ || list-alt\n    categories: /categories/ || th\n    tags: /tags/ || tags\n  friends: /friends/ || heart\n```\n\n`menu` 支持一级子目录，子目录设置中的第一项必须为 `default` ，用来定义父级按钮的样式。\n\n\n\n# 社交按钮\n\n```yaml\n# Social Links\n# Usage: `Key: permalink || icon || color`\n# Key is the link label showing to end users.\n# Value before `||` delimiter is the target permalink,\n# secend value is the name of Font icon.\nsocial:\n  github: https://github.com/amehime || github || \"#191717\"\n  #google: https://plus.google.com/yourname || google\n  twitter: https://twitter.com/amehime || twitter || \"#00aff0\"\n  zhihu: https://www.zhihu.com/people/rurismzk || zhihu || \"#1e88e5\"\n  music: https://music.163.com/#/user/home?id=12886823 || cloud-music || \"#e60026\"\n  weibo: https://weibo.com/amehime || weibo || \"#ea716e\"\n  about: https://about.me/amehime || address-card || \"#3b5998\"\n  #email: mailto:yourname@mail.com || envelope || \"#55acd5\"\n  #facebook: https://www.facebook.com/yourname || facebook\n  #stackoverflow: https://stackoverflow.com/yourname || stack-overflow\n  #youtube: https://youtube.com/yourname || youtube\n  #instagram: https://instagram.com/yourname || instagram\n  #skype: skype:yourname?call|chat || skype\n  #douban: https://www.douban.com/people/yourname/ || douban\n```\n\n如上，使用 `||` 作为分隔符，依次为 `链接 || 图标 || 颜色` 。\n注意，只需要写图标名称，如 `github` ，则会自动转换为 `ic i-github` 。\n十六进制颜色码需要 `\"\"` 包绕。\n\n\n\n# 边栏配置\n\n边栏可以选择在左侧，或右侧。\n\n```yaml\nsidebar:\n  # Sidebar Position.\n  position: left\n  #position: right\n  # Replace the default avatar image and set the url here.\n  avatar: avatar.jpg\n```\n\n修改头像文件的地址，相对于静态文件目录 `images` 中配置的路径。\n\n可以将自己的图片放在 `<root>/source/_data/images/` 目录下并保持同名，甚至以同名覆盖主题内默认的头像图片。\n\n\n\n# 底部 widgets\n\n目前页面底部可以显示两个小部件，即 `随机文章` 和 `最近评论` 。\n\n```yaml\nwidgets:\n  random_posts: true # 显示随机文章\n  recent_comments: true # 显示最近评论\n```\n\n\n\n# 打赏功能\n\n```yaml\n# Reward (Donate)\nreward:\n  # If true, reward will be displayed in every article by default.\n  enable: true\n  account:\n    wechatpay: /wechatpay.png\n    alipay: /alipay.png\n    # paypal: /paypal.png\n```\n\n默认打开，对应的奖赏图片在 `<root>/themes/shoka/source/images` 中找到对应的名称图片。\n\n\n\n# 标签显示\n\n```yaml\n# TagCloud settings for tags page.\ntagcloud:\n  # All values below are same as default, change them by yourself.\n  min: 16 # Minimun font size in px\n  max: 22 # Maxium font size in px\n  start: \"#72cecf\" # Start color (hex, rgba, hsla or color keywords)\n  end: \"#ffbac3\" # End color (hex, rgba, hsla or color keywords)\n  amount: 200 # Amount of tags, change it if you have more than 200 tags\n```\n\n\n\n# 背景音乐\n\n在主题配置文件中，设置全局播放列表。\n在文章的 Front Matter 中，设置文章专有播放列表，访问该文章页面时，将覆盖全局配置。\n\n```yaml\naudio:\n  - https://music.163.com/song?id=1387098940\n  - https://music.163.com/#/playlist?id=2088001742\n  - https://www.xiami.com/collect/250830668\n  - https://y.qq.com/n/yqq/playsquare/3535982902.html\n```\n\n如上，可以直接使用网易云、虾米、QQ 音乐的播放列表、单曲，可以同时填写多个。\n\n```yaml\naudio:\n  - title: 列表1\n    list:\n      - https://music.163.com/#/playlist?id=2943811283\n      - https://music.163.com/#/playlist?id=2297706586\n  - title: 列表2\n    list:\n      - https://music.163.com/#/playlist?id=2031842656\n```\n\n如果需要自定义媒体文件，可以按照以下格式填写：\n\n```yaml\naudio:\n  - name: \"曲目1\"\n    url: \"播放地址\"\n    artist: \"艺术家\"\n    cover: \"封面\"\n    lrc: \"歌词\"\n  - name: \"曲目2\"\n    url: \"播放地址\"\n    artist: \"艺术家\"\n    cover: \"封面\"\n    lrc: \"歌词\"\naudio:\n    - title: 列表1\n      list:\n        - name: \"曲目1\"\n          url: \"播放地址\"\n          artist: \"艺术家\"\n          cover: \"封面\"\n          lrc: \"歌词\"\n        - name: \"曲目2\"\n          url: \"播放地址\"\n          artist: \"艺术家\"\n          cover: \"封面\"\n          lrc: \"歌词\"\n    - title: 列表2\n      list:\n        - https://music.163.com/#/playlist?id=2031842656\n```\n\n如果要关闭当前页面的背景音乐播放器，则在文章 Front Matter 中配置：\n\n```markdown\n---\ntitle: 关闭背景音乐\naudio: false\n---\n```\n\n\n\n# 随机图库\n\n- 默认的图片列表位于 `<root>/themes/shoka/_images.yml` 中。\n  使用了渣浪图库，使用一些上传工具，比如[这里](https://pic.gimhoy.com/)\n  上传后图片的链接是 `http://wx4.sinaimg.cn/large/6833939bly1gicmnywqgpj20zk0m8dwx.jpg` 。\n  只需要新一行写上 `- 6833939bly1gicmnywqgpj20zk0m8dwx.jpg` 。\n\n  如果想要自定义，则在 `<root>/source/_data/` 目录新建一个 `images.yml` 文件，这个文件中的图片至少 6 枚，将完全覆盖默认的图片列表。\n\n- 也可以直接在图片列表 yml 文件中，写上任意外链图片地址\n\n```yaml\n- https://i.loli.net/2020/10/30/qAMYEFXxJcKRsiG.gif\n- https://i.loli.net/2020/10/30/rjdhcSgEN8COBPA.jpg\n- https://i.loli.net/2020/10/30/HKyzSd7NI3mlBpt.jpg\n- https://i.loli.net/2020/10/30/Y1CBXqgeokEs457.jpg\n- https://i.loli.net/2020/10/30/Z5W6r2BSoiThHG1.jpg\n```\n\n- 也可以在主题配置文件中，设置图床 API：\n\n```yaml\nimage_server: \"https://acg.xydwz.cn/api/api.php\"\n```\n\n\n\n# 网页标题栏签名\n\n原样式：\n\n- **（●´3｀●）やれやれだぜ**\n\n- **（´Д｀）大変だ！**\n\n对应修改文件位置： `<root>\\themes\\shoka\\languages` 中对应语言中的 `favicon` 元素：\n\n```yaml\nfavicon:\n  show: # 切换回来的提示语\n  hide: # 退出页面的签名\n```\n\n\n\n# 加载第三方组件\n\n```yaml\nvendors:\n  css:\n    # 略略略\n  js:\n    # 略略略\n```\n\n包括：\n\n| `pace`                    | 加载进度条                                  | 全局 |\n| :------------------------ | :------------------------------------------ | :--- |\n| `pjax`                    | 页面无刷新加载                              | 全局 |\n| `anime`                   | js 动画效果                                 | 全局 |\n| `algolia` `instantsearch` | 基于 algolia 的站内搜索                     | 全局 |\n| `lazyload`                | 图片懒加载                                  | 全局 |\n| `quicklink`               | 链接资源预加载                              | 全局 |\n| `fetch`                   | 获取播放列表                                | 全局 |\n| `katex` `copy_tex`        | 数学公式显示及复制                          | 按需 |\n| `fancybox`                | 图片放大显示及排列                          | 按需 |\n| `valine`                  | 基于 LeanCloud 的评论系统及文章阅读次数统计 | 按需 |\n| `chart`                   | 图表显示                                    | 按需 |\n\n以上文件加载全部基于 jsDelivr，并对全局加载的组件进行了文件合并。\n如果不明白啥意思，则不要轻易修改。\n\n\n\n# 文章 Hover 效果\n\n在 `<root>/themes/shoka/source/css/_mixins.styl` 文件中添加：\n\n```stylus\nthe-transition-margin(duration = .3s, function = ease, delay = 0s, property = margin) {\n\ttransition:property duration function delay;\n}\n```\n\n在 `<root>/themes/shoka/source/css/_common/components/pages/home.styl` 文件上的 `.segments` 字段里的内容，分别进行如下修改：\n\n1. 修改鼠标悬浮后图片变暗效果，增加 `brightness` 属性：\n\n   ```stylus\n   // 在 257 line 左右插入\n         .cover {\n           filter: brightness(.3);\n         }\n   ```\n\n2. 修改两处 `&:hover` 父引用里的 `.cover img` 字段里的变量 `transform` ：\n\n   ```stylus\n   // 在 263 line 左右更改为\n   transform: scale(1.25) rotate(2deg); // 修改鼠标悬浮后旋转效果\n   \n   // 在 383 line 左右更改为\n   transform: scale(1.25) rotate(-2deg); // 修改另一个方向的旋转效果\n   ```\n\n3. 修改鼠标悬浮后内容宽度、标题位置，摘要显示：\n\n   ```stylus\n   // 紧接 .cover img 下面插入\n         .info {\n           width: 75%;\n           +mobile(){\n             width: 100%;\n           }\n         }\n   \n         .info h3{\n           margin: .625rem 0;\n           color: var(--color-blue);\n         }\n   \n         .excerpt {\n           opacity: 1;\n         }\n   ```\n\n4. 修改鼠标悬浮前标题位置：\n\n   ```stylus\n   // 在 314 line 左右找到\n       h3 {\n         text-overflow: ellipsis;\n         overflow: hidden;\n         white-space: nowrap;\n         margin: .625rem 0;\n         color: var(--primary-color);\n       }\n   \n   修改为\n   \n       h3 {\n         text-overflow: ellipsis;\n         overflow: hidden;\n         white-space: nowrap;\n         margin: 3.525rem 0 0 0;\n         color: var(--primary-color);\n         the-transition-margin(); // 平滑过渡\n       }\n   ```\n\n5. 修改悬浮前摘要内容显示，在 `.excerpt` 字段中追加变量：\n\n   ```stylus\n   // 在 340 line 左右找到\n       .excerpt {\n         overflow: hidden;\n         font-size: $font-size-small;\n         max-height: 5rem;\n         display: -webkit-box;\n         -webkit-box-orient: vertical;\n         -webkit-line-clamp: 3;\n         text-overflow: ellipsis;\n         // 以下 3 项为追加内容\n         opacity: 0; // 不显示\n         pointer-events: none;\n         the-transition(); // 过渡\n       }\n   ```\n\n6. 最后在相应的地方加入过度处理，这里就直接全部贴上 code 吧：\n\n   ```stylus\n   .segments {\n     the-flex();\n   \n     > .item {\n       @extend $item;\n   \n       display: flex;\n       border-radius: .625rem;\n   \n       width: calc(100% - 2rem);\n       min-width: calc(100% - 2rem);\n   \n       shadow-box(false);\n       the-transition();\n   \n   \n       +mobile() {\n         flex-direction: column;\n         height: fit-content;\n         max-height: fit-content;\n       }\n   \n       &:hover {\n         box-shadow: 0 0 2rem var(--box-bg-shadow);\n   \n         .cover {\n           filter: brightness(.3);\n         }\n   \n         .cover img {\n           transform: scale(1.25) rotate(2deg);\n         }\n   \n         .info {\n           width: 75%;\n           +mobile(){\n             width: 100%;\n           }\n         }\n   \n         .info h3{\n           margin: .625rem 0;\n           color: var(--color-blue);\n         }\n   \n         .excerpt {\n           opacity: 1;\n         }\n       }\n     }\n   \n     .cover {\n       width: 50%;\n       margin-right: 1.5rem;\n       clip-path: polygon(0 0, 92% 0%, 100% 100%, 0% 100%);\n       border-radius: .625rem 0 0 .625rem;\n       overflow: hidden;\n       the-transition();\n   \n       +mobile() {\n         width: 100%;\n         height: 14rem;\n         margin: auto;\n         clip-path: polygon(0 0, 100% 0, 100% 92%, 0 100%);\n         border-radius: .625rem .625rem 0 0;\n       }\n   \n       img {\n         object-fit: cover;\n         width: 100%;\n         height: 100%;\n       }\n     }\n   \n     .info {\n       position: relative;\n       width: 50%;\n       padding: 1rem 1.5rem 3rem 0;\n       perspective: 62.5rem;\n       the-transition();\n   \n       +mobile() {\n         width: 100%;\n         height: 14rem;\n         padding: 0rem 1rem 3rem;\n       }\n   \n       .meta {\n         display: flex;\n         justify-content: flex-end;\n         margin: 0;\n   \n         +mobile() {\n           .item:not(:first-child) {\n             display: none;\n           }\n         }\n       }\n   \n       h3 {\n         text-overflow: ellipsis;\n         overflow: hidden;\n         white-space: nowrap;\n         margin: 3.525rem 0 0 0;\n         color: var(--primary-color);\n         the-transition-margin();\n       }\n   \n       .excerpt {\n         overflow: hidden;\n         font-size: $font-size-small;\n         max-height: 5rem;\n         display: -webkit-box;\n         -webkit-box-orient: vertical;\n         -webkit-line-clamp: 3;\n         text-overflow: ellipsis;\n         opacity: 0;\n         pointer-events: none;\n         the-transition();\n       }\n   \n     }\n   \n   \n     > .item:nth-child(even) {\n       flex-direction: row-reverse;\n   \n       +mobile() {\n         flex-direction: column;\n       }\n   \n       .cover {\n         margin-right: auto;\n         margin-left: 1.5rem;\n         clip-path: polygon(0 0%, 100% 0%, 100% 100%, 8% 100%);\n         border-radius: 0rem .625rem .625rem 0;\n   \n         +mobile() {\n           width: 100%;\n           margin: auto;\n           clip-path: polygon(0 0,100% 0,100% 100%,0 92%);\n           border-radius: .625rem .625rem 0 0;\n         }\n       }\n   \n       .info {\n         padding: 1rem 0 3rem 1.5rem;\n   \n         +mobile() {\n           padding: 0rem 1rem 3rem;\n         }\n   \n         .meta {\n           justify-content: flex-start;\n         }\n       }\n   \n       .btn {\n         left: 0;\n         right: auto;\n         border-radius: 0 1rem;\n         background-image: linear-gradient(to right, var(--color-orange) 0, var(--color-pink) 100%);\n       }\n   \n       .meta.footer {\n         right: .5rem;\n         justify-content: flex-start;\n       }\n   \n       &:hover {\n         .cover img {\n           transform: scale(1.25) rotate(-2deg);\n         }\n       }\n     }\n   }\n   \n   ```\n\n   \n\n","tags":["hexo"],"categories":["Hexo-shoka"]},{"title":"博客搭建笔记之 Hexo-shoka","url":"/hexo-shoka-create/","content":"\n# 前言\n\n1. 欢迎访问 “ **Arachnid's blog** ”：[https://arachnid.cc](https://arachnid.cc)\n\n2. 本系列专属于记录个人博客搭建过程，使用 Hexo 框架 + shoka 主题 + Github pages 服务；你说有啥好？那就是：gayhub 不倒博客继续跑。\n3. 目前功能效果：分类、标签、评论、搜索、背景音乐、赞赏、字数统计、阅读量统计、随机图库、社交外链、页面特效等等。\n\n\n\n# 准备工作\n\n此处开始之前，默认你已经实现了以下操作：\n\n- 拥有一个 [Github](https://github.com/) 账号，没有的话去注册一个；\n- 安装了 [Node.js](https://nodejs.org/en/) （注意 [Hexo版本限制](https://hexo.io/zh-cn/docs/#Node-js-%E7%89%88%E6%9C%AC%E9%99%90%E5%88%B6)），并了解相关 npm 的基础知识；\n- 安装了 [git](https://git-scm.com/)（或者其它终端），以下默认你的终端服务为 git 。\n\n然后其他的 git 绑定 Github、生成 ssh 这些操作也默认你准备完成了，实在不懂就网上搜一下吧。\n\n\n\n# 网站建立\n\n## 本地建站\n\n**1、安装 Hexo**\n\n打开 git 终端，输入安装命令并回车：\n\n```bash\nnpm install -g hexo-cli\n```\n\n然后拓展一下 npm常规命令：\n\n```bash\nnpm ls -dept 0 #查看已安装插件\nnpm install Plugin_name --save #安装名为 Plugin_name的插件\nnpm uninstall Plugin_name #卸载名为 Plugin_name的插件\nnpm outdated #检查插件更新\n```\n\n**2、建立本地存储**\n\n**创建**并**打开**你需要存放 blog 网站代码的文件夹，例如 “*blog_dir*” ：\n\n```\nmkdir \"blog_dir\"\ncd \"blog_dir\"\n```\n\n初始化 Hexo，输入命令并回车：\n\n```bash\nhexo init\n```\n\n然后启动本地服务查看，此处为动态访问，非静态网页：\n\n```bash\nhexo s\n```\n\n最后根据输出提示，浏览器打开链接 [http://localhost:4000/](http://localhost:4000/)，你将会访问到 Hello World；至此，你已经完成本地博客搭建了，请为自己欢呼 \"tada\"\n\n**note：** 可能有些在启动本地服务查看时会出现端口被占用的情况，那么可以通过更改端口来实现访问，具体命令看下一点。\n\n**3、hexo 常用命令**\n\n```raw\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo new draft \"draftName\" #新建草稿\nhexo generate #生成静态页面至 public目录\nhexo server #本地动态访问页面（默认端口 4000，'ctrl + c'关闭 server）\nhexo deploy #部署到服务器\nhexo clean #删除缓存文件及静态文件\nhexo help  #查看帮助\nhexo version  #查看 Hexo的版本\n```\n\n更多操作可查看：[Hexo指令](https://hexo.io/zh-cn/docs/commands.html)\n\n关于有用的指令缩写：\n\n```raw\nhexo cl == hexo clean\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n\nhexo s -p \"new_port\" #更改访问端口并启动访问服务\nhexo s -s #调用静态页面进行本地访问，确保调用过 `hexo g` 命令\nhexo d -g #预先生成静态文件并部署到服务器\n\nhexo cl && hexo d -g #清缓存、重构静态页面、部署 --- 俗称 \"一键三连\"\n```\n\n\n\n## 云端部署 --- 基于 Github pages\n\n**1、创建仓库**\n\n前往 [GitHub](https://github.com/) 并[创建](https://github.com/new)一个名为 ***username* .github.io** 的公共存储库，其中*username* 是您在 GitHub 上的用户名（注意必须要对应上，否则无法使用）\n\n**2、关联服务器地址**\n\n打开你的 “*blog_dir*” 文件夹，在根目录下找到 `_config.yml` 文件对其进行以下修改：\n\n![image-20220503173246533](image-20220503173246533.png)\n\n`repo`为上面创建的仓库地址，`branch`填写主分支（新的是 `main` ，以前旧的是 `master`）\n\n安装关联插件：\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n其他的就不多作解释了，详细可看：[Hexo 一站式部署](https://hexo.io/docs/one-command-deployment)\n\n**3、一键三连**\n\n执行：\n\n```bash\nhexo cl && hexo d -g\n```\n\n\n\n## 域名绑定（可选）\n\n**1、注册购买域名**\n\n一般的话，国内比较好的就 [阿里云](https://wanwang.aliyun.com/domain/)或者 [腾讯云](https://dnspod.cloud.tencent.com/)，国外就 [NameSilo](https://www.namesilo.com/)和 [Dynadot](https://www.dynadot.com/)，当然，除了这些还有很多域名购买网站；然而，最好就是找那些比较大型稳定的网站购买；除此之外，你也可以到 https://www.nazhumi.com/ 中查看在哪里购买会性价比更高一些。\n\n**2、域名解析**\n\n对于不同的购买网站，其操作不同，这里用的是 NameSilo：\n\n![image-20220512223909467](image-20220512223909467.png)\n\n进入域名管理，然后在你想要设置的域名中，配置 DNS 解析。\n\n![image-20220512224914568](image-20220512224914568.png)\n\n在 DNS 设置部分，你可以删除自带的记录，再重新添加；又或者直接编辑原有的记录，不过要对应上类型，一般只需要 `C` 和 `CNAME` 这两个类型就足够了。\n\n**3、绑定域名到 Hexo 博客**\n\n进入本地博客文件夹的 source 目录，打开记事本，里面输入自己的域名，如 http://www.example.com，保存名称为 “CNAME”。如我的是：\n\n![image-20220512230351288](image-20220512230351288.png)\n\n记住，直接是 “CNAME” 文件，是不带后缀的。\n\n**4、开启 HTTPS服务**\n\n在完成上一步域名文件创建后，通过 “一键三连” 重新部署网站，然后来到 GitHub博客仓库里进行打开：\n\n![image-20220512231152522](image-20220512231152522.png)\n\nHTTPS 证书部署成功需要一定时间，等大概几分钟再访问域名，就可以看到域名前面的小绿锁了，至此 HTTPS 配置完成！\n\n\n\n# 主题修改\n\nhexo目前收录了三百多个[主题](https://hexo.io/themes/)，你可以对他们进行一直修改，这些都是可以的，当然，如果你也可以自己创作一个专属于你自己的主题。以下皆以 shoka 主题进行解说。\n\n\n\n## 应用主题\n\n### 安装主题文件\n\n拉取 Shoka 主题到 `themes/shoka` 目录，在 Hexo 根目录（即你的 blog 根目录，后面全部统称 `<root>` ）执行下面的命令：\n\n```bash\ngit clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka\n```\n\n### 更换主题模式\n\n修改配置文件，更改主题模式为 `shoka` ；在 `<root>/_config.yml` 文件中找到 `theme` ，做如下更改：\n\n```yaml\ntheme: shoka\n```\n\n### 修改主题配置\n\n主题配置的所有参数在 `<root>/themes/shoka/_config.yml` 文件中。\n\n为了避免以后主题版本升级或者提交出现配置合并或冲突，建议复制主题目录下的  `_config.yml` 到 Hexo 根目录，并命名为 `_config.shoka.yml` ，也就是说，所有主题的自定义配置均保存于 `<root>/_config.shoka.yml` 文件。现在，您可以删除 shoka 主题目录下的 `_config.yml` 文件，或将它重命名为 `_config.yml.template` 。\n\n然后，里面的配置信息，这里就不阐述了，直接看 shoka 主题的博主姐姐的文章吧：\n\n[主题的基础配置可以参考这里](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/)\n[界面显示相关的配置参考这里](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/)\n\n\n\n## 插件依赖\n\n根据 shoka 主题的博主姐姐写的[文章](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/) ，净化的 shoka 主题必须安装以下两个插件：\n\n| 插件名称                        | npm 地址                                                     | 功能                              |\n| ------------------------------- | ------------------------------------------------------------ | --------------------------------- |\n| hexo-renderer-multi-markdown-it | [链接](https://www.npmjs.com/package/hexo-renderer-multi-markdown-it) | md 文件渲染器，压缩 css/js/html   |\n| hexo-autoprefixer               | [链接](https://www.npmjs.com/package/hexo-autoprefixer)      | 给生成的 css 文件们添加浏览器前缀 |\n\n然后安装完以上插件后，修改站点配置文件 `<root>/_config.yml` ，加入相关配置。\n\n### multi-markdown-it 安装与配置\n\n#### 安装\n\n1. 安装前，记得务必卸载掉默认的 `hexo-renderer-marked` ，以及别的 markdown 文件渲染器。\n\n   ```bash\n   npm un hexo-renderer-marked --save\n   # 或者\n   yarn remove hexo-renderer-marked\n   ```\n\n2. 安装插件\n\n   ```bash\n   npm i hexo-renderer-multi-markdown-it --save\n   # 或者\n   yarn add hexo-renderer-multi-markdown-it\n   ```\n\n#### 配置\n\n1. 加入 `markdown` 配置，用来渲染 md 文件\n\n   ```yaml\n   markdown:\n     render: # 渲染器设置\n       html: false # 过滤 HTML 标签\n       xhtmlOut: true # 使用 '/' 来闭合单标签 （比如 <br />）。\n       breaks: true # 转换段落里的 '\\n' 到 <br>。\n       linkify: true # 将类似 URL 的文本自动转换为链接。\n       typographer: \n       quotes: '“”‘’'\n     plugins: # markdown-it 插件设置\n       - plugin:\n           name: markdown-it-toc-and-anchor\n           enable: true\n           options: # 文章目录以及锚点应用的 class 名称，shoka 主题必须设置成这样\n             tocClassName: 'toc'\n             anchorClassName: 'anchor'\n       - plugin:\n           name: markdown-it-multimd-table\n           enable: true\n           options:\n             multiline: true\n             rowspan: true\n             headerless: true\n       - plugin:\n           name: ./markdown-it-furigana\n           enable: true\n           options:\n             fallbackParens: \"()\"\n       - plugin:\n           name: ./markdown-it-spoiler\n           enable: true\n           options:\n             title: \"你知道得太多了\"\n   ```\n\n2. 加入 `minify` 配置，压缩 css/js/html\n\n   ```yaml\n   minify:\n     html:\n       enable: true\n       exclude: # 排除 hexo-feed 用到的模板文件\n         - '**/json.ejs'\n         - '**/atom.ejs'\n         - '**/rss.ejs'\n     css:\n       enable: true\n       exclude:\n         - '**/*.min.css'\n     js:\n       enable: true\n       mangle:\n         toplevel: true\n       output:\n       compress:\n       exclude:\n         - '**/*.min.js'\n   ```\n\n3. 停用默认代码高亮功能，否则代码块的 mac 样式不能正常显示。\n\n   在 `<root>/_config.yml` 中找到 `highlight` 和 `prismjs` ，把 `enable` 改成 `false` 。\n\n   ```yaml\n   highlight:\n     enable: false\n   \n   prismjs:\n     enable: false\n   ```\n\n### autoprefixer 安装与配置\n\n#### 安装\n\n```yaml\nnpm i hexo-autoprefixer --save\n# 或者\nyarn add hexo-autoprefixer\n```\n\n#### 配置\n\n```yaml\nautoprefixer:\n  exclude:\n    - '*.min.css'\n```\n\n\n\n# 站点基本配置\n\n## 设置站点资料\n\n在 `<root>/_config.yml` 中的 `# Site` 栏目可以配置属于自己信息：\n\n|    参数     |                             描述                             |\n| :---------: | :----------------------------------------------------------: |\n|    title    |                           网站标题                           |\n|  subtitle   |                          网站副标题                          |\n| description |                           网站描述                           |\n|  keywords   |             网站关键词，搜索引擎会搜索这些关键词             |\n|   author    |                           博主名字                           |\n|  language   |            网站语言，默认为英语 en，中文为 zh-CN             |\n|  timezone   | 网站使用时区，默认使用访问电脑所在时区也可以指定比如使用上海时区 `Asia/Shanghai` 。建议使用默认就行了 |\n\n\n\n## 配置 About 页面\n\n在 Hexo 根目录下执行：\n\n```bash\nhexo new page \"about\"\n```\n\n在 `<root>/source/about/index.md` 文件中添加下面的字段：\n\n```markdown\n---\ntitle: 自我介绍标题\nlayout: about\n---\n自我介绍正文\n```\n\n其中 Front-matter 的 `layout: about` 字段为**必要的**且**不可修改**为其它值；Front-matter 的 `title` 和正文内容由您自定义编写。\n\n\n\n## 配置 404 页面\n\n[一般来说，hexo的 404 页面配置是通过如下来设置的：]{.red}\n\n在 Hexo 根目录下 `source` 中创建 `404.md` 文件，添加字段如下：\n\n```markdown\n---\nlayout: 404\ntitle: \"[404]\"\ndescription: \"May the Force be with you :&#41;\"\n---\n```\n\n其中 Front-matter 的 `layout: 404` 字段为**必要的**且**不可修改**为其它值，`title` 字段为您自定义的标题，`description` 字段为 404 页面的自定义描述。\n\n[但是，在 shoka主题上，主题作者是写死了 404 页面的，因此只能做一些简单的修改，当然，你也可以魔改： ]{.red}\n\n1. **显示图片：**\n\n   在 `<root>\\themes\\shoka\\source\\images` 中找到 `404.png` ，用你喜欢的图片替换即可，如果是其它格式的，在 `<root>\\themes\\shoka\\source\\css\\_common\\components\\pages\\pages.styl` 搜索 `404.png` 替换即可；\n\n   需要注意的是，`links` 链接块中站点图片默认设为 `./*/images/404.png` 。\n\n2. **标题文字：**\n\n   在 `<root>\\themes\\shoka\\languages` 文件夹中，找到你当前设置的语言文件，对 `not_found` 字段进行更改 。\n\n","tags":["hexo"],"categories":["Hexo-shoka"]},{"title":"markdown 语法测试","url":"/markdown-syntax-testing/","content":"\n\n\n\n\n# Welcome to Arachnid‘s blog!\n\n> 本文用于测试 multi-markdown-it 渲染器语法。\n>\n> 官方配置教程: [Hexo 主题 Shoka & multi-markdown-it 渲染器使用说明](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/) \\\n> [**🚀快速开始**](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/) -> [💌依赖插件](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/) -> [📌基本配置](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/) -> [🌈界面显示](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/display/) -> [🦄特殊功能](https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/special/)\n>\n> 个人搭建记录可看 [Hexo-shoka](https://arachnid.cc/categories/Hexo/) 分类。\n\n\n\n# 排版\n\n**粗体** *斜体* \n\n~~这是一段错误的文本。~~\n\n> 引用：我以为 “别人尊重我，是因为我很优秀”，后来才明白，“别人尊重我，是因为别人很优秀。\n\n有序列表：\n\n  1. 支持 Vim\n  2. 支持 Emacs\n\n无序列表:\n\n - 项目1\n - 项目2\n\n\n\n# 图片\n\n- 网络图片插入，跟正规的 markdown 语法一样，使用 `![alt_name](https://xxx.jpg \"img_name\")` 格式：\n\n![网络插入](https://avatars.githubusercontent.com/u/48347583?v=4 \"test Image\")\n\n- 本地路径插入，跟正规的 markdown 语法有点不一样，需要在路径前面加上 `/` ，即改成 `![alt_name](/images/xxx.jpg \"img_name\")` ：\n\n![本地插入](/images/avatar.webp)\n\n\n\n链接：\n\n[这是去往 Arachnid 博客的链接](https://arachnid.cc)\n\n\n\n## 标题\n\n以下是各级标题, 最多支持5级标题\n\n```\n# h1\n## h2\n### h3\n#### h4\n##### h4\n###### h5\n```\n\n\n\n## 代码\n\n示例:\n\n    function get(key) {\n        return m[key];\n    }\n\n代码高亮示例:\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n \ndocument.write(fib(10));\n```\n\n```python\nclass Employee:\n   empCount = 0\n \n   def __init__(self, name, salary):\n        self.name = name\n        self.salary = salary\n        Employee.empCount += 1\n```\n\n\n\n# Markdown 扩展\n\nMarkdown 扩展支持:\n\n* 表格\n* 定义型列表\n* Html 标签\n* 脚注\n* 目录\n* 时序图与流程图\n* MathJax 公式\n\n\n\n## 表格\n\n| Item     | Value  |\n| -------- | ------ |\n| Computer | \\$1600 |\n| Phone    | \\$12   |\n| Pipe     | \\$1    |\n\n可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐\n\n| Item     |  Value | Qty  |\n| :------- | -----: | :--: |\n| Computer | \\$1600 |  5   |\n| Phone    |   \\$12 |  12  |\n| Pipe     |    \\$1 | 234  |\n\n\n\n## 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n\n\n## Html 标签\n\n支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格，最后使用 `{% raw %}` `{% endraw %}` 把 Html 代码包裹起来应该就可以了：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n{% raw %}\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n\n{% endraw %}\n\n\n\n**提示**, 如果想对图片的宽度和高度进行控制, 你也可以通过 img标签, 如:\n\n{% raw %}\n\n<img src=\"https://avatars.githubusercontent.com/u/48347583?v=4\" width=\"50px\" />\n\n{% endraw %}\n\n\n\n## 脚注\n\nMarkdown[^footnote]来创建一个脚注\n\n[^footnote]: Markdown是一种轻量级标记语言.\n\n## 目录\n\n通过 `[TOC]` 在文档中插入目录, 如:\n\n[TOC]\n\n## 时序图与流程图\n\n```mermaid\nsequenceDiagram\n    Alice->Bob: Hello Bob, how are you?\n    Note right of Bob: Bob thinks\n    Bob-->Alice: I am good thanks!\n```\n\n流程图:\n\n```mermaid\ngraph TB\n    A[Hard] -->|Text| B(Round)\n    B --> C{Decision}\n    C -->|One| D[Result 1]\n    C -->|Two| E[Result 2]\n```\n\n\n> **提示:** 更多关于时序图与流程图的语法请参考:\n>\n> - [Mermaid](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n\n\n\n## KaTex 数学公式\n\n$ 表示行内公式： \n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n`$$` 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0 $$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k} $$\n\n更复杂的公式：\n\n$$\\begin{eqnarray}\\vec\\nabla \\times (\\vec\\nabla f) & = & 0  \\cdots\\cdots梯度场必是无旋场\\\\\n\\vec\\nabla \\cdot(\\vec\\nabla \\times \\vec F) & = & 0\\cdots\\cdots旋度场必是无散场\\\\\n\\vec\\nabla \\cdot (\\vec\\nabla f) & = & {\\vec\\nabla}^2f\\\\\n\\vec\\nabla \\times(\\vec\\nabla \\times \\vec F) & = & \\vec\\nabla(\\vec\\nabla \\cdot \\vec F) - {\\vec\\nabla}^2 \\vec F\\\\\\end{eqnarray} $$\n\n访问 [KaTex](https://katex.org/) 参考更多使用方法。"},{"title":"基于官方指导安装 Arch Linux","url":"/arch-linux-install/","content":"\n\n\n> 官方 wiki安装中文指导：https://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\n>\n> 最好还是以**英文版**的为基准，因为 ArchLinux是一个激进的系统，更新比较快，可能刚写完这篇笔记，转头已经有些对应不上了，哈哈哈。\n\n\n\n## 系统镜像\n\n官方镜像下载地址：https://archlinux.org/download/\n\n当然，也可以去各大高校提供的镜像源网站下载。\n\n\n\n## 启动盘制作\n\n**1、windows 平台**\n\n可以使用 Rufus：https://rufus.ie/zh/\n\n这是一款开源、免费、小巧（1.1mb）纯粹的系统启动盘制作工具。\n目前所支持的 ISO镜像如下：\n\n![image-20220412112425056](image-20220412112425056.png)\n\n**2、Uinx 平台**\n\n类 Unix系统可以直接使用 `dd` 命令来制作启动盘。\n\n`dd` 命令使用可参考：https://www.runoob.com/linux/linux-comm-dd.html\n\n**3、多平台**\n\n可以使用开源的 etcher：https://www.balena.io/etcher/\n\n\n\n> 然后本篇文章是基于官方指导的总结分析安装的笔记，如下开始正式安装配置，因为是以官方 wiki安装为指导，所以下面用到的操作的标题将一一对应官方 wiki的标题，没用到的将忽略不写，以及需要增加的将给出说明。目前使用的镜像版本：`archlinux-2022.04.01-x86_64.iso`\n\n\n\n## 引导安装\n\nArch 的启动引导过程有两种：[BIOS](https://en.wikipedia.org/wiki/BIOS) 和 [UEFI](https://wiki.archlinux.org/title/UEFI) 系统，这两者的引导过程是完全不同的。在 Arch 中它们的引导加载及区别可看：https://wiki.archlinux.org/title/Arch_boot_process\n\n目前大部分设备的引导方式主要分为 `UEFI 引导 + GPT 分区表` 和 `BIOS(LEGACY) 引导 + MBR 分区表` 这两种，而在新的机器里大部分都采用了 `UEFI/GPT` 引导的方式，当然，同时也兼容 `BIOS/MBR` 。\n\nUEFI进入：\n\n![image-20220412115757611](image-20220412115757611.png)\n\nBIOS进入：\n\n![image-20220412120426116](image-20220412120426116.png)\n\n启动安装后，最终界面出现的效果是一样的：\n\n![image-20220412153955531](image-20220412153955531.png)\n\n\n\n## 验证引导模式\n\n键入如下命令：（`ls`：表示列出目录内容；后面的路径可以利用 Tab键 自动补全，即键入命令或文件名的前几个字符，然后按 [Tab] 键）\n\n```\nls /sys/firmware/efi/efivars\n```\n\n如果命令结果显示了目录且没有报告错误，则系统以 UEFI 模式引导。 \n\n如果目录不存在，则系统可能 **（注意是可能，并不一定确是 BIOS模式）** 以 [BIOS](https://en.wikipedia.org/wiki/zh:BIOS) 模式 (或 [CSM](https://en.wikipedia.org/wiki/Compatibility_Support_Module) 模式) 引导，如显示：\n\n```\nls: cannot access '/sys/firmware/efi/efivars': No such file or directory\n```\n\n对于一些不是新的/格式过的磁盘，可能就不太适用了，当然，最好方法就是查看安装的主分区磁盘的属性。\n\n\n\n## 连接到因特网\n\n1、检查网络接口是否启用\n\n```\nip link\n```\n\n2、连接到网络\n\n- 有线：连接网线，并保证上级路由有网。\n- 无线：使用 [iwctl](https://wiki.archlinux.org/title/Iwd_(简体中文)#iwctl) 验证无线网络，具体操作点击链接查看。\n\n3、配置网络连接\n\n- 动态：需要支持 DHCP，然后执行以下命令。\n\n  ```\n  dhcpcd\n  ```\n\n- 静态：直接按照 [静态 IP 地址](https://wiki.archlinux.org/title/Network_configuration_(简体中文)#静态_IP_地址) 这个链接进行操作。\n\n4、检查网络连接\n\n在确认无误完成上面的操作后，通过 PING IP来检查：\n\n```\nping archlinux.org\n```\n\n\n\n**note：** 关于网络部分的，详情请看 https://wiki.archlinux.org/title/Network_configuration\n\n\n\n## 更新系统时间\n\n执行：\n\n```\ntimedatectl set-ntp true\n```\n\n然后正常情况下是并没有输出的，所谓没有消息就是最好的消息，这就是 Linux/Unix系统的设计思想。\n\n最后，执行如下命令来检查服务状态：\n\n```\ntimedatectl status\n```\n\n\n\n## 建立硬盘分区\n\n系统如果识别到磁盘，就会将其分配为一个块设备，如 `/dev/sda`、`/dev/nvme0n1` 或 `/dev/mmcblk0` 等等。然后可以执行如下命令查看：\n\n```\nfdisk -l\n```\n\n然后，针对不同的引导方式，其分区布局是不一样的，以官方给出的分区为例：\n\n- **UEFI 与** [GPT](https://wiki.archlinux.org/title/Partitioning_(简体中文)#GUID_分区表)\n\n  | 挂载点    | 分区                        | 分区类型                | 建议大小     |\n  | --------- | --------------------------- | ----------------------- | ------------ |\n  | /mnt/boot | /dev/*efi_system_partition* | EFI 系统分区            | 至少 300 MiB |\n  | [SWAP]    | /dev/*swap_partition*       | Linux swap (交换空间)   | 大于 512 MiB |\n  | /mnt      | /dev/*root_partition*       | Linux x86-64 根目录 (/) | 剩余空间     |\n\n- **BIOS 与** [MBR](https://wiki.archlinux.org/title/Partitioning_(简体中文)#Master_Boot_Record)\n\n  | 挂载点 | 分区                  | 分区类型                | 建议大小     |\n  | ------ | --------------------- | ----------------------- | ------------ |\n  | [SWAP] | /dev/*swap_partition* | Linux swap (交换空间)   | 大于 512 MiB |\n  | /mnt   | /dev/*root_partition* | Linux x86-64 根目录 (/) | 剩余空间     |\n\n  然后在这里拓展一下 `MiB` 跟 `MB` 这两个单位，`MB` 是国际单位制 SI 制定的十进制标准单位制，这个 M 是 1000K，而 `MiB` 是国际电工委员会 IEC 制定的二进制标准，这个 M 是 1024K 。参看：https://physics.nist.gov/cuu/Units/binary.html\n\n- 其它的布局实例可看：https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B\n\n在了解上面的布局后，然后我们常用的引导方式有 `UEFI 引导 + GPT 分区表` 和 `BIOS(LEGACY) 引导 + MBR 分区表` 这两种，所以下面分开说明：\n\n1. **BIOS/MBR**\n\n   这种方式相对于另一种比较简单，所以就先说了。\n\n   首先，先来了解一下 `[SWAP]` 挂载点和 `/mnt` 挂载点：\n\n   - `[SWAP]`：swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存（物理内存，可以理解为内存条容量）不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间（有点类似于 windows系统下的虚拟内存）。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替，等到那些程序要运行时，再从 swap 中恢复保存的数据到内存中。这种 “拆东墙，补西墙” 的方式应用于几乎所有的操作系统中。\n\n     使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。\n\n     那么 swap 分区到底设置成多大才最优？少了又觉得不够，多了又感觉浪费，那么我们可以参考 Redhat 官方文档中 [关于swap分区大小设置的建议](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007)：\n\n     |   物理内存   | 建议的交换空间大小 | 如果开启休眠功能建议的交换空间大小 |\n     | :----------: | :----------------: | :--------------------------------: |\n     |    ⩽ 2GB     |     内存的2倍      |             内存的3倍              |\n     | > 2GB – 8GB  |    等于内存大小    |             内存的2倍              |\n     | > 8GB – 64GB |       至少4G       |            内存的1.5倍             |\n     |    > 64GB    |       至少4G       |           不建议使用休眠           |\n\n     最后结合日常使用，一般来说可以按照如下规则设置 swap 大小：\n\n     - 4G以内的物理内存，SWAP 设置为内存的2倍，不超过4G。\n     - 4-8G的物理内存，SWAP 等于内存大小。\n     - 8-64G 的物理内存，SWAP 设置为8G。\n     - 64-256G物理内存，SWAP 设置为16G。\n\n   - `/mnt`：全称 `mount` 可直接理解为 “挂载”，用于存放手动挂载的硬件。这部分是根目录`/` 下的目录，用来挂载文件系统。\n\n     一般的 Linux根目录展开如下图：\n\n     ![img](994198-20160908160724832-375737054.png)\n\n     然后按照官方的说明，是想把将根磁盘卷挂载到 `/mnt` 目录下，即 `/mnt` 变成 `/` 根目录。\n\n   **好了，了解完后下面正式开始。**\n\n   执行命令：\n\n   ```\n   fdisk /dev/sdx （sdx可以为sda、sdb等，具体以你实际需要挂载的磁盘名称为准）\n   ```\n\n   接着你就进入了 `fdisk` 操作环境，为了获取该命令下的操作功能，根据提示输入 `m` 并回车查看各命令的作用：\n\n   ![image-20220414144302934](image-20220414144302934.png)\n\n   在 `fdisk` 操作环境下：\n\n   1、对于一个全新的磁盘（格式化了），输入 `o` 来创建一个全新的 `MBR` 分区表（因为这里是 BIOS引导）；如果是旧磁盘（要么原本有 `MBR` 分区表，要么不是 `MBR` 属性 `DOS` 的），那对于非 `MBR` 分区表可能得更改分区表或者格式化，而已有 `MBR` 分区表的直接执行第 2步。\n\n   2、输入 `n` 创建一个新的分区，首先会让你选择类型分区，输入 `p` 选择主分区，回车接着选择分区号，这里一般直接回车使用默认数值，这样可以避免自己定义出现冲突；紧接着选择开始起扇区地址，如果不知道原有区域划分情况，那一般直接回车使用默认数值即可；随后，输入结束扇区地址或者容量大小，这里决定了你为该分区创建的容量大小；我们按照表格顺序创建分区，那这第一个就是 `swap` 交换分区，例如我分配的是 8G容量，那可以直接输入容量大小：`+8G` 。\n\n   3、创建完毕后，可以输入 `p` 来查看创建的分区。\n\n   4、重复第 2项创建根目录分区和第 3项确认最后的分区信息，至此就有两个分区（对应表格）。\n\n   5、最后输入 `w` 将之前所有的操作写入磁盘并生效。\n\n2. **UEFI/GPT**\n\n   与上一种引导方式相比，根据表格显示，只多了一个 **EFI 系统分区**，然后了解一下这个挂载点：\n\n   - `/mnt/boot`：上面说了官方是想把将根磁盘卷挂载到 `/mnt` 目录下，那这个 boot引导自然就挂载到了新的 `/mnt` 目录下了。\n\n   在该引导模式下的操作就如下。\n\n   执行命令如下进入 `fdisk` 操作环境：\n\n   ```\n   fdisk /dev/sdx （sdx可以为sda、sdb等，具体以你实际需要挂载的磁盘名称为准）\n   ```\n\n   在 `fdisk` 操作环境下：\n\n   1、对于一个全新的磁盘（格式化了），这里则输入 `g` 来创建一个全新的 `GPT` 分区表（因为到这里是 UEFI引导）；同样的如果是旧磁盘那跟上面的 BIOS引导操作差不多，只不过这里是 `GPT` 属性了。\n\n   2、输入 `n` 创建一个新的分区，让你选择分区号 **（UEFI 比 BIOS 少了类型分区选择）** ，这里一般直接回车使用默认数值，这样可以避免自己定义出现冲突；紧接着选择开始起扇区地址，如果不知道原有区域划分情况，那一般直接回车使用默认数值即可；随后，输入结束扇区地址或者容量大小，这里决定了你为该分区创建的容量大小；我们按照表格顺序创建分区，那这第一个就是 `/mnt/boot` 引导分区，例如我取的是 512MiB容量，那可以直接输入容量大小：`+512M` 。\n\n   3、创建完毕后，可以输入 `p` 来查看创建的分区。\n\n   4、重复第 2项和第 3项两次，分别创建 `[SWAP]` 和 `/mnt`，至此就有三个分区（对应表格）。\n\n   5、最后输入 `w` 将之前所有的操作写入磁盘并生效。\n\n\n\n## 格式化分区\n\n- **EFI系统分区（仅对于 UEFI/GPT引导方式）**\n\n  使用 `mkfs.fat` 命令将其格式化为 Fat32：\n\n  ```\n  mkfs.fat -F 32 /dev/sdxY （sdxY为上面创建的 EFI 系统分区符）\n  ```\n\n- **swap交换分区**\n\n  如果有创建，则请使用 `mkswap` 命令将其初始化：\n\n  ```\n  mkswap /dev/sdxY （sdxY为上面创建的交换空间分区符）\n  ```\n\n- **`/mnt` 根目录分区**\n\n  执行以下命令创建一个 Ext4 文件系统：\n\n  ```\n  mkfs.ext4 /dev/sdxY （sdxY为上面创建的根分区符）\n  ```\n\n\n\n## 挂载分区\n\n1、将根磁盘卷挂载到 `/mnt`，执行：\n\n```\nmount /dev/sdxY /mnt （把 sdxY替换为上面创建根分区符）\n```\n\n2、如果创建了 `swap` 交换空间卷，执行：\n\n```\nswapon /dev/sdxY （把 sdxY替换为上面创建的交换空间分区符）\n```\n\n3、对于 UEFI 系统，挂载 EFI 系统分区：\n\n```\nmkdir /mnt/boot\nmount /dev/sdxY /mnt/boot （把 sdxY替换为上面创建的 EFI 系统分区符）\n```\n\n\n\n## 选择镜像\n\n文件 `/etc/pacman.d/mirrorlist` 定义了软件包会从哪个镜像源下载。在列表中越前的镜像在下载软件包时有越高的优先权。\n\n各地区镜像源获取：https://archlinux.org/mirrorlist/ ，然后点击生成：\n\n![image-20220415095310180](image-20220415095310180.png)\n\n编辑 `/etc/pacman.d/mirrorlist` 文件，执行：\n\n```\nvim /etc/pacman.d/mirrorlist\n```\n\n然后进入 VIM 环境，输入 `i` 进入编辑状态，然后根据上面生成提供的镜像表，选择几个放到文件最顶端，在这里笔者选择阿里云镜像：\n\n![image-20220415103048537](image-20220415103048537.png)\n\n如果其速度不佳，可以手动指定其他镜像源，像中科大或者清华的放在最上面即可：\n\n```\nServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n```\n\n然后，按 `Esc` 键退出编程，最后输入 `:wq` 保存退出。\n\n关于 vim 命令的使用，可看：https://www.runoob.com/linux/linux-vim.html\n\n\n\n## 安装必需的软件包\n\n使用 `pacstrap` 脚本，安装 [base](https://archlinux.org/packages/?name=base) 软件包和 Linux [内核](https://wiki.archlinux.org/title/Kernel_(简体中文))以及常规硬件的固件：\n\n```\npacstrap /mnt base base-devel linux linux-headers linux-firmware （base-devel在 AUR包的安装是必须的）\n```\n\n\n\n## Fstab配置\n\n生成自动挂载分区的 `fstab` 文件，执行命令：\n\n```\ngenfstab -U /mnt >> /mnt/etc/fstab\n```\n\n然后 `cat` 一下检查生成的 `/mnt/etc/fstab` 文件是否正确：\n\n```\ncat /mnt/etc/fstab\n```\n\n执行后将显示各分区挂载情况及属性信息。\n\n\n\n## Chroot配置\n\n[Change root](https://wiki.archlinux.org/title/Change_root_(简体中文)) 到新安装的系统：\n\n```\narch-chroot /mnt\n```\n\n执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。\n\n\n\n## 时区配置\n\n设置时区：\n\n```\nln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime\n```\n\neg：以上海为例，执行 `ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime`\n\n然后运行 `hwclock` 以生成 `/etc/adjtime`：\n\n```\nhwclock --systohc\n```\n\n\n\n## 本地化配置\n\n程序和库如果需要本地化文本，则需要根据区域设置 Locale，以明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准。\n\n需在这两个文件设置：`locale.gen` 与 `locale.conf`。\n\n通过前面的 Chroot配置，我们已经处于 chroot 环境下了，这就意味这现在所在的系统中只有一些最基本的包（组件），而 VIM 组件并未包含在里面，这时候就需要自己安装组件包了。利用 Archlinux 下非常强大的包管理工具 `pacman`，其安装包的命令格式为 `pacman -S 包名`，`pacman` 会自动检查这个包所需要的其他包（即为依赖）并一起装上。\n\n然后我们安装 VIM 组件，执行：\n\n```\npacman -S vim\n```\n\n1、利用刚安装的 `vim` ，编辑 `locale.gen` 文件：\n\n```\nvim /etc/locale.gen\n```\n\n找到 `zh_CN.UTF-8 UTF-8`、`en_US.UTF-8 UTF-8` 这两行，去掉注释并保存。\n\n紧接着执行 `locale-gen` 以生成 locale 信息：\n\n```\nlocale-gen\n```\n\n2、然后创建 [locale.conf](https://man.archlinux.org/man/locale.conf.5) 文件，并 [编辑设定 LANG 变量](https://wiki.archlinux.org/title/Locale_(简体中文)#系统区域设置)，\n\n```\necho LANG=en_US.UTF-8 > /etc/locale.conf\n```\n\n\n\n## 网络配置\n\n创建 `/etc/hostname` 文件，并设定的一个 `myhostname`：\n\n```\necho myhostname > /etc/hostname （myhostname是你想要为该系统设置的名称）\n```\n\n这步在我目前使用的功能里好像没用到。。。\n\n然后，在官方文档中有一条说明：\n\n>  请注意，目前的 [base](https://archlinux.org/packages/?name=base) 不含有任何网络管理工具。对于新安装的系统环境，请接着完成[网络配置](https://wiki.archlinux.org/title/网络配置)，配置过程中可能包括要安装合适的[网络管理](https://wiki.archlinux.org/title/网络管理)软件。\n\n因此，我们需要安装网络配置管理包（[DHCP](https://wiki.archlinux.org/title/Dhcpcd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))客户端和 [netctl](https://wiki.archlinux.org/title/Netctl_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))网络管理器）：\n\n```\npacman -S dhcpcd netctl\n```\n\n\n\n## Root 密码\n\n`Root` 是 `Linux` 中具有最高权限帐户，有些敏感的操作必须通过 `Root` 用户进行，比如使用`pacman` 命令。\n\n执行以下命令，然后根据提示输入两次密码即可（注意输入是不显示出来）：\n\n```\npasswd root\n```\n\n\n\n## 安装引导程序\n\n如果是 Intel 或 AMD 的 CPU，启用 [微码](https://wiki.archlinux.org/title/Microcode_(简体中文)) 更新：\n\n- Intel\n\n  ```\n  pacman -S intel-ucode\n  ```\n\n- AMD\n\n  ```\n  pacman -S amd-ucode\n  ```\n\n接着，官方推荐的引导加载是 [GRUB](https://wiki.archlinux.org/title/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)) （其他的引导加载可看：[引导功能比较](https://wiki.archlinux.org/title/Arch_boot_process_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83)），因此我们对其安装并配置，不同的引导系统，其操作不一样：\n\n- **BIOS/MBR**\n\n  1、安装 `grub`：\n\n  ```\n  pacman -S grub\n  ```\n\n  2、部署 `grub`：\n\n  ```\n  grub-install --target=i386-pc /dev/sdx （sdx为要安装 GRUB 的磁盘，注意不是分区）\n  ```\n\n- **UEFI/GPT**\n\n  1、安装 `grub` 和 `efibootmgr`：\n\n  ```\n  pacman -S grub efibootmgr\n  ```\n\n  2、部署 `grub`：\n\n  ```\n  grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB （这里的 esp 替换成挂载点）\n  ```\n\n  像在这里，那就是：\n\n  ```\n  grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB\n  ```\n\n**最后，不管是哪个引导方式，都执行第三步：**\n\n3、生成配置文件：\n\n```\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n\n执行后，最后显示 `done` 即完成操作。\n\n\n\n**note：这一步是至关重要的一步，请检查是否正确安装好引导加载程序后再重新启动，否则下次重启后将无法正常进入系统。**\n\n\n\n## 重启\n\n最最最后，你需要进行重启来启动已经安装好的系统。\n\n1、输入以下命令退出 chroot 环境：\n\n```\nexit\n```\n\n2、手动取消挂载的分区（这有助于发现任何「繁忙」的分区）：\n\n**如果挂载了 `/mnt/boot`，先 `umount -r /mnt/boot`，再 `umount -r /mnt`，否则直接 `umount /mnt`。**\n\n```\numount -r /mnt/boot\numount -r /mnt\n```\n\n3、执行重启：\n\n```\nreboot\n```\n\n\n\n## Other\n\n另外一些比较详细的安装教程：\n\n[Arch Linux 安装使用教程](https://archlinuxstudio.github.io/ArchLinuxTutorial/#/?id=arch-linux-安装使用教程-archtutorial-arch-linux-studio)\n\n[以官方Wiki的方式安装ArchLinux](https://www.viseator.com/2017/05/17/arch_install/)\n\n","tags":["history","Linux"]},{"title":"X/YModem 传输协议","url":"/x-ymodem-protocol/","content":"\n\n\n# 文件传输\n\n最常用的几种文件传输协议有：XModem、YModem、ZModem等。\n\n- XModem是最早的文件传输协议之一，由于出现较早，几乎大部分的通讯程序所支持的文件传输都使用该协议，通常是传输 128字节的信息块；这种古老的传输协议速度虽然较慢，但由于使用了 CRC错误校验方法，传输的准确率可高达 99.6%。\n\n- YModem协议是 XModem的改进版，它最早用于调制解调器之间的文件传输，具有快速，稳定传输的优点。它的传输速度比 XModem快，这是由于它可以一次传输 1024字节的信息块，同时它还支持传输多个文件，也就是常说的批文件传输。\n\n- ZModem协议的处理速度快于 XModem和 YModem，这是因为它采用了串流式（streaming）传输方式，而且还具有自动改变区段大小和断点续传、快速错误侦测等功能，可以很好地进行断开后恢复传输。这是目前最流行的文件传输协议。\n\n- 除开上面介绍的三种 X / Y / ZModem协议，还有个常见的传输协议 --- ASCII协议，这是最快的传输协议，但只能传送文本文件。\n\n\n\nX / Ymodem协议：\nhttp://pauillac.inria.fr/~doligez/zmodem/ymodem.txt\n\nZmodem协议：\nhttp://gallium.inria.fr/~doligez/zmodem/zmodem.txt\n\n\n\n# 控制字符定义\n\n```\n<SOH> 01H       // 传输 128Byte 启动标志\n<STX> 02H \t\t// 传输 1024Byte 启动标志\n<EOT> 04H       // 传输结束\n<ACK> 06H       // 应答\n<NAK> 15H       // 没应答\n<CAN> 18H       // 取消传输\n<C> 43H         // ASCII 'C' CRC校验请求\n\n<NUL> 00H       // 空符填充\n<CPMEOF> 1AH    // 数据填充 (^Z)\n```\n\n\n\n# XModem通讯\n\nXmodem 是使用最广泛的文件传输协议之一。原始的 Xmodem 协议使用 128字节数据包和一个简单的 “校验和\" 错误检测方法。后面增强为 Xmodem-CRC，使用了更安全的循环冗余校验 (CRC) 用于错误检测方法。Xmodem 协议总是首先尝试使用 CRC。如果发件人不确认对 CRC 的请求，接收器将转移到 ”校验和“ 模式并继续其传输请求。\n\n增强型 Xmodem-1K 本质上是 Xmodem CRC 模式传输 1K (1024字节) 数据包。在某些系统和通报上它也可以称为 Ymodem。\n\n\n\nXmodem 协议传输由接收程序和发送程序完成，先由接收程序发送协商字符，协商校验方式，协商通过之后发送程序就开始发送数据包，接收程序接收到完整的一个数据包之后按照协商的方式对数据包进行校验。校验通过之后发送确认字符，然后发送程序继续发送下一包；如果校验失败，则发送否认字符，发送程序重传此数据包。**信息报中如果剩余的数据不足 128字节，不足的部分将以 `0x1A` 填充。**\n\n## 校验和模式\n\n### 帧包格式\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~131     | Byte132  |\n| :------------------: | :-------------: | :----------------: | :--------------: | :------: |\n| Start Of Header(SOH) | Packet NumberID | ~(Packet NumberID) | Packet Data[128] | CheckSUM |\n\n### 传输方式\n\n|                        Sender                        | Flow |             Receiver             |\n| :--------------------------------------------------: | :--: | :------------------------------: |\n|                                                      | <--- |               NAK                |\n|                                                      |      |     Time out after 3 Second      |\n|                                                      | <--- |               NAK                |\n| \\<SOH\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **Line hit during transmission** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                 **ACK get garbaged**                 | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |       **Duplicate packet**       |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **UART Framing err on any byte** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **UART Overrun err on any byte** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n|                         EOT                          | ---> |            Packet OK             |\n|                 **ACK get garbaged**                 | <--- |               ACK                |\n|                         EOT                          | ---> |            Packet OK             |\n|                       Finished                       | <--- |               ACK                |\n\n## CRC模式\n\n计算 16位 CRC 校验的除数多项式为：`X ^ 16 + X ^ 12 + X ^ 5 + 1`，信息报中的 128数据字节将参加 CRC 校验的计算，在发送端 CRC-16 的高字节在前，低字节在后。\n\n### 帧包格式\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~131     | Byte132~133 |\n| :------------------: | :-------------: | :----------------: | :--------------: | :---------: |\n| Start Of Header(SOH) | Packet NumberID | ~(Packet NumberID) | Packet Data[128] | 16-Bit CRC  |\n\n### 传输方式\n\n传输流程：接收方要求发送方以 CRC 校验方式发送时以 ‘C’ 来请求，发送方将对此作出应答。\n\n|                       Sender                        | Flow |             Receiver             |\n| :-------------------------------------------------: | :--: | :------------------------------: |\n|                                                     | <--- |               'C'                |\n|                                                     |      |     Time out after 3 Second      |\n|                                                     | <--- |               'C'                |\n| \\<SOH\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> | **Line hit during transmission** |\n|                                                     | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n|                         EOT                         | ---> |            Packet OK             |\n|                  ACK get garbaged                   | <--- |               ACK                |\n|                         EOT                         | ---> |            Packet OK             |\n|                      Finished                       | <--- |               ACK                |\n\n## 扩展\n\n关于校验和和 CRC 校验可以看以前的文章《[常用校验算法](https://arachnid.cc/check-algorithm/)》\n\n[XModem Protocol with CRC](https://web.mit.edu/6.115/www/amulet/xmodem.htm)\n\n\n\n# YModem通讯\n\nYmodem 本质上是允许多个批处理文件传输的 Xmodem-1K，也可表示为 YModem-1K。\n\nYmodem 在 Xmodem-1K 基础上发展，沿用了 `TeLink` 协议的添加空头块的做法，也就是增加 `block 0`。该 block 标识即将发送文件的 `文件名`，`文件大小` 和  `文件创建时间戳(一般不填写)`\n\nYmodem-g 是 Ymodem 的变体。它设计用于支持错误控制的调制解调器。该协议不提供软件纠错或恢复，但期望调制解调器提供服务。它是一种流式传输协议，以连续流的形式发送和接收 1K 个数据包，直到指示停止。YModem-g 传输形式与 YModem-1K 差不多，同时在发送完一个数据块后，它不会等待应答确认，而是快速连续地发送下一个数据块；如果有任何块不成功转移，整个转移被取消。\n\n## 起始帧（block 0）\n\nYModem 的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输，它的帧长 = 3字节数据首部 + 128字节数据 + 2字节 CRC16 校验码 = 33字节。\n\n|        Byte1         | Byte2 | Byte3 |                 Byte4~131                 | Byte132~133 |\n| :------------------: | :---: | :---: | :---------------------------------------: | :---------: |\n| Start Of Header(SOH) | 0x00  | 0xFF  | [ \\<`filename`\\> \\<`filezise`\\> \\<NUL\\> ] | 16-Bit CRC  |\n\n说明：\n\n- Byte 1~3：头标志是 SOH，起始帧序固定为 0x00，帧序取反为 0xFF。\n- Byte 4~131：\n  - `filename` 是传输的文件名字，如文件名 `foo.c`，它在起始帧中的格式为：`66 6F 6F 2E 63 00`，也就是把 ASCII 码转成十六进制，最后的 0x00 代表文件名结束。\n  - `filesize` 是要传输的文件的大小，比如文件大小为 120 KByte，转换为 `120 * 1024 = 122880` Byte，转化为十六进制为 `0x1E00`，它在起始帧中的格式为：`31 45 30 30 00`，对应 ASCII 为 `1E00`，最后的 0x00 代表文件长度结束。\n  - 最后 `NUL` 代表剩余不足 128 Byte 部分用 0x00 填充。\n- Byte 132~133：CRCH、CRCL分别表示 16位 CRC 校验码的高 8位与低 8位，高字节在前，低字节在后。\n\n## 数据帧（block n）\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~1027     | Byte1028~1029 |\n| :------------------: | :-------------: | :----------------: | :---------------: | :-----------: |\n| Start Of Header(STX) | Packet NumberID | ~(Packet NumberID) | Packet Data[1024] |  16-Bit CRC   |\n\n注意：有一种特殊的情况是，如果文件总大小小于等于 128字节或者文件数据最后剩余的数据小于 128字节，则 YModem 会选择 SOH 数据帧格式用 128 字节来传输数据，而数据不满 128 字节，剩余的数据用 `0x1A` 填充。\n\n这时数据帧的结构就变成了：\n\n文件大小小于 128字节：`<SOH> <01> <FE> <data1> <data2> ... <datan>  <CPMEOF> ... <CRCH> <CRCL>`\n\n文件最后剩余数据小于 128字节：`<SOH> <ID> <~ID> <data1> <data2> ... <datan> <CPMEOF> ... <CRCH> <CRCL>`\n\n## 结束帧（block n+1）\n\nYModem 的结束帧数据也采用 SOH 的 128字节数据帧\n\n|        Byte1         | Byte2 | Byte3 | Byte4~131 | Byte132~133 |\n| :------------------: | :---: | :---: | :-------: | :---------: |\n| Start Of Header(SOH) | 0x00  | 0xFF  |  \\<NUL\\>  | 16-Bit CRC  |\n\n## 传输流程\n\n以把 foo.c，大小为 4196Byte（16进制为 0x1064）的文件作为传输的对象：\n\n|                            Sender                            | Flow |        Receiver         |\n| :----------------------------------------------------------: | :--: | :---------------------: |\n|                                                              | <--- |           'C'           |\n|                                                              |      | Time out after 3 Second |\n|                                                              | <--- |           'C'           |\n| \\<SOH\\> \\<0x00\\> \\<0xFF\\> \\<Data[ `<foo.c>` \\| `<0x1064>` \\| \\<NUL\\> ]\\> \\<CRC16\\> | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                                                              | <--- |           'C'           |\n|     \\<STX\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-99]\\> \\<CPMEOF[0-27]\\> \\<CRC16\\> | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                             EOT                              | ---> |        Packet OK        |\n|                                                              | <--- |         **NAK**         |\n|                             EOT                              | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                                                              | <--- |           'C'           |\n|      \\<SOH\\> \\<0x00\\> \\<0xFF\\> \\<NUL[0-127]\\> \\<CRC16\\>      | ---> |        Packet OK        |\n|                           Finished                           | <--- |           ACK           |\n\n\n\n# 参考\n\nhttps://en.wikipedia.org/wiki/XMODEM\n\nhttps://en.wikipedia.org/wiki/YMODEM\n\nhttps://en.wikipedia.org/wiki/ZMODEM\n\n[XMODEM, YMODEM, and ZMODEM](http://web.cecs.pdx.edu/~rootd/catdoc/guide/TheGuide_toc.html#SEC237)\n\n[Transmisja modemowa - Xmodem, Ymodem, Zmodem](https://slideplayer.pl/slide/434572/)\n\n[lrzsz: free x/y/zmodem implementation](https://www.ohse.de/uwe/software/lrzsz.html)\n\n\n\n# 附录\n\nCRC校验计算：\n\n```c\nint calcrc(char *ptr, int count)\n{\n    int  crc;\n    char i;\n    crc = 0;\n    while (--count >= 0)\n    {\n        crc = crc ^ (int) *ptr++ << 8;\n        i = 8;\n        do\n        {\n            if (crc & 0x8000)\n                crc = crc << 1 ^ 0x1021;\n            else\n                crc = crc << 1;\n        } while(--i);\n    }\n    return (crc);\n}\n```\n\n","tags":["history","Modem"]},{"title":"Modbus家族之 ASCII","url":"/modbus-ascii-protocol/","content":"\n\n\n> 嗨，相信在上一篇经过我的兄弟 RTU的介绍之后，已经对 Modbus有了一定的了解了吧；那么本篇就跟紧我的脚步一起学习新的知识吧。\n>\n\n\n\n# 描述\n\nModbus在串行设备中通过实现主从模型结构，解决了电子设备之间的数据通讯问题；在采用 Modbus协议时，它有两种主要的原始传输方式 ---- Modbus RTU 和 Modbus ASCII。而 Modbus RTU已经在上一篇介绍了，那么就在本篇中瞅瞅 ASCII吧。\n\n\n\n# 通讯方式\n\n## 帧格式\n\n|   Name   | Length (bytes) |                         Description                          |\n| :------: | :------------: | :----------------------------------------------------------: |\n|  Start   |       1        | Starts with colon : (ASCII hex value is 3A)<br/>（以冒号 `:` 开头，ASCII十六进制值为 3A） |\n| Address  |       2        |    Node address in hex<br/>（十六进制节点地址，字符表示）    |\n| Function |       2        |    Function code in hex<br/>（十六进制功能码，字符表示）     |\n|   Data   |     n x 2      | n is the number of data bytes, it depends on function<br/>（n是数据字节数，它取决于功能码） |\n|   LRC    |       2        |       Longitudinal redundancy check<br/>（LRC校验码）        |\n|   End    |       2        |                           CR / LF                            |\n\n注：地址、功能、数据和 LRC都是表示 8位值 (0-255) 的**大写**十六进制可读字符对；即：在 Modbus ASCII中，每个数据字节被分割成表示十六进制值中的两个 ASCII字符的两个字节。\n\n在 ASCII模式下，消息以冒号 `:` 字符开头（ASCII表示为 0x3A），以回车换行对 `\\r\\n` （ASCII表示为 0x0D和 0x0A）结尾；所有其他字段传输的数据所允许的十六进制表示字符为的 `0-9`、`A-F`。\n\n|    START     | ADDRESS | FUNCTION |  DATA   | LRC CHECK |       END        |\n| :----------: | :-----: | :------: | :-----: | :-------: | :--------------: |\n| 1 CHAR<br/>: | 2 CHARS | 2 CHARS  | n CHARS |  2 CHARS  | 2 CHARS<br/>CRLF |\n\n![image-20220326235527004](image-20220326235527004.png)\n\n## 功能码\n\nASCII最常用的功能代码跟 RTU的功能代码定义是一样的，这里就不多说了，可以去查看 《[Modbus家族之 RTU](https://arachnid.cc/modbus-rtu-protocol/)》篇章的功能码部分，这里只是格式上有所不同而已，~~下一篇会对这两个原始传输方式进行对比的。~~ 嘛，还是直接合并到本篇，对 RTU和 ASCII进行对比分析吧，顺便回顾一下 RTU协议。\n\n| 访问地址：address |   映射地址    |       描述        |   功能   | R/W  |\n| :---------------: | :-----------: | :---------------: | :------: | :--: |\n|     1 ~ 10000     |   address-1   |       Coils       | 01/05/15 | R/W  |\n|   10001 ~ 20000   | address-10001 |  Discrete Inputs  |    02    |  R   |\n|   30001 ~ 40000   | address-30001 |  Input Registers  |    04    |  R   |\n|   40001 ~ 50000   | address-40001 | Holding Registers | 03/06/16 | R/W  |\n\n在这里，简单的举个 ASCII传输例子：\n\n例如，要读取 VAR1，你需要从地址 0x20C1读取 2个寄存器，所以你需要发送以下 ASCII消息：\n\n`:010420C1000218<CRLF>`\n\n- 请求：\n\n  |      Name       |                      Description                       |\n  | :-------------: | :----------------------------------------------------: |\n  |       ‘:’       |                Start of message - 0x3A                 |\n  |     ‘0’ ‘1’     |                  Node address – 0x01                   |\n  |     ‘0’ ‘4’     |      Function code (Read Input Registers) – 0x04       |\n  | ‘2’ ‘0’ ‘C’ ‘1’ |       Register address for reading VAR1 – 0x20C1       |\n  | ‘0’ ‘0’ ‘0’ ‘2’ |  Length of registers to be read (must be 2) – 0x0002   |\n  |     ‘1’ ‘8’     |                          LRC                           |\n  |    \\<CRLF\\>     | End of message, carriage return and line feed – 0x0D0A |\n\n此消息的响应如下：\n\n`:01040400001234B1<CRLF>`\n\n- 响应：\n\n  |              Name               |                      Description                       |\n  | :-----------------------------: | :----------------------------------------------------: |\n  |               ‘:’               |                Start of message - 0x3A                 |\n  |             ‘0’ ‘1’             |                  Node address – 0x01                   |\n  |             ‘0’ ‘4’             |      Function code (Read Input Registers) – 0x04       |\n  |             ‘0’ ‘4’             |           Read data length (4 bytes) – 0x04            |\n  | ‘0’ ‘0’ ‘0’ ‘0’ ‘1’ ‘2’ ‘3’ ‘4’ |           Value read from VAR1 – 0x00001234            |\n  |             ‘B’ ‘1’             |                          LRC                           |\n  |            \\<CRLF\\>             | End of message, carriage return and line feed – 0x0D0A |\n\n好了，那么就直入主题吧，常用功能码部分依然是如下几个：\n\n### 功能 01（01H）读线圈\n\n- 请求\n\n  读取从机中线圈的 ON/OFF 状态。不支持广播。请求消息指定了开始线圈和要读取的线圈数量。\n\n  下面是一个请求读取线圈的例子：19 - 55（Coil 20 to 56），37个线圈，从设备节点 3（注意起始地址是 19或 0x13，比线圈 20小 1）：\n\n  ![image-20220327151916968](image-20220327151916968.png)\n\n- 响应\n\n  线圈状态响应消息被打包为数据字段的每比特表示一个线圈。状态表示为：1 = ON，0 = OFF。第一个数据字节的 LSB包含请求中寻址的线圈。其他线圈跟随这个字节的高阶末端，并在随后的字节中从低阶到高阶。\n\n  例如，当线圈 20 - 27的状态显示 `ON - ON - OFF - OFF - ON - OFF - ON - OFF - ON - OFF` 时，以字节值二进制 `0101 0011 (0x53)` 表示。一个字节包含八个线圈的状态。如果返回的线圈数量不是 8的倍数，则最终数据字节中的剩余位将用 0填充(朝向字节的高阶末端)；字节计数字段指定数据的完整字节数。\n\n  > Figure 6 shows an example of a response to the query shown in Figure 5：\n\n  ![image-20220327152253123](image-20220327152253123.png)\n\n### 功能 02（02H）读离散输入\n\n- 请求\n\n  读取从机中离散输入的 ON/OFF 状态。不支持广播。请求消息指定起始输入和要读取的输入数量。\n\n  下面是一个从从设备节点 3读取离散输入 10101 - 10120，总共 20个输入的例子（注意起始地址是 100或 0x64，比输入 10101小 10001）：\n\n  ![image-20220327155421391](image-20220327155421391.png)\n\n- 响应\n\n  离散输入状态响应消息的构造与线圈状态(01H) 操作相同。\n\n  > Figure 8 shows an example of a response to the query shown in Figure 7：\n\n  ![image-20220327155851480](image-20220327155851480.png)\n\n### 功能 03（03H）读保持寄存器\n\n- 请求\n\n  读取从机中保持寄存器的二进制内容。不支持广播。请求消息指定起始寄存器和要读取的寄存器数量。\n\n  下面是一个从从设备节点 7读取保持寄存器 40201 - 40203，总共 3个寄存器的请求的例子（注意起始地址是 200或 0xC8，比寄存器 40201小 40001）：\n\n  ![image-20220327160332698](image-20220327160332698.png)\n\n- 响应\n\n  响应消息中的保持寄存器数据在每个寄存器中打包为两个字节，二进制内容在每个字节中右对齐；对于每个寄存器，第一个字节包含高阶位，第二个字节包含低阶位。\n\n  > Figure 10 shows an example of a response to the query shown in Figure 9：\n\n  ![image-20220327160607639](image-20220327160607639.png)\n\n### 功能 04（04H）读输入寄存器\n\n- 请求\n\n  读取从机中保持寄存器的二进制内容。不支持广播。请求消息指定起始寄存器和要读取的寄存器数量。\n\n  下面是一个从从设备节点 7读取输入寄存器 30301 - 30303，总共 3个寄存器的请求的例子（注意起始地址是300或0x12C，比寄存器 30301小 30001）：\n\n  ![image-20220327171629490](image-20220327171629490.png)\n\n- 响应\n\n  读输入寄存器数据的响应消息的构造与读取保持寄存器(03H) 操作相同。\n\n  > Figure 12 shows an example of a response to the query shown in Figure 11：\n\n  ![image-20220327171942458](image-20220327171942458.png)\n\n### 功能 05（05H）写单线圈\n\n- 请求\n\n  将单个线圈写入 ON或 OFF。当广播时，该函数强制所有附加的从机使用相同的线圈引用。请求消息指定要写入的线圈引用（启动线圈和状态）。\n\n  `FF 00` 的值要求线圈打开，值为 `00 00` 的请求为关闭，所有其他值都是非法的，不会影响线圈。\n\n  下面是一个在从设备节点 3中请求打开线圈 150的例子（注意起始地址是 149或 0x95，比线圈 150小 1）：\n\n  ![image-20220327172937327](image-20220327172937327.png)\n\n- 响应\n\n  正常的响应是请求的回显，在写入线圈状态之后返回。\n\n  > Figure 14 shows an example of a response to the query shown in Figure 13：\n\n  ![image-20220327173100544](image-20220327173100544.png)\n\n### 功能 06（06H）写单个保持寄存器\n\n- 请求\n\n  将一个值写入单个保持寄存器中。当广播时，该函数在所有附加的从机上设置相同的寄存器引用。请求消息指定要写入的寄存器引用（指定地址和数值）。\n\n  下面是一个请求从从设备节点 3中的保持寄存器 40150写入 1000数值的例子（注意起始地址为 149或 0x95，比寄存器 40150小 40001）：\n\n  ![image-20220327175033869](image-20220327175033869.png)\n\n- 响应\n\n  正常的响应是请求的回显，在写入保持寄存器内容之后返回。\n\n  > Figure 16 shows an example of a response to the query shown in Figure 15：\n\n  ![image-20220327175344005](image-20220327175344005.png)\n\n### 功能 15（0FH）写多个线圈\n\n- 请求\n\n  将一个线圈序列中的每个线圈写入 ON或 OFF。当广播时，该函数强制所有附加的从机使用相同的线圈引用。请求消息指定要写入的线圈引用（起始线圈和状态）。\n\n  下面的示例显示了从设备节点 5中的线圈 20开始写入一系列 10个线圈状态的请求。二进制位与线圈的对应方式如下（注意起始地址是 19或 0x13，比线圈 20小 1）：\n\n  | Bit  | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    |\n  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  | Coil | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | ...  | ...  | ...  | ...  | ...  | 30   | 29   | 28   |\n  \n  ![image-20220327182406708](image-20220327182406708.png)\n\n- 响应\n\n  正常响应返回从地址、功能代码、起始地址和写入的线圈数量，不包括字节数和对应写入的状态。\n\n  > Figure 24 shows an example of a response to the query shown in Figure 23：\n\n  ![image-20220327182618637](image-20220327182618637.png)\n\n### 功能 16（10H）写多个保持寄存器\n\n- 请求\n\n  将值写入到一个保持寄存器序列中。当广播时，该函数在所有附加的从机上设置相同的寄存器引用。请求消息指定要写入的寄存器引用（起始寄存器和数值）。\n\n  下面是一个请求从从设备节点 5中的保持寄存器 40020到 40022写入以下数据的示例（注意起始地址是 19或 0x13，比寄存器 40020小 40001）：\n\n  | address | data   |\n  | ------- | ------ |\n  | 40020   | 0x0164 |\n  | 40021   | 0x0165 |\n  | 40022   | 0x0166 |\n  \n  ![image-20220327184941057](image-20220327184941057.png)\n\n- 响应\n\n  正常响应返回从地址、功能代码、起始地址和写入的寄存器数量，不包括字节数和对应写入的数据。\n\n  > Figure 26 shows an example of a response to the query shown in Figure 25：\n\n  ![image-20220327185223421](image-20220327185223421.png)\n\n## LRC校验\n\n```c\nunsigned char\nucMBLRC( unsigned char * pucFrame, unsigned short usLen )\n{\n    unsigned char ucLRC = 0;  /* LRC char initialized */\n\n    while( usLen-- )\n    {\n        ucLRC += *pucFrame++;   /* Add buffer byte without carry */\n    }\n\n    /* Return twos complement */\n    ucLRC = ( UCHAR ) ( -( ( CHAR ) ucLRC ) );\n    return ucLRC;\n}\n```\n\n校验原理可看 [常用校验算法](https://arachnid.cc/check-algorithm/)-LRC章节","tags":["history","modbus"],"categories":["modbus"]},{"title":"Modbus家族之 RTU","url":"/modbus-rtu-protocol/","content":"\n\n\n> 您好啊，我是 Modbus家族成员的 RTU，同时期诞生的还有我的兄弟，它就是 ASCII。本篇呢就来让大家熟悉一下我吧，下一篇则由我兄弟 ASCII进行介绍。好了，废话不多说，接下来就带你们来认识一下我吧。\n>\n\n\n\n# 描述\n\nModbus RTU（远程终端单元）是原始 Modbus规范中定义的两种传输模式之一。 这两种模式是 Modbus RTU和 ASCII，它们被设计用于支持 RS232，RS485和 RS422接口的串行设备。 Modbus RTU的一个显着特点是它使用二进制编码和强大的 CRC错误检查。 Modbus RTU是 Modbus协议的实现，最常用于工业应用和自动化生产设施。嘻嘻，我可是很受工业场景应用的哦。\n\n\n\n# 通讯方式\n\n## 帧格式\n\n|   Name   | Length (bytes) |                         Description                          |\n| :------: | :------------: | :----------------------------------------------------------: |\n| Address  |       1        |                   Node address（节点地址）                   |\n| Function |       1        |                  Function code（功能代码）                   |\n|   Data   |       n        | n is the number of data bytes, it depends on function<br/>（n是数据字节数，它取决于功能码） |\n|   CRC    |       2        |          Cyclic redundancy check<br/>（CRC校验码）           |\n\n在 RTU模式下，消息以至少 3.5个字符的静默间隔为开始，以至少 3.5个字符的类似间隔结束。这是最容易实现的以波特率在网络上使用的字符次数的倍数(如下图中所示的 T1 - T2 - T3 - T4)。\n\n| START             | ADDRESS | FUNCTION | DATA       | CRC CHECK | END               |\n| ----------------- | ------- | -------- | ---------- | --------- | ----------------- |\n| **\\*T1–T2–T3–T4** | 8 BITS  | 8 BITS   | n x 8 BITS | 16 BITS   | **\\*T1–T2–T3–T4** |\n\n**\\*T1-T2-T3-T4**：表示不通信时的 3.5个字符。\n\n所有其他字段都由 8位数据组成。\n\n![image-20220319201759692](image-20220319201759692.png)\n\n## 功能码\n\nModbus设备最常用的功能代码如下表所示：\n\n![image-20220319195917761](image-20220319195917761.png)\n\n### 功能 01（01H）读线圈\n\n- 请求：\n\n  | 名称      | 长度   | 说明              |\n  | --------- | ------ | ----------------- |\n  | 设备地址  | 1 字节 |                   |\n  | 功能码    | 1 字节 | **0x01**          |\n  | 开始地址  | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈数量  | 2 字节 | 1 to 2000 (0x7D0) |\n  | CRC校验码 | 2 字节 |                   |\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 起始地址（2byte）+ 线圈数（2byte）+ CRC（2byte）\n  \n- 应答：\n\n  | 名称                 | 长度   | 说明         |\n  | -------------------- | ------ | ------------ |\n  | 设备地址             | 1 字节 |              |\n  | 功能码               | 1 字节 | **0x01**     |\n  | 线圈数量对应的字节数 | 1 字节 | **\\*N**      |\n  | 线圈数据1            | 1 字节 |              |\n  | 线圈数据2            | 1 字节 |              |\n  | 线圈数据n            | 1 字节 | n = N or N+1 |\n  | CRC校验码            | 2 字节 |              |\n\n  **\\*N** = 线圈数量 / 8，如果余数非 0，则 N = N+1\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 字节数（1byte）+ 线圈状态（Nbyte）+ CRC（2byte）\n  \n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x81**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319211327513](image-20220319211327513.png)\n\n### 功能 02（02H）读离散输入\n\n- 请求：\n\n  | 名称         | 长度   | 说明              |\n  | ------------ | ------ | ----------------- |\n  | 设备地址     | 1 字节 |                   |\n  | 功能码       | 1 字节 | **0x02**          |\n  | 开始地址     | 2 字节 | 0x0000 to 0xFFFF  |\n  | 离散状态数量 | 2 字节 | 1 to 2000 (0x7D0) |\n  | CRC校验码    | 2 字节 |                   |\n  \n  指令：设备地址（1byte）+ **0x02**（1byte）+ 起始地址（2byte）+ 离散数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                     | 长度   | 说明         |\n  | ------------------------ | ------ | ------------ |\n  | 设备地址                 | 1 字节 |              |\n  | 功能码                   | 1 字节 | **0x02**     |\n  | 离散状态数量对应的字节数 | 1 字节 | **\\*N**      |\n  | 离散数据1                | 1 字节 |              |\n  | 离散数据2                | 1 字节 |              |\n  | 离散数据n                | 1 字节 | n = N or N+1 |\n  | CRC校验码                | 2 字节 |              |\n  \n  **\\*N** = 离散状态数量 / 8，如果余数非 0，则 N = N+1\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 字节数（1byte）+ 离散状态（Nbyte）+ CRC（2byte）\n  \n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x82**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n  \n\n**流程图：**\n\n![image-20220319212623922](image-20220319212623922.png)\n\n### 功能 03（03H）读保持寄存器\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x03**         |\n  | 开始地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | 保持寄存器数量 | 2 字节 | 1 to 125 (0x7D)  |\n  | CRC校验码      | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x03**（1byte）+ 起始地址（2byte）+ 保持寄存器数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                       | 长度   | 说明     |\n  | -------------------------- | ------ | -------- |\n  | 设备地址                   | 1 字节 |          |\n  | 功能码                     | 1 字节 | **0x03** |\n  | 保持寄存器数量对应的字节数 | 1 字节 | 2 \\* N   |\n  | 寄存器数值1                | 2 字节 |          |\n  | 寄存器数值2                | 2 字节 |          |\n  | 寄存器数值n                | 2 字节 | n = N    |\n  | CRC校验码                  | 2 字节 |          |\n\n  指令：设备地址（1byte）+ **0x03**（1byte）+ 字节数（1byte）+ 保持寄存器值（2 \\* Nbyte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x83**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319213419588](image-20220319213419588.png)\n\n### 功能 04（04H）读输入寄存器\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x04**         |\n  | 开始地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | 输入寄存器数量 | 2 字节 | 1 to 125 (0x7D)  |\n  | CRC校验码      | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x04**（1byte）+ 起始地址（2byte）+ 输入寄存器数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                       | 长度   | 说明     |\n  | -------------------------- | ------ | -------- |\n  | 设备地址                   | 1 字节 |          |\n  | 功能码                     | 1 字节 | **0x04** |\n  | 保持寄存器数量对应的字节数 | 1 字节 | 2 \\* N   |\n  | 寄存器数值1                | 2 字节 |          |\n  | 寄存器数值2                | 2 字节 |          |\n  | 寄存器数值n                | 2 字节 | n = N    |\n  | CRC校验码                  | 2 字节 |          |\n\n  指令：设备地址（1byte）+ **0x04**（1byte）+ 字节数（1byte）+ 输入寄存器值（2 \\* Nbyte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x84**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319214513539](image-20220319214513539.png)\n\n### 功能 05（05H）写单线圈\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x05**         |\n  | 输出地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | **\\*线圈数值** | 2 字节 | 0x0000 or 0xFF00 |\n  | CRC校验码      | 2 字节 |                  |\n\n  ***线圈数值** ：0xFF00 -> 请求线圈状态为 ON\n\n  ​\t\t\t\t\t\t0x0000 -> 请求线圈状态为 OFF\n\n  ​\t\t\t\t\t\t其他值 -> 非法且对线圈不起作用\n\n  指令：设备地址（1byte）+ **0x05**（1byte）+ 输出地址（2byte）+ 线圈值（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称      | 长度   | 说明             |\n  | --------- | ------ | ---------------- |\n  | 设备地址  | 1 字节 |                  |\n  | 功能码    | 1 字节 | **0x05**         |\n  | 输出地址  | 2 字节 | 0x0000 to 0xFFFF |\n  | 线圈数值  | 2 字节 | 0x0000 or 0xFF00 |\n  | CRC校验码 | 2 字节 |                  |\n\n  指令：正常响应是请求的应答\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x85**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319215633462](image-20220319215633462.png)\n\n### 功能 06（06H）写单个保持寄存器\n\n- 请求：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x06**         |\n  | 寄存器地址 | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数值 | 2 字节 | 0x0000 to 0xFFFF |\n  | CRC校验码  | 2 字节 |                  |\n  \n  指令：设备地址（1byte）+ **0x06**（1byte）+ 保持寄存器地址（2byte）+ 保持寄存器值（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x06**         |\n  | 寄存器地址 | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数值 | 2 字节 | 0x0000 to 0xFFFF |\n  | CRC校验码  | 2 字节 |                  |\n\n  指令：正常响应是请求的应答\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x86**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319220604204](image-20220319220604204.png)\n\n### 功能 15（0FH）写多个线圈\n\n- 请求：\n\n  | 名称                 | 长度   | 说明              |\n  | -------------------- | ------ | ----------------- |\n  | 设备地址             | 1 字节 |                   |\n  | 功能码               | 1 字节 | **0x0F**          |\n  | 开始地址             | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈输出数量         | 2 字节 | 1 to 1968 (0x7B0) |\n  | 线圈数量对应的字节数 | 1 字节 | **\\*N**           |\n  | 线圈输出数据1        | 1 字节 |                   |\n  | 线圈输出数据2        | 1 字节 |                   |\n  | 线圈输出数据n        | 1 字节 | n = N or N+1      |\n  | CRC校验码            | 2 字节 |                   |\n\n  **\\*N** = 线圈输出数量 / 8，如果余数非 0，则 N = N+1\n\n  指令：设备地址（1byte）+ **0x0F**（1byte）+ 起始地址（2byte）+ 线圈输出数（2byte）+ 字节数（1byte）+ 线圈输出数据（Nbyte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称         | 长度   | 说明              |\n  | ------------ | ------ | ----------------- |\n  | 设备地址     | 1 字节 |                   |\n  | 功能码       | 1 字节 | **0x0F**          |\n  | 开始地址     | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈输出数量 | 2 字节 | 1 to 1968 (0x7B0) |\n  | CRC校验码    | 2 字节 |                   |\n\n  指令：设备地址（1byte）+ **0x0F**（1byte）+ 起始地址（2byte）+ 线圈输出数（2byte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x8F**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319223636555](image-20220319223636555.png)\n\n### 功能 16（10H）写多个保持寄存器\n\n- 请求：\n\n  | 名称                   | 长度   | 说明             |\n  | ---------------------- | ------ | ---------------- |\n  | 设备地址               | 1 字节 |                  |\n  | 功能码                 | 1 字节 | **0x10**         |\n  | 开始地址               | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数量             | 2 字节 | 1 to 123 (0x7B)  |\n  | 寄存器数量对应的字节数 | 1 字节 | 2 * N            |\n  | 寄存器数值1            | 2 字节 |                  |\n  | 寄存器数值2            | 2 字节 |                  |\n  | 寄存器数值n            | 2 字节 | n = N            |\n  | CRC校验码              | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x10**（1byte）+ 起始地址（2byte）+ 寄存器数（2byte）+ 字节数（1byte）+ 寄存器数值（2 * Nbyte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x10**         |\n  | 开始地址   | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数量 | 2 字节 | 1 to 123 (0x7B)  |\n  | CRC校验码  | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x10**（1byte）+ 起始地址（2byte）+ 保持寄存器数（2byte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x90**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319224924985](image-20220319224924985.png)\n\n## CRC校验\n\n- CRC16_MODBUS查表法：\n\n    ```c\n    static const unsigned char aucCRCHi[] = {\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, \n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, \n        0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, \n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40\n    };\n\n    static const unsigned char aucCRCLo[] = {\n        0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,\n        0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,\n        0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,\n        0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,\n        0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,\n        0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,\n        0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,\n        0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, \n        0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,\n        0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,\n        0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,\n        0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,\n        0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, \n        0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,\n        0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,\n        0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,\n        0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,\n        0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,\n        0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,\n        0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,\n        0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,\n        0x41, 0x81, 0x80, 0x40\n    };\n\n    unsigned short\n    usMBCRC16( unsigned char * pucFrame, unsigned short usLen )\n    {\n        unsigned char   ucCRCHi = 0xFF;\n        unsigned char   ucCRCLo = 0xFF;\n        int             iIndex;\n\n        while( usLen-- )\n        {\n            iIndex = ucCRCLo ^ *( pucFrame++ );\n            ucCRCLo = ( unsigned char )( ucCRCHi ^ aucCRCHi[iIndex] );\n            ucCRCHi = aucCRCLo[iIndex];\n        }\n        return ( unsigned short )( ucCRCHi << 8 | ucCRCLo );\n    }\n    ```\n\n- CRC16_MODBUS运算法：\n\n  运算分析及计算，可看文章 [常用校验算法](https://arachnid.cc/check-algorithm/)-CRC章节\n\n\n\n# 实例应用\n\n测试应用可看以前的文章：\n\n[Nano130之 FreeModbus移植](https://blog.csdn.net/qq_42992084/article/details/107590803)","tags":["history","modbus"],"categories":["modbus"]},{"title":"RT-Thread 应用总结","url":"/rt-thread-summarize/","content":"\n\n\n官方文档介绍：[RT-Thread文档中心](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/README)\n\n\n\n# 各模块 API接口\n\n由于 RT-Thread实时操作系统跟各大类 RTOS应用原理大致相同，因此不再详述各模块功能的作用了（各模块功能的详细信息可参考以前的 《[FreeRTOS专栏](https://arachnid.cc/categories/RTOS/)》），只总结各类功能接口的 API调用函数。\n\n\n\n官方 API参考手册：[RT-Thread API参考手册](https://www.rt-thread.org/document/api/index.html)\n\n\n\n![](04thread_sta.png)\n\n\n\n## 线程管理\n\n### A、线程使用\n\n![线程相关操作](04thread_ops.png)\n\n| 函数功能 | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数 |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------- |\n| 创建线程 | rt_thread_t rt_thread_create(const char \\*name, void (\\*entry)(void \\*parameter), void \\*parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick); | 该函数将**从动态堆内存中**创建一个线程对象并分配线程对象内存和堆栈。 | xTaskCreate()           |\n| 删除线程 | rt_err_t rt_thread_delete(rt_thread_t thread);               | 调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。 | vTaskDelete()           |\n|          |                                                              |                                                              |                         |\n| 初始线程 | rt_err_t rt_thread_init(struct rt_thread \\*thread, const char \\*name, void (\\*entry)(void \\*parameter),  void \\*parameter, void \\*stack_start,  rt_uint32_t stack_size, rt_uint8_t priority,  rt_uint32_t tick); | 使用该函数创建的线程，线程句柄(或者说线程控制块指针) 、线程栈所占用的内存空间，均通过全局变量的方式进行分配，内核不负责动态分配内存空间（即由用户提供，**属于静态分配**，在编译时就被确定、被分配处理）。 | xTaskCreateStatic()     |\n| 脱离线程 | rt_err_t rt_thread_detach (rt_thread_t thread);              | 与 rt_thread_delete() 函数相对应，使线程对象在线程队列和内核对象管理器中被脱离。注：线程本身不应调用这个接口脱离线程本身 | vTaskDelete()           |\n|          |                                                              |                                                              |                         |\n| 启动线程 | rt_err_t rt_thread_startup(rt_thread_t thread);              | 当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。 |                         |\n|          |                                                              |                                                              |                         |\n| 线程睡眠 | rt_err_t rt_thread_sleep(rt_tick_t tick); rt_err_t rt_thread_delay(rt_tick_t tick); rt_err_t rt_thread_mdelay(rt_int32_t ms); | 这三个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。 | vTaskDelay()            |\n\n对比：[FreeRTOS篇章之任务管理](https://arachnid.cc/freertos-task/)\n\n\n\n### B、挂起和恢复\n\n- **线程挂起的函数接口：**\n\n  `rt_err_t rt_thread_suspend (rt_thread_t thread);`\n\n  线程挂起接口 rt_thread_suspend() 的参数和返回值见下表：\n\n  | **参数** | **描述**                                     |\n  | -------- | -------------------------------------------- |\n  | thread   | 线程句柄                                     |\n  | **返回** | ——                                           |\n  | RT_EOK   | 线程挂起成功                                 |\n  | RT_ERROR | 线程挂起失败，因为该线程的状态并不是就绪状态 |\n\n- [ ] 注：RT-Thread对此此函数有严格的使用限制，该函数只能使用来挂起当前线程（即自己挂起自己），不可以在线程A中尝试挂起线程B，而且在挂起线程自己后，需要立刻调用 `rt_schedule()` 函数进行手动的线程上下文切换。用户只需要了解该接口的作用即可，强烈不建议在程序中使用该接口，该接口可以视为是内部接口。这是因为A线程在尝试挂起B线程时，A线程并不清楚B线程正在运行什么程序，一旦B线程正在使用例如互斥量、信号量等影响、阻塞其他线程的内核对象，那么A线程尝试挂起B线程的操作将会引发连锁反应，严重危及系统的实时性（有些地方会将其描述为死锁，实际上这种现象不是死锁，但是也不比死锁好到哪去）。\n\n- **线程恢复的函数接口：**\n\n  `rt_err_t rt_thread_resume (rt_thread_t thread);`\n\n  线程恢复接口 rt_thread_resume() 的参数和返回值见下表：\n\n  | **参数** | **描述**                                                     |\n  | -------- | ------------------------------------------------------------ |\n  | thread   | 线程句柄                                                     |\n  | **返回** | ——                                                           |\n  | RT_EOK   | 线程恢复成功                                                 |\n  | RT_ERROR | 线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态 |\n\n以上这两个函数类似于 [FreeRTOS篇章之临界区与调度器](https://arachnid.cc/freertos-critical-scheduler/) 里面的调度器中的操作，但其要求并不一样。\n\n\n\n## 信号量\n\n![信号量相关接口](06sem_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                    |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |\n| 创建信号量       | rt_sem_t rt_sem_create(const char \\*name, rt_uint32_t value, rt_uint8_t flag); | 系统**动态分配**一个 semaphore 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 semaphore 相关的部分。 | xSemaphoreCreateBinary()                   |\n| 删除信号量       | rt_err_t rt_sem_delete(rt_sem_t sem);                        | 通过删除信号量以释放系统资源，适用于动态创建的信号量。       | vSemaphoreDelete()                         |\n|                  |                                                              |                                                              |                                            |\n| 初始信号量       | rt_err_t rt_sem_init(rt_sem_t sem, const char \\*name, rt_uint32_t value, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xSemaphoreCreateBinaryStatic()             |\n| 脱离信号量       | rt_err_t rt_sem_detach(rt_sem_t sem);                        | 让信号量对象从内核对象管理器中脱离，适用于静态初始化的信号量。 | vSemaphoreDelete()                         |\n|                  |                                                              |                                                              |                                            |\n| 获取信号量       | rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);        | 通过获取信号量来获得信号量资源实例，当信号量值大于零时，线程将获得信号量，并且相应的信号量值会减 1。 | xSemaphoreTake() / xSemaphoreTakeFromISR() |\n| 无等待获取信号量 | rt_err_t rt_sem_trytake(rt_sem_t sem);                       | 与 `rt_sem_take(sem, RT_WAITING_NO)` 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - `RT_ETIMEOUT`。 |                                            |\n|                  |                                                              |                                                              |                                            |\n| 释放信号量       | rt_err_t rt_sem_release(rt_sem_t sem);                       | 释放之前所获得的信号量资源实例。                             | xSemaphoreGive() / xSemaphoreGiveFromISR() |\n\n对比：[FreeRTOS篇章之二值信号量](https://arachnid.cc/freertos-binary-semaphore/)\n\n\n\n## 互斥量\n\n![互斥量相关接口](06mutex_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数       |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------- |\n| 创建互斥量       | rt_mutex_t rt_mutex_create (const char \\*name, rt_uint8_t flag); | 系统将先从对象管理器中**动态分配**一个 mutex 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 mutex 相关的部分。 | xSemaphoreCreateMutex()       |\n| 删除互斥量       | rt_err_t rt_mutex_delete (rt_mutex_t mutex);                 | 通过删除互斥量以释放系统资源，适用于动态创建的互斥量。       | vSemaphoreDelete()            |\n|                  |                                                              |                                                              |                               |\n| 初始互斥量       | rt_err_t rt_mutex_init (rt_mutex_t mutex, const char \\*name, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xSemaphoreCreateMutexStatic() |\n| 脱离互斥量       | rt_err_t rt_mutex_detach (rt_mutex_t mutex);                 | 把互斥量对象从内核对象管理器中脱离，适用于静态初始化的互斥量。 | vSemaphoreDelete()            |\n|                  |                                                              |                                                              |                               |\n| 获取互斥量       | rt_err_t rt_mutex_take (rt_mutex_t mutex, rt_int32_t time);  | 当线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。 | xSemaphoreTake()              |\n| 无等待获取互斥量 | rt_err_t rt_mutex_trytake(rt_mutex_t mutex);                 | 与 `rt_mutex_take(mutex, RT_WAITING_NO)` 的作用相同，即当线程申请的互斥量资源实例不可用的时候，它不会等待在该互斥量上，而是直接返回 - `RT_ETIMEOUT`。 |                               |\n|                  |                                                              |                                                              |                               |\n| 释放互斥量       | rt_err_t rt_mutex_release(rt_mutex_t mutex);                 | 使用该函数接口时，只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。 | xSemaphoreGive()              |\n\n对比：[FreeRTOS篇章之互斥量](https://arachnid.cc/freertos-mutex-semaphore/)\n\n\n\n## 事件集\n\n![事件相关接口](06event_ops.png)\n\n| 函数功能   | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                            |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------- |\n| 创建事件集 | rt_event_t rt_event_create(const char \\*name, rt_uint8_t flag); | 系统从对象管理器中**动态分配**事件集对象，并初始化这个对象，然后初始化父类 IPC 对象。 | xEventGroupCreate()                                |\n| 删除事件集 | rt_err_t rt_event_delete(rt_event_t event);                  | 通过删除事件集对象控制块来释放系统资源，适用于动态创建的事件集。 | vEventGroupDelete()                                |\n|            |                                                              |                                                              |                                                    |\n| 初始事件集 | rt_err_t rt_event_init(rt_event_t event, const char \\*name, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xEventGroupCreateStatic()                          |\n| 脱离事件集 | rt_err_t rt_event_detach(rt_event_t event);                  | 将该事件集从内核对象管理器中脱离，适用于静态初始化的事件集。 | vEventGroupDelete()                                |\n|            |                                                              |                                                              |                                                    |\n| 发送事件   | rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);   | 通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。 | xEventGroupSetBits() / xEventGroupSetBitsFromISR() |\n|            |                                                              |                                                              |                                                    |\n| 接收事件   | rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t \\*recved); | 系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 `RT_EVENT_FLAG_CLEAR` 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - `RT_ETIMEOUT`。 | xEventGroupWaitBits()                              |\n\n对比：[FreeRTOS篇章之事件位和事件组](https://arachnid.cc/freertos-event/)\n\n\n\n## 邮箱\n\n![邮箱相关接口](07mb_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |\n| 创建邮箱         | rt_mailbox_t rt_mb_create (const char \\*name, rt_size_t size, rt_uint8_t flag); | 创建邮箱对象时会先从对象管理器中分配一个邮箱对象，然后给邮箱**动态分配一块内存空间**用来存放邮件，这块内存的大小等于邮件大小（4 字节）与邮箱容量的乘积，接着初始化接收邮件数目和发送邮件在邮箱中的偏移量。 | xQueueCreate()                               |\n| 删除邮箱         | rt_err_t rt_mb_delete (rt_mailbox_t mb);                     | 释放相应的系统资源，当操作一旦完成，邮箱将被永久性的删除。   | vQueueDelete()                               |\n|                  |                                                              |                                                              |                                              |\n| 初始邮箱         | rt_err_t rt_mb_init(rt_mailbox_t mb, const char \\*name, void \\*msgpool, rt_size_t size, rt_uint8_t flag); | **属于静态分配**，与创建邮箱不同的是，静态邮箱对象的内存是在系统编译时由编译器分配的，一般放于读写数据段或未初始化数据段中，其余的初始化工作与创建邮箱时相同。 | xQueueCreateStatic()                         |\n| 脱离邮箱         | rt_err_t rt_mb_detach(rt_mailbox_t mb);                      | 把静态初始化的邮箱对象从内核对象管理器中脱离。               | vQueueDelete()                               |\n|                  |                                                              |                                                              |                                              |\n| 发送邮件         | rt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);    | 发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针；当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -`RT_EFULL` 的返回值。 | xQueueOverwrite() / xQueueOverwriteFromISR() |\n| 等待方式发送邮件 | rt_err_t rt_mb_send_wait (rt_mailbox_t mb, rt_uint32_t value, rt_int32_t timeout); | 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间；如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。 |                                              |\n| 发送紧急邮件     | rt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);   | 与发送邮件几乎一样，唯一的不同是，当发送紧急邮件时，邮件被**直接插队放入了邮件队首**，这样，接收者就能够优先接收到紧急邮件，从而及时进行处理。 |                                              |\n|                  |                                                              |                                                              |                                              |\n| 接收邮件         | rt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t \\*value, rt_int32_t timeout); | 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 `RT_EOK` 的返回值，否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。 | xQueueReceive() / xQueueReceiveFromISR()     |\n\n对比：[FreeRTOS篇章之队列管理](https://arachnid.cc/freertos-queue/) 中的消息数目为 1 的队列\n\n注：由于 FreeRTOS中并没有邮箱这一概念（邮箱这概念在 uCOS中有），但是其原理类似于利用队列发送单一数目的信息，由于在 32 系统上 4 字节（32 bit）的内容恰好可以放置一个指针，因此该信息通常为**数据指针**。\n\n\n\n## 消息队列\n\n![消息队列相关接口](07msg_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                                      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 创建队列         | rt_mq_t rt_mq_create(const char \\*name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag); | 从对象管理器中**动态分配**一个消息队列对象，然后给消息队列对象分配一块内存空间，组织成空闲消息链表，这块`内存的大小 = [消息大小 + 消息头（用于链表连接）的大小] x 消息队列最大个数`，接着再初始化消息队列，此时消息队列为空。 | xQueueCreate()                                               |\n| 删除队列         | rt_err_t rt_mq_delete(rt_mq_t mq);                           | 删除它以释放系统资源，一旦操作完成，消息队列将被永久性地删除。 | vQueueDelete()                                               |\n|                  |                                                              |                                                              |                                                              |\n| 初始队列         | rt_err_t rt_mq_init(rt_mq_t mq, const char \\*name, void \\*msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag); | **属于静态分配**，跟创建消息队列对象类似，只是静态消息队列对象的内存是在系统编译时由编译器分配的，一般放于读数据段或未初始化数据段中。 | xQueueCreateStatic()                                         |\n| 脱离队列         | rt_err_t rt_mq_detach(rt_mq_t mq);                           | 将使消息队列对象被从内核对象管理器中脱离。                   | vQueueDelete()                                               |\n|                  |                                                              |                                                              |                                                              |\n| 发送信息         | rt_err_t rt_mq_send (rt_mq_t mq, void \\*buffer, rt_size_t size); | 线程或者中断服务程序都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-`RT_EFULL`）。 | xQueueSend() / xQueueSendFromISR() xQueueSendToFront() / xQueueSendToFrontFromISR() |\n| 等待方式发送信息 | rt_err_t rt_mq_send_wait(rt_mq_t     mq, const void \\*buffer, rt_size_t size, rt_int32_t  timeout); | 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。 |                                                              |\n| 发送紧急信息     | rt_err_t rt_mq_urgent(rt_mq_t mq, void \\*buffer, rt_size_t size); | 与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。 |                                                              |\n|                  |                                                              |                                                              |                                                              |\n| 接收信息         | rt_err_t rt_mq_recv (rt_mq_t mq, void \\*buffer, rt_size_t size, rt_int32_t timeout); | 当消息队列中有消息时，接收者才能接收消息，否则接收者会根据超时时间设置，或挂起在消息队列的等待线程队列上，或直接返回。 | xQueueReceive() / xQueueReceiveFromISR()                     |\n\n对比：[FreeRTOS篇章之队列管理](https://arachnid.cc/freertos-queue/)\n\n\n\n# 中断管理\n\n![中断相关接口](09interrupt_ops.png)\n\n对于上图，通常用的较多的是：\n\n## 全局中断开关\n\n**全局中断开关也称为**中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。\n\n| 函数功能           | API 接口                                      | 函数描述                 | 与 FreeRTOS相匹配的函数                               |\n| ------------------ | --------------------------------------------- | ------------------------ | ----------------------------------------------------- |\n| 关闭整个系统的中断 | rt_base_t rt_hw_interrupt_disable(void);      | 关闭整个系统的中断       | taskENTER_CRITICAL() / taskENTER_CRITICAL_FROM_ISR()  |\n| 恢复整个系统的中断 | void rt_hw_interrupt_enable(rt_base_t level); | 恢复系统的上一个中断状态 | taskEXIT_CRITICAL() / taskEXIT_CRITICAL_FROM_ISR( x ) |\n\n**（1）rt_hw_interrupt_disable() API 函数**\n\n原型：`rt_base_t rt_hw_interrupt_disable(void);`\n\n返回参数：\n\n- rt_hw_interrupt_disable 函数运行前的中断状态\n\n\n\n**（2）rt_hw_interrupt_enable() API 函数**\n\n原型：`void rt_hw_interrupt_enable(rt_base_t level);`\n\n输入参数：\n\n- 前一次 rt_hw_interrupt_disable 返回的中断状态\n\n\n\n注：在这里就相当于 [FreeRTOS篇章之临界区与调度器](https://arachnid.cc/freertos-critical-scheduler/) 里面的临界段中的操作。\n\n\n\n## 中断通知\n\n当整个系统被中断打断，进入中断处理函数时，需要通知内核当前已经进入到中断状态。\n\n针对这种情况，RT-Thread 提供如下两个接口：\n\n```c\nvoid rt_interrupt_enter(void);\t\t// 用于通知内核，当前已经进入了中断状态，并增加中断嵌套深度（执行 rt_interrupt_nest++）\nvoid rt_interrupt_leave(void);\t\t// 用于通知内核，当前已经离开了中断状态，并减少中断嵌套深度（执行 rt_interrupt_nest--）\n\n注：不要在应用程序中调用这两个接口函数。\n```\n\n其实这两个函数等同于 FreeRTOS中带 FromISR后缀的函数说明。\n\n\n\n# RT-Thread Studio上手\n\n安装及环境搭建过程可以直接参看官方的指导文档：[RT-Thread Studio使用文档](https://www.rt-thread.org/document/site/#/development-tools/rtthread-studio/um/studio-user-begin)\n\n**以下只是简单记录部分关键点：**\n\n## 控制台调试口修改\n\n在新建项目过程中，可从 GUI窗口中选择配置，如下图：\n\n![TIM截图20220226114622](TIM截图20220226114622.png)\n\n当后期需要重新分配时，则需要在代码和 RT-Thread setting中修改了，（以修改为 `UART 3` 为例）修改内容如下：\n\n![TIM截图20220226120341](TIM截图20220226120341.png)\n\n\n\n## 串口终端集成显示\n\n在 RT-Thread Studio上，是可以通过点击工具栏 `终端` 按钮，来打开对应的终端功能窗口查看输出信息的，并且同样支持与 RT-Thread特有的 `finsh` 命令进行交互，串口终端显示操作如下：\n\n![TIM截图20220226141345](TIM截图20220226141345.png)\n\n![TIM截图20220226142044](TIM截图20220226142044.png)\n\n\n\n## 与 CubeMX联合编程\n\n此操作的前提条件是已经安装了 STM32CubeMX\n\n### A、启动 CubeMX settings配置\n\n新建的工程，都是优先使用内部时钟源（如下图），但实际情况下，大部分是使用外部时钟的，因为其稳定性比较好；因此，以修改外部时钟为例。\n\n![TIM截图20220226115723](TIM截图20220226115723.png)\n\n由于 RT-Thread Studio支持与 CubeMX联合编程，所以我们只需在项目资源管理器中启动 `CubeMX settings` 进行配置就好（如下图），进入界面后，其操作实际等同于操作 STM32CubeMX。\n\n![image-20220226210308862](image-20220226210308862.png)\n\n### B、CubeMX settings配置生成注意点\n\n- 尽量生成 GCC工程，因为 RT-Thread Studio用的是 gcc编译器\n  ![image-20220226233830986](image-20220226233830986.png)\n\n- 选择生成独立的 .c .h文件\n  ![img](313583-20201110104753899-295524523.png)\n\n- 生成完成后返回界面，会提示替换了 `stm32xxx_hal_conf.h` 文件，因此，我们需要把原来的配置，同步过去，该哪些配置需要打开的，都一一打开。\n\n### C、添加编译规则\n\n在生成 CubeMX产生的工程后，打开 `drv_clk.c` 文件，你会发现 `clk_init()` 函数里面被自动更改了（如下图）；这也就意味着什么呢？记得备份啦，或者上 git / svn进行版本管理啦。\n\n![TIM截图20220226143627](TIM截图20220226143627.png)\n\n于是乎，对工程进行编译时，发现一堆报错，不禁怀疑 RT-Thread Studio是否支持与 CubeMX联合编程的。。。\n\n在这里就需要对编译做相关操作了：\n\n（1）在生成的 cubemx文件夹里，先检查 cubemx文件夹下有没有 `SConscript` 文件，如果有就跳过创建环节，检查内容。\n\n（2）核查并更改 `SConscript` 文件里面的内容。\n\n（3）有时候在生成 CubeMX产生的工程后，RT-Thread Studio会帮你生成一个 `SConscript` 文件，并写好了规则，如果是已有的，那么可以尝试先编译一下是否有新增的源码进行编译，如果没有，那么可以仿照如下的代码进行修改：\n\n![TIM截图20220226150650](TIM截图20220226150650.png)\n\n其中，上面规则里的 `src` 部分，需要根据实际内容增删需要编译的源文件（如下）：\n\n```markdown\nsrc = Split('''\nSrc/stm32g4xx_hal_msp.c\nSrc/main.c\nSrc/dma.c\nSrc/gpio.c\nSrc/usart.c\n''')\n```\n\n当然，为了一劳永逸，你也可以把它修改成这样子：\n\n```python\n# 引入 building 模块中所有的东西\nfrom building import *\n\n# 获取当前路径。\ncwd = GetCurrentDir()\n\n# 使能选择\nsearch_EN = 1\n\n# add cubemx drivers\n# search_EN为 0时，手动选择添加需要编译的源文件\n# search_EN为 1时，自动搜寻与 SrcRemove匹配以外的源文件\nif (0 == search_EN):\n\tsrc = Split('''\n\tSrc/stm32f4xx_hal_msp.c\n\tSrc/main.c\n\t''')\nelse:\n\tsrc = Glob('Src/*.c')\t\n\tSrcRemove(src, ['Src/stm32f4xx_it.c'])\n\tSrcRemove(src, ['Src/system_stm32f4xx.c'])\n\n# 创建头文件路径列表，并保存至 path中\npath = [cwd + '/Inc']\n\n# 这是 RT-Thread 基于 SCons 扩展的一个方法（函数）。\ngroup = DefineGroup('cubemx', src, depend = [''], CPPPATH = path)\n\nReturn('group')\n\n```\n\n通过上面，你可能发现，为什么文件中的 `stm32f4xx_it.c` 和 `system_stm32f4xx.c` 不加入构建；其实你可以尝试一下加入编译一下，你就会发现玄机了。\n\n更多的关于 SCons工具的使用可以观看如下链接：\n\n[https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-%e7%ae%80%e4%bb%8b](https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-简介)\n\n[https://scons.org/doc/production/HTML/scons-user/index.html](https://scons.org/doc/production/HTML/scons-user/index.html)\n\n最后记得更新 Sconscripts（在项目资源管理器选择目标工程 -> 右键 -> 更新 `Sconscripts`）：\n\n![image-20220226231733878](image-20220226231733878.png)\n\n### D、迁移 CubeMX产生的代码\n\n当完成上面操作后，再次构建工程，或多或少还会出现错误，大概率是函数重复定义导致，比如 `multiple definition of main`。这时候可以如下操作：\n\n![20220226173146](20220226173146.png)\n\n嘛，或许有时候在 CubeMX初次生成的 main()函数上自带了 `__WEAK` 弱处理关键字，但后期在多次更改 CubeMX settings配置后，会有出现去掉 `__WEAK` 的情况，所以为了安全，还是把 `__WEAK` 添加到上述的保护区域位置去吧。\n\n除了以上情况，在 CubeMX settings配置更多外设时，需要把 cubemx/Src里的 main.c文件里的配置函数，手动移加到 RT-Thread工程的 main.c主文件函数中（一些 RTT配置里面有的，就不用添加过去了，避免功能出错，例如 ETH 的配置）。如下图：\n\n![20220226172930](20220226172930.png)","tags":["history","RTOS"]},{"title":"Modbus家族之开篇","url":"/modbus-family/","content":"\n\n\n\n# 历史溯源\n\nModbus是由 Modicon公司（现在的施耐德电气 Schneider Electric）在 1979年开发的一种消息传递结构，为使用可编程逻辑控制器（PLC）通信而发表，用于在智能设备之间建立客户端 - 服务器通信；这是一个划时代、里程碑式的网络协议，因此为工业网络拉开了序幕。Modbus已经成为工业领域通信协议事实上的业界标准，并且现在是工业电子设备之间常用的连接方式。\n\nModbus在工业环境下很流行，因为它是公开发表并且无著作权要求的。它是为工业应用开发的，与其他标准相比，它相对易于部署和维护，除了要传输的数据格式的大小外，几乎没有其他限制。Modbus通常使用 **RS485**作为其物理层。\n\n## 发展史\n\nModicon，即今天的施耐德电气，于 1979 年向市场推出了 Modbus原始协议（Modbus ASCII和 Modbus RTU）；随着通信领域的迅速发展以及传输速度的提高，扩展版本 Modbus Plus（Modbus+或者MB+）紧接着出现，不过此协议是 Modicon专有的，**和 Modbus并不相同**；直到以太网技术的标准化和商品化，以太网成为了企业系统的业界标准，同时也成为了工业网络的业界标准；为了将 Modbus带入 21 世纪，一个开放的 Modbus TCP/IP规范于 1999 年修订发行；到了 2004 年 4 月，Modbus 协议从施耐德电气转移到 Modbus组织，这标志着对开放的承诺（**该规范可免费下载，并且**使用 Modbus 或 Modbus TCP/IP 协议无需后续许可费用）；至此，在 Modbus TCP/IP 因为它的开放性、简单、低成本的开发以及支持它所需的最少硬件等特点，存在多个 Modbus TCP变种，而 Modbus ASCII和 Modbus RTU在小型的嵌入式设备当中得到广泛应用。\n\n\n\n# 协议版本\n\nModbus协议目前存在用于**串口**、**以太网**以及其他支持**互联网协议**的网络的版本。\n\nModbus是一种请求 / 回复协议，提供由功能代码指定的服务。Modbus功能代码是 Modbus Request(请求) / Response(响应)  PDU 的元素。\n\n串行端口和以太网存在多种版本的 Modbus协议，最常见的是：\n\n- Modbus RTU\n- Modbus ASCII\n- Modbus TCP\n- Modbus Plus\n\n![](Modbus-Different-Types.jpg)\n\n\n\n## Modbus RTU\n\n`Modbus RTU` 是一种紧凑的，采用二进制表示数据的方式；因为使用二进制编码和 CRC错误检查的结合使得 Modbus RTU适用于工业应用，因为它比 ASCII字符的替代方案更有效地传输。在 Modbus RTU与 ASCII之间进行选择时，如果考虑性能，则 RTU是首选。\n\n\n\n## Modbus ASCII\n\n`Modbus ASCII` 是当设备设置为使用 `ASCII` （**美国信息交换标准代码**）模式时，在 `MODBUS` 串行线上把通信消息中的每个 8位字节将作为两个 ASCII 4位字符发送。当物理通信链路或设备的功能不允许符合 RTU计时器管理要求时，使用此模式。所以此模式的效率不如 RTU，因为每个字节需要两个字符。示例：字节0x7D编码为两个字符： `0x35`和 `0x42`（在 `ASCII`表中为 `0x37` = `'7'`，而 `0x44` = `'D'`）。\n\n\n\n## Modbus TCP\n\n`Modbus TCP` 是在 `TCP/IP` 网络上运行的 Modbus的实现，旨在允许 Modbus ASCII / RTU协议在基于 TCP / IP的网络上传输。Modbus / TCP将 Modbus消息嵌入 TCP / IP帧内。尽管实现起来非常简单，但是与网络相关的特性增加了一些挑战。例如，由于Modbus主机期望并要求在一定时间范围内对其轮询做出响应，因此必须考虑 TCP / IP网络的不确定性（和其他方面）。Modbus ASCII和 Modbus TCP之间的主要区别在于，Modbus ASCII所需的 LRC错误检查由 IP层执行。\n\n\n\n> 对于以上 `TCP`/ `RTU`/ `ASCII`的这三种通信协议在数据模型和功能调用上都是相同的，只有封装方式是不同的。\n\n\n\n## Modbus Plus\n\n`Modbus Plus` （Modbus+或者MB+）属于 Modbus的一个扩展版本，不过此协议是Modicon专有的，和 Modbus不同。它需要一个专门的协处理器来处理类似 HDLC的高速令牌旋转。它使用 1Mbit/s的双绞线，并且每个节点都有转换隔离设备，是一种采用转换／边缘触发而不是电压／水平触发的设备。连接 Modbus Plus到计算机需要特别的接口，通常是支持 ISA（SA85），PCI或者 PCMCIA总线的板卡。\n\n\n\n# 通信和设备\n\nModbus有下列三种通信方式：\n\n（1）以太网：对应的通信模式是 **Modbus TCP/IP**\n\n（2）异步串行传输（各种介质如有线 RS-232/422/485/、光纤、无线等）：对应的通信模式是 **Modbus RTU**或 **Modbus ASCII**\n\n（3）高速令牌传递网络：对应的通信模式是 **Modbus PLUS**\n\n\n\nModbus通过多种类型的物理介质进行通信，例如：\n\n- 串行RS-232\n- 串行RS-485\n- 串行RS-422\n- 以太网\n\nModbus RTU和 Modbus ASCII协议应用于串口链接（RS232、RS485、RS422），Modbus TCP/IP协议应用于以太网链接。\n\n![img](Modbus-Communication-Physical-Media.gif)\n\n\n\n# 消息结构\n\nModbus的主要消息结构是点对点，能够在点对点和多点网络上运行。\n\n![image-20220208222537825](image-20220208222537825.png)\n\nModbus协议遵循**主 / 从（客户端 / 服务器）**架构，主（客户端）向从（服务器）发送请求并等待响应。注意！目前 Modbus中使用的术语 “主” 和 “从” 已被术语 “客户端” 和 “服务器” 所取代了。\n\n![image-20220209165731722](image-20220209165731722.png)\n\n\n\n# 常见 Modbus开源库\n\n## [FreeModbus](https://www.embedded-experts.at/en/freemodbus/)\n\nFreeMODBUS 是流行的 Modbus 协议的免费实现，专门针对嵌入式系统。FreeMODBUS 提供了 *Modbus 应用协议 v1.1a* 的实现，并支持 *Modbus over serial line 规范 1.0* 中定义的 **RTU/ASCII** 传输模式 ；自 0.7 版以来，FreeModbus 还支持 **Modbus/TCP**；0.9 版添加了第一个 Modbus/TCP 端口嵌入式使用 LWIP TCP/IP 堆栈的系统。唯一可惜的是，该 FreeMODBUS 只对从机开放了源码，主机部分并未实现开源。\n\n以下是该 FreeMODBUS 的下载链接：\n\nhttps://www.embedded-experts.at/en/freemodbus-downloads/\n\n\n\n## [libmodbus](https://libmodbus.org/)\n\nlibmodbus是一个多平台的 Modbus 源库，适用于 Linux、Mac OS X、FreeBSD、QNX 和 Win32 等操作系统；可以根据 Modbus协议发送和接收数据。支持 RTU（串行）和 TCP（以太网）通信。\n\n以下是该 libmodbus 的下载链接：\n\nhttps://libmodbus.org/download/\n\n\n\n# 参考\n\n[Modbus主页](https://modbus.org/)\n\n[Modbus](https://zh.wikipedia.org/wiki/Modbus) - wiki\n\n[WHAT IS MODBUS?](https://realpars.com/modbus/)\n\n《[modbus communication manual](https://process.honeywell.com/us/en/support/product-documents-downloads?search=modbus%20communication%20manual)》\n\n《[MODBUS APPLICATION PROTOCOL SPECIFICATION V1.1b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf)》\n\n《[Modbus Fieldbus Networking](https://www.generationrobots.com/media/roboteq/modbus-manual.pdf)》\n\n《[Modbus Protocol Reference Guide](https://www.m-system.co.jp/mssenglish/service/emmodbus.pdf)》\n\n[Modbus RTU通信指南](https://www.virtual-serial-port.org/cn/articles/modbus-rtu-guide/)\n\n[高级Modbus ASCII教程](https://www.virtual-serial-port.org/cn/articles/modbus-ascii-guide/)\n\n[modbus tools](https://www.modbustools.com/modbus.html)\n\n","tags":["history","modbus"],"categories":["modbus"]},{"title":"步进电机及丝杆","url":"/stepper-motor/","content":"\n\n\n# 步进电机\n\n## 介绍\n\n步进电机（英语：Stepper motor、Step motor）是直流无刷电机的一种，为具有如齿轮状突起（小齿）相锲合的定子和转子，可借由切换流向定子线圈中的电流，以一定角度逐步转动的电动机，能将电脉冲信号转换成相应角位移或线位移。\n\n\n\n### A、构造上\n\n步进电机在构造上有三种主要类型：反应式（Variable Reluctance, VR）、永磁式（Permanent Magnet, PM）和混合式（Hybrid Stepping, HS）\n\n![](15350977719637sn7os61sp.jpg)\n\n- 反应式：也叫感应式、磁滞式或磁阻式步进电机。定子上有绕组、转子由软磁材料组成；定、转子周边均匀分布小齿和槽，通电后利用磁导的变化产生转矩。结构简单、成本低、步距角小，可达1.2°、但动态性能差、效率低、发热大，可靠性难保证。\n\n  ![](2_10.png)\n\n- 永磁式：永磁式步进电机的转子用永磁材料制成，转子的极数与定子的极数相同。其特点是动态性能好、输出力矩大，但这种电机精度差，步矩角大（一般为7.5°或15°）。\n\n  ![](3_11.png)\n\n- 混合式：也叫永磁反应式、永磁感应式步进电机，综合了反应式和永磁式的优点。其定子上有多相绕组、转子上采用永磁材料，转子和定子上均有多个小齿以提高步矩精度。其特点是输出力矩大、动态性能好，步距角小，但结构复杂、成本相对较高。\n\n  ![](4_10.png)\n\n结构区别：\n\n![](step%20motor.jpg)\n\n### B、相数上\n\n从定子上绕组来分类，共有二相、三相和五相等系列。目前最受欢迎的是两相混合式步进电机，约占 97%以上的市场份额，其原因是性价比高，配上细分驱动器后效果良好。\n\n![](1535097802673o0o22s1864.jpg)\n\n- 两相：\n\n  ![](5_6%20-%20%E5%89%AF%E6%9C%AC.png)\n\n- 三相：\n\n  ![](5_6.png)\n\n### C、极数上\n\n按照接线方式的不同，步进电机又可以分为单极步进电机（Unipolar Stepper Motor），和双极步进电机（Bipolar Stepper Motor）。\n\n![](153509774969411451pn716%20-%20%E5%89%AF%E6%9C%AC.jpg)\n\n- 单极型：采用电流在一个绕组中始终沿固定方向流动的驱动方式（单极驱动）。虽然步进电机的结构较为复杂，但是由于仅需要电流 ON /OFF的控制，因此步进电机的驱动电路较简单。\n\n  ![](MT1-30_f02.gif)\n\n- 双极型：采用电流在一个绕组中双向流动的驱动方式（双极驱动）。这种方式电机的结构比较简单，端子数也较少，但由于必须控制一个端子的极性，因此驱动电路较为复杂。\n\n  ![](MT1-30_f01.gif)\n\n单极跟双极比较：\n\n・双极连接\n －采用电流在一个绕组中双向流动的驱动方式（双极驱动）。\n －结构简单，但步进电机的驱动电路复杂。\n －绕组利用率好，且可以进行精细的控制，因此步进电机能够获得很高的输出转矩。\n －可以减小在线圈中产生的反电动势，因此可以使用耐压低的电机驱动器。\n\n・单极连接\n －具有中心抽头，采用电流在一个绕组中始终沿固定方向流动的驱动方式（单极驱动）。\n －结构复杂，但步进电机的驱动电路简单。\n －绕组利用率差，与双极连接相比，步进电机只能获得约一半的输出转矩。\n －由于会在线圈中产生较高的反电动势，因此需要使用高耐压的电机驱动器。\n\n\n\n## 步进模式\n\n主要有 3种步进模式 ：\n\n- 整步\n- 半步\n- 微步\n\n### A、整步\n\n![](full-step-mode-stepper-motor.png)\n\n顾名思义，就是每走一步都是取整的意思。而在整步控制上，也可分成**单相通电驱动**和**双相通电驱动**：\n\n![](11_2.png)\n\n![](full_step_driving_1.png)\n\n它们之间最大的区别在于，双相通电驱动下，由于电机中流动的电流更多，产生的磁场也更强，因此扭矩也更大。\n\n### B、半步\n\n![](half-step-operation-of-stepper-motor.png)\n\n半步模式属于单相通电驱动和双相通电驱动的组合，这种模式可以将步距减小一倍（旋转45°，而不是90°）。其唯一的缺点是电机产生的扭矩不是恒定的，当两相都通电时扭矩较高，只有一相通电时扭矩较小。\n\n![](half_step_driving.png)\n\n### C、微步\n\n![](modes-of-excitation-of-stepper-motor-stepper-microstepping.png)\n\n在微步模式下，可以看作是半步模式的增强版，因为它可以进一步减小步距，并且具有恒定的扭矩输出。这是通过控制每相流过的电流强度来实现的。最多可将电机步距角细分 256倍，提高了低速光滑度和低速谐振效果。\n\n![](microstepping.png)\n\n\n\n## 运作方式\n\n步进电机的运行一般分为三个部分：\n\n- 控制器\n- 驱动器\n- 电机马达\n\n![](TIM%E6%88%AA%E5%9B%BE20211031144528.png)\n\n### A、控制器\n\n控制器类似于人的大脑，指引着电机转动的方向以及操控着电机运转的快慢；当配合着一些控制策略，如：PID 控制、自适应控制等等，会使得其运作效果相当出色；而对于常见的控制方式有：传统方式的步进电机控制系统、基于 PLC的步进电机控制系统、基于 DSP的步进电机控制系统、基于 ARM的步进电机控制系统等。\n\n### B、驱动器\n\n驱动器一般作两个功能：电机的精度控制和驱动运转控制。可分为恒流驱动与恒压驱动两种；恒压驱动方式因其电路构造简单，在高速领域时不易获得转矩的特性，现今已经很少使用；然而恒流驱动方式则是现在广为使用的驱动方式，在高速领域中能掌 握优良的转矩特性。\n\n常见的驱动电路有：\n\n- 单极步进电机驱动电路\n\n  ![](9_5.png)\n\n- 双极步进电机驱动电路\n\n  ![](10_4.png)\n\n### C、电机马达\n\n![](Image_506.png)\n\n略\n\n<br>\n\n# 滚珠丝杆\n\n## 种类\n\n![](TIM%E6%88%AA%E5%9B%BE20211101201524.png)\n\n![](TIM%E6%88%AA%E5%9B%BE20211101201817.png)\n\n## 型号\n\n![image-20211101202146111](image-20211101202146111.png)\n\n![image-20211101202211688](image-20211101202211688.png)\n\n![image-20211101202236464](image-20211101202236464.png)\n\n![image-20211101202300243](image-20211101202300243.png)\n\n![image-20211101202323044](image-20211101202323044.png)\n\n![image-20211101202343698](image-20211101202343698.png)\n\n![image-20211101202416290](image-20211101202416290.png)\n\n![image-20211101202437316](image-20211101202437316.png)\n\n![image-20211101202459745](image-20211101202459745.png)\n\n![image-20211101202522600](image-20211101202522600.png)\n\n\n\n# 传动装置\n\n## 通电自锁\n\n绕组通电时步进电机具有全部的保持力矩。这就意味着步进电机可以在不使用机械刹车的情况下保持在停止位置。\n\n![](stop_position_self_hold.jpg)\n\n## 刹车抱闸\n\n一旦电源被切断，电机自身的保持力矩丢失，电机不能在垂直操作中或施加外力作用下保持在停止位置。在提升和其它相似应用中需要使用带电磁刹车的电机。\n\n![](electromagnetic_brake_motor.jpg)\n\n<br>\n\n# 常用知识归纳\n\n## 细分与步进数\n\n### A、定义\n\n- **什么是步进数**\n\n  步进数，也叫脉冲数，是指步进电机转动一圈或是前进一段距离，需要电机需要接受的信号个数，单位为步。 因为电机的转动最终还是转化为直线运动，所以通常步进数指的是电机推动、拉动主轴，龙门等配件前进 1毫米所需要的步数。\n\n  当步进数不对的后果：\n\n  例如当一台雕刻机的电机步进数不对，直接影响雕刻出来的结果大小不对。比如步进为 100的机器，雕刻 1毫米的直线，电机需要的信号是 100，如果设置步进数为 200，那就多走了一倍的距离，实际雕刻出来的线条就为 2毫米了。\n\n- **什么是细分**\n\n  细分是步进电机驱动器的功能。步进电机的精度有限，一般的步进电机为 200步走一圈，走一步转动的角度是 1.8度。当我们需要电机走 0.9度时，电机就没有办法了。好在步进电机驱动器，可以帮助步进电机把精度提高，把精度提高一倍，叫做半步细分，也叫 1/2细分，此时电机一个信号脉冲就可以转动 0.9度。再把精度提高一倍，叫 1/4细分，走一步，相当于 0.45度。细分都是一倍倍上去的，有 1/2, 1/4, 1/8, 1/16, 1/32等，最大可达 256细分。\n\n### B、应用\n\n- **步进数计算三要素**\n\n  一个是电机转动一圈所需的脉冲数（原始步数）。这个一般为 200，对应的步进角为 1.8度；当然也有其他的，像一些小电机只有 15度，那么转一圈只需 24个脉冲。\n\n  二是所采用的传动结构。如果用丝杆，要知道丝杆的导程，就是说丝杆转一圈时，前进的毫米数（这个稍后说）。如果是皮带轮，就要知道齿数和齿距，两个相乘得到皮带轮转一圈，皮带前进的毫米数。\n\n  三是步进电机驱动器的细分数。计算的公式是： **原始脉冲数** 除于 **毫米数** 再乘于 **细分数**。\n\n- **合理的步进数**\n\n  步进数越大，理论上来说精度越高；然在实际应用中，精度是由很多因素决定的，比如说齿轮可能有间隙，皮带有弹性，机架会抖动等。因此小于 0.01精度的步进数是大部分是没有意义的。\n\n- **如何纠正步进参数**\n\n  有些不是我们自己购买的机器，我们可能不知道具体的电机，传动参数，那么还有一种调整的办法。 先随便设置一个步进数，如 200，然后在软件上控制电机走100毫米，如果设置对，实际走的距离就是100毫米，如果不对，那么有偏差，比如实际它只走了 80毫米。那么可以用以下方式计算正确的步进数。\n\n  原理： 正确的步进数跟正确的距离之比 = 错误的步进数跟错误的距离之比\n\n  公式：正确的步进数 = 正确的距离 乘于 错误的步进数 除于 错误的距离 = 100 * 200 / 80= 250 设置步进数为 250后，你会发现，走 100mm，就是100mm，校对成功。\n\n\n\n## 丝杆脉冲计算\n\n1. 首先认识丝杆的导程，一般来说常见的有 1205、1210、1605、1610等这些说法，然后前两位是直径，后两位表示导程，导程 05的丝杆就是每两个丝的间距为 5（单位：mm）。\n2. 以常规的步进电机 1.8度 200步进，那么走一圈就是 200 * 1.8 = 360度\n3. 假设驱动器是 8细分，那就是把 1.8度再分成 8份；所以经过驱动器的电机每一步进就是 1.8度 / 8 = 0.225度；最终在 8细分下每转一圈就是 200 * 8 = 1600步进。\n4. 当导程为 5的丝杠，则每转一圈走 5毫米，每一步进就是 5 / 1600 = 0.003125毫米，这就是**电机参数**。如果是导程为 3的参数，那就是 0.001875毫米，以次类推。\n5. 用 1除以电机参数就是**脉冲当量**，例如: 1 / 0.003125 = 320步进，就是每走 1毫米需要多少步进。\n\n## 常规公式\n\n$ 步进电机运行步数 = 运行位移 / 导程 * 360 / 步距角 * 细分数 $\n\n这是用步进电机接丝杆做驱动时用的，就是计算步进数的式子：各个变量如下：\n\n1. 步进电机运行步进数 —— 这是你要计算的（也可以说是脉冲的数量），\n2. 运行位移 / 导程 —— 这是位移和导程的关系，这个除出来，就是移动这一段距离螺杆需要转几圈。\n3. 360 / 步距角 —— 因为正常步进电机是一个脉冲转一个步距角，这个算出来就是多少步电机转一圈。例如：步距角 = 7.5度，这样算出来是 48，这就是 48步就走一圈。\n4. 细分数 —— 一般情况这个数值是 1，但是采用了细分的方式驱动，可以控制电机一步只转半个步距角，这时细分数就为 2。合在上面式子里就会算出 96步转一圈。\n5. 最后将 2、3、4 相乘。\n\n\n\n# 参考：\n\n[步进电机驱动器简介（上）——步进电机的特点、分类和工作原理](http://news.eeworld.com.cn/mp/TOSHIBA/a22212.jspx)\n\n[步进电机驱动器简介（下）——步进电机的控制驱动和安全技术](http://news.eeworld.com.cn/mp/TOSHIBA/a22342.jspx)\n\n[步进电机基础知识：类型、用途和工作原理](https://www.monolithicpower.cn/cn/stepper-motors-basics-types-uses)","tags":["history"]},{"title":"关于 FreeRTOS 和 newlib库共存问题","url":"/freertos-newlib-coexist/","content":"\n\n\n# 前言\n\nnewlib 的 strtod、sprintf、sscanf、snprintf、vsnprintf 这些函数都是非线程安全的，这些函数的行为和 keil \\ IAR 以及我们的认知并不一样，这些函数在使用 `%f` or `%lf` 来输出浮点时，会在申请一块 **3.5K** 左右的内存空间，该内存空间只申请一次，且不释放。作为全局内存使用。如果有多个线程同时调用 sprintf 来字符串化浮点数据，会有几率或较大几率导致系统死机（尤其是多个线程高密度的调用 sprintf 来输出浮点数据）。如果仅用来输出字符串或整形数据，则不会出该问题，即该问题仅局限于浮点数这一块。\n\n总而言之，sprintf、sscanf、snprintf、vsnprintf、sscanf 这些函数在不处理浮点数相关的时候还是线程安全的，一旦涉及到浮点数 `%f` or `%lf` 就会申请一块公共的内存空间(3.5KB)导致线程的不安全；而 strtod 以及 printf 是彻头彻底的线程不安全（printf 线程不安全是正常的，printf 在哪个编译链下都是线程不安全的；而 strtod、sprintf 等函数理论上都应该是线程安全的 https://manpages.courier-mta.org/htmlman3/strtod.3.html）。\n\n\n\n# 版本\n\n以下说明仅对于：\n\n1、FreeRTOS v9.0.0（https://github.com/FreeRTOS/FreeRTOS/tree/V9.0.0）\n\n2、GNU Arm Embedded Toolchain 10-2020-q4-major（https://launchpad.net/gcc-arm-embedded/10.0/10-2020-q4-major）内置的 newlib 库\n\n\n\n# FreeRTOS 对 newlib 的支持\n\n当我们使用 FreeRTOS 的同时，需要值得注意的是，必须要使我们的执行任务处于线程安全之中，否者将会容易出现数据访问异常；而对 newlib 库来讲，其本身是默认不带线程安全保护的（因其内部大多数调用了 `malloc()` 等内存分配函数），虽是这样，但 FreeRTOS 仍为其上下文管理提供支持，因此当我们在 `FreeRTOSconfig.h` 中添加：\n`#define configUSE_NEWLIB_REENTRANT 1 // newlib sprintf、strtok 等的线程安全需要...`，那么，在使用此选项时 FreeRTOS 将执行以下操作（在 `task.c` 中）：\n\n- 对于每个任务，在任务控制块 (TCB) 中分配并初始化一个 newlib 重入结构。\n- 每次任务切换，设置 `_impure_ptr` 指向新激活任务的可重入结构。\n- 在任务销毁时，清理重入结构（帮助 newlib 释放任何相关内存）。\n\n当然，newlib 支持是已经包含在 FreeRTOS 的普遍需求中了，但 FreeRTOS 维护者本身并未使用。FreeRTOS 是不负责由此产生的 newlib 操作的，因此用户必须熟悉 newlib，并且必须提供必要存根的系统级实现，即这部分还需要您的供应商提供内置 newlib中内存管理线程安全的支持，否者，就自己设计实现了一个系统级的内存管理线程安全（主要是 `malloc()` 等函数的可重入等问题）\n\n\n\n# 当在 FreeRTOS 中直接使用 newlib 库的 printf/sprintf/snprintf/vsprintf/vsnprintf 时出现的问题\n\n前面说了  newlib 库本身是默认不带线程安全保护，因此使得一些调用了 `malloc()` 函数的 API 函数线程不安全了，这样的结果往往就会导致出现 Hardfault 异常，因此也写了 [ARM Cortex-M3/M4/M7 Hardfault异常分析](https://arachnid.cc/cortex-m-abnormal/) 这篇笔记。嘛，摊牌了，是来填坑的。\n\n至于这种情况，网上出现很多这样的问题（本次碰到了，为了避免忘记，所以也记录一下吧）：\n\nFreeRTOS社区：\n\n[HardFault from printf - freertos 9.0.0 / stm32f0 / gcc-arm-eabi 7.2.0](https://forums.freertos.org/t/hardfault-from-printf-freertos-9-0-0-stm32f0-gcc-arm-eabi-7-2-0/7533)\n\n[How to make printf/sprintf/strtod thread safe](https://forums.freertos.org/t/how-to-make-printf-sprintf-strtod-thread-safe/7103)\n\n[How to catch code that caused the hard fault](https://forums.freertos.org/t/how-to-catch-code-that-caused-the-hard-fault/6687)\n\n[I/O Hardfault](https://forums.freertos.org/t/i-o-hardfault/9364)\n\nST社区：\n\n[HardFault Debug in STM32CubeIDE](https://community.st.com/s/question/0D50X0000BrC7hrSQC/hardfault-debug-in-stm32cubeide)\n\n[BUG: CubeMX FreeRTOS projects corrupt memory](https://community.st.com/s/question/0D50X0000BB1eL7SQJ/bug-cubemx-freertos-projects-corrupt-memory)\n\n注意：在 CubeMX 中生成的，对 newlib 库可重入函数 _sbrk() 的实现，需要干掉它（至少在我对它进行编译的时候，出现 Hardfault 异常的可能性更大）\n\nstackoverflow社区：\n\n[problem with sprint/printf with freeRTOS on stm32f7](https://stackoverflow.com/questions/64118480/problem-with-sprint-printf-with-freertos-on-stm32f7)\n\n\n\n附：newlib 可重入问题及外部接口定义\n\n[Reentrancy](https://sourceware.org/newlib/libc.html#Reentrancy)\n\n[Definitions for OS interface](https://sourceware.org/newlib/libc.html#Stubs)\n\n\n\n# 调用 printf/sprintf/snprintf/vsprintf/vsnprintf的线程安全处理\n\n在使用 printf/sprintf/snprintf/vsprintf/vsnprintf 等 newlib 库中的 I/O 输入输出 API 函数时，由于其调用了 `malloc()` 函数等问题，导致整个任务线程处于非安全状态，然而对于一些任意内部使用 malloc 系列或依赖于特定于线程的可重入上下文的库，您往往无能为力，因为您并没用这么大的精力去主动对 `malloc()` 等函数进行加锁保护。那么不如考虑一下大佬提供的如下操作：\n\nhttps://nadler.com/embedded/newlibAndFreeRTOS.html\n\nhttps://nadler.com/embedded/NXP_newlibAndFreeRTOS.html\n\nhttps://github.com/DRNadler/FreeRTOS_helpers\n\n\n\n# newlib 下 memcpy/memset 函数可能导致的死机问题\n\n在newlib 下面的 memcpy 以及 memset 等函数是不考虑字节对齐问题的，这可能会导致指针地址为非字节对齐时直接死机。\n\n详见：https://github.com/lvgl/lvgl/issues/2790#issuecomment-980481374","tags":["history","FreeRTOS"]},{"title":"Kicad 应用总结","url":"/kicad-summary/","content":"\n\n\n> 在当前这个时代，对于 PCB设计，有太多的 EDA设计软件了，如：Cadence、PADS、Altium等，但绝大多数是要授权的，而且如今人们版权意识正在提高；这对电子爱好者来说，要想 DIY一个好东西，免不了依赖于这些设计软件，但如果有开源的、顺手的软件，那么我们更倾于应用这些软件，毕竟从版权意识上看以及投向开源社区来讲都是好的。\n\n\n\n## 简介\n\nKiCad 是一个开源软件工具，用于设计电子原理图和 PCB 图形。 \n\n其官网地址：https://www.kicad.org/\n\n各操作文档说明：https://docs.kicad.org/\n\n由于 KiCad 是一个开源软件，所以我们可以获取到它的源码：https://github.com/KiCad/kicad-source-mirror\n\n当然，基于开源，它实现了跨平台：\n\n![image-20210814170409099](image-20210814170409099.png)\n\n\n\n然后在正式开篇之前，以下这些说明都是基于 V5.1.9版本（最新版为 V5.1.10，修正了部分 Bug）；该死 V6.0版本居然还没发布，对于想要了解 V6.0版本的一些升级功能的，可以移到 [KiCad 6 is coming!](https://techexplorations.com/blog/kicad/kicad-6-review-new-and-improved-features/#t-1611031599240)\n\n<br/>\n\n## 入门\n\n### 工作流程\n\nKicad有着其独特的工作流程：\n\n![kicad_flowchart](kicad_flowchart.png)\n\n设计一个 PCB板，主要由两个任务来完成：绘制原理图和布置电路板。\n\n### 文件说明\n\nKiCad在创建并使用时具有以下特定扩展名文件和文件夹，其主要用于原理图和电路板编辑。\n\n1. 项目管理文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | :----------------------------------------------------------- |\n   | *.pro      | Small file containing a few parameters for the current project, including the component library list. |\n\n2. 原理图编辑器文件\n\n   | 文件扩展名    | 描述                                                         |\n   | ------------- | :----------------------------------------------------------- |\n   | *.sch         | Schematic files, which do not contain the components themselves. |\n   | *.lib         | Schematic component library files, containing the component descriptions: graphic shape, pins, fields. |\n   | *.dcm         | Schematic component library documentation, containing some component descriptions: comments, keywords, reference to data sheets. |\n   | *_cache.lib   | Schematic component library cache file, containing a copy of the components used in the schematic project. |\n   | sym-lib-table | Symbol library list (symbol library table): list of symbol libraries available in the schematic editor. |\n\n3. 制板编辑文件和文件夹\n\n   | 文件扩展名   | 描述                                                         |\n   | ------------ | :----------------------------------------------------------- |\n   | *.kicad_pcb  | Board file containing all info but the page layout.          |\n   | *.pretty     | Footprint library folders. The folder itself is the library. |\n   | *.kicad_mod  | Footprint files, containing one footprint description each.  |\n   | *.brd        | Board file in the legacy format. Can be read, but not written, by the current board editor. |\n   | *.mod        | Footprint library in the legacy format. Can be read by the footprint or the board editor, but not written. |\n   | fp-lib-table | Footprint library list (footprint library table): list of footprint libraries (various formats) which are loaded by the board or the footprint editor or CvPcb. |\n\n4. 通用文件\n\n   | 文件扩展名  | 描述                                                         |\n   | ----------- | :----------------------------------------------------------- |\n   | *.kicad_wks | Page layout description files, for people who want a worksheet with a custom look. |\n   | *.net       | Netlist file created by the schematic, and read by the board editor. This file is associated to the .cmp file, for users who prefer a separate file for the component/footprint association. |\n\n5. 特殊文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | *.cmp      | Association between components used in the schematic and their footprints. It can be created by Pcbnew and imported by Eeschema. Its purpose is to import changes from Pcbnew to Eeschema, for users who change footprints inside Pcbnew (for instance using Exchange Footprints command) and want to import these changes in schematic. |\n\n6. 其他文件\n\n   主要是生产生成文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | *.gbr      | Gerber files, for fabrication.                               |\n   | *.drl      | Drill files (Excellon format), for fabrication.              |\n   | *.pos      | Position files (ASCII format), for automatic insertion machines. |\n   | *.rpt      | Report files (ASCII format), for documentation.              |\n   | *.ps       | Plot files (Postscript), for documentation.                  |\n   | *.pdf      | Plot files (PDF format), for documentation.                  |\n   | *.svg      | Plot files (SVG format), for documentation.                  |\n   | *.dxf      | Plot files (DXF format), for documentation.                  |\n   | *.plt      | Plot files (HPGL format), for documentation.                 |\n\n<br/>\n\n## 常用快捷键\n\n首先说明一下，热键（即单个按键）直接用字母表示；组合键（是指先按住第一个键不放，然后按下第二个键，再放开这两个键。）则用 “ + ” 表示；多次按键（是指先按下第一个键并放开，然后按下第二个键并放开，以此类推。）则用 “ - ” 表示。\n\n### 常规\n\n| 快捷键           | 功能     |\n| ---------------- | -------- |\n| Ctrl + N         | 新建     |\n| Ctrl + O         | 打开     |\n| Ctrl + S         | 保存     |\n| Ctrl + Shift + S | 另存为   |\n| Ctrl + Z         | 撤销     |\n| Ctrl + Y         | 重做     |\n| Ctrl + X         | 剪切     |\n| Ctrl + C         | 复制     |\n| Ctrl + V         | 粘贴     |\n| Ctrl + F         | 查找     |\n| F1               | 放大     |\n| F2               | 缩小     |\n| F3               | 缩放重绘 |\n| F4               | 缩放中心 |\n| Home             | 适合屏幕 |\n| E                | 编辑     |\n\n### 原理图\n\n| 快捷键   | 功能                 |\n| -------- | -------------------- |\n| C        | 重复的器件符号或标签 |\n| R        | 旋转                 |\n| M        | 移动                 |\n| A        | 添加器件符号         |\n| P        | 添加电源符号         |\n| X        | X轴镜像              |\n| Y        | Y轴镜像              |\n| W        | 画线                 |\n| B        | 放置总线             |\n| L        | 添加标签             |\n| H        | 添加分层标签         |\n| Ctrl + L | 添加全局标签         |\n| J        | 添加连接点           |\n| Q        | 添加禁止连接标志     |\n| F8       | 更新到 PCB           |\n\n### PCB\n\n| 快捷键           | 功能                                             |\n| ---------------- | ------------------------------------------------ |\n| O                | 放置封装                                         |\n| D                | 保持角度拖动布线                                 |\n| X                | 布线                                             |\n| Q                | 编辑线宽/过孔尺寸                                |\n| L                | 锁定/解锁封装                                    |\n| V                | 常规状态下，切换层；布线状态下，放置过孔并切换层 |\n| N / Shift + N    | 切换网格大小                                     |\n| Ctrl + H         | 板层高对比模式（单层显示）                       |\n| W / Shift + W    | 切换线宽                                         |\n| Ctrl             | 保持角度                                         |\n| /                | 布线轨迹切换                                     |\n| B                | 填充所有铜层区域                                 |\n| Ctrl + Shift + M | 测量                                             |\n| Alt + 6          | 差分布线                                         |\n| G                | 调整铜层区域                                     |\n\n### 库封装\n\n| 快捷键  | 功能     |\n| ------- | -------- |\n| M       | 移动     |\n| X       | X轴镜像  |\n| Y       | Y轴镜像  |\n| Instert | 重复引脚 |\n\n<br/>\n\n## 常用插件\n\n### 主题配色\n\n地址链接：https://github.com/pointhi/kicad-color-schemes\n\n例如笔者当前的主题配色为（**behave-dark**）：\n\n![eeschema](eeschema.png)\n\n![pcbnew](pcbnew.png)\n\n### 动态 BOM\n\n吾称之为最硬合交互式 BOM操作：\n\n![Interactive HTML BOM](capture.gif)\n\n地址链接：https://github.com/openscopeproject/InteractiveHtmlBom\n\n### 泪滴生成\n\n地址链接：https://github.com/NilujePerchut/kicad_scripts\n\n泪滴的作用，这里就不说啦，以前有讲过，然后演示：\n\n焊盘：\n\n![image-20210814210020179](image-20210814210020179.png)\n\n通孔：\n\n![image-20210814211109805](image-20210814211109805.png)\n\n<br/>\n\n## Pcbnew中各层用途说明\n\n### 所支持的板层\n\nKiCAD在 Pcbnew中总计提供了 32个铜层供导线走线（可覆铜），12个固定技术层（按照正反面分为 6对），2个独立技术层，4个辅助层。\n\n在 KiCad里 Pcbnew的层描述中：\n\n- F.代表电路板上层（Front），B.代表电路板的下层（Back）；\n\n- 6对固定技术层：Adhesive、Solder Paste、Silk Screen、Solder Mask、Courtyard、Fabrication；\n\n- 2个独立技术层：Edge Cuts、Margin；\n\n- 4个辅助层：Comments、E.C.O. 1、E.C.O. 2、Drawings；\n\n![image-20210814212055614](image-20210814212055614.png)\n\n### 层的使用说明\n\n#### 固定技术层\n\nKiCad中12个技术层分为 6对：上层一个，下层一个。可以通过 F.或者 B.来区分它们的位置。\n\n| 技术层名称                                | 功能描述                                                     |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| Adhesive (F.Adhes and B.Adhes) 粘合层     | 用于在波峰焊前将 SMD元件的粘合剂粘贴到电路板上的粘合层。     |\n| Solder Paste (F.Paste and B.Paste) 焊膏层 | 用于在回流焊接之前生产掩模以允许焊膏放置在 SMD元件的焊盘上；通常这些层只有表面安装元件的焊盘。 |\n| Silk Screen (F.SilkS and B.SilkS) 丝印层  | 主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。   |\n| Solder Mask (F.Mask and B.Mask) 阻焊层    | 这两个层定义了焊接的掩模，即不过绿油的区域；所有焊盘都要出现在这两个层的其中一个层（SMD元件）或者所有两个层（通孔元件）以防止焊盘被过油，影响导电。 |\n| Courtyard (F.CrtYd and B.CrtYd) 空间层    | 用于显示元件在 PCB上实际占用的空间大小。                     |\n| Fabrication (F.Fab and B.Fab) 制造层      | 用于辅助元件贴装；主要用于记录目的，以将信息传达给例如 PCB 制造商或组装厂。 |\n\n#### 独立技术层\n\n| 技术层名称        | 功能描述                                                     |\n| ----------------- | ------------------------------------------------------------ |\n| Edge.Cuts 边界层  | 用于绘制电路板轮廓。一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。所以请仅使用此图层绘制 PCB的轮廓。 |\n| Margin 电气边界层 | 用于定义在电路板上能够有效放置元件和布线的区域。             |\n\n#### 辅助层\n\n| 技术层名称            | 功能描述      |\n| --------------------- | ------------- |\n| E.C.O. 1/2 用户自定层 | 2层，用于拓展 |\n| Comments 注释层       | 描述性注释    |\n| Drawings 图层         | 图形说明      |\n\n这些层可以任意使用，它们可以是组装或布线等的说明文本，也可以是组装或加工的构造图，嘛，一般没啥用。\n\n#### 铜层\n\n该层在 Kicad中最多可拓展 32层。\n\n在 Pcbnew中任何铜层的名字都是可以编辑的，我们一般使用默认的名称。当电路板是 2层板时，只有 F.Cu层和 B.Cu层。当增加相应的层级数时，在 F.Cu层和 B.Cu层之间，将插入从上层到下层的顺序依次为 In1.Cu，In2.Cu，In3.Cu和 In4.Cu等的名称板层。\n\n1. 通常，电路板是 2层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | B.Cu   | GND Plane |\n\n2. 通常，电路板是 4层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | VCC Plane |\n   | 4      | B.Cu   | Signal    |\n\n3. 通常，电路板是 6层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | Signal    |\n   | 5      | In4.Cu | VCC Plane |\n   | 6      | B.Cu   | Signal    |\n\n4. 通常，电路板是 8层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | VCC Plane |\n   | 5      | In4.Cu | GND Plane |\n   | 6      | In5.Cu | Signal    |\n   | 7      | In6.Cu | VCC Plane |\n   | 8      | B.Cu   | Signal    |\n\n5. 通常，电路板是 10层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | Signal    |\n   | 5      | In4.Cu | VCC Plane |\n   | 6      | In5.Cu | GND Plane |\n   | 7      | In6.Cu | Signal    |\n   | 8      | In7.Cu | Signal    |\n   | 9      | In8.Cu | VCC Plane |\n   | 10     | B.Cu   | Signal    |\n\n<br/>\n\n## 生产制造\n\n在使用本操作时，假定您已经在 KiCad中完成了 PCB的设计。\n\n### 设置 PCB原点坐标\n\n选择 “菜单栏”，放置 -> 钻孔和位置偏移（或者在右边菜单栏直接选择），将原点放置到 PCB板框左下角位置，再放置【层对齐标记】到刚刚放置的原点位置。\n\n![image-20210814222049491](image-20210814222049491.png)\n\n### Gerber导出\n\n从菜单栏中点击绘制按键：\n\n![image-20210814220901206](image-20210814220901206.png)\n\n绘制 Gerber，并输出到相应文件夹：\n\n![image-20210814221059310](image-20210814221059310.png)\n\n绘制完后，点击旁边的 “生成钻孔文件” 进入设置生成：\n\n![image-20210814222350241](image-20210814222350241.png)\n\n生成文件放置到同样的文件夹，同时需要注意一下钻孔单位一般要对应 Pcbnew中所使用的单位。\n\n### BOM输出\n\n1. 从原理图输出\n\n   点击生成 BOM：\n\n   ![image-20210814230416366](image-20210814230416366.png)\n\n   选择生成插件：\n\n   ![image-20210814230521885](image-20210814230521885.png)\n\n   值得注意的是，在箭头处需要添加后缀 “**.csv**\"\n\n2. 从 PCB中输出\n\n   ![image-20210814231010230](image-20210814231010230.png)","tags":["history","EDA"]},{"title":"Cortex-M3/M4/M7 故障异常分析","url":"/cortex-m-abnormal/","content":"\n\n\n> 在程序开发阶段，少不了 Debug调试，除去编程架构搭建不稳定所造成的错误外，大部分会出现或多或少的故障异常，而这些异常有可能是粗心或者对编程了解不到位所导致的 ‘ 堆栈溢出 ’ 、‘ 数组下标越界 ’ 、‘ 数学运算异常 ’ 等等；而本篇则主要以常见的进入 Hardfault中断来进行分析错误来源。\n\n\n\n# ARM Cortex-M核心\n\n**ARM** 架构，过去称作**高级精简指令集机器**（英语：Advanced RISC Machine，更早称作艾康精简指令集机器，Acorn RISC Machine），是一个精简指令集（RISC）处理器架构家族，其广泛地使用在许多嵌入式系统设计。\n\n而对于 **ARM Cortex-M** 是 ARM架构处理器核心中，低阶系列的统称，由安谋控股所授权。这组核心的特点为低成本以及高能源效率的微处理器而优化设计，已有上千万个消费性设备中有此系列的微处理器。此系列核心包括 Cortex-M0、Cortex-M0+、Cortex-M1、Cortex-M3、Cortex-M4、Cortex-M7、Cortex-M23、Cortex-M33、Cortex-M35P和 Cortex-M55。其中 Cortex-M4 / M7 / M33 / M35P / M55 核心有浮点运算器的选项，若有浮点运算器的选项，会在型号后面说明，例如 Cortex-Mx with FPU或 Cortex-MxF，其中 x是核心编号。\n\n如标题所述，其中 Cortex-M3/M4/M7同属 **ARMv7-M**架构，再细分一点，Cortex-M3实现的是 **ARMv7-M**架构，Cortex-M4 /Cortex-M7实现的是 **ARMv7E-M**架构。\n\n\n\n# ARMv7-M和 ARMv7E-M架构区别\n\n如果有玩过过 Cortex-M3系列的芯片跟 Cortex-M4/M7的芯片，或多或少都知道 Cortex-M4/M7比 Cortex-M3多了 **DSP**跟**硬件浮点运算**，以下是 ARMv7E-M架构的拓展功能介绍：\n\n![image-20210717125804779](image-20210717125804779.png)\n\n由于 ARMv7E-M是 ARMv7-M的一个拓展子集，所以以下统称 **ARMv7-M**为 “ ARMv7-M ” 和 “ ARMv7E-M ” 的集合。\n\n\n\n# ARM 寄存器\n\n![image-20210717153032356](image-20210717153032356.png)\n\n## 通用寄存器（R0 - R12）\n\nR0-R7被称为低组寄存器。所有指令都能访问它们。它们的字长全是 32位，复位后的初始值是不可预料的。\n\nR8-R12被称为高组寄存器。这是因为只有很少的 16位 Thumb指令能访问它们，32位的 thumb-2指令则不受限制。它们也是 32位字长，且复位后的初始值是不可预料的。\n\n## 堆栈指针寄存器（SP）\n\n在 ARMv7-M架构中，共有两个堆栈指针 `SP_main` 和 `SP_process`，有时候也会把这个堆栈指针寄存器称为 **R13**。\n\n- 主堆栈指针（MSP），或写作 `SP_main`。这是缺省的堆栈指针，它由 OS内核、异常服务例程以及所有需要特权访问的应用程序代码来使用。\n- 进程堆栈指针（PSP），或写作 `SP_process`。用于常规的应用程序代码（不处于异常服用例程中时）。\n\n## 链接寄存器（LR）\n\n链接寄存器（LR） 主要用于在调用子程序时存储返回地址；有时候也会把这个链接寄存器称为 **R14**。\n\n## 程序计数器（PC）\n\n程序计数器作为 PC（或称为 R15）访问，它根据所执行指令的大小（在 ARM 状态下始终为 4 个字节）递增；并通过分支指令将目标地址加载到 PC 中。 您还可以使用数据处理指令直接加载 PC。\n\n\n\n**Note：** 寄存器 R0-R12、SP、LR和 PC被称为 Arm核心寄存器。这些寄存器可以描述为 R0-R15。更详细的说明可以看《ARMv7-M Architecture Reference Manual》B1.4章 Registers部分\n\n\n\n# 异常定义\n\n## 异常类型\n\n![image-20210717132436090](image-20210717132436090.png)\n\n## 异常更新\n\n在入栈和取向量操作完成之后，执行服务例程之前，需要更新一系列的寄存器：\n\n- SP：在入栈后会把堆栈指针（PSP或 MSP）更新到新的位置。在执行服务例程时，将由 MSP负责对堆栈的访问。\n- PSR：更新 IPSR位段（地处PSR的最低部分）的值为新响应的异常编号。\n- PC：在取向量完成后，PC将指向服务例程的入口地址，\n- LR：在出入 ISR的时候，LR的值将得到重新的诠释，这种特殊的值称为 “EXC_RETURN”，在异常进入时由系统计算并赋给 LR，并在异常返回时使用它。EXC_RETURN的二进制值除了最低 4位外全为 1，而其最低4位则有另外的含义。\n\n以上是在响应异常时核心寄存器的变化。另一方面，在 NVIC中，也会更新若干个相关有寄存器。例如，新响应异常的悬起位将被清除，同时其活动位将被置位。\n\n## 异常返回值\n\n在进入异常服务程序后，将自动更新 LR的值为特殊的 EXC_RETURN。这是一个高 28位全为 1的值，只有[3:0]的值有特殊含义，如下图所示。当异常服务例程把这个值送往 PC时，就会启动处理器的中断返回序列。因为 LR的值是由内核自动设置的，所以只要没有特殊需求，就不要改动它。\n\n![image-20210717203515783](image-20210717203515783.png)\n\n![image-20210717203628501](image-20210717203628501.png)\n\n\n\n# 异常入口的堆栈对齐\n\nArmv7-M 架构保证堆栈指针值至少是 4 字节对齐的。 但是，某些软件标准要求堆栈指针按 8 字节对齐，并且体系结构可以强制执行这种对齐。 在配置和控制寄存器的 CCR. STKALIGN 位指示中作为异常入口的一部分，决定着处理器是将 SP 对齐到 4 个字节还是 8 个字节。 该位是由编译器决定是否为：\n• RW，在这种情况下，它的复位值是由编译器决定的。\n• RO，在这种情况下它是 RAO，表示 8 字节 SP 对齐。\n**Arm 不赞成实现或使用 4 字节 SP 对齐。**\n\n\n\nRegister --- CCR. STKALIGN bit：\n\n![image-20210717172228588](image-20210717172228588.png)\n\n下图显示了在异常发生时进入堆栈的信息框架，以及处理器如何在堆栈上保留一个额外的字（如果需要的话），以获得 8字节堆栈对齐。（这里就是我们要分析地方）\n\n![image-20210717172649123](image-20210717172649123.png)\n\n\n\n# HardFault异常分析处理\n\nHardFault是一种通用故障，它适用于所有不能被任何其他异常机制处理的故障类。通常，HardFault用于不可恢复的系统故障，尽管这不是必需的，而且 HardFault的某些用途可能是可恢复的。HardFault永久启用，优先级固定为 -1。\n\n\n\n## 方法一：先来个简单的，使用第三方组件 “cm_backtrace”\n\n项目地址：https://github.com/armink/CmBacktrace\n\n怎么用这里就不说了，毕竟官方已经写得很清楚了，而且还有相应的 Demo例程。\n\n使用该方法的特点是不需要过多的关注更底层的东西，只需移植好后配置相应的功能就好了，而且它可以离线（脱离仿真器）来寻找错误点；但是前提是你的串口正常，而且还需要预留部分内存供其执行。\n\n## 方法二：仿真情况下的 bug寻找\n\n如果是平常的 while循环执行，导致挂掉了无法切换任务，那么我们可以轻松通过上下文切换寻找问题；但是在 HardFault异常中它并不给你显示执行错误的所在地方，而是直接跳到 HardFault中断中，这往往让我们头大。\n\nKeil平台的可以看：\n\nhttps://www.keil.com/appnotes/files/apnt209.pdf\n\nIAR平台的可以看：\n\nhttps://www.iar.com/knowledge/support/technical-notes/debugger/debugging-a-hardfault-on-cortex-m/\n\nGCC平台的可以看：\n\n方法三。。。\n\n## 方法三：通过 ARM 寄存器逆向推导 \n\n使用该方法的前提是获取到第五个大点最后一张图展示的核心寄存器（R0-R3、R12、LR、PC、xPSR以及原 SP）的数值。\n\n**1、常见的核心寄存器数据获取**\n\n一般地，我们会使用以下代码嵌入到 HardFault中断中，使其在入口处打印服务异常时各核心寄存器的值：\n\n```c\n/* Exception frame without floating-point storage\n* hard fault handler in C,\n* with stack frame location as input parameter\n*/\nvoid\nhard_fault_handler_c(unsigned int * hardfault_args)\n{\n    unsigned int stacked_r0;\n    unsigned int stacked_r1;\n    unsigned int stacked_r2;\n    unsigned int stacked_r3;\n    unsigned int stacked_r12;\n    unsigned int stacked_lr;\n    unsigned int stacked_pc;\n    unsigned int stacked_psr;\n   \n    //Exception stack frame\n    stacked_r0 = ((unsigned long) hardfault_args[0]);\n    stacked_r1 = ((unsigned long) hardfault_args[1]);\n    stacked_r2 = ((unsigned long) hardfault_args[2]);\n    stacked_r3 = ((unsigned long) hardfault_args[3]);\n   \n    stacked_r12 = ((unsigned long) hardfault_args[4]);\n    stacked_lr = ((unsigned long) hardfault_args[5]);\n    stacked_pc = ((unsigned long) hardfault_args[6]);\n    stacked_psr = ((unsigned long) hardfault_args[7]);\n   \n    printf (\"[Hard fault handler]\\n\");\n    printf (\"R0     = 0x%08X\\n\", stacked_r0);\n    printf (\"R1     = 0x%08X\\n\", stacked_r1);\n    printf (\"R2     = 0x%08X\\n\", stacked_r2);\n    printf (\"R3     = 0x%08X\\n\", stacked_r3);\n    printf (\"R12    = 0x%08X\\n\", stacked_r12);\n    printf (\"LR     = 0x%08X\\n\", stacked_lr);\n    printf (\"pre_LR = 0x%08X\\n\", stacked_lr - 4);\n    printf (\"PC     = 0x%08X\\n\", stacked_pc);\n    printf (\"PSR    = 0x%08X\\n\", stacked_psr);\n#ifndef CW\n    printf (\"CFSR =  0x%08X\\n\", (*((volatile unsigned long *)SCB->CFSR)));\n    printf (\"HFSR =  0x%08X\\n\", (*((volatile unsigned long *)SCB->HFSR)));\n    printf (\"DFSR =  0x%08X\\n\", (*((volatile unsigned long *)SCB->DFSR)));\n    printf (\"MMFAR = 0x%08X\\n\", (*((volatile unsigned long *)SCB->MMFAR)));\n    printf (\"BFAR =  0x%08X\\n\", (*((volatile unsigned long *)SCB->BFAR)));\n    printf (\"AFSR =  0x%08X\\n\", (*((volatile unsigned long *)SCB->AFSR)));\n#else\n    printf (\"CFSR =  0x%08X\\n\", (*((volatile unsigned int *)SCB->CFSR)));\n    printf (\"HFSR =  0x%08X\\n\", (*((volatile unsigned int *)SCB->HFSR)));\n    printf (\"DFSR =  0x%08X\\n\", (*((volatile unsigned int *)SCB->DFSR)));\n    printf (\"MMFAR = 0x%08X\\n\", (*((volatile unsigned int *)SCB->MMFAR)));\n    printf (\"BFAR =  0x%08X\\n\", (*((volatile unsigned int *)SCB->BFAR)));\n    printf (\"AFSR =  0x%08X\\n\", (*((volatile unsigned int *)SCB->AFSR)));\n#endif\n    for(;;)\n    {}\n}\n\n/* The prototype shows it is a naked function - in effect this is just an\nassembly function. */\nvoid HardFault_Handler( void ) __attribute__( ( naked ) );\n\n/* The fault handler implementation calls a function called\nprvGetRegistersFromStack(). */\nvoid HardFault_Handler(void)\n{\n  #ifdef CORTEX_M3_M4_M7\n    asm volatile(\n        \" tst lr, #4                        \\n\" /* Check EXC_RETURN[2] */\n        \" ite eq                            \\n\"\n        \" mrseq r0, msp                     \\n\"\n        \" mrsne r0, psp                     \\n\"\n        \"b hard_fault_handler_c             \\n\"\n        : /* no output */\n        : /* no input */\n        : \"r0\" /* clobber */\n    );\n  #else\n    asm volatile(\n        \"movs r0, #4                        \\n\"\n        \"mov  r1, lr                        \\n\"\n        \"tst  r0, r1                        \\n\" /* Check EXC_RETURN[2] */\n        \"beq 1f                             \\n\"\n        \"mrs r0, psp                        \\n\"\n        \"ldr r1,=hard_fault_handler_c       \\n\"\n        \"bx r1                              \\n\"\n        \"1:mrs r0,msp                       \\n\"\n        \"ldr r1,=hard_fault_handler_c       \\n\"\n        : /* no output */\n        : /* no input */\n        : \"r0\" /* clobber */\n    );\n  #endif\n}\n```\n\nNote：\n\n1. 值得注意的是 void HardFault_Handler(void);函数是相应的 HardFault中断函数，不同的厂家会定义不同的名称。\n\n2. 对于不同的编译器，如：armcc、iar、gcc for arm等，需要把相应的关键字替换掉（eg：`asm`、`naked`）。\n\n   `naked` 拓展：https://www.keil.com/support/man/docs/armclang_ref/armclang_ref_jhg1476893564298.htm\n\n   https://zhuanlan.zhihu.com/p/33933891\n\n**2、逆向定位入口**\n\n如果有看过方法二的两个链接，那么就很容易理解以下的分析了：\n\n1. 确保你能正常获取输出数据（包括但不限于仿真查看、串口打印、SWO输出、SEGGER_RTT输出等等）。\n2. 由于我们在第一点修改过代码，所以可以直接查看 LR和 PC两个的值；因为这两个的值是关键。\n3. 使用 addr2line软件定位故障代码位置（使用方法：https://sourceware.org/binutils/docs-2.27/binutils/addr2line.html#addr2line）\taddr2line属于 GNU Binutils组件之一，获取可以从方法一里面的 tools文件夹里获取，也可以从 `安装路径\\GNU Tools ARM Embedded\\5.4 2016q3\\bin\\arm-none-eabi-addr2line.exe` 提取出来。\n\n**3、使用演示**\n\n先制造一个 HardFault：\n\n```c\nvoid fault_test_by_div0(void) {\n    volatile int * SCB_CCR = (volatile int *) 0xE000ED14; // SCB->CCR\n    int x, y, z;\n\n    *SCB_CCR |= (1 << 4); /* bit4: DIV_0_TRP. */\n\n    x = 10;\n    y = 0;\n    z = x / y;\n    printf(\"z:%d\\n\", z);\n}\n\n/************************************************\n函数名称 ： main\n功    能 ： 主函数入口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nint main( void )\n{\n#ifdef DEBUG\n    debug();\n#endif\n\n    BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为 pdPASS */\n\n    prvSetupHardware();\n\n    fault_test_by_div0();\n\n    /* Start the tasks defined within this file/specific to this demo. */\n    xReturn = xTaskCreate( (TaskFunction_t)prvUser_Task,\t\t\t/* 任务入口函数 */\n                           (const char *)\"prvUser_Task\",\t\t\t/* 任务名字 */\n                           (uint16_t)configMINIMAL_STACK_SIZE,\t\t/* 任务栈大小 */\n                           (void *)NULL,\t\t\t\t\t\t\t/* 任务入口函数参数 */\n                           (UBaseType_t)mainCREATOR_TASK_PRIORITY,\t/* 任务的优先级 */\n                           (TaskHandle_t *)UserTaskCreate_Handle );\t/* 任务控制块指针 */\n\n    if(pdPASS == xReturn) {\n        /* Start the scheduler. */\n        vTaskStartScheduler();\n    }\n\n    /* Will only get here if there was not enough heap space to create the\n    idle task. */\n    return 0;\n}\n\n/*----------------------------- End -----------------------------*/\n```\n\n接着可以观察到程序已经跑到 HardFault_Handler里并输出相应信息了：\n\n![image-20210718160907873](image-20210718160907873.png)\n\n然后利用 addr2line，执行命令 `arm-none-eabi-addr2line.exe -e \"可执行映像\" -a -f \"相应的值\"` （注：实际命令并不需要双引号 `“ ”`，应用可看下图）：\n\n- `-e` ：指定可执行映像名称\n- `-a` ：显示函数地址\n- `-f` ：显示函数名称\n\n![image-20210718160622030](image-20210718160622030.png)\n\n然后，对于不同的编译器，可执行映像并不一样（像 Keil是 `.axf`、IAR是 `.out`）；最后，如果细心的可以看到命令后面的两个值只有 PC的值是对应上，第二个值并不是 LR的值，而是其减去 4的结果；若果你直接使用 LR值，你会发现定位出来的下一条指令要执行的地方，至于为什么要减掉 4，是因为在 ARM下执行指令的大小始终为 4 个字节递增，所以可以通过减掉 4，使其指向上一条内容。\n\n![image-20210718163058462](image-20210718163058462.png)\n\n![image-20210718163412930](image-20210718163412930.png)\n\n## 方法四：透过最底层进行分析\n\n这种方法不需要修改什么，在进入 HardFault_Handler后直接分析核心寄存器。\n\n同样的，还是先制造一个 HardFault，沿用方法三的 fault_test_by_div0();函数代码，然后直到进入 HardFault_Handler后，（注意，这里的 HardFault_Handler中断函数并没有像方法三那样区嵌入代码，而是保持其原始的样子）：\n\n![image-20210718204135298](image-20210718204135298.png)\n\n接着跟上面的一样，获取各核心寄存器的值（ps：这里用的仿真查看）：\n\n![image-20210718204626787](image-20210718204626787.png)\n\n在这里就不是像方法三那样直接拿 LR和 PC这两个值来用了，必须进行层层分析：\n\n1. 查看 LR值是对应下图的哪个：\n\n   ![image-20210718205017651](image-20210718205017651.png)\n\n   通过转换，-7为 0xFFFFFFF9，然后在第四大点的第三小点有讲过 LR=0xFFFF_FFF9时是使用 MSP，而 LR=0xFFFF_FFFD时则使用 PSP；所以我们可以确定该返回值是被压入到主堆栈指针（MSP）中。\n\n2. 找到 MSP指示的值：\n\n   ![image-20210718205953987](image-20210718205953987.png)\n\n   得到该值为 0x2002ffc8。\n\n3. 查看该值所对应的内存块：\n\n   ![image-20210718210515637](image-20210718210515637.png)\n\n   得到紫色框里的两个数据（嘿嘿，是不是很神奇，居然跟方法三的 LR、PC值一样），可能你会疑惑，为什么是提取该地址往后第六、七个数（4 字节递增），而不是其他呢？这就看第五个大点了，它的入栈顺序以及地址位置都是有规律的，可以归纳为下图：\n\n   ![image-20210718211434499](image-20210718211434499.png)\n\n   按箭头方向，顺数第六、七是不是就是 LR、PC值啊，而这里就是旧的内容信息；所以跟方法三比较一下，其实方法三的那段嵌入代码，就是让其改变各个核心寄存器的信息内容，使其不要存储跳转到 HardFault_Handler，而是存储跳转前的数据信息。\n\n4. 到了这步，就是使用 addr2line来定位，这里就不说了，方法三里面有写。\n\n\n\n# Usage-/Bus-/MemManage Fault\n\n一般情况，如果出现异常，常常会进入 HardFault 处理函数中，但除了上面定位发生错误的地址或函数外，无法对错误类型进行划分，这样对于解决问题还欠缺一点细节处理，那是否就真的只能这样无法细分了呢？答案是否的，在 ARM Cortex-M3/M4/M7 架构上，是存在一种错误异常再划分的处理的，它就是 `Usage faults`、`Bus faults` 和 `Memory management faults` ，当然还有 `Debug Fault` ，这个就不展开说明了，感兴趣可以自己看手册。\n\n对于这些细分出来的故障中断处理，系统默认是不打开，想要打开，必须操作 `SCB->SHCSR` 寄存器，关于该寄存器的定义如下：\n\n![image_2024-05-08_000949](image_2024-05-08_000949.png)\n\n因此，可以利用如下操作打开：\n\n```c\n/* SCB System Handler Control and State Register Definitions */\n#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */\n#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */\n\n#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */\n#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */\n\n#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */\n#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */\n\n\nSCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk\n            | SCB_SHCSR_BUSFAULTENA_Msk\n            | SCB_SHCSR_MEMFAULTENA_Msk;  // enable Usage-/Bus-/MemManage Fault\n```\n\n\n\n## Usage faults\n\nUsage Fault 异常可能由多种因素引起：\n\n- 执行未定义的指令（包括在禁用浮点单元时试图执行浮点指令）。\n\n- 协处理器指令的执行。Cortex® - m3 、 Cortex - m4 和 Cortex - m7 处理器不支持协处理器访问指令，但可以使用使用错误机制来模拟协处理器指令支持。\n\n- 尝试切换到 `ARM state`。经典的 ARM 处理器如 ARM7TDMI 同时支持 ARM 指令和 Thumb 指令集，而 Cortex-M 处理器只支持 Thumb 指令集。从经典 ARM 处理器移植过来的软件可能包含将处理器切换到 ARM state 的代码，软件可能会使用这个特性来测试它运行的处理器是否支持 ARM 代码。\n\n- 异常返回序列中的 `EXC_RETURN` 代码无效。例如，试图返回到线程级别，异常仍然活动（除了当前服务异常）。\n- 具有 multiple load 或 multiple store 指令的非对齐内存访问（包括 load double 和 store double）。\n\n- 当 SVC 的优先级等于或低于当前优先级时，执行 SVC。\n\n- 异常返回时在未堆叠的 xPSR 中带有中断可持续性指令(ICI) 位，但是在异常返回后执行的指令不是 multiple-load/store 指令。\n\n也可以通过设置配置控制寄存器(CCR) 产生下面两种 `Usage fault`：\n\n- 除法除以 0。\n- 访问任何不对齐的内存。\n\n对应寄存器字段：\n\n| Bits | Name       | Type | Reset Value | Description                                             |\n| ---- | ---------- | ---- | ----------- | ------------------------------------------------------- |\n| 9    | DIVBYZERO  | R/Wc | 0           | 表示除法运算时除数为零（只有在DIV_0_TRP置位时才会发生） |\n| 8    | UNALIGNED  | R/Wc | 0           | 未对齐访问导致的fault                                   |\n| 7:4  | -          | -    | -           | -                                                       |\n| 3    | NOCP       | R/Wc | 0           | 尝试执行协处理器指令                                    |\n| 2    | INVPC      | R/Wc | 0           | 在异常返回时试图非法地加载 `EXC_RETURN` 到 PC           |\n| 1    | INVSTATE   | R/Wc | 0           | 尝试切换到 `ARM state`                                  |\n| 0    | UNDEFINSTR | R/Wc | 0           | 尝试执行一个未定义的指令                                |\n\n然后对于其中断可以如下处理：\n\n```c\n/**\n  * @brief  This function handles Usage Fault exception.\n  * @param  None\n  * @retval None\n  */\nvoid UsageFault_Handler(void)\n{\n  #define UNDEFINSTR    (1 << 0)\n  #define INVSTATE      (1 << 1)\n  #define INVPC         (1 << 2)\n  #define NOCP          (1 << 3)\n  #define UNALIGNED     (1 << 8)\n  #define DIVBYZERO     (1 << 9)\n\n  /* Go to infinite loop when Usage Fault exception occurs */\n  printf (\"[UsageFault fault handler]\\n\");\n\n  printf (\"CFSR = 0x%08X\\n\", (*((volatile unsigned int *)SCB->CFSR)));\n  printf (\"UFSR = 0x%04X\\n\", ((*((volatile unsigned int *)SCB->CFSR)) >> 16) & 0xFFFF);\n\n  while (1)\n  {\n  }\n}\n```\n\n## Bus faults\n\nBus faults 可由存储器在访问期间从处理器总线接口接收的错误响应而触发。例如：\n\n- 指令预取阶段，通常称为 `prefetch abort` 。\n- 数据读/写阶段，通常称为 `data abort` 。\n\n此外，Bus faults 也可能发生在异常处理顺序的堆叠和解堆叠过程中：\n\n- 如果 Bus faults 发生在异常入口序列的堆栈 PUSH 期间，则称为 “入栈错误”。\n\n- 如果 Bus faults 发生在异常退出序列的堆栈 POP 期间，则称为 “出栈错误”。\n\n请注意，如果在向量获取时返回总线错误，则即使启用了 Bus faults 异常，也会激活 HardFault 异常。\n\n内存系统可以在下列情况下返回错误响应：\n\n- 处理器试图访问无效的内存位置。\n- 设备没有准备好接受传输（例如，试图访问 DRAM 而没有初始化 DRAM 控制器可能会触发总线错误。此行为是特定于设备的）。\n- 接收传输请求的总线从服务器返回一个错误响应。（例如，如果 bus slave 不支持传输类型/大小，或者 peripherals 确定执行的操作是不允许的，就可能发生这种情况）。\n\nBus faults 可分为以下两种：\n\n- 精确总线故障 --- 当内存访问指令被执行时，立即发生故障异常。\n\n- 不精确总线错误 --- 在内存访问指令执行后的某个时间发生的错误异常。\n\n对应寄存器字段：\n\n| Bits | Name        | Type | Reset Value | Description                       |\n| ---- | ----------- | ---- | ----------- | --------------------------------- |\n| 7    | BFARVALID   | -    | 0           | 指示 BFAR 是否有效                |\n| 6:5  | -           | -    | -           | -                                 |\n| 4    | STKERR      | R/Wc | 0           | 入栈时发生错误                    |\n| 3    | UNSTKERR    | R/Wc | 0           | 出栈时发生错误                    |\n| 2    | IMPRECISERR | R/Wc | 0           | 不精确的数据访问违例（violation） |\n| 1    | PRECISERR   | R/Wc | 0           | 精确的数据访问违例                |\n| 0    | IBUSERR     | R/Wc | 0           | 取指时的访问违例                  |\n\n然后对于其中断可以如下处理：\n\n```c\n/**\n  * @brief  This function handles Bus Fault exception.\n  * @param  None\n  * @retval None\n  */\nvoid BusFault_Handler(void)\n{\n  #define IBUSERR       (1 << 0)\n  #define PRECISERR     (1 << 1)\n  #define IMPRECISERR   (1 << 2)\n  #define UNSTKERR      (1 << 3)\n  #define STKERR        (1 << 4)\n\n  /* Go to infinite loop when Bus Fault exception occurs */\n  printf (\"[Bus fault handler]\\n\");\n\n  printf (\"CFSR = 0x%08X\\n\", (*((volatile unsigned int *)SCB->CFSR)));\n  printf (\"BFSR = 0x%02X\\n\", ((*((volatile unsigned int *)SCB->CFSR)) >> 8) & 0xFF);\n  printf (\"BFAR = 0x%08X\\n\", (*((volatile unsigned int *)SCB->BFAR)));\n\n  while (1)\n  {\n  }\n}\n```\n\n## Memory management faults\n\nMemory management faults 可能由非法访问 MPU(内存保护单元 `Memory Protection Unit` )或某些非法访问（如执行某些不可执行的内存区域的代码）引起。常见的 MPU 错误如下：\n\n- 非特权状态下试图访问只有在特权下才能访问的内存区域。\n- 访问没有被任何 MPU 区域定义的内存位置（专用外围总线(PPB) 除外，它总是由特权代码访问）。\n- 写入被 MPU 定义为只读的内存位置。\n\n这些访问可以是程序执行期间的数据访问、程序读取或执行序列期间的堆栈操作。对于触发 MemManage fault 的指令获取，只有当失败的程序位置进入执行阶段时才会触发故障。\n\n异常序列期间栈操作触发 MemManage fault：\n\n- 如果 MemManage fault 发生在异常入口序列的堆栈 PUSH 期间，则称为 “入栈错误”。\n\n- 如果 MemManage fault 发生在异常退出序列的堆栈 POP 期间，则称为 “出栈错误”。\n\n对应寄存器字段：\n\n| Bits | Name      | Type | Reset Value | Description        |\n| ---- | --------- | ---- | ----------- | ------------------ |\n| 7    | MMARVALID | -    | 0           | 指示 MMAR 是否有效 |\n| 6:5  | -         | -    | -           | -                  |\n| 4    | MSTKERR   | R/Wc | 0           | 入栈时发生错误     |\n| 3    | MUNSTKERR | R/Wc | 0           | 出栈时发生错误     |\n| 2    | -         | -    | -           | -                  |\n| 1    | DACCVIOL  | R/Wc | 0           | 数据访问违例       |\n| 0    | IACCVIOL  | R/Wc | 0           | 取指访问违例       |\n\n然后对于其中断可以如下处理：\n\n```c\n/**\n  * @brief  This function handles Memory Manage exception.\n  * @param  None\n  * @retval None\n  */\nvoid MemManage_Handler(void)\n{\n  #define IACCVIOL      (1 << 0)\n  #define DACCVIOL      (1 << 1)\n  #define MUNSTKERR     (1 << 3)\n  #define MSTKERR       (1 << 4)\n\n  /* Go to infinite loop when Memory Manage exception occurs */\n  printf (\"[MemManage fault handler]\\n\");\n\n  printf (\"CFSR = 0x%08X\\n\", (*((volatile unsigned int *)SCB->CFSR)));\n  printf (\"MMFSR  = 0x%02X\\n\", (*((volatile unsigned int *)SCB->CFSR)) & 0xFF);\n  printf (\"MMFAR = 0x%08X\\n\", (*((volatile unsigned int *)SCB->MMFAR)));\n\n  while (1)\n  {\n  }\n}\n```\n\n## Hard Faults\n\n如果 `Usage faults`、`Bus faults` 和 `Memory management faults` 没有其对应的错误处理程序，都将产生一个 `Hard fault`。此外，它也会由在异常处理程序执行过程中读向量表( `vector fetch` )产生的 `Bus fault` 而引起。NVIC 中有一个硬件错误状态寄存器( `HFSR` , `Hard Fault Status Register`)，可用于确定错误是否由 `vector fetch` 引起。如果不是，则 `Hard fault` 的错误处理程序需要检查其他 `FSRs` 以确定 `Hard fault` 的原因。\n\n`HFSR` 寄存器与其它 `FSRs` 一样，错误状态可以通过写入 `1` 来清除，其字段如下：\n\n| Bits | Name      | Type | Reset Value | Description                                                  |\n| ---- | --------- | ---- | ----------- | ------------------------------------------------------------ |\n| 31   | DIVBYZERO | R/Wc | 0           | 指示错误是否由debug事件引起的                                |\n| 30   | FORCED    | R/Wc | 0           | 指示错误是否是由`Usage faults`、`Bus faults`和`Memory management faults`产生的 |\n| 29:2 | -         | -    | -           | -                                                            |\n| 1    | VECTBL    | R/Wc | 0           | 指示错误是由`vector fetch`引起的                             |\n| -    | -         | -    | -           | -                                                            |\n\n\n\n# 参考：\n\n[ARM架构](https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B)\n\n[ARM Cortex-M](https://zh.wikipedia.org/wiki/ARM_Cortex-M)\n\n[Arm® Cortex®-M4 in a nutshell](https://www.st.com/content/st_com/zh/arm-32-bit-microcontrollers/arm-cortex-m4.html)\n\n<<ARM Cortex-M3 权威指南>>\n\n[ARMv7-M Architecture Reference Manual](https://developer.arm.com/documentation/ddi0403/ee/?lang=en)\n\n[Overview of the ARM Architecture](https://www.keil.com/support/man/docs/armasm/armasm_dom1359731124840.htm)\n\n[error: Hard Fault Handler](https://community.arm.com/developer/ip-products/system/f/embedded-forum/4749/error-hard-fault-handler)\n\n[How to debug a HardFault on an ARM Cortex-M MCU](https://interrupt.memfault.com/blog/cortex-m-fault-debug)\n\n[Debugging a ARM Cortex-M Hard Fault](https://forums.freertos.org/t/debugging-a-arm-cortex-m-hard-fault/9873)\n\n[Analyzing HardFaults on Cortex-M CPU](https://www.segger.com/downloads/application-notes/AN00016)\n\n[ARM Cortex M3: Recovering from a Hard Fault](https://gist.github.com/hossboss/e1d0e51fdb99bc125aadac64f5d67f04)\n\n[Debug a HardFault](https://www.silabs.com/community/mcu/32-bit/knowledge-base.entry.html/2014/05/26/debug_a_hardfault-78gc)","tags":["history","MCU"]},{"title":"常用校验算法","url":"/check-algorithm/","content":"\n\n\n# 奇偶校验\n\n## 介绍\n\n**奇偶校验位**（英语：**parity bit**）或**校验比特**（英语：**check bit**）是一个表示给定位数的二进制数中1的个数是奇数还是偶数的二进制数。奇偶校验位是最简单的错误检测码。\n\n## 原理\n\n奇偶校验常见于串口数据收发，如其名，可分为奇校验和偶校验：\n\n- **奇校验：原始码流+校验位，其 “1” 的个数为奇数，则校验位为 “0”；若为偶数，则校验位为 “1”。**\n\n- **偶校验：原始码流+校验位，其 “1” 的个数为奇数，则校验位为 “1”；若为偶数，则校验位为 “0”。**\n\n奇校验是在每个字节后增加一个附加位，使得 “1” 的总数为奇数；而偶校验是在每个字节后增加一个附加位，使得 “1” 的总数为偶数。\n\neg：\n\n以**偶校验位**来说，如果一组给定数据位中1的个数是奇数，补一个bit为1，使得总的1的个数是偶数。例：0000001, 补一个bit为1, 0000001**1**。\n\n以**奇校验位**来说，如果给定一组数据位中1的个数是奇数，补一个bit为0，使得总的1的个数是奇数。例：0000001, 补一个bit为0, 0000001**0**。\n\n其原理是：假如采用奇校验，发送端发送的一个字符编码（含校验位）中，“1” 的个数一定为奇数个，在接收端对接收字符二进制位中的 “1” 的个数进行统计，若统计出 “1” 的个数为偶数个，则意味着传输过程中有 1位（或奇数位）发生差错。\n\n## 应用场景\n\n奇校验通常用于同步传输；偶校验常用于异步传输或低速传输。\n\n## 总结\n\n虽然这个校验应该算是校验算法中最简单的，可是它却有不足之处：\n\n如果数据传输过程只有奇数个码位变化，那么不管变化在哪我们都可以直接判断数据传输是错误的，但是一旦有偶数位发生了变化，或者出现移位情况，我们就无法检测到错误，该方法的校错率是 50%。\n\neg：\n\n奇校验 正确码流 `11000001`\n\n**错 1位** `11000011` 变成了偶数个 1，能检测出错误\n\n错 2位 `11001011` 变成了奇数个 1，检测不出错误\n\n出现移位 `11000010` 变成了奇数个 1，检测不出错误\n\n\n\n# 校验和\n\n## 介绍\n\n**校验和**（英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或时间（如计算机存储）所传送数据的完整性进行检查的一种简单方法。\n\n## 原理\n\n所谓校验和，就是将被校验数据进行 “累加”，并省略 “累加” 溢出的位，最终得到的 1个或多个字节的结果。这个 “累加”，可以是简单的整数加法校验，又或者是反码加法校验等等。\n\n一般常用的有：\n\n**A、整数加法校验和（Integer Addition Checksum）**\n\n其操作如加法运算一样，把数据值累加，最后省略高位。\n\n![image-20210506204818892](image-20210506204818892.png)\n\n在熟知其操作后，我们来看下误码率；假设传输数据以两个 bit为单位，进行传输两个两位数 `00b` 和 `00b` ，则该校验和为：00+00=00，那么在传输过程中其出现错码的数据有以下，那么来简单分析下本次校验出错的概率有多少：\n\n|         | 00b  | 01b  | 10b  | 11b  |\n| ------- | ---- | ---- | ---- | ---- |\n| **00b** | 00b  | 01b  | 10b  | 11b  |\n| **01b** | 01b  | 10b  | 11b  | 00b  |\n| **10b** | 10b  | 11b  | 00b  | 01b  |\n| **11b** | 11b  | 00b  | 01b  | 00b  |\n\n如上表所示，在传输两个两位数 `00b` 和 `00b` 时，会有其余三种组合相加校验和也是 00，所以有 3/16 的概率会校验出错的，约为 1/4；但当数据的位宽越大，校验出错概率越低。\n\n**B、反码加法校验和（One’s Complement Addition Checksum）**\n\n反码加法校验，实际就是先进行整数加法运算，然后将进位加回来。\n\n![image-20210506205712724](image-20210506205712724.png)\n\n该处理相对于上一个的整数加法校验，由于需要加上进位操作，所以校验出错概率比它低一点。\n\n## 补充\n\n由于有讲到 `One’s Complement`，所以在这里稍微说一下：one's-complement 和 two's-complement以及 one's complement sum和 two's complement sum。\n\n- **one's-complement 和 two's-complement**\n\n  前者表示：反码，高位为符号位；后者表示：补码，高位为符号位。\n\n  ![image-20210506210446251](image-20210506210446251.png)\n\n  参考：https://tutorialspoint.dev/computer-science/computer-organization-and-architecture/whats-difference-between-1s-complement-and-2s-complement\n\n- **one's complement sum和 two's complement sum**\n\n  前者表示：反码加法，需要加上进位；\n\n  ![image-20210506210955942](image-20210506210955942.png)\n\n  后者表示：补码加法，舍弃进位。\n\n  ![image-20210506210936345](image-20210506210936345.png)\n\n  参考：《Short description of the Internet checksum》\n\n\n\n# 纵向冗余校验（LRC）\n\n## 介绍\n\n纵向冗余校验（LRC）是一种从纵向通道上的特定比特串产生校验比特的错误检测方法；而最常用的是 **LRC-8**错误检验，除此之外，还有 **LRC-16**、 **LRC-32**，它们是逐字节的奇偶校验计算，通过将数据字的所有字节异或在一起，生成一个对应字节的校验数。下面以 LRC-8为说明。\n\n## 原理\n\n通过对数据拆分为单字节，并利用纵向排列，把对应的字节位异或计算，最终得到一个单字节校验数：\n\n![image-20220327112126895](image-20220327112126895.png)\n\n## 应用处理\n\n![image-20220327113147917](image-20220327113147917.png)\n\n然后，它有什么特点呢：\n\n- 可以检测垂直切片分析中所有奇数的比特错误\n- 无法检测垂直切片分析中偶数个比特的错误\n- 可以检测所有 1位错误或检测单个字节内的所有错误\n- 可以检测多个 2位错误，但并不是所有的 2位错误类型都可检测到\n\n所以，最终得到的是：在检测同一垂直切片分析中的任何 2位（bit）出现错误都是不可检测的。\n\n最后附一张到目前介绍为止的检测概率图：\n\n![image-20220327114446012](image-20220327114446012.png)\n\n\n\n# 循环冗余校验（CRC）\n\n## 介绍\n\n**循环冗余校验**（英语：**Cyclic redundancy check**，通称“**CRC**”）是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。\n\n## CRC多项式\n\n多项式的选择是 CRC算法实现中最重要的部分，所选择的多项式必须有最大的错误检测能力，同时保证总体的碰撞概率最小。多项式最重要的属性是它的长度，也就是最高非零系数的数值，因为它直接影响着计算的校验和的长度。\n\n最常用的多项式长度有\n\n- 9位（CRC-8）\n- 17位（CRC-16）\n- 33位（CRC-32）\n- 65位（CRC-64）\n\n在构建一个新的 CRC多项式或者改进现有的 CRC时，一个通用的数学原则是使用满足所有模运算不可分解多项式约束条件的多项式。\n\n- 这种情况下的不可分解是指多项式除了 1与它自身之外不能被任何其它的多项式整除。\n\n生成多项式的特性可以从算法的定义中推导出来：\n\n- 如果 CRC有多于一个的非零系数，那么 CRC能够检查出输入消息中的所有单数据位错误。\n- CRC可以用于检测短于 2k的输入消息中的所有双位错误，其中k是多项式的最长的不可分解部分的长度。\n- 如果多项式可以被 x+1整除，那么不存在可以被它整除的有奇数个非零系数的多项式。因此，它可以用来检测输入消息中的奇数个错误，就像奇偶校验函数那样。\n\n## 多项式与二进制数码\n\n假设一个多项式为 `G(x)=x^4+x^3+x+1`， 可转换为二进制数码 `11011b`。\n\n等式 `G(X)=x^4+x^3+x+1`，可以写成 `G(X) = 1*(X^4) + 1*(X^3) + 0*(X^2) + 1*(X^1) + 1*(X^0)`\n\n总结：有幂次就为 1，没有幂次就为 0，首尾一定要是 1， 所以 `G(x)=x^4+x^3+x+1`为 `11011b`。\n\n## CRC校验核心\n\n从上面可以看出，CRC校验中有两个关键点：\n\n- 一是要预先确定一个发送端和接收端都用来作为除数的二进制比特串（或多项式）；\n- 二是把原始帧与上面选定的除进行二进制除法运算，计算出 FCS。\n\n前者可以随机选择，也可按国际上通行的标准选择，但**最高位和最低位必须均为 “1”**，如在 IBM的 SDLC（同步数据链路控制）规程中使用的 CRC-16（也就是这个除数一共是17位）生成多项式 `G（x）= x^16 + x^15 + x^2 +1`（对应二进制比特串为：`11000000000000101b`）；而在 ISO HDLC（高级数据链路控制）规程、ITU的 SDLC、X.25、V.34、V.41、V.42等中使用 CCITT-16生成多项式 `G（x）= x^16 + x^15 + x^5 +1`（对应二进制比特串为：`11000000000100001b`）。\n\n## 校验原理\n\nCRC算法的是以GF(2)(2元素伽罗瓦域)多项式算术为数学基础的，原理看起来比较复杂、好难懂，但实际上它的主要特点和运算规则是很好理解的。\n\n在 CRC算法中，其运算法制使用 “模 2算术”运算。\n\n**A、模 2加减法运算**\n\n- 模 2加法运算：1+1=0，0+1=1，0+0=0，无进位，也无借位\n- 模 2减法运算：1-1=0，0-1=1，1-0=1，0-0=0，无进位，也无借位\n\n   显然，加和减是一样的效果(故在GF(2)多项式中一般不出现 \"-\" 号)，相当于二进制中的逻辑异或运算；也就是相互比较后，两者对应位相同则结果为 “0”，不同则结果为 “1”。\n\neg：\n\n多项式：`P1 = x^3 + x^2 + 1，P2 = x^3 + x^1 + 1，P1 + P2 = `\n\n```\n      x^3 + x^2       + 1\n  +   x^3       + x^1 + 1\n  ------------------------------\n            x^2 + x^1\n```\n二进制：`P1 = 1101，P2 = 1011，P1 + P2 = `\n\n```\n      1 1 0 1\n  +   1 0 1 1\n  --------------\n        1 1 0\n```\n\n**B、模 2乘法运算**\n\nGF(2)多项式乘法和一般多项式乘法基本一样，只是在各项相加的时候按模 2算术进行，同样的，无进位，也无借位。\n\neg：\n多项式：`P1 = x^3 + x^2 + 1，P2 = x^3 + x^1 + 1，P1 x P2 = `\n\n```\n  (x^3 + x^2 + 1) (x^3 + x^1 + 1)  \n  = (x^6 + x^4 + x^3\n    + x^5 + x^3 + x^2\n    + x^3 + x + 1)\n  = x^6 + x^5 + x^4 + x^3 + x^2 + x + 1\n```\n二进制：`P1 = 1101，P2 = 1011，P1 x P2 = `\n\n```\n          1 1 0 1\n x        1 0 1 1\n --------------------\n\t      1 1 0 1\n\t    1 1 0 1\n\t  0 0 0 0\n +  1 1 0 1     \n --------------------\n    1 1 1 1 1 1 1\n```\n**C、模 2除法运算**\n\n多项式：`P1 = x^5 + x^2 + 1，P2 = x^3 + x^2 + x^1，P1 / P2 = `\n\n```\n                                      x^2   x^1\n                   ----------------------------------\n x^3 + x^2 + x^1  ) x^5             + x^2       + 1\n                    x^5 + x^4 + x^3\n                   ----------------------------------\n                          x^4 + x^3 + x^2\n                          x^4 + x^3 + x^2\n                   ----------------------------------\n                                                  1                          \n```\n二进制：`P1 = 100101，P2 = 1110，P1 x P2 = `\n\n```\n                          1 1\n                   ---------------\n          1 1 1 0 ) 1 0 0 1 0 1\n                    1 1 1 0\n                   ---------------\n                      1 1 1 0\n                      1 1 1 0\n                   ---------------\n                              1         \n```\n\n\n 具体来说，CRC校验原理就是以下几个步骤：\n\n   （1）先选择（可以随机选择，也可按标准选择，具体在后面介绍）一个用于在接收端进行校验时，对接收的帧进行除法运算的除数（是二进制比较特串，通常是以多项方式表示，所以 CRC又称多项式编码方法，这个多项式也称之为“生成多项式”）。\n\n   （2）看所选定的除数二进制位数（假设为k位），然后在要发送的数据帧（假设为m位）后面加上 k-1位 “0”，然后以这个加了 k-1个 “0“的新帧（一共是 m+k-1位）以 “模 2除法”方式除以上面这个除数，所得到的余数（也是二进制的比特串）就是该帧的 CRC校验码，也称之为 FCS（帧校验序列）。但要注意的是，余数的位数一定要是比除数位数只能少一位，哪怕前面位是 0，甚至是全为 0（附带好整除时）也都不能省略。\n\n   （3）再把这个校验码附加在原数据帧（就是 m位的帧，注意不是在后面形成的 m+k-1位的帧）后面，构建一个新帧发送到接收端，最后在接收端再把这个新帧以 “模 2除法” 方式除以前面选择的除数，如果没有余数，则表明该帧在传输过程中没出错，否则出现了差错。\n\n![image-20210523204223295](image-20210523204223295.png)\n\n## 计算步骤\n\n假设以最常用的 CRC-16_MODBUS为例：\n\n（1）、预置 1个16位的寄存器值 0xFFFF，称此寄存器为CRC寄存器；\n\n（2）、把第一个 8位二进制数据（既通讯信息帧的第一个字节）与 16位的 CRC寄存器的低 8位相异或，把结果放于 CRC寄存器，高八位数据不变；\n\n（3）、把 CRC寄存器的内容右移一位（朝高位）用 0填补最高位，并检查右移后的移出位；\n\n（4）、如果移出位为 0则重复第 3步（再次右移一位）；如果移出位为1，那么将 CRC寄存器与一多项式（A001）进行异或；\n\n（5）、重复步骤 3和 4，直到右移 8次，这样整个 8位数据全部进行了处理；\n\n（6）、重复步骤 2到步骤 5，进行通讯信息帧下一个字节的处理；\n\n（7）、将该通讯信息帧所有字节按上述步骤计算完成后，得到的 16位CRC寄存器的高、低字节进行交换；\n\n（8）、最后得到的 CRC寄存器内容即为：CRC码。\n\n以上计算步骤中的多项式 A001是 8005按位颠倒后的结果。\n\n## CRC-16实现代码\n\n常用 CRC-16码表：\n\n| Algorithm         | Poly   | Init   | RefIn | RefOut | XorOut |\n| ----------------- | ------ | ------ | ----- | ------ | ------ |\n| CRC16_CCITT       | 0x1021 | 0x0000 | true  | true   | 0x0000 |\n| CRC16_CCITT_FALSE | 0x1021 | 0xFFFF | false | false  | 0x0000 |\n| CRC16_XMODEM      | 0x1021 | 0x0000 | false | false  | 0x0000 |\n| CRC16_X25         | 0x1021 | 0xFFFF | true  | true   | 0xFFFF |\n| CRC16_MODBUS      | 0x8005 | 0xFFFF | true  | true   | 0x0000 |\n| CRC16_IBM         | 0x8005 | 0x0000 | true  | true   | 0x0000 |\n| CRC16_MAXIM       | 0x8005 | 0x0000 | true  | true   | 0xFFFF |\n| CRC16_USB         | 0x8005 | 0xFFFF | true  | true   | 0xFFFF |\n\n这里只演示常用的 CRC-16的部分程序：\n\n![image-20210506233502474](image-20210506233502474.png)\n\n","tags":["history","算法"],"categories":["算法"]},{"title":"常用设备接口类型","url":"/device-Interface/","content":"\n\n\n# 8P8C（RJ45）\n\n**8P8C**，常被误称为 **RJ45**，嘛，现在已经被叫成 RJ45了，是以太网使用双绞线连接时常用的一种连接器插头。\n\n8P8C（8 position 8 contact）的意思是 8个位置（Position，指 8个凹槽）、8个触点（Contact，指 8个金属接点）。\n\n\n\n## TIA/EIA-568\n\n**1、接口**\n\n![](49657238ec115.png)\n\n**2、接线**\n\n1. 在 [T568A](https://zh.wikipedia.org/wiki/T568A)中，与之相连的8根线分别定义为：白绿、绿；白橙、蓝；白蓝、橙；白棕、棕。\n\n   T568A可以跟早期的 USOC向下兼容。\n\n![image-20210412211638963](image-20210412211638963.png)\n\n![](772331-20200825113857619-227066782.png)\n\n2. 在 [T568B](https://zh.wikipedia.org/wiki/T568B)中，与之相连的8根线分别定义为：白橙、橙；白绿、蓝；白蓝、绿；白棕、棕。其中橙白色和橙色组成一对[差分传输线](https://arachnid.cc/differential-transmission/)，绿白色和绿色组成一对差分传输线，蓝白色和蓝色组成一对差分传输线，棕白色和棕色组成一对差分传输线。\n\n![image-20210412211836739](image-20210412211836739.png)\n\n![](772331-20200825113935318-2084011331.png)\n\n\n\n## 参考\n\nhttps://zh.wikipedia.org/wiki/8P8C\n\nhttps://zh.wikipedia.org/wiki/TIA/EIA-568\n\n\n\n# D-Sub\n\n**D-sub**（全名：D-subminiature）是常见的[电子连接器](https://zh.wikipedia.org/wiki/电子连接器)，因其接头处D型的金属屏蔽层而得名，以往常用于电脑的电子连接器上。在刚开始发展使用D-sub时，D-sub是电脑系统中最小型的连接器之一，所以称作D-subminiature。\n\n按照接口数量细分为 A型（15针），B型（25针），C型（37针），D型（50针），E型（9针）。因此常见的计算机并口即为 DB25针的连接器。而串口则为 DE9针连接器。\n\n![](v2-1927cce92db750c4763425cba2f8eb26_720w.png)\n\n\n\n## DE-9（RS232/EIA232）\n\n**1、接口**\n\n![](v2-c3ce6da08a0efeacd0a473995858593e_r.jpg)\n\n**2、接线**\n\n![](08114701_96952.jpg)\n\n\n\n## DB-25（RS530/EIA530）\n\n**1、接口**\n\n![](db25_connector_pins.png)\n\n**2、接线**\n\n![image-20210412230409150](image-20210412230409150.png)\n\n![image-20210412230342219](image-20210412230342219.png)\n\n\n\n## DC-37（RS422/EIA422）\n\n**1、接口**\n\n![image-20210413210022102](image-20210413210022102.png)\n\n**2、接线**\n\n![](rs422.jpg)\n\n\n\n## 参考\n\nhttps://en.wikipedia.org/wiki/D-subminiature\n\nhttps://en.wikipedia.org/wiki/D-subminiature_(professional_audio)\n\nhttps://wiki.sound4.biz/index.php/RS232_and_GPIO_Connector\n\nhttps://en.wikipedia.org/wiki/Null_modem\n\nhttps://edac.net/products/db25-connector/169\n\nhttps://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%AB%AF%E5%8F%A3\n\nhttps://www.activexperts.com/serial-port-component/tutorials/pinout423/\n\nhttps://www.camiresearch.com/Data_Com_Basics/RS232_standard.html\n\n\n\n# USB\n\n**通用串行总线**（英语：**U**niversal **S**erial **B**us，缩写：**USB**）是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，被广泛地应用于个人电脑和移动设备等信息通讯产品，并扩展至摄影器材、数字电视（机顶盒）、游戏机等其它相关领域。\n\n最新一代的 USB是 USB4，传输速度为 40Gbit/s。物理接头 USB Type-A、Type-B接头分正反面，新型 USB Type-C接头不分正反。\n\n![image-20210413211810297](image-20210413211810297.png)\n\n![](usb%E6%8E%A5%E5%A4%B4.png)\n\n![image-20210413212814207](image-20210413212814207.png)\n\n\n\n## Mini USB/Micro USB\n\n**1、Mini USB接线**\n\n![image-20210413214649606](image-20210413214649606.png)\n\n**2、Micro USB接线**\n\n![image-20210413214724363](image-20210413214724363.png)\n\n\n\n## USB Type-A/USB Type-B\n\n![image-20210413215241947](image-20210413215241947.png)\n\n\n\n## USB Type-C\n\n**1、Male Connector接线**\n\n![](USB_Type-C_plug_pinout.png)\n\n**2、Female Connector接线**\n\n![](USB_Type-C_Receptacle_Pinout.png)\n\n## 参考\n\nhttps://zh.wikipedia.org/wiki/USB\n\nhttps://zh.wikipedia.org/wiki/USB_Type-C\n\nhttps://web.archive.org/web/20161220102924/http://www.usb.org/developers/presentations/USB_DevDays_Hong_Kong_2016_-_USB_Type-C.pdf\n\n\n\n# 更多接口类型\n\n地址：https://pinouts.ru/conn/","tags":["history"]},{"title":"差分传输及其应用","url":"/differential-transmission/","content":"\n\n\n# 差分信号跟单端信号\n\n**1、差分信号：**指在两根线上都传输信号，这两个信号的大小相等，极性相反，这两根线上传输的信号就是差分信号（差模信号），简单的说就是在同一时间段内，通过比较这两个电压的差值来判断逻辑状态 “0” 还是 “1” 。\n\n![](aIBZja.png)\n\n**2、单端信号：**也叫单端走线；即平常所看到的单一数据线进行传输，从物理角度来讲，其实并不是只有一条线，它是有参考点的，其参考点是地平面；实际是指用一根信号线和一根地线来传输信号。\n\n![](fMBNFr.png)\n\n**3、比较**：\n\n差分信号与传统的一根信号线一根地线（即单端信号传输）走线的做法相比，其优缺点分别是：\n\n优点：\n\n1. 抗干扰能力强。干扰噪声一般会等值、同时的被加载到两根信号线上，而其差值为0，即，噪声对信号的逻辑意义不产生影响。\n2. 能有效抑制电磁干扰（EMI）。由于两根线靠得很近且信号幅值相等，这两根线与地线之间的耦合电磁场的幅值也相等，同时他们的信号极性相反，其电磁场将相互抵消。因此对外界的电磁干扰也小。\n3. 时序定位准确。差分信号的接收端是两根线上的信号幅值之差发生正负跳变的点，作为判断逻辑 0/1跳变的点的。而普通单端信号以阈值电压作为信号逻辑 0/1的跳变点，受阈值电压与信号幅值电压之比的影响较大，不适合低幅度的信号。\n\n缺点：\n\n1. 若电路板的面积非常吃紧，单端信号可以只有一根信号线，地线走地平面，而差分信号一定要走两根等长、等宽、紧密靠近、且在同一层面的线。这样的情况常常发生在芯片的管脚间距很小，以至于只能穿过一根走线的情况下。\n\n\n\n总结：\n\n|      | 差分信号传输 | 单端信号传输 |\n| :--: | :----------: | :----------: |\n| 优点 | 抗干扰能力强 |   简单方便   |\n| 缺点 |   传输复杂   | 抗干扰能力差 |\n\n<br/>\n\n\n\n# 应用场景\n\n在电路板上，差分走线必须是等长、等宽、紧密靠近、且在同一层面的两根线。与之相关的还有一个蛇形走线，蛇形线是 Layout中经常使用的一类走线方式；其主要目的就是为了调节延时，满足系统时序设计要求。\n\n那么，差分线，一般应用在哪里呢？\n\n答：一般在 USB 、以太网、PCI-E、SATA、RS485、RS422、HDMI、LVDS、CAN这些会出现。\n\n**常用对表示方法有：+/- 、PM/PN 、TXN/TXP**\n\n\n\n## 1、USB总线\n\nUSB协议定义由两根差分信号线（D+、D-）传输数字信号，若要 USB设备工作稳定差分信号线就必须严格按照差分信号的规则来布局布线。\n\n![img](IC3J8E@T%7B4CDBT72%5DJOWK7.png)\n\n## 2、Ethernet（以太网）\n\n![image-20210303202439474](image-20210303202439474.png)\n\n早期的以太网，其传输速率只有几兆；像 ”1BASE5“ ─ ─ 也称为星型局域网，速率是 1Mbit/s，在商业上很失败，但同时也是双绞线的第一次使用。而一般用到双绞线的链路，基本上都是差分信号传输。\n\n## 3、RS485和 RS422\n\nRS485和 RS422同属 UART（通用异步收发传输器）类属性，它们只是接口不同。\n\nRS485和 RS422可以从以前的 [常用逻辑电平标准总结](https://arachnid.cc/logical-level/) 这篇可以了解到，它们的逻辑数据表示方式是以 AB两线间的电压差来决定其某一时间的逻辑状态\n\n## 4、CAN Bus\n\nCAN总线传输介质可以是双绞线，同轴电缆。CAN总线适用于大数据量短距离通信或者长距离小数据量，实时性要求比较高，多主多从或者各个节点平等的现场中使用；其通信距离最远可达 10KM(速率低于 5Kbps)速率可达到 1Mbps（通信距离小于40M）。\n\n可以通过之前的 [CAN总线（Controller Area Network bus）协议（一）](https://blog.csdn.net/qq_42992084/article/details/106579252) 文章去了解其拓扑和设计，就知道为什么使用双绞线差分传输了。\n\n## 5、PCI-E\n\n这个我们在电脑上见的多了，**PCI Express**，简称 **PCI-E**，官方简称 **PCIe**，是计算机总线的一个重要分支，它沿用现有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准；PCIe拥有更快的速率，所以几乎取代了以往所有的内部总线（包括[AGP和PCI）。\n\n要说为什么是差分信号传输呢，这是由于它需要那超高速的传输速率：\n\n![image-20210303210309134](image-20210303210309134.png)\n\n那么，我们可以想象，为什么它接口引线设计像下图这样：\n\n![](a4c259bceca04e789633c7ea964a02e6.jpeg)\n\n而不是像以下这样节省面积呢？\n\n![](50-pair-telephone-cable-500x500.jpg)\n\n嘛，这就是前面说的，差分信号一定要两根等长、等宽、紧密靠近，而且它还这么多对。。。\n\n![](image-20210303211303300.png)\n\n## 6、SATA\n\n跟上面的 PCI-E差不多，常见于计算机中，是一种电脑总线，负责主板和大容量存储装置（如[硬盘及光驱）之间的數據传输。\n\n![image-20210303212437783](image-20210303212437783.png)\n\n## 7、HDMI\n\n**HDMI**是一种全数字化影像和声音发送接口，可以发送未压缩的音频及视频信号。目前是被设计来取代较旧的模拟信号影音发送接口如 SCART或 RCA等端子的。\n\n![image-20210303213420508](image-20210303213420508.png)\n\n同样的也是高速率传输，而且从引脚定义上看：\n\n![image-20210303213538865](image-20210303213538865.png)\n\n嗯嗯，差分传输少不了了。\n\n## 8、LVDS\n\n**LVDS**全称 Low-Voltage Differential Signaling，即：低电压差分信号；如其名字，必是差分信号传输。\n\n它是一种电子信号系统，可满足现今对高性能资料传输应用的需求，同时系统供电电压减低到 2伏特，适用于分辨率高于 SVGA的 TFT LCD显示设备，目前已得到了广泛的应用，甚至可以嵌入到 FPGA、ASIC或其他组件身上。也可以从 [常用逻辑电平标准总结](https://arachnid.cc/logical-level/) 这里了解其产生的原因及 PCB常规要求。","tags":["history"]},{"title":"cJSON库 API解析（下）","url":"/cjson-api-next-part/","content":"\n\n\n> 继上一篇 [cJSON库 API解析（上）](https://arachnid.cc/cjson-api-first-part/)，本篇为下篇，以解析 JSON数据包为主\n\n\n\n# JSON数据解析\n\n在 cJSON里，解析 JSON数据包，其实就是通过搜寻对应的配对关键符号或者关键字，然后一个一个剥离成为链表节点(键值对)的过程。\n\n其所支持的解析函数有以下几个：\n\n- `CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);`\n\n但一般来说，平常我们只需要用到 cJSON_Parse();函数来解析。同样的，在调用了 parse函数后，使用完毕需要调用 cJSON_Delete();及时释放；\n\n整个解析过程，其核心操作函数为：\n\n```c\n/* Parser core - when encountering text, process appropriately. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item->type = cJSON_NULL;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item->type = cJSON_False;\n        input_buffer->offset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item->type = cJSON_True;\n        item->valueint = 1;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}\n```\n\n就像前面说的，通过搜寻对应的配对关键符号或者关键字去调用不同的处理函数，然后配对校验，并把相应的数据插入到根结点，形成一个个相连的子节点链表。\n\n\n\n# JSON数据获取\n\n当调用完上面的解析函数后，返回的是根结点指针，通过这个 cJSON的结构指针，我们就可以利用其解析后每个节点所对应的类型，快速寻找同类型的数据，再根据提供的键（名称）来获取数据。\n\n下面就来认识一下常用的 API函数：\n\n**1、类型校验：**\n\n- False：`CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);`\n\n- True：`CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);`\n\n- 布尔值：`CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);`\n\n- null：`CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);`\n\n- 数值：`CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);`\n\n- 字符串：`CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);`\n\n- 数组：`CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);`\n\n- 对象：`CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);`\n\n不难发现，这些函数都是用于判断参数的类型的，因此返回值只有 true（真）和 false（假）；用的比较多的是 cJSON_IsFalse();和 cJSON_IsTrue();，直接判断 JSON数据包里的布尔变量。\n\n**2、信息提取：**\n\n- 数组：`CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);`\n\n- 对象：`CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);`\n\n- 对象（名称区分大小写）：`CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);`\n\n**3、校验类型并返回值：**\n\n- 字符串：`CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);`\n\n- 数值：`CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);`\n\n**4、获取项目数：**\n\n- `CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);`\n\n**5、错误分析：**\n\n- `CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);`\n\n\n\n# 示例\n\n以上篇打印的封装的数据信息为例；\n\n原封装的 JSON数据包：\n\n```json\n{\n  \"name\": \"cJSON\",\n  \"version\": \"v1.7.14\",\n  \"file\": {\n    \"name\": \"cJSON.c\",\n    \"size\": 75.8,\n    \"unit\": \"KB\"\n  },\n  \"released\": [\n    2020,\n    \"Sep\",\n    3\n  ],\n  \"latest\": true\n}\n```\n\n随后解析打印出来的信息：\n\n```tex\nname:cJSON\nversion:v1.7.14\n\nfile:cJSON.c\nsize:75.800000\nunit:KB\n\nreleased date:2020 Sep 3\n\nIs it necessary to update?\nnot update\n```\n\n代码执行（沿用上篇的封装代码）：\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cJSON.h\"\n\n\nint main(int argc, char *argv[])\n{\n    cJSON *jtest = NULL;\n    cJSON *jfile = NULL;\n    cJSON *jissue = NULL;\n    cJSON *jyear = NULL;\n    cJSON *jmonth = NULL;\n    cJSON *jday = NULL;\n    char *str = NULL;\n\n    /* 创建一个 JSON格式的主对象(主链表头结点) */\n    jtest = cJSON_CreateObject();\n\n    /* 追加字符串类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddStringToObject(jtest, \"name\", \"cJSON\");\n    cJSON_AddStringToObject(jtest, \"version\", \"v1.7.14\");\n\n    /* 追加一个对象到主对象中(添加一个链表节点) */\n    jfile = cJSON_AddObjectToObject(jtest, \"file\");\n    /* 往追加的对象添加对应的值 */\n    cJSON_AddStringToObject(jfile, \"name\", \"cJSON.c\");\n    cJSON_AddNumberToObject(jfile, \"size\", 75.8);\n    cJSON_AddStringToObject(jfile, \"unit\", \"KB\");\n\n    /* 创建一个 JSON格式的数组(另一个链表头结点) */\n    jissue = cJSON_CreateArray();\n    /* 创建相应的值并把这些值添加到数组里 */\n    jyear = cJSON_CreateNumber(2020);\n    cJSON_AddItemToArray(jissue, jyear);\n    jmonth = cJSON_CreateString(\"Sep\");\n    cJSON_AddItemToArray(jissue, jmonth);\n    jday = cJSON_CreateNumber(3);\n    cJSON_AddItemToArray(jissue, jday);\n    /* 把已经填好的数据的数组插入到主对象中 */\n    cJSON_AddItemToObject(jtest, \"released\", jissue);\n\n    /* 追加一个值为 True的布尔类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddTrueToObject(jtest, \"latest\");\n\n    /* 打印 JSON对象(整条链表)的所有数据 */\n    str = cJSON_Print(jtest);\n    printf(\"%s\\n\\n\", str);\n    \n    /* 释放整条链表的内存数据 */\n    cJSON_Delete(jtest);\n\n/* ------------------------- 以上为上篇的封装代码 ------------------------- */\n\n\n/* ------------------------- 数据保留并初始化变量 ------------------------- */    \n    jtest = NULL;\n    jfile = NULL;\n    jissue = NULL;\n    jyear = NULL;\n    jmonth = NULL;\n    jday = NULL;\n    cJSON *jtemp = NULL;\n    \n/* ------------------------- 以下为本篇的解析代码 ------------------------- */\n\n    /* 解析整段 JSON数据 */\n    jtest = cJSON_Parse(str);\n    if (jtest == NULL)\n    {\n        printf(\"parse fail.\\n\");\n        return -1;\n    }\n\n    /* 依次根据名称提取 JSON数据（键值对） */\n    jtemp = cJSON_GetObjectItem(jtest, \"name\");\n    printf(\"name:%s\\n\", jtemp->valuestring);\n    jtemp = cJSON_GetObjectItem(jtest, \"version\");\n    printf(\"version:%s\\n\\n\", jtemp->valuestring);\n\n    /* 解析嵌套的 JSON对象 */\n    jfile = cJSON_GetObjectItem(jtest, \"file\");\n    jtemp = cJSON_GetObjectItem(jfile, \"name\");\n    printf(\"file:%s\\n\", jtemp->valuestring);\n    jtemp = cJSON_GetObjectItem(jfile, \"size\");\n    printf(\"size:%f\\n\", jtemp->valuedouble);\n    jtemp = cJSON_GetObjectItem(jfile, \"unit\");\n    printf(\"unit:%s\\n\\n\", jtemp->valuestring);\n\n    /* 解析嵌套的 JSON数组 */\n    jissue = cJSON_GetObjectItem(jtest, \"released\");\n    jyear = cJSON_GetArrayItem(jissue, 0);\n    jmonth = cJSON_GetArrayItem(jissue, 1);\n    jday = cJSON_GetArrayItem(jissue, 2);\n    printf(\"released date:%d \", jyear->valueint);\n    printf(\"%s \", jmonth->valuestring);\n    printf(\"%d\\n\\n\", jday->valueint);\n\n    /* 解析布尔型数据 */\n    printf(\"Is it necessary to update?\\n\");\n    jtemp = cJSON_GetObjectItem(jtest, \"latest\");\n    cJSON_IsTrue(jtemp) ? printf(\"not update\") : printf(\"update\");\n    /* 等同于 cJSON_IsFalse(jtemp) ? printf(\"update\") : printf(\"not update\"); */\n    printf(\"\\n\\r\");\n\n    cJSON_Delete(jtest);\n    \n    cJSON_free(str);\n\n    return 0;\n}\n```\n\n实例：\n\n![image-20210131224342050](image-20210131224342050.png)\n\n\n\n#  内存管理\n\n**1、cJSON_Delete();函数**\n\n```c\n/* Delete a cJSON structure. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}\n```\n\n通过上面的代码可以了解到，当调用 cJSON_Delete();函数后，会通过 while循环一直从当前节点删除释放其后面的节点，直至到尾部结点 null节点为止；因此，在应用中，一般都是传入主链表的头结点来释放整个 JSON数据包。\n\n**2、cJSON_Hooks里的钩子函数**\n\n在 cJSON项目里面，是留有 cJSON_InitHooks();外部引用内存管理函数的 API接口的，其原型：\n\n`CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);`\n\n通过结构体 struct cJSON_Hooks跟内部调用的内存分配挂钩，其 Hooks原型：\n\n```c\ntypedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;\n```\n\n一般情况是默认不调用 cJSON_InitHooks();函数的，因此，其内存分配管理处于默认状态，使用的是以下标准内存分配函数：\n\n```c\n#if defined(_MSC_VER)\n/* work around MSVC error C2322: '...' address of dllimport '...' is not static */\nstatic void * CJSON_CDECL internal_malloc(size_t size)\n{\n    return malloc(size);\n}\nstatic void CJSON_CDECL internal_free(void *pointer)\n{\n    free(pointer);\n}\nstatic void * CJSON_CDECL internal_realloc(void *pointer, size_t size)\n{\n    return realloc(pointer, size);\n}\n#else\n#define internal_malloc malloc\n#define internal_free free\n#define internal_realloc realloc\n#endif\n```\n\n如此一来，假设我们在系统上跑了 FreeRTOS（或者其他 RTOS），那么，在默认情况下，如果使用其标准内存分配函数，这样，对于多线程来讲是不安全的，所以，可以利用该函数重新把内存分配函数定义调用；例如在 FreeRTOS中：\n\n```c\ncJSON_Hooks cJSON_mem;\n\ncJSON_mem.malloc_fn = pvPortMalloc;\ncJSON_mem.free_fn = vPortFree;\ncJSON_InitHooks(&cJSON_mem);\n```\n\n通过该钩子函数，把 cJSON内部调用的内存分配处理，更换为线程安全的 pvPortMalloc();和 vPortFree();函数。\n\n**3、cJSON_malloc();和 cJSON_free();**\n\n其原型分别为：\n\n```c\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size);\nCJSON_PUBLIC(void) cJSON_free(void *object);\n```\n一般来说，cJSON_malloc();很少用，因为 cJSON的数据处理 API函数都默认会自动分配内存；而 cJSON_free();则更多的是用来 free cJSON格式化出来的数据（即调用 print类的 API接口）。\n\n","tags":["history","JSON"],"categories":["middleware"]},{"title":"cJSON库 API解析（上）","url":"/cjson-api-first-part/","content":"\n\n\n> cJSON项目可以说是一个很适合学习及应用 C语言中的链表的项目，刨析它的源码，你会惊叹它设计之巧妙，其代码为之简洁；同时，在嵌入式应用场景中也经常发现它的身影。\n>\n> 本系列分为上下两篇，其中上篇以应用分析其 JSON数据封装为主。\n\n\n\n# 介绍\n\n在认识 cJSON之前，先来认识一下 JSON：\n\n**JSON**（**J**ava**S**cript **O**bject **N**otation，JavaScript对象表示法，读作/ˈdʒeɪsən/）是一种由道格拉斯·克罗克福特构想和设计、轻量级的资料交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。JSON采用完全独立于语言的文本格式，但是也使用了类似于 C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使 JSON成为理想的数据交换语言。\n\n其官网：https://www.json.org/json-en.html\n\n而 cJSON，顾名思义就是一个使用 C 语言编写的 JSON 数据解析器，目前 cJSON 项目托管在 Github上，仓库地址如下：https://github.com/DaveGamble/cJSON；以前的旧版本则是存放在：https://sourceforge.net/projects/cjson/files/上面，但现已停止更新，继而转到 Github上了。\n\n\n\n# JSON语法\n\nJSON的基本数据类型：\n\n1. 对象（*object*）：若干无序的 “键值对” (key-value pairs)，其中键是数值或字符串，以花括号 `{` 开始，并以 `}` 结束。\n2. 数组 / 值的有序列表（array）：有序的零个或者多个值，使用方括号 `[ ]` 括起来。\n3. 字符串（*string*）：以双引号 `\" \"` 括起来的零个或多个 Unicode码位。支持反斜杠开始的转义字符序列。\n\n4. 数值（*number*）：不区分整数与浮点数。JavaScript用双精度浮点数 double表示所有数值。\n5. 布尔值（*boolean*）：表示为 `true` 或者 `false` 。\n6. null 类型：值写为 `null`\n\n\n\n1、JSON 对象是一个若干无序的 \"名称 /值\" 键值对的集合：\n\n- 以 \"`{`\" 开始，以 \"`}`\" 结束，允许嵌套使用；\n- 每个名称和值成对出现，名称和值之间使用 \"`:`\" 分隔；\n- 键值对之间用 \"`,`\" 分隔\n- 在这些字符前后允许存在无意义的空白符；\n\n\n\n2、JSON 数组是一个有序的零个或者多个值的序列表：\n\n- 以 \"`[`\" 开始，以 \"`]`\" 结束，允许嵌套使用；\n- 每个值可以为任意类型，可以是双引号括起来的字符串（*string*）、数值（*number*）、`true`、`false`、 `null`、对象（*object*）或者数组（*array*）；\n- 元素之间用 \"`,`\" 分隔\n- 在这些元素前后允许存在无意义的空白符；\n\n\n\n# cJSON结构\n\n在下载的 cJSON源码中，实际用到的文件只有两个（cJSON.c和 cJSON.h），因此 cJSON具有超轻便，可移植，单文件的特点。\n\n对于 cJSON文件，整个的数据结构就主要用到以下结构体：\n\n```c\n/* The cJSON structure: */\ntypedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;\n```\n\n从上面的代码可以看出，cJSON的设计思想是 --- 链表。\n\n然后我们分析一下各部分的成员信息：\n\n- `type`：用于表示该键值对中值的类型；\n- `valuestring`：如果键值类型 (type) 是字符串，则将该指针指向键值；\n- `valueint`：如果键值类型 (type) 是整数，则将该指针指向键值；\n- `valuedouble`：如果键值类型 (type) 是浮点数，则将该指针指向键值；\n- `String`：用于表示当前键值对的名称；\n\n还有两个 cJSON格式的结构体指针：\n\n- `next`：指向下一个键值对\n- `prev`：指向上一个键值对\n\n最后一个 cJSON格式的结构体指针：\n\n- `child`：该子指针指向当前数组 /对象中的节点\n\n\n\n如果是想要分析 cJSON它的代码设计，除开那两个承接上下节点的 `next` 和 `prev` 结构体指针，那么你还要重点关注上面说到 `type` 成员，它支持以下定义：\n\n> The type can be one of the following:\n>\n> - `cJSON_Invalid` (check with `cJSON_IsInvalid`): Represents an invalid item that doesn't contain any value. You automatically have this type if you set the item to all zero bytes.\n> - `cJSON_False` (check with `cJSON_IsFalse`): Represents a `false` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n> - `cJSON_True` (check with `cJSON_IsTrue`): Represents a `true` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n> - `cJSON_NULL` (check with `cJSON_IsNull`): Represents a `null` value.\n> - `cJSON_Number` (check with `cJSON_IsNumber`): Represents a number value. The value is stored as a double in `valuedouble` and also in `valueint`. If the number is outside of the range of an integer, `INT_MAX` or `INT_MIN` are used for `valueint`.\n> - `cJSON_String` (check with `cJSON_IsString`): Represents a string value. It is stored in the form of a zero terminated string in `valuestring`.\n> - `cJSON_Array` (check with `cJSON_IsArray`): Represent an array value. This is implemented by pointing `child` to a linked list of `cJSON` items that represent the values in the array. The elements are linked together using `next` and `prev`, where the first element has `prev.next == NULL` and the last element `next == NULL`.\n> - `cJSON_Object` (check with `cJSON_IsObject`): Represents an object value. Objects are stored same way as an array, the only difference is that the items in the object store their keys in `string`.\n> - `cJSON_Raw` (check with `cJSON_IsRaw`): Represents any kind of JSON that is stored as a zero terminated array of characters in `valuestring`. This can be used, for example, to avoid printing the same static JSON over and over again to save performance. cJSON will never create this type when parsing. Also note that cJSON doesn't check if it is valid JSON.\n>\n> Additionally there are the following two flags:\n>\n> - `cJSON_IsReference`: Specifies that the item that `child` points to and/or `valuestring` is not owned by this item, it is only a reference. So `cJSON_Delete` and other functions will only deallocate this item, not its `child`/`valuestring`.\n> - `cJSON_StringIsConst`: This means that `string` points to a constant string. This means that `cJSON_Delete` and other functions will not try to deallocate `string`.\n\n<br/>\n\n\n\n# JSON数据封装\n\n封装一个 JSON格式的数据包，其实就是创建链表和向链表中添加节点的过程。\n\n在 cJSON源码里面是存放着很多 API接口的，但是，一般来说我们并不是全部用到，而且有些函数是辅助函数，例如：\n\n```c\ncJSON *Info;\nInfo = cJSON_CreateObject();\ncJSON_AddStringToObject(Info, \"Nationality\", \"China\");\n\n/* 等价于 */\n\ncJSON *Info, *jtext;\nInfo = cJSON_CreateObject();\njtext = cJSON_CreateString(\"China\");\ncJSON_AddItemToObject(Info, \"Nationality\", jtext);\n```\n\n然后下面就分析一些常用的 API函数：\n\n**1、创建原始框架：**\n\n- 数组（等于创建了一个空的 `[ ]`）：`CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);`\n- 对象（等于创建了一个空的 `{ }`）：`CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);`\n\n**2、追加类型值：**\n\n- 数组：`CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);`\n\n- 对象：`CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);`\n\n**3、追加对应的值到对象中：**\n\n- null：`CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);`\n- True：`CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);`\n- False：`CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);`\n- 布尔值（实际为 True和 False合并）：`CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);`\n- 数值：`CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);`\n- 字符串：`CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);`\n- 对象：`CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);`\n- 数组：`CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);`\n\n**4、创建同一类型的值到数组中：**\n\n- 整形：`CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);`\n- 单精度：`CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);`\n- 双精度：`CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);`\n- 字符串：`CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);`\n\n**5、创建对应类型的值**\n\n- null：`CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);`\n- True：`CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);`\n- False：`CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);`\n- 布尔值：`CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);`\n- 数值：`CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);`\n- 字符串：`CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);`\n\n\n\n# 示例\n\n```json\n{\n  \"name\": \"cJSON\",\n  \"version\": \"v1.7.14\",\n  \"file\": {\n    \"name\": \"cJSON.c\",\n    \"size\": 75.8,\n    \"unit\": \"KB\"\n  },\n  \"released\": [\n    2020,\n    \"Sep\",\n    3\n  ],\n  \"latest\": true\n}\n```\n\n以打印输出上面为例，建立以下代码：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"cJSON.h\"\n\n\nint main( int argc, char *argv[] )\n{\n    cJSON *jtest = NULL;\n    cJSON *jfile = NULL;\n    cJSON *jissue = NULL;\n    cJSON *jyear = NULL;\n    cJSON *jmonth = NULL;\n    cJSON *jday = NULL;\n    char* str = NULL;\n\n    /* 创建一个 JSON格式的主对象(主链表头结点) */\n    jtest = cJSON_CreateObject();\n\n    /* 追加字符串类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddStringToObject(jtest, \"name\", \"cJSON\");\n    cJSON_AddStringToObject(jtest, \"version\", \"v1.7.14\");\n\n    /* 追加一个对象到主对象中(添加一个链表节点) */\n    jfile = cJSON_AddObjectToObject(jtest, \"file\");\n    /* 往追加的对象添加对应的值 */\n    cJSON_AddStringToObject(jfile, \"name\", \"cJSON.c\");\n    cJSON_AddNumberToObject(jfile, \"size\", 75.8);\n    cJSON_AddStringToObject(jfile, \"unit\", \"KB\");\n    \n    /* 创建一个 JSON格式的数组(另一个链表头结点) */\n    jissue = cJSON_CreateArray();\n    /* 创建相应的值并把这些值添加到数组里 */\n    jyear = cJSON_CreateNumber(2020);\n    cJSON_AddItemToArray(jissue, jyear);\n    jmonth = cJSON_CreateString(\"Sep\");\n    cJSON_AddItemToArray(jissue, jmonth);\n    jday = cJSON_CreateNumber(3);\n    cJSON_AddItemToArray(jissue, jday);\n    /* 把已经填好的数据的数组插入到主对象中 */\n    cJSON_AddItemToObject(jtest, \"released\", jissue);\n\n    /* 追加一个值为 True的布尔类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddTrueToObject(jtest, \"latest\");\n\n    /* 打印 JSON对象(整条链表)的所有数据 */\n    str = cJSON_Print(jtest);\n    printf(\"%s\\n\", str);\n\n    cJSON_free(str);\n    cJSON_Delete(jtest);\n\n    return 0;\n}\n```\n\n实例：\n\n![image-20210130174615600](image-20210130174615600.png)\n\n\n\n# 注意事项\n\n1、在调用了 create接口的数据，并且用完一个完整的 JSON格式包后，必须要使用 cJSON_Delete();释放内存，且不说不释放会造成泄露数据，在嵌入式中，内存容量可是很少的，很容易就耗完内存。\n\n2、cJSON_Delete();函数，并不是每调用一个 create接口，等用完都要一一对应释放，而是要释放主链表，简单的来说要处理的是头一个创建的数据类型，对于后期往其追加的数据，cJSON_Delete();函数会自动把插入进来的节点删除掉，这个在下篇再详细分析。\n\n3、cJSON里面的 Print接口格式化出来返回的数据，需要调用 cJSON_free();释放。cJSON的内存申请涉及到初始化钩子函数 cJSON_InitHooks();那里，这个也是下篇分析。","tags":["history","JSON"],"categories":["middleware"]},{"title":"FreeRTOS 篇章之任务通知","url":"/freertos-task-notify/","content":"\n\n\n# 任务通知的特性\n\n通过任务通知，无需单独的通信对象，任务就可以与其他任务进行交互，以及与 ISR 同步。通过使用任务通知，任务或 ISR 可以直接向接收任务发送事件。\n\n任务通知可以通过以下几种方式更新接收任务的通知值：\n\n- 直接设置而不用覆写接收任务的通知值。\n- 覆写接收任务的通知值。\n- 设置接收任务通知值的一个或多个 bit 位。\n- 增加接收任务的通知值。\n\n相对于使用中介对象发送到任务（这样的例子对象是队列，信号量，互斥对象和事件组）如下图：\n\n![img](20210124204637565.png)\n\n任务通知是一种将事件直接发送到任务的方法，而无需这样做中介对象：\n\n![img](20210124204803426.png)\n\n任务通知功能是可选的，要包含任务通知功能，请在 `FreeRTOSConfig.h` 中将 `configUSE_TASK_NOTIFICATIONS` 设置为 `1` 。\n\n当 `configUSE_TASK_NOTIFICATIONS` 设置为 `1` 时，每个任务都有一个通知状态（待处理或未在等待处理）和一个通知值（一个 32 位无符号整数）。当任务收到通知时，其通知状态将设置为待处理。当任务读取其通知值时，其通知状态将设置为未在等待处理。如果出于节省空间的考虑（每个任务可以节省 4 个字节），可以设置 `configUSE_TASK_NOTIFICATIONS` 为 `0` 来禁用。\n 任务可在 “被阻止” 状态中等待其通知状态变为待处理，还可以选择指定超时。\n\n\n\n# 存在的限制\n\n在以下情形中不能使用任务通知：\n\n- 向 ISR 发送事件或数据。\n\n  通信对象可供 ISR 和任务相互发送事件和数据。\n\n  任务通知可用于从 ISR 向任务发送事件和数据，但不能用于从任务向 ISR 发送事件或数据。\n\n- 启用多个接收任务。\n\n  通信对象可由任何知其句柄（可能是队列句柄、信号灯句柄或事件组句柄）的任务或 ISR 访问。任意数量的任务和 ISR 可处理发送到任何给定通信对象的事件或数据。\n\n  任务通知直接发送给接收任务，因此只能由接收通知的任务来处理。这在多数情况下并不是限制，因为尽管通常有多个任务和 ISR 向相同的通信对象发送事件或数据，但是很少有多个任务和 ISR 接收来自同一通信对象的事件或数据。\n\n- 缓冲多个数据项。\n\n  队列是一次可保存多个数据项的通信对象。已发送到队列但尚未从队列中接收的数据将在队列对象中缓冲。\n\n  任务通知通过更新接收任务的通知值向任务发送数据。任务的通知值一次只能保存一个值。\n\n- 广播到多个任务。\n\n  事件组是可用于一次向多个任务发送事件的通信对象。\n\n  任务通知直接发送给接收任务，因此只能由接收任务来处理。\n\n- 在 “被阻止” 状态中等待发送完成。\n\n  如果通信对象暂时处于无法向其中写入更多数据或事件的状态（例如，当队列已满、无法向该队列发送更多数据时），尝试向该对象写入内容的任务可以选择进入“被阻止”状态，以等待其写入操作完成。\n\n  如果一个任务尝试向已有待处理通知的另一个任务发送任务通知，则发送任务无法在 “被阻止” 状态中等待接收任务重置其通知状态。在大多数使用任务通知的情况下，这极少成为限制。\n\n\n\n# API函数\n\n任务通知使用 API 函数 `xTaskNotify() `或 `xTaskNotifyGive()` 来发送，这个通知将一直挂起直到接收任务使用API函数 `xTaskNotifyWait() `或 `ulTaskNotifyTake() `来接收通知。如果接收任务在通知到来时已经被阻塞，则会从阻塞态恢复，同时通知被清除。\n\n| 功能                   | API 接口                     | 实际执行函数                | 其它                       |\n| :--------------------- | :--------------------------- | :-------------------------- | :------------------------- |\n| 发送通知               | xTaskNotifyGive()            | xTaskGenericNotify()        | 没有通知值 （信号量类型）  |\n| 发送通知（用于中断中） | vTaskNotifyGiveFromISR()     |                             |                            |\n| 接收通知               | ulTaskNotifyTake()           |                             | 单独对应 xTaskNotifyGive() |\n| 发送通知               | xTaskNotify()                | xTaskGenericNotify()        | 带通知值                   |\n| 发送通知（用于中断中） | xTaskNotifyFromISR()         | xTaskGenericNotifyFromISR() |                            |\n| 发送通知               | xTaskNotifyAndQuery()        | xTaskGenericNotify()        | 带通知值，并且返回原通知值 |\n| 发送通知（用于中断中） | xTaskNotifyAndQueryFromISR() |                             |                            |\n| 接收通知               | xTaskNotifyWait()            |                             |                            |\n| 清除通知               | xTaskNotifyStateClear()      |                             |                            |\n\n在大多数情况下，并不需要 `xTaskNotify()` 和 `xTaskNotifyWait()` API 函数提供的灵活性。更简单的函数就足够了。`xTaskNotifyGive()` API 函数可替代 `xTaskNotify()` ，它更简单、但灵活性稍差。`ulTaskNotifyTake()` API 函数可替代 `xTaskNotifyWait()`，它更简单、但灵活性稍差。\n\n**1、xTaskNotifyGive() 和 vTaskNotifyGiveFromISR() API 函数**\n\n```c\nBaseType_t  xTaskNotifyGive( TaskHandle_t  xTaskToNotify );\n```\n\n```c\nvoid vTaskNotifyGiveFromISR( TaskHandle_t  xTaskToNotify,\n                             BaseType_t    *pxHigherPriorityTaskWoken );\n```\n\n传入参数：\n\n- **xTaskToNotify**：需要通知的任务句柄。这个句柄即是调用 `xTaskCreate()` 创建任务时传递的句柄。\n- **pxHigherPriorityTaskWoken**：如果调用 `vTaskNotifyGiveFromISR()` 发送通知导致被发送通知的任务离开阻塞状态，并且这个任务的优先级高于当前任务（也就是被中断的任务），那么 `xSemaphoreGiveFromISR()` 会在函数内部将 `*pxHigherPriorityTaskWoken` 设为 `pdTRUE` 。如果 `vTaskNotifyGiveFromISR()` 将此值设为 `pdTRUE` ，则在中断退出前应当进行一次上下文切换。\n\n返回参数（始终返回 pdPASS）：\n\n- **pdPASS**：发送成功。\n\n**2、ulTaskNotifyTake() API 函数**\n\n```c\nuint32_t  ulTaskNotifyTake( BaseType_t  xClearCountOnExit,\n                            TickType_t  xTicksToWait );\n```\n\n传入参数：\n\n- **xClearCountOnExit**：当设置为 `pdFALSE` ，则在函数退出时任务的通知值递减，这样，通知值就像一个计数信号量；如果是 `pdTRUE` ，那么当函数退出时，任务的通知值将被清除为零，这样，通知值就像一个二进制信号量。\n- **xTicksToWait**：阻塞超时时间。任务进入阻塞态以等待任务通知有效的最长时间。如果 `xTicksToWait` 为 `0` ，则 `ulTaskNotifyTake()` 在通知无效时会立即返回；如果把 `xTicksToWait` 设置为 `portMAX_DELAY` ，那么阻塞等待将没有超时限制。\n\n返回参数：\n\n- **uint32_t**：在任务的通知计数清空为零或递减之前的任务通知值。\n\n**3、xTaskNotify() 和 xTaskNotifyFromISR() API 函数**\n\n```c\nBaseType_t  xTaskNotify( TaskHandle_t  xTaskToNotify,\n                         uint32_t      ulValue,\n                         eNotifyAction  eAction );\n```\n\n```c\nBaseType_t  xTaskNotifyFromISR( TaskHandle_t   xTaskToNotify, \n                                uint32_t       ulValue, \n                                eNotifyAction  eAction, \n                                BaseType_t     *pxHigherPriorityTaskWoken );\n```\n\n传入参数：\n\n- **xTaskToNotify**：需要通知的任务句柄。这个句柄即是调用 `xTaskCreate()` 创建任务时传递的句柄。\n- **ulValue**：与通知一起发送的数据，如何使用 `ulValue` 取决于 `eNotifyAction` 值。\n- **eAction**：枚举类型，用于指定如何更新接收任务的通知值。\n\n| 枚举成员                  | 描述                                                         |\n| :------------------------ | :----------------------------------------------------------- |\n| eNoAction                 | 通知任务，而不更新其通知值；参数 ulValue 未使用。可用作更快速的二进制信号量轻型替代方案。始终返回 pdPASS。 |\n| eSetBits                  | 对被通知任务的通知值按位执行或运算。可用作更快速的事件组轻型替代方案。始终返回 pdPASS。 |\n| eIncrement                | 接收任务的通知值将递增。可用作更快速的计数信号量轻型替代方案。始终返回 pdPASS。 |\n| eSetValueWithOverwrite    | 即使任务尚未读取前一个值，也将任务的通知值设置为 ulValue 参数中传递的值。始终返回 pdPASS。 |\n| eSetValueWithoutOverwrite | 如果任务当前没有通知值，则设置任务的通知值并返回 pdPASS；如果任务没有取出前一个通知值，则不执行任何操作，将返回 pdFAIL。 |\n\n- **pxHigherPriorityTaskWoken**：如果调用 `xTaskNotifyFromISR()` 发送通知导致被发送通知的任务离开阻塞状态，并且这个任务的优先级高于当前任务(也就是被中断的任务)，那么 `xTaskNotifyFromISR()` 会在函数内部将 `*pxHigherPriorityTaskWoken` 设为 `pdTRUE` 。如果 `xTaskNotifyFromISR()` 将此值设为 `pdTRUE` ，则在中断退出前应当进行一次上下文切换。\n\n返回参数：\n\n- **BaseType_t**：取决于 `eAction` 的值。\n\n**4、xTaskNotifyWait() API函数**\n\n```c\nBaseType_t  xTaskNotifyWait( uint32_t    ulBitsToClearOnEntry, \n                             uint32_t    ulBitsToClearOnExit, \n                             uint32_t    *pulNotificationValue, \n                             TickType_t  xTicksToWait );\n```\n\n传入参数：\n\n- **ulBitsToClearOnEntry**：在使用通知之前，先将任务的通知值与参数 `ulBitsToClearOnEntry` 的按位取反值按位与操作。设置参数 `ulBitsToClearOnEntry` 为 `0xFFFFFFFF(ULONG_MAX)` ，表示清零任务通知值。\n- **ulBitsToClearOnExit**：在退出函数之前，将任务的通知值与参数 `ulBitsToClearOnExit` 的按位取反值按位与操作。设置参数 `ulBitsToClearOnExit` 为 `0xFFFFFFFF(ULONG_MAX)` ，表示清零任务通知值。\n- **pulNotificationValue**：用于向外回传任务的通知值。这个通知值在参数 `ulBitsToClearOnExit` 起作用前将通知值拷贝到 `*pulNotificationValue` 中。可选参数，如果不需要，可将其设置为 NULL。\n- **xTicksToWait**：阻塞超时时间。任务进入阻塞态以等待任务通知有效的最长时间。如果 `xTicksToWait` 为 `0` ，则 `xTaskNotifyWait()` 在通知无效时会立即返回；如果把 `xTicksToWait` 设置为 `portMAX_DELAY` ，那么阻塞等待将没有超时限制。\n\n返回参数：\n\n- **pdPASS**：接收成功。\n- **pdFAIL**：接收失败（超时）。\n\n\n\n# 应用\n\n**1、替代二值信号量(binary semaphore)**\n\n任务通知比二值信号量快 45% 并且内存占用更小\n\n- 发送处理：**`xTaskNotifyGive() `** 和 **`vTaskNotifyGiveFromISR()`** 用来代替 **`xSemaphoreGive()`** 和 **`xSemaphoreGiveFromISR()`** 。\n- 接收处理：**`ulTaskNotifyTake()`** 用来替代 **`xSemaphoreTake()`** （ps：`ulTaskNotifyTake()` 的第一个参数 `xClearCountOnExit` 应设置为 `pdTRUE` ）。\n\n**2、替代计数信号量(counting semaphore)**\n\n与替代二值信号量类似，当使用任务通知来代替计数信号量的时候，接收任务的通知值被用来代替计数信号量的计数值\n\n- 发送处理：**`xTaskNotifyGive()`** 和 **`vTaskNotifyGiveFromISR()`** 用来代替 **`xSemaphoreGive() `** 和 **`xSemaphoreGiveFromISR()`** 。\n- 接收处理：**`ulTaskNotifyTake()`** 用来替代 **`xSemaphoreTake()`** （ps：`ulTaskNotifyTake()` 的第一个参数 `xClearCountOnExit` 应设置为 `pdFALSE` ）。\n\n**3、替代事件组(event group)**\n\n当任务通知用来代替时间组的时候，通知值被用来代替事件组的任务值，通知值的每一位被用来代表某个标志\n\n- 发送处理：**`xTaskNotify()`** 和 **`xTaskNotifyFromISR()`** 用来代替 **`xEventGroupSetBits()`** 和 **`xEventGroupSetBitsFromISR()`** 。\n- 接收处理：**`xTaskNotifyWait()`** 用来代替 **`xEventGroupWaitBits()`** 。\n\n**4、替代邮箱队列(mailbox)**\n\nRTOS 任务通知只能用来发送数据到一个任务中，相比用队列实现，有一些限制：\n\n1. 只能发送 32-bit 数据。\n2. 保存的是接收任务的值，同一个时刻只能存在一个接收任务。\n\n因此，使用 “轻量邮箱” 这个短语代替 “轻量队列”。任务的通知值就是邮箱值\n\n- 发送处理：使用 **`xTaskNotify()`** 和 **`xTaskNotifyFromISR()`** 发送至任务，可以用来替换 **`xQueueOverwtite()`** 和 **`xQueueOverwtiteFromISR()`** 。\n- 接收处理：使用 **`xTaskNotifyWait()`** 来获取通知值，可以用来代替 **`xQueueReceive()`** 和 **`xQueuePeek()`** 。","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"MD5 算法","url":"/md5-algorithm/","content":"\n\n\n# 介绍\n\n**MD5消息摘要算法**，英文全称：Message-Digest 5 Algorithm，是一种被广泛使用的[密码散列函数](https://zh.wikipedia.org/wiki/密碼雜湊函數)，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。但是，很不幸，自 1996年后被证实存在弱点，可以被加以 “破解”；可由于这种算法的公开性和安全性，在 90年代被广泛使用在各种程序语言中，用以确保资料传递无误等，对于非严格的安全信息，还是值得推选的；同时也是哈希算法的一种。\n\nMD5算法的算法特点如下：\n\n（1）压缩性：任意长度的数据，算出的MD5值长度都是固定的。\n\n（2）容易计算：从原数据计算出MD5值很容易。\n\n（3）抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的 MD5值都有很大区别。\n\n（4）弱抗碰撞：已知原数据和其 MD5值，想找到一个具有相同 MD5值的数据（即伪造数据）是非常困难的。\n\n（5）强抗碰撞：想找到两个不同的数据，使它们具有相同的 MD5值，是非常困难的。\n\n具体介绍：https://en.wikipedia.org/wiki/MD5\n\n\n\n# 算法处理\n\nMD5是输入不定长度信息，输出固定长度128-bits的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits 散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。\n\n运算方式：\n\n![在这里插入图片描述](20210105205511203.png)\n\n\n图示：\n\n![在这里插入图片描述](20210105205537918.png)\n\n\n\n\n# 应用场景\n\n**1、文件校验**\n\n一般来说，我们比较熟悉的校验算法有奇偶校验和 CRC校验，这 2种校验并没有抗数据篡改的能力，它们一定程度上能检测并纠正数据传输中的信道误码，但却不能防止对数据的恶意破坏。\n\n而 MD5 Hash算法的 “数字指纹” 特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少 Unix系统有提供计算 md5 checksum的命令。\n\neg：\n\n![在这里插入图片描述](20210105205608753.png)\n\n\n![在这里插入图片描述](20210105205624425.png)\n\n\n**2、数字签名**\n\nHash算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash值，又称 “数字摘要” 进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。\n\neg：\n\n在互联网信息时代，假设你注册一个网站，如果网站后台直接将用户的原始口令存放到数据库中，会产生极大的安全风险：\n\n- 数据库管理员能够看到用户明文口令；\n- 数据库数据一旦泄漏，黑客即可获取用户明文口令。\n\n不存储用户的原始口令，那么如何对用户进行认证？\n\n方法是存储用户口令的哈希，例如，MD5。\n\n在用户输入原始口令后，系统计算用户输入的原始口令的 MD5并与数据库存储的 MD5对比，如果一致，说明口令正确，否则，口令错误。\n\n就好比：\n\n数据库存储用户名和口令的表内容应该像下面这样：\n\n| username      | password                         |\n| :------------ | :------------------------------- |\n| Administrator | 25d55ad283aa400af464c76d713c07ad |\n\n这样，你能看出来实际的密码吗？其实际的明文密码是：12345678。\n\n当然，前面也说了，目前 MD5算法已经被 \"破解\" 了，但是，注意这个 ”破解“ 一词，并不是真正的逆向计算破解，而是用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的 MD5恰好等于指定值。\n\n因此，也引出 “彩虹表” 一词。什么是彩虹表呢？对于暴力穷举，是会消耗大量的算力和时间的，即使当前计算机运算速度那么快，但在黑客眼里并不会做这么愚蠢的事，如果有一个预先计算好的常用口令和它们的 MD5的对照表（如下表），那么通过查表方式，时间上将大大减少，而这个表就叫做**彩虹表**：\n\n| 常用口令 | MD5                              |\n| :------- | :------------------------------- |\n| hello123 | f30aa7a662c728b7407c54ae6bfd27d1 |\n| 12345678 | 25d55ad283aa400af464c76d713c07ad |\n| passw0rd | bed128365216c019988915ed3add75fb |\n| 19700101 | 570da6d5277a646f6552b8832012f5dc |\n| …        | …                                |\n| 20201231 | 6879c0ae9117b50074ce0a0d4c843060 |\n\n这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。\n\n\n\n由于 MD5具有抗修改性，人们利用这一性质，可以采取相应的措施来抵御彩虹表攻击，方法就是对每个口令额外添加随机数，这个方法称之为加盐（salt）：\n\n```\ndigest = md5(salt + inputPassword)\n```\n\n加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从 MD5反推原始口令。\n\neg：（摘自心知天气 API接口文档，注意看第二点）\n\n![在这里插入图片描述](20210105205734586.png)\n\n\n大致的一个流程：\n\n用户注册时，\n\n1. 用户输入【账号】和【密码】（以及其他用户信息）；\n2. 系统为用户生成【Salt值】；\n3. 系统将【Salt值】和【用户密码】连接到一起；\n4. 对连接后的值进行散列，得到【Hash1值】；\n5. 将【Hash1值】和【Salt值】分别放到数据库中。\n\n用户登录时，\n\n1. 用户输入【账号】和【密码】；\n2. 系统通过用户名找到与之对应的【Hash值】和【Salt值】；\n3. 系统将【Salt值】和【用户输入的密码】连接到一起；\n4. 对连接后的值进行散列，得到【Hash2值】（注意是即时运算出来的值）；\n5. 比较【Hash1值】和【Hash2值】是否相等，相等则表示密码正确，否则表示密码错误。\n\n有时候，为了减轻开发压力，程序员会统一使用一个 Salt值（储存在某个地方），而不是每个用户都生成私有的 Salt值。\n\n\n\n# 公开的  MD5 Message-Digest Algorithm代码\n\n```c md5c.c\n/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm\n */\n/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All\nrights reserved.\nLicense to copy and use this software is granted provided that it\nis identified as the \"RSA Data Security, Inc. MD5 Message-Digest\nAlgorithm\" in all material mentioning or referencing this software\nor this function.\nLicense is also granted to make and use derivative works provided\nthat such works are identified as \"derived from the RSA Data\nSecurity, Inc. MD5 Message-Digest Algorithm\" in all material\nmentioning or referencing the derived work.\nRSA Data Security, Inc. makes no representations concerning either\nthe merchantability of this software or the suitability of this\nsoftware for any particular purpose. It is provided \"as is\"\nwithout express or implied warranty of any kind.\nThese notices must be retained in any copies of any part of this\ndocumentation and/or software.\n */\n#include \"global.h\"\n#include \"md5.h\"\n\n\n/* Constants for MD5Transform routine.\n */\n#define S11 7\n#define S12 12\n#define S13 17\n#define S14 22\n#define S21 5\n#define S22 9\n#define S23 14\n#define S24 20\n#define S31 4\n#define S32 11\n#define S33 16\n#define S34 23\n#define S41 6\n#define S42 10\n#define S43 15\n#define S44 21\nstatic void MD5Transform PROTO_LIST((UINT4[4], unsigned char[64]));\nstatic void Encode PROTO_LIST((unsigned char *, UINT4 *, unsigned int));\nstatic void Decode PROTO_LIST((UINT4 *, unsigned char *, unsigned int));\nstatic void MD5_memcpy PROTO_LIST((POINTER, POINTER, unsigned int));\nstatic void MD5_memset PROTO_LIST((POINTER, int, unsigned int));\nstatic unsigned char PADDING[64] = {\n    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n/* F, G, H and I are basic MD5 functions.\n */\n#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))\n#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define I(x, y, z) ((y) ^ ((x) | (~z)))\n/* ROTATE_LEFT rotates x left n bits.\n */\n#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.\nRotation is separate from addition to prevent recomputation.\n */\n#define FF(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += F((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n#define GG(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += G((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n#define HH(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += H((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n#define II(a, b, c, d, x, s, ac)                 \\\n  {                                              \\\n    (a) += I((b), (c), (d)) + (x) + (UINT4)(ac); \\\n    (a) = ROTATE_LEFT((a), (s));                 \\\n    (a) += (b);                                  \\\n  }\n/* MD5 initialization. Begins an MD5 operation, writing a new context.\n */\nvoid MD5Init(context)\n    MD5_CTX *context; /* context */\n{\n  context->count[0] = context->count[1] = 0;\n  /* Load magic initialization constants.\n*/\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xefcdab89;\n  context->state[2] = 0x98badcfe;\n  context->state[3] = 0x10325476;\n}\n/* MD5 block update operation. Continues an MD5 message-digest\n operation, processing another message block, and updating the\n context.\n */\nvoid MD5Update(context, input, inputLen)\n    MD5_CTX *context;  /* context */\nunsigned char *input;  /* input block */\nunsigned int inputLen; /* length of input block */\n{\n  unsigned int i, index, partLen;\n  /* Compute number of bytes mod 64 */\n  index = (unsigned int)((context->count[0] >> 3) & 0x3F);\n  /* Update number of bits */\n  if ((context->count[0] += ((UINT4)inputLen << 3)) < ((UINT4)inputLen << 3))\n    context->count[1]++;\n  context->count[1] += ((UINT4)inputLen >> 29);\n  partLen = 64 - index;\n  /* Transform as many times as possible.\n*/\n  if (inputLen >= partLen)\n  {\n    MD5_memcpy((POINTER)&context->buffer[index], (POINTER)input, partLen);\n    MD5Transform(context->state, context->buffer);\n    for (i = partLen; i + 63 < inputLen; i += 64)\n      MD5Transform(context->state, &input[i]);\n    index = 0;\n  }\n  else\n    i = 0;\n  /* Buffer remaining input */\n  MD5_memcpy((POINTER)&context->buffer[index], (POINTER)&input[i],\n             inputLen - i);\n}\n/* MD5 finalization. Ends an MD5 message-digest operation, writing the\n the message digest and zeroizing the context.\n */\nvoid MD5Final(digest, context) unsigned char digest[16]; /* message digest */\nMD5_CTX *context;                                        /* context */\n{\n  unsigned char bits[8];\n  unsigned int index, padLen;\n  /* Save number of bits */\n  Encode(bits, context->count, 8);\n  /* Pad out to 56 mod 64.\n*/\n  index = (unsigned int)((context->count[0] >> 3) & 0x3f);\n  padLen = (index < 56) ? (56 - index) : (120 - index);\n  MD5Update(context, PADDING, padLen);\n  /* Append length (before padding) */\n  MD5Update(context, bits, 8);\n  /* Store state in digest */\n  Encode(digest, context->state, 16);\n  /* Zeroize sensitive information.\n*/\n  MD5_memset((POINTER)context, 0, sizeof(*context));\n}\n/* MD5 basic transformation. Transforms state based on block.\n */\nstatic void MD5Transform(state, block)\n    UINT4 state[4];\nunsigned char block[64];\n{\n  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];\n  Decode(x, block, 64);\n  /* Round 1 */\n  FF(a, b, c, d, x[0], S11, 0xd76aa478);  /* 1 */\n  FF(d, a, b, c, x[1], S12, 0xe8c7b756);  /* 2 */\n  FF(c, d, a, b, x[2], S13, 0x242070db);  /* 3 */\n  FF(b, c, d, a, x[3], S14, 0xc1bdceee);  /* 4 */\n  FF(a, b, c, d, x[4], S11, 0xf57c0faf);  /* 5 */\n  FF(d, a, b, c, x[5], S12, 0x4787c62a);  /* 6 */\n  FF(c, d, a, b, x[6], S13, 0xa8304613);  /* 7 */\n  FF(b, c, d, a, x[7], S14, 0xfd469501);  /* 8 */\n  FF(a, b, c, d, x[8], S11, 0x698098d8);  /* 9 */\n  FF(d, a, b, c, x[9], S12, 0x8b44f7af);  /* 10 */\n  FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */\n  FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */\n  FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */\n  FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */\n  FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */\n  FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */\n  /* Round 2 */\n  GG(a, b, c, d, x[1], S21, 0xf61e2562);  /* 17 */\n  GG(d, a, b, c, x[6], S22, 0xc040b340);  /* 18 */\n  GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */\n  GG(b, c, d, a, x[0], S24, 0xe9b6c7aa);  /* 20 */\n  GG(a, b, c, d, x[5], S21, 0xd62f105d);  /* 21 */\n  GG(d, a, b, c, x[10], S22, 0x2441453);  /* 22 */\n  GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */\n  GG(b, c, d, a, x[4], S24, 0xe7d3fbc8);  /* 24 */\n  GG(a, b, c, d, x[9], S21, 0x21e1cde6);  /* 25 */\n  GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */\n  GG(c, d, a, b, x[3], S23, 0xf4d50d87);  /* 27 */\n  GG(b, c, d, a, x[8], S24, 0x455a14ed);  /* 28 */\n  GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */\n  GG(d, a, b, c, x[2], S22, 0xfcefa3f8);  /* 30 */\n  GG(c, d, a, b, x[7], S23, 0x676f02d9);  /* 31 */\n  GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */\n  /* Round 3 */\n  HH(a, b, c, d, x[5], S31, 0xfffa3942);  /* 33 */\n  HH(d, a, b, c, x[8], S32, 0x8771f681);  /* 34 */\n  HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */\n  HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */\n  HH(a, b, c, d, x[1], S31, 0xa4beea44);  /* 37 */\n  HH(d, a, b, c, x[4], S32, 0x4bdecfa9);  /* 38 */\n  HH(c, d, a, b, x[7], S33, 0xf6bb4b60);  /* 39 */\n  HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */\n  HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */\n  HH(d, a, b, c, x[0], S32, 0xeaa127fa);  /* 42 */\n  HH(c, d, a, b, x[3], S33, 0xd4ef3085);  /* 43 */\n  HH(b, c, d, a, x[6], S34, 0x4881d05);   /* 44 */\n  HH(a, b, c, d, x[9], S31, 0xd9d4d039);  /* 45 */\n  HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */\n  HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */\n  HH(b, c, d, a, x[2], S34, 0xc4ac5665);  /* 48 */\n  /* Round 4 */\n  II(a, b, c, d, x[0], S41, 0xf4292244);  /* 49 */\n  II(d, a, b, c, x[7], S42, 0x432aff97);  /* 50 */\n  II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */\n  II(b, c, d, a, x[5], S44, 0xfc93a039);  /* 52 */\n  II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */\n  II(d, a, b, c, x[3], S42, 0x8f0ccc92);  /* 54 */\n  II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */\n  II(b, c, d, a, x[1], S44, 0x85845dd1);  /* 56 */\n  II(a, b, c, d, x[8], S41, 0x6fa87e4f);  /* 57 */\n  II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */\n  II(c, d, a, b, x[6], S43, 0xa3014314);  /* 59 */\n  II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */\n  II(a, b, c, d, x[4], S41, 0xf7537e82);  /* 61 */\n  II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */\n  II(c, d, a, b, x[2], S43, 0x2ad7d2bb);  /* 63 */\n  II(b, c, d, a, x[9], S44, 0xeb86d391);  /* 64 */\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  /* Zeroize sensitive information.\n*/\n  MD5_memset((POINTER)x, 0, sizeof(x));\n}\n/* Encodes input (UINT4) into output (unsigned char). Assumes len is\n a multiple of 4.\n */\nstatic void Encode(output, input, len) unsigned char *output;\nUINT4 *input;\nunsigned int len;\n{\n  unsigned int i, j;\n  for (i = 0, j = 0; j < len; i++, j += 4)\n  {\n    output[j] = (unsigned char)(input[i] & 0xff);\n    output[j + 1] = (unsigned char)((input[i] >> 8) & 0xff);\n    output[j + 2] = (unsigned char)((input[i] >> 16) & 0xff);\n    output[j + 3] = (unsigned char)((input[i] >> 24) & 0xff);\n  }\n}\n/* Decodes input (unsigned char) into output (UINT4). Assumes len is\n a multiple of 4.\n */\nstatic void Decode(output, input, len)\n    UINT4 *output;\nunsigned char *input;\nunsigned int len;\n{\n  unsigned int i, j;\n  for (i = 0, j = 0; j < len; i++, j += 4)\n    output[i] = ((UINT4)input[j]) | (((UINT4)input[j + 1]) << 8) |\n                (((UINT4)input[j + 2]) << 16) | (((UINT4)input[j + 3]) << 24);\n}\n/* Note: Replace \"for loop\" with standard memcpy if possible.\n */\nstatic void MD5_memcpy(output, input, len)\n    POINTER output;\nPOINTER input;\nunsigned int len;\n{\n  unsigned int i;\n  for (i = 0; i < len; i++)\n    output[i] = input[i];\n}\n/* Note: Replace \"for loop\" with standard memset if possible.\n */\nstatic void MD5_memset(output, value, len)\n    POINTER output;\nint value;\nunsigned int len;\n{\n  unsigned int i;\n  for (i = 0; i < len; i++)\n    ((char *)output)[i] = (char)value;\n}\n```\n\n\n\n```c md5.h\n/* MD5.H - header file for MD5C.C\n */\n/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All\nrights reserved.\nLicense to copy and use this software is granted provided that it\nis identified as the \"RSA Data Security, Inc. MD5 Message-Digest\nAlgorithm\" in all material mentioning or referencing this software\nor this function.\nLicense is also granted to make and use derivative works provided\nthat such works are identified as \"derived from the RSA Data\nSecurity, Inc. MD5 Message-Digest Algorithm\" in all material\nmentioning or referencing the derived work.\nRSA Data Security, Inc. makes no representations concerning either\nthe merchantability of this software or the suitability of this\nsoftware for any particular purpose. It is provided \"as is\"\nwithout express or implied warranty of any kind.\nThese notices must be retained in any copies of any part of this\ndocumentation and/or software.\n */\n\n/* MD5 context. */\ntypedef struct\n{\n    UINT4 state[4];           /* state (ABCD) */\n    UINT4 count[2];           /* number of bits, modulo 2^64 (lsb first) */\n    unsigned char buffer[64]; /* input buffer */\n} MD5_CTX;\nvoid MD5Init PROTO_LIST((MD5_CTX *));\nvoid MD5Update PROTO_LIST((MD5_CTX *, unsigned char *, unsigned int));\nvoid MD5Final PROTO_LIST((unsigned char[16], MD5_CTX *));\n```\n\n\n\n```c global.h\n/* GLOBAL.H - RSAREF types and constants\n */\n/* PROTOTYPES should be set to one if and only if the compiler supports\n function argument prototyping.\nThe following makes PROTOTYPES default to 0 if it has not already\nbeen defined with C compiler flags.\n */\n#ifndef PROTOTYPES\n#define PROTOTYPES 0\n#endif\n\n/* POINTER defines a generic pointer type */\ntypedef unsigned char *POINTER;\n/* UINT2 defines a two byte word */\ntypedef unsigned short int UINT2;\n/* UINT4 defines a four byte word */\ntypedef unsigned long int UINT4;\n\n/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.\nIf using PROTOTYPES, then PROTO_LIST returns the list, otherwise it\n returns an empty list.\n */\n#if PROTOTYPES\n#define PROTO_LIST(list) list\n#else\n#define PROTO_LIST(list) ()\n#endif\n```\n\n以上代码摘自：[RFC 1321](https://tools.ietf.org/pdf/rfc1321.pdf)\n\n\n\n# 修改后的应用代码\n\n![在这里插入图片描述](20210105205854304.png)\n\n\n![在这里插入图片描述](20210105205923507.png)\n\n\n测试：\n\n![在这里插入图片描述](20210105205956186.png)","tags":["history","算法"],"categories":["算法"]},{"title":"逻辑门、锁存器和触发器","url":"/logic-device/","content":"\n\n> 好久没写硬件的笔记了，写这篇笔记是因为在网上或者在现有的书上查阅相关知识点的时候，发现大多数东西都是一略带过、不全面，而且内容讲的有点沉闷，容易让人呼呼入睡（ps：这里绝对没有瞧不起作者的意思哈，可能风格有点不适应），所以想着以后可能也会用到，还是自己总结一篇吧。\n>\n> 本篇主要分析半导体存储电路（其中包括时序图跟真值表），但由于涉及到逻辑门电路，所以就一并放在一起总结了。嘛，原本的标题是想写 “半导体存储电路分析” 的。。。\n>\n\n\n\n# 逻辑门电路\n\n## 与、或、非\n\n- 与门\n\n  ![AND](AND.jpg)\n\n  特点：所有输入为高电平时（逻辑 1），才会有高电平（逻辑 1）输出；其中一个输入为低电平（逻辑 0）则出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出**  |\n  | :------: | :------: | :-------: |\n  |    A     |    B     | A  and  B |\n  |    0     |    0     |     0     |\n  |    0     |    1     |     0     |\n  |    1     |    0     |     0     |\n  |    1     |    1     |     1     |\n\n  ==总结：遇 0为 0。==\n\n  \n\n- 或门\n\n  ![OR](OR.jpg)\n\n  特点：其中一个输入为高电平时（逻辑 1），输出为高电平（逻辑 1）；只有当所有输入为低电平（逻辑 0）才出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出** |\n  | :------: | :------: | :------: |\n  |    A     |    B     | A  or  B |\n  |    0     |    0     |    0     |\n  |    0     |    1     |    1     |\n  |    1     |    0     |    1     |\n  |    1     |    1     |    1     |\n\n  ==总结：遇 1为 1。==\n\n  \n\n- 非门\n\n  ![NOT](NOT.jpg)\n\n  特点：输出的电平与输入的电平（逻辑）相反。\n\n  **真值表：**\n\n  | **输入** | **输出** |\n  | :------: | :------: |\n  |    A     |  not  A  |\n  |    0     |    1     |\n  |    1     |    0     |\n  \n  ==总结：状态取反。==\n\n\n\n## 异或和同或\n\n- 异或\n\n  ![XOR](XOR.jpg)\n\n  特点：输入的电平相同时，输出为低电平（逻辑 0）；若输入的电平不同，则输出高电平（逻辑 1）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出**  |\n  | :------: | :------: | :-------: |\n  |    A     |    B     | A  xor  B |\n  |    0     |    0     |     0     |\n  |    0     |    1     |     1     |\n  |    1     |    0     |     1     |\n  |    1     |    1     |     0     |\n\n  ==总结：相同为 0，不同为 1。==\n\n  \n\n- 同或\n\n  ![XNOR](XNOR.jpg)\n\n  特点：只有当输入的电平相同时，输出才为高电平（逻辑 1）；而输入的电平不同时，输出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** |  **输出**  |\n  | :------: | :------: | :--------: |\n  |    A     |    B     | A  xnor  B |\n  |    0     |    0     |     1      |\n  |    0     |    1     |     0      |\n  |    1     |    0     |     0      |\n  |    1     |    1     |     1      |\n\n  ==总结：不同为 0，相同为 1。==\n\n\n\n## 与非和或非\n\n与非和或非，其实相当于与门和或门输出取反：\n\n![X](X.jpg)\n\n真值表这里就不放了，其实就是把与门和或门的输出状态取反。。。\n\n\n\n## 逻辑门电路实现\n\n逻辑门电路的实现，可由三极管或者 CMOS管构建而成，可以看以前的文章：[三极管---初识(图文并茂)](https://blog.csdn.net/qq_42992084/article/details/98784963)\n\n\n\n# 存储电路\n\n**基本概念：**\n\n- **存储单元**：存储一位数据的电路。可分为**静态存储单元**和**动态存储单元**两大类。静态存储单元由门电路连接而成，其中包括各种电路结构形式的**锁存器**和**触发器**，只要保持通电，静态存储单元的状态会一直保持下去。动态存储单元则是利用**电容**的电荷存储效应来存储数据的，由于电容存储的电荷会随着时间的推移逐渐泄露，必须定期地进行 “刷新”，才能保证数据不会丢失。\n- **寄存器**：存储一组数据的电路。由 N个触发器构成的寄存器可以存储一组 N位的二值数据。\n- **存储器**：存储大量数据的电路。存储器种类虽然很多，但它们的基本结构形式都是由**存储矩阵**和**读/写控制电路**两部分组成的。从存储功能上讲，可分为**随机存储器**（Random Access  Memory，简称 RAM）和**只读存储器**（Read Only Memory ，简称 ROM）两大类。随机存储器又分成**静态随机存储器**（SRAM）和**动态随机存储器**（DRAM）两类；而只读存储器又有**掩模 ROM**、**可编程 ROM**（PRAM）和**可擦除可编程 ROM**（EPRAM）几种不同类型。\n\n\n\n# 锁存器和触发器\n\n下面主要分析硬件电路中经常接触的**静态存储单元**，那么就先来了解一下**锁存器**和**触发器**之间的关系：\n\n触发器的线路图由逻辑门组合而成，其结构均由 SR锁存器派生而来（广义的触发器包括锁存器）；\n\n**触发器**除了自身的输入信号外，还带有 CLK时钟信号线，通过时钟信号的变化，使得触发器的次态仅仅取决于 CLK信号下降沿（或上升沿）到达时刻输入信号的状态，以此来增强靠干扰能力，因此，触发器也叫边沿触发器；\n\n而**锁存器**并没有 CLK时钟信号线作为辅助，只有自身的输入信号，但是，通过改进（增加一条使能信号线）可以产生新的门控锁存器，此时锁存器上多了一条使能信号线，如果在使能信号线上给予一定频率的脉冲信号，那么门控锁存器就相当于触发器了。\n\n知识补充：https://circuitglobe.com/difference-between-latch-and-flip-flop.html\n\n\n\n# 锁存器\n\n锁存器的类型有很多种：S-R、J-K、T and D latches。这里只介绍比较常用的 S-R latch and Gated D latch。\n\n## SR锁存器\n\n![R-S_mk2](R-S_mk2.gif)\n\nSR锁存器（Set-Reset Latch）是静态存储单元当中最基本、也是电路结构最简单的一种。通常它由两个**或非门**或者**与非门**组成。\n\n\n\n**Ⅰ、电路组成：**\n\n- 由**或非门**构成\n\n  ![Logic_Design_NOR_Latches](Logic_Design_NOR_Latches.jpg)\n\n- 由**与非门**构成\n\n  ![Logic_Design_NAND_Latches](Logic_Design_NAND_Latches.jpg)\n\n**Ⅱ、状态分析：**\n\n从上面的两种构成进行比较，根据它们对应的状态表可以看出，当 S、R信号为高电平（逻辑 1）【对应的，$\\overline{S}$、$\\overline{R}$信号（由于符号表示的是非的关系）就为低电平（逻辑 0）】，就相当于这两个状态表高亮部分，所以无论是由哪个逻辑门构成，其输出状态都是一样的；因此，找其中一个表对照着理解就好了，那么就来稍微分析一下吧：\n\n- [ ] 当输入的 S = 0、R = 1（$\\overline{S}$ = 1、$\\overline{R}$ = 0），输出 Q = 0和 $\\overline{Q}$ = 1（定义为 0状态）；\n\n- [ ] 当输入的 S = 1、R = 0（$\\overline{S}$ = 0、$\\overline{R}$ = 1），输出 Q = 1和 $\\overline{Q}$ = 0（定义为 1状态）；\n- [ ] 当输入的 S = R = 0（ $\\overline{S}$ = $\\overline{R}$ = 1）；输出将会保持；\n\n- [ ] 当输入的 S = 1、R = 1（$\\overline{S}$ = 0、$\\overline{R}$ = 0），输出 Q和 $\\overline{Q}$其状态是不确定的；因此，在 SR锁存器里，有一条约束条件：S · R = 0（即不应该出现 $\\overline{S}$ = $\\overline{R}$ = 0，这种情况）。\n\n**Ⅲ、时序分析：**\n\n以**与非门**构成电路为例：\n\n![SR latch](SR%20latch.png)\n\n在上图可以看到， t3 ~ t4时刻，输入端出现了 $\\overline{S}$ = $\\overline{R}$ = 0的状态，但由于 $\\overline{S}$ 首先回到了高电平，所以 SR锁存器的次态仍是可以确定的；可能你会觉得，上面不是说了无法确定状态吗？这是由于 $\\overline{S}$ = $\\overline{R}$ = 0时会出现非定义的 Q =  $\\overline{Q}$ = 1的非法状态（要知道我们只定义了 0和 1的状态），而且当 $\\overline{S}$ 和 $\\overline{R}$ 同时回到高电平以后锁存器的状态难以确定，因此一般情况下还是避免这种 $\\overline{S}$ = $\\overline{R}$ = 0的状态；同时，由于这个缺陷，**JK触发器**产生了，下面会讲。\n\n**Ⅳ、电路改进：**\n\n从上面可以得知，由**与非门**构成的 SR触发器，输入的电平（逻辑）是反向的输入（即为  $\\overline{S}$、$\\overline{R}$ ），因此，人们在电路的前端输入部分添加了转换功能，并且引入了使能控制信号，如下图：\n\n![Logic_Design_gated_SR_latch](Logic_Design_gated_SR_latch.jpg)\n\n于是乎，把上面的电路称之为：**门控 SR锁存器**\n\n\n\n门控使能信号（一般表示为 E或者 C）的作用：\n\n| E/C  |              Action              |\n| :--: | :------------------------------: |\n|  0   |      No action (keep state)      |\n|  1   | The same as non-clocked SR latch |\n\n\n\n## 门控 D锁存器\n\n在上面已经见识到了 **门控 SR锁存器**，那么稍微修改一下就会得到 **门控 D锁存器**，由于是从 SR锁存器上进行的修改，所以也存在着由**或非门**或者**与非门**所组成电路。\n\n**Ⅰ、电路组成：**\n\n- 基于 SR NAND锁存器的门控 D锁存器\n\n  ![676px-D-Type_Transparent_Latch.svg](676px-D-Type_Transparent_Latch.svg.png)\n\n- 基于 SR NOR锁存器的门控 D锁存器\n\n  ![676px-D-type_Transparent_Latch_(NOR).svg](676px-D-type_Transparent_Latch_(NOR).svg.png)\n\n对应上面两个门控 D锁存器，其真值表都是一样的：\n\n|  E   |   D   |   Q   |   $\\overline{Q}$   |  Comment  |\n| :--: | :---: | :---: | :----------------: | :-------: |\n|  0   | **X** | Qprev | $\\overline{Q}$prev | No change |\n|  1   |   0   |   0   |         1          |   Reset   |\n|  1   |   1   |   1   |         0          |    Set    |\n\n从真值表上看，可以知道，在使能信号输入为高电平（逻辑 1）时，D锁存器才起作用，否则，输出信号将保持原状态；并且，当 D锁存器起作用时，输出的信号 Q状态跟 D输入状态一致，因此，D锁存器也叫 D跟随。\n\n**Ⅱ、时序分析**\n\n![Gated D latch](Gated%20D%20latch.png)\n\n\n\n锁存器部分相关链接：https://learn.circuitverse.org/docs/Latches\n\n\n\n# 触发器\n\n触发器的类型同样也有很多种：S-R、J-K、T and D Flip flops。这里也只是分析常见的 J-K、T and D Flip flops。\n\n根据时钟信号触发的不同，可以分为两种情况（上升沿触发和下降沿触发）：\n\n![Logic_Design_SR_flip_flop_symbol](Logic_Design_SR_flip_flop_symbol.jpg)\n\n从上图可以看到，上升沿触发和下降沿触发根本区别在于时钟信号输入端是否多了个非门。\n\n## JK触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_JK_flip_flop_symbol](Logic_Design_JK_flip_flop_symbol.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![jk flip flop](jk%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   J   |   K   |   Q   | Qnext |  Comment   |\n| :--------: | :---: | :---: | :---: | :---: | :--------: |\n| $\\searrow$ | **X** | **X** | Qprev |   Q   | No change  |\n| $\\nearrow$ |   0   |   0   |   0   |   0   | Hold state |\n| $\\nearrow$ |   0   |   0   |   1   |   1   | Hold state |\n| $\\nearrow$ |   0   |   1   |   0   |   0   |   Reset    |\n| $\\nearrow$ |   0   |   1   |   1   |   0   |   Reset    |\n| $\\nearrow$ |   1   |   0   |   0   |   1   |    Set     |\n| $\\nearrow$ |   1   |   0   |   1   |   1   |    Set     |\n| $\\nearrow$ |   1   |   1   |   0   |   1   |   Toggle   |\n| $\\nearrow$ |   1   |   1   |   1   |   0   |   Toggle   |\n\n**时序分析：**\n\n![JK Flip-Flop](JK%20Flip-Flop.png)\n\n**特征方程式：**\n\n![JK](JK.png)\n\n\n\n## T触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_T_flip_flop_symbol](Logic_Design_T_flip_flop_symbol.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![T flip flop](T%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   T   |   Q   | Qnext |  Comment   |\n| :--------: | :---: | :---: | :---: | :--------: |\n| $\\searrow$ | **X** | Qprev |   Q   | No change  |\n| $\\nearrow$ |   0   |   0   |   0   | Hold state |\n| $\\nearrow$ |   0   |   1   |   1   | Hold state |\n| $\\nearrow$ |   1   |   0   |   1   |   Toggle   |\n| $\\nearrow$ |   1   |   1   |   0   |   Toggle   |\n\n**时序分析：**\n\n![T Filp-Flop](T%20Filp-Flop.png)\n\n**特征方程式：**\n\n![T](T.png)\n\n\n\n## D触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_D_flip_flop_symbols](Logic_Design_D_flip_flop_symbols.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![D flip flop](D%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   D   |   Q   | Qnext |  Comment  |\n| :--------: | :---: | :---: | :---: | :-------: |\n| $\\searrow$ | **X** | Qprev |   Q   | No change |\n| $\\nearrow$ |   0   |   0   |   0   |   Reset   |\n| $\\nearrow$ |   0   |   1   |   0   |   Reset   |\n| $\\nearrow$ |   1   |   0   |   1   |    Set    |\n| $\\nearrow$ |   1   |   1   |   1   |    Set    |\n\n**时序分析：**\n\n![D Filp-Flop](D%20Filp-Flop.png)\n\n**特征方程式：**\n\n![D](D.png)\n\n\n\n触发器部分相关链接：https://learn.circuitverse.org/docs/flipflop\n\n\n\n# 相关资料\n\nhttps://en.wikipedia.org/wiki/Flip-flop_(electronics)\n\nhttps://www.youtube.com/watch?v=-aQH0ybMd3U&list=RDCMUCSX3MR0gnKDxyXAyljWzm0Q&start_radio=1\n\nhttp://yhhuang1966.blogspot.com/2019/06/latch-flip-flop.html\n\nhttps://www.electronics-tutorials.ws/sequential/seq_1.html\n\n","tags":["电子","history"]},{"title":"SDCC 编译器 + VSCode 开发","url":"/sdcc-develop/","content":"\n\n\n> SDCC是一个小型设备的 C语言编译器，该编译器支持标准 C语言；相对于 GCC编译器来说可能知名度不是很高，但它跟 GCC一样，是跨平台，并且遵循 GPL开源协议。本次实验是使用 nuvoton的 MS51系列单片机来操作（基于 8051内核）\n\n\n\nsdcc官方网址：http://sdcc.sourceforge.net/\n\nWiki主页：https://sourceforge.net/p/sdcc/wiki/Home/\n\n\n\n# 关于 SDCC\n\nSDCC是可重定目标的、优化的标准 C（ANSI C89，ISO C99，ISO C11）编译器套件，针对的是基于 Intel MCS51的微处理器（8031、8032、8051、8052等），Maxim（以前为达拉斯）DS80C390变体，飞思卡尔（ 基于 HC08（hc08，s08），基于 Zilog Z80的 MCU（z80，z180，gbz80，Rabbit 2000/3000，Rabbit 3000A，TLCS-90），Padauk（pdk14，pdk15）和 STMicroelectronics STM8。 \n\n在安装了 SDCC后，通过指令查看版本号可以看到它所支持的设备类型：\n\n![image-20201027210643106](image-20201027210643106.png)\n\n然后，这里有个帖子有讨论 SDCC的一些相关东西，而且好像（我也不确定）SDCC的开发者也在里面，感兴趣的可以看一下：https://wap.newsmth.net/article/905eb27dddf829f15c81077215d66284?title=%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E8%AF%95&from=search\n\nSDCC较于 Keil来说，它对 C语法的严谨度是很高的，更像一个标准的 C语言编译器，并不会像 Keil那样把一些 warning去除掉，自动帮你优化；前面说了， SDCC是一个好的编译器，可优化方面稍微有点不够完美，以至于代码生成的体积还是比 Keil C51大一些（是不是我还有些优化指令没 get到呢？）。\n\n\n\n# 安装及环境配置\n\n**1、 SDCC**\n\n软件的下载路径在上面的 sdcc主页上有对应的接口，只需要下载相关的平台程序包安装就好了，安装完成后添加系统环境变量这个就不用多说了，最后就 `sdcc -v` 测试检验。就这么简单。。。\n\n**2、 MinGW-w64**\n\n下载地址：https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/\n\n安装完成后需要添加系统环境变量，可以利用 cmd命令：`gcc -v` 测试。\n\n**3、** **MSYS2**或者 **Git**（只要支持 shell命令的终端控制台就行）\n\n[msys2下载 <-- 自戳](http://www.msys2.org/)\n\nGit自行搜索下载。\n\n**2、 VSCode**\n\nVSCode环境部署可以看之前的 [STM32开发之 VS Code + gcc环境编译](https://blog.csdn.net/qq_42992084/article/details/108892169) 的第三节，然后如果你懂得配置 VSCode的配置项的话，那么你可以跳过下面的配置操作自己写。\n\n- c_cpp_properties.json\n\n  ```json\n  {\n      \"configurations\": [\n          {\n              \"name\": \"C51\",\n              \"includePath\": [\t\t\t// 你的工程中存放 include的文件夹路径\n                  \"${workspaceFolder}/**\",\n                  \"${workspaceFolder}/App\",\n                  \"${workspaceFolder}/Libraries/Device/Include\",\n                  \"${workspaceFolder}/Libraries/StdDriver/inc\"\n              ],\n              \"defines\": [\n                  \"_DEBUG\",\n                  \"UNICODE\",\n                  \"_UNICODE\",\n              ],\n              \"compilerPath\": \"C:\\\\Program Files\\\\SDCC\\\\bin\\\\sdcc.exe\",\t// sdcc bin路径\n              \"cStandard\": \"gnu18\",\n              \"cppStandard\": \"gnu++14\",\n              \"intelliSenseMode\": \"gcc-x64\"\n          }\n      ],\n      \"version\": 4\n  }\n  ```\n\n- tasks.json\n\n  ```json\n  {\n      // See https://go.microsoft.com/fwlink/?LinkId=733558\n      // for the documentation about the tasks.json format\n      \"version\": \"2.0.0\",\n      \"tasks\": [\n          {\n              \"label\": \"Build\",\n              \"type\": \"shell\",\n              \"command\": \"make\",\n              \"args\": [\n                  \"target=${fileBasenameNoExtension}\"\n              ],\n              \"group\": {\n                  \"kind\": \"build\",\n                  \"isDefault\": true\n              }\n          }\n      ]\n  }\n  ```\n\n- settings.json\n\n  ```json\n  {\n      \"files.encoding\": \"gb2312\",\n      \"files.autoGuessEncoding\": true,\n  \n      \"C_Cpp.errorSquiggles\": \"Enabled\",     // 语法错误\n  \n      \"files.associations\": {\n          \"main.h\": \"c\",\n      },\n      \n      /* 终端在Windows上使用的shell的路径 */\n      \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\",\n  }\n  ```\n\n\n\n# SDCC规则（仅对于 MCS51说明）\n\n**1、支持的数据类型**\n\n![image-20201027235219085](image-20201027235219085.png)\n\n**2、存储类型**\n\n![image-20201027235506151](image-20201027235506151.png)\n\n相对于 Keil，其存储类型关键字加上了前缀 ’ __ ' 双下划线，这也是 SDCC的特色风格。\n\n`__data` ：这是小内存模式的默认(通用)地址空间，声明的变量将被放在 8051内核的直接寻址 RAM中。\n\n`__idata` ：这个地址空间中的变量将被分配到 8051的内部 RAM的间接可寻址部分。\n\n`__pdata` ：存储类型 pdata用于访问分页的外部数据存储器。\n\n`__xdata` ：这个地址空间中的变量将被放在外部 RAM中。\n\n`__code` ：存放程序代码的内存地址空间。\n\n**3、存储器模式**\n\nSDCC支持四种存储器模式：(small, medium, large, huge)\n\n采用 SDCC编译时，默认为小模式。如果要强制 SDCC使用特定的存储器模式，可使用以下命令行参数（在手册的 P3.3.6章节可以查询得到）：\n\n![image-20201029212546249](image-20201029212546249.png)\n\n类似于 Keil的这个选项（只不过 Keil是 GUI操作，SDCC是命令操作）：\n\n![image-20201029212824145](image-20201029212824145.png)\n\n关于不同模式下变量的存储位置不一样，可以查阅手册 P3.13章节；总的来说，对于中（medium）、大（large）、巨大（huge）存储模式来说，所有未指定内部命名地址空间而声明的变量都将分配到外部 RAM中，这包括所有参数和局部变量（用于不可重入函数），中型模式使用 pdata，大型模式使用 xdata；而小内存模式（small）则默认存放在 data。\n\n**4、bit 和 sbit关键字**\n\nbit和 int、char之类的差不多，只不过 char = 8位，bit = 1位；\n\nsbit是对应可位寻址空间的一个位。\n\n同样的，在 SDCC这里加上了前缀 ’ __ ’  双下划线，变成 `__bit`、`__sbit`\n\n**5、SFR（特殊功能寄存器）**\n\n与 bit关键字类似，表示命名地址空间，用于描述 8051的特殊函数寄存器和特殊位变量。\n\neg：\n\n&nbsp;&nbsp;&nbsp;&nbsp;_\\_sfr __at (0x80) P0;\t\t\t/* special function register P0 at location 0x80 */\n\n**6、绝对寻址**\n\nSDCC支持采用 `__at` 关键字表示绝对寻址。\n\n**7、内嵌汇编**\n\nSDCC完全支持内嵌汇编。使用该功能时，汇编代码应嵌在 `__asm` 和 `__endasm` 标识符之间。\n\n**8、编译生成文件**\n\n- xxx.asm：程序的汇编文件。\n- xxx.lst：程序的列表文件。\n- xxx.rst：被链接器更新的列表文件。\n- xxx.sym：由链接器生成的符号清单。\n- xxx.rel：由汇编器生成的对象文件，提供给链接器使用。\n- xxx.map：被链接器更新的最终存储器映射。\n- xxx.mem：内存的使用情况摘要。\n- xxx.ihx：Intel十六进制格式的加载模块。该文件必须被下载到微控制器中。\n\n\n\n# SDCC头文件处理\n\n前面说了，sdcc的非标关键字是带 ‘ __ ' 双下滑线的，但是 MS51的官方 SDK包中，寄存器寻址的关键字全是 keil格式的，这就需要转换过来；如果是一些成熟的 8051内核单片机，那么你可以在 sdcc的安装路径 ...\\SDCC\\include\\mcs51下找到对应的芯片头文件，若是没有，那么就要自己进行格式转换了。sdcc格式转换，你可以去上网搜一下，这里给一个链接：https://www.amobbs.com/thread-5625040-1-1.html ，里面有提供一个转换工具，当然你也可以自己去写一个程序。\n\n![MS51 include](MS51%20include.png)\n\n\n\n# 工程构建\n\n因为是用 VSCode做编辑开发，只要有 .vscode文件夹的配置项就可以了，剩下的编译过程就交给 sdcc编译，所以工程的构建比较简单，文件夹创建以及移植 SDK库都方便，以下是我的工程文件分布（看起来还是比较容易理解的）：\n\n![image-20201028213341368](image-20201028213341368.png)\n\n这里 Libraries文件夹的内容是直接移植 SDK库的，其余的看文件名就知道用途了。\n\n另外就是，App文件夹里，除了 lint.h（用来语法解析 mcs51特定代码）和添加了 main.h头文件（往常 main主文件是不带头文件）；然后为什么要这两个呢，是为了避免 VSCode的语法错误的，当然你也可以一劳永逸，直接关了 VSCode的语法提示（这个可以看上面的 settings.json配置文件），至于 lint.h是从 sdcc的安装路径 ...\\SDCC\\include\\mcs51提取出来的，原滋原味。\n\n\n\n# VSCode语法修饰\n\n上面也讲了，sdcc使用了部分非 ASCII C关键字，所以 VSCode会在程序中凸显语法错误；那么，我们就来解决这个问题（当然，不是用关闭语法检查这种粗暴形式）：\n\n1、首先要了解的是，在使用 sdcc进行编译的时候，是会自动在进行编译前预定义 `__SDCC` 宏的，这样就好办，利用条件编译，区别智能提示运行环境和 SDCC实际编译环境，用空的 define去取代这些关键字，寄存器也都用宏代替，然后在 SDCC实际编译时调用原来 C51语法的寄存器定义。\n\n2、根据上面第一点，然后结合上面的提到的 lint.h（默认是留了 sdcc关键字的空 define），得到这样的一个例子：\n\n```c\n#ifdef __SDCC\n    __sfr __at (0x80) P0;    //实际有效的寄存器定义\n\n#else\n\t/* 关键字部分 */\n\t#define __sfr                    // 空的关键字宏，消除关键字不兼容(在 lint.h上可以获取到相关的关键字)\n\t...\n\t...\n\t/* 寄存器部分 */\n\t#define P0    (*(char *) (0x80)) // 无实际意义，用于兼容（欺骗）标准 C语法的寄存器符号\n\t...\n\t...\n\n#endif\n```\n\n通过以上条件编译，就可以把代码区分到智能提示和实际编译两个环境：\n\n- 在实际编译时，SDCC 编译器会预定义 `__SDCC` 宏，因此实际编译时使用实际有效的寄存器定义；\n- 而在智能提示环境，用空的宏取代所有关键字，消除关键字的不兼容，然后用一个宏定义寄存器，保证寄存器名智能提示依然可以使用。这里将寄存器定义为 char* 指针解引用的左值表达式，目的是为迎合语法上对寄存器赋值是合法的，括号里的值可以是任意值，意义不大，当然如果使用寄存器本来的值更合适，但处理起来比较麻烦。\n\n3、对上面的 1、2点总结起来，就可以得到：\n\n```c\n#ifndef __MAIN_H__\n#define __MAIN_H__\n\n\n#include <stdint.h>\n\n#ifdef __SDCC\n    #include \"MS51_16K.h\"\n\n#else\n    #include <stdbool.h>\n    #include \"lint.h\"\n    #include \"SFR_Macro_MS51_16K.h\"\n\n/******************************************************************************/\n/*                      Macro define  header files                            */\n/******************************************************************************/\n\n#define P0          (*(char *) (0)) //= 0x80;\n#define SP          (*(char *) (0)) //= 0x81;\n#define DPL         (*(char *) (0)) //= 0x82;\n#define DPH         (*(char *) (0)) //= 0x83;\n#define RCTRIM0     (*(char *) (0)) //= 0x84;\n#define RCTRIM1     (*(char *) (0)) //= 0x85;  \n#define RWK         (*(char *) (0)) //= 0x86;\n#define PCON        (*(char *) (0)) //= 0x87;\n\n#define TCON        (*(char *) (0)) //= 0x88;\n#define TMOD        (*(char *) (0)) //= 0x89;\n#define TL0         (*(char *) (0)) //= 0x8A;\n#define TL1         (*(char *) (0)) //= 0x8B;\n#define TH0         (*(char *) (0)) //= 0x8C;\n#define TH1         (*(char *) (0)) //= 0x8D;\n#define CKCON       (*(char *) (0)) //= 0x8E;\n#define WKCON       (*(char *) (0)) //= 0x8F;\n\n#define P1          (*(char *) (0)) //= 0x90;\n#define SFRS        (*(char *) (0)) //= 0x91; //TA Protection\n#define CAPCON0     (*(char *) (0)) //= 0x92;\n#define CAPCON1     (*(char *) (0)) //= 0x93;\n#define CAPCON2     (*(char *) (0)) //= 0x94;\n#define CKDIV       (*(char *) (0)) //= 0x95;\n#define CKSWT       (*(char *) (0)) //= 0x96; //TA Protection\n#define CKEN        (*(char *) (0)) //= 0x97; //TA Protection\n\n#define SCON        (*(char *) (0)) //= 0x98;\n#define SBUF        (*(char *) (0)) //= 0x99;\n#define SBUF_1      (*(char *) (0)) //= 0x9A;\n#define EIE         (*(char *) (0)) //= 0x9B;\n#define EIE1        (*(char *) (0)) //= 0x9C;\n#define CHPCON      (*(char *) (0)) //= 0x9F; //TA Protection\n\n#define P2          (*(char *) (0)) //= 0xA0;\n#define AUXR1       (*(char *) (0)) //= 0xA2;\n#define BODCON0     (*(char *) (0)) //= 0xA3; //TA Protection\n#define IAPTRG      (*(char *) (0)) //= 0xA4; //TA Protection\n#define IAPUEN      (*(char *) (0)) //= 0xA5;  //TA Protection\n#define IAPAL       (*(char *) (0)) //= 0xA6;\n#define IAPAH       (*(char *) (0)) //= 0xA7;\n\n#define IE          (*(char *) (0)) //= 0xA8;\n#define SADDR       (*(char *) (0)) //= 0xA9;\n#define WDCON       (*(char *) (0)) //= 0xAA; //TA Protection\n#define BODCON1     (*(char *) (0)) //= 0xAB; //TA Protection\n#define P3M1        (*(char *) (0)) //= 0xAC;\n#define P3S         (*(char *) (0)) //= 0xAC; //Page1\n#define P3M2        (*(char *) (0)) //= 0xAD;\n#define P3SR        (*(char *) (0)) //= 0xAD; //Page1\n#define IAPFD       (*(char *) (0)) //= 0xAE;\n#define IAPCN       (*(char *) (0)) //= 0xAF;\n\n#define P3          (*(char *) (0)) //= 0xB0;\n#define P0M1        (*(char *) (0)) //= 0xB1;\n#define P0S         (*(char *) (0)) //= 0xB1; //Page1\n#define P0M2        (*(char *) (0)) //= 0xB2;\n#define P0SR        (*(char *) (0)) //= 0xB2; //Page1\n#define P1M1        (*(char *) (0)) //= 0xB3;\n#define P1S         (*(char *) (0)) //= 0xB3; //Page1\n#define P1M2        (*(char *) (0)) //= 0xB4;\n#define P1SR        (*(char *) (0)) //= 0xB4; //Page1\n#define P2S         (*(char *) (0)) //= 0xB5; \n#define IPH         (*(char *) (0)) //= 0xB7;\n#define PWMINTC     (*(char *) (0)) //= 0xB7;  //Page1\n\n#define IP          (*(char *) (0)) //= 0xB8;\n#define SADEN       (*(char *) (0)) //= 0xB9;\n#define SADEN_1     (*(char *) (0)) //= 0xBA;\n#define SADDR_1     (*(char *) (0)) //= 0xBB;\n#define I2DAT       (*(char *) (0)) //= 0xBC;\n#define I2STAT      (*(char *) (0)) //= 0xBD;\n#define I2CLK       (*(char *) (0)) //= 0xBE;\n#define I2TOC       (*(char *) (0)) //= 0xBF;\n\n#define I2CON       (*(char *) (0)) //= 0xC0;\n#define I2ADDR      (*(char *) (0)) //= 0xC1;\n#define ADCRL       (*(char *) (0)) //= 0xC2;\n#define ADCRH       (*(char *) (0)) //= 0xC3;\n#define T3CON       (*(char *) (0)) //= 0xC4;\n#define PWM4H       (*(char *) (0)) //= 0xC4; //Page1\n#define RL3         (*(char *) (0)) //= 0xC5;\n#define PWM5H       (*(char *) (0)) //= 0xC5;  //Page1\n#define RH3         (*(char *) (0)) //= 0xC6;\n#define PIOCON1     (*(char *) (0)) //= 0xC6; //Page1\n#define TA          (*(char *) (0)) //= 0xC7;\n\n#define T2CON       (*(char *) (0)) //= 0xC8;\n#define T2MOD       (*(char *) (0)) //= 0xC9;\n#define RCMP2L      (*(char *) (0)) //= 0xCA;\n#define RCMP2H      (*(char *) (0)) //= 0xCB;\n#define TL2         (*(char *) (0)) //= 0xCC; \n#define PWM4L       (*(char *) (0)) //= 0xCC; //Page1\n#define TH2         (*(char *) (0)) //= 0xCD;\n#define PWM5L       (*(char *) (0)) //= 0xCD; //Page1\n#define ADCMPL      (*(char *) (0)) //= 0xCE;\n#define ADCMPH      (*(char *) (0)) //= 0xCF;\n\n#define PSW         (*(char *) (0)) //= 0xD0;\n#define PWMPH       (*(char *) (0)) //= 0xD1;\n#define PWM0H       (*(char *) (0)) //= 0xD2;\n#define PWM1H       (*(char *) (0)) //= 0xD3;\n#define PWM2H       (*(char *) (0)) //= 0xD4;\n#define PWM3H       (*(char *) (0)) //= 0xD5;\n#define PNP         (*(char *) (0)) //= 0xD6;\n#define FBD         (*(char *) (0)) //= 0xD7;\n\n#define PWMCON0     (*(char *) (0)) //= 0xD8;\n#define PWMPL       (*(char *) (0)) //= 0xD9;\n#define PWM0L       (*(char *) (0)) //= 0xDA;\n#define PWM1L       (*(char *) (0)) //= 0xDB;\n#define PWM2L       (*(char *) (0)) //= 0xDC;\n#define PWM3L       (*(char *) (0)) //= 0xDD;\n#define PIOCON0     (*(char *) (0)) //= 0xDE;\n#define PWMCON1     (*(char *) (0)) //= 0xDF;\n\n#define ACC         (*(char *) (0)) //= 0xE0;\n#define ADCCON1     (*(char *) (0)) //= 0xE1;\n#define ADCCON2     (*(char *) (0)) //= 0xE2;\n#define ADCDLY      (*(char *) (0)) //= 0xE3;\n#define C0L         (*(char *) (0)) //= 0xE4;\n#define C0H         (*(char *) (0)) //= 0xE5;\n#define C1L         (*(char *) (0)) //= 0xE6;\n#define C1H         (*(char *) (0)) //= 0xE7;\n\n#define ADCCON0     (*(char *) (0)) //= 0xE8;\n#define PICON       (*(char *) (0)) //= 0xE9;\n#define PINEN       (*(char *) (0)) //= 0xEA;\n#define PIPEN       (*(char *) (0)) //= 0xEB;\n#define PIF         (*(char *) (0)) //= 0xEC;\n#define C2L         (*(char *) (0)) //= 0xED;\n#define C2H         (*(char *) (0)) //= 0xEE;\n#define EIP         (*(char *) (0)) //= 0xEF;\n\n#define B           (*(char *) (0)) //= 0xF0;\n#define CAPCON3     (*(char *) (0)) //= 0xF1;\n#define CAPCON4     (*(char *) (0)) //= 0xF2;\n#define SPCR        (*(char *) (0)) //= 0xF3;\n#define SPCR2       (*(char *) (0)) //= 0xF3; //Page1\n#define SPSR        (*(char *) (0)) //= 0xF4;\n#define SPDR        (*(char *) (0)) //= 0xF5;\n#define AINDIDS     (*(char *) (0)) //= 0xF6;\n#define EIPH        (*(char *) (0)) //= 0xF7;\n\n#define SCON_1      (*(char *) (0)) //= 0xF8;\n#define PDTEN       (*(char *) (0)) //= 0xF9; //TA Protection\n#define PDTCNT      (*(char *) (0)) //= 0xFA; //TA Protection\n#define PMEN        (*(char *) (0)) //= 0xFB;\n#define PMD         (*(char *) (0)) //= 0xFC;\n#define EIP1        (*(char *) (0)) //= 0xFE;\n#define EIPH1       (*(char *) (0)) //= 0xFF;\n\n/*  BIT Registers  */\n/*  SCON_1  */\n#define SM0_1      (*(char *) (0)) //= SCON_1^7;\n#define FE_1       (*(char *) (0)) //= SCON_1^7; \n#define SM1_1      (*(char *) (0)) //= SCON_1^6; \n#define SM2_1      (*(char *) (0)) //= SCON_1^5; \n#define REN_1      (*(char *) (0)) //= SCON_1^4; \n#define TB8_1      (*(char *) (0)) //= SCON_1^3; \n#define RB8_1      (*(char *) (0)) //= SCON_1^2; \n#define TI_1       (*(char *) (0)) //= SCON_1^1; \n#define RI_1       (*(char *) (0)) //= SCON_1^0; \n\n/*  ADCCON0  */\n#define ADCF       (*(char *) (0)) //= ADCCON0^7;\n#define ADCS       (*(char *) (0)) //= ADCCON0^6;\n#define ETGSEL1    (*(char *) (0)) //= ADCCON0^5;\n#define ETGSEL0    (*(char *) (0)) //= ADCCON0^4;\n#define ADCHS3     (*(char *) (0)) //= ADCCON0^3;\n#define ADCHS2     (*(char *) (0)) //= ADCCON0^2;\n#define ADCHS1     (*(char *) (0)) //= ADCCON0^1;\n#define ADCHS0     (*(char *) (0)) //= ADCCON0^0;\n\n/*  PWMCON0  */\n#define PWMRUN     (*(char *) (0)) //= PWMCON0^7;\n#define LOAD       (*(char *) (0)) //= PWMCON0^6;\n#define PWMF       (*(char *) (0)) //= PWMCON0^5;\n#define CLRPWM     (*(char *) (0)) //= PWMCON0^4;\n\n\n/*  PSW */\n#define CY         (*(char *) (0)) //= PSW^7;\n#define AC         (*(char *) (0)) //= PSW^6;\n#define F0         (*(char *) (0)) //= PSW^5;\n#define RS1        (*(char *) (0)) //= PSW^4;\n#define RS0        (*(char *) (0)) //= PSW^3;\n#define OV         (*(char *) (0)) //= PSW^2;\n#define P          (*(char *) (0)) //= PSW^0;\n\n/*  T2CON  */\n#define TF2        (*(char *) (0)) //= T2CON^7;\n#define TR2        (*(char *) (0)) //= T2CON^2;\n#define CM_RL2     (*(char *) (0)) //= T2CON^0;\n \n/*  I2CON  */\n#define I2CEN      (*(char *) (0)) //= I2CON^6;\n#define STA        (*(char *) (0)) //= I2CON^5;\n#define STO        (*(char *) (0)) //= I2CON^4;\n#define SI         (*(char *) (0)) //= I2CON^3;\n#define AA         (*(char *) (0)) //= I2CON^2;\n#define I2CPX  \t(*(char *) (0)) //= I2CON^0;\n\n/*  IP  */  \n#define PADC       (*(char *) (0)) //= IP^6;\n#define PBOD       (*(char *) (0)) //= IP^5;\n#define PS         (*(char *) (0)) //= IP^4;\n#define PT1        (*(char *) (0)) //= IP^3;\n#define PX1        (*(char *) (0)) //= IP^2;\n#define PT0        (*(char *) (0)) //= IP^1;\n#define PX0        (*(char *) (0)) //= IP^0;\n\n/*  P3  */  \n#define P30    \t(*(char *) (0)) //= P3^0;\n\n\n/*  IE  */\n#define EA         (*(char *) (0)) //= IE^7;\n#define EADC       (*(char *) (0)) //= IE^6;\n#define EBOD       (*(char *) (0)) //= IE^5;\n#define ES         (*(char *) (0)) //= IE^4;\n#define ET1        (*(char *) (0)) //= IE^3;\n#define EX1        (*(char *) (0)) //= IE^2;\n#define ET0        (*(char *) (0)) //= IE^1;\n#define EX0        (*(char *) (0)) //= IE^0;\n\n/*  P2  */ \n#define P20        (*(char *) (0)) //= P2^0;\n\n/*  SCON  */\n#define SM0        (*(char *) (0)) //= SCON^7;\n#define FE         (*(char *) (0)) //= SCON^7; \n#define SM1        (*(char *) (0)) //= SCON^6; \n#define SM2        (*(char *) (0)) //= SCON^5; \n#define REN        (*(char *) (0)) //= SCON^4; \n#define TB8        (*(char *) (0)) //= SCON^3; \n#define RB8        (*(char *) (0)) //= SCON^2; \n#define TI         (*(char *) (0)) //= SCON^1; \n#define RI         (*(char *) (0)) //= SCON^0; \n\n/*  P1  */     \n#define P17  \t\t(*(char *) (0)) //= P1^7;\n#define P16  \t\t(*(char *) (0)) //= P1^6;\n#define TXD_1  \t(*(char *) (0)) //= P1^6; \n#define P15  \t\t(*(char *) (0)) //= P1^5;\n#define P14  \t\t(*(char *) (0)) //= P1^4;\n#define SDA  \t\t(*(char *) (0)) //= P1^4;    \n#define P13  \t\t(*(char *) (0)) //= P1^3;\n#define SCL  \t\t(*(char *) (0)) //= P1^3;  \n#define P12        (*(char *) (0)) //= P1^2; \n#define P11        (*(char *) (0)) //= P1^1;\n#define P10        (*(char *) (0)) //= P1^0;\n\n/*  TCON  */\n#define TF1        (*(char *) (0)) //= TCON^7;\n#define TR1        (*(char *) (0)) //= TCON^6;\n#define TF0        (*(char *) (0)) //= TCON^5;\n#define TR0        (*(char *) (0)) //= TCON^4;\n#define IE1        (*(char *) (0)) //= TCON^3;\n#define IT1        (*(char *) (0)) //= TCON^2;\n#define IE0        (*(char *) (0)) //= TCON^1;\n#define IT0        (*(char *) (0)) //= TCON^0;\n\n/*  P0  */  \n#define P07        (*(char *) (0)) //= P0^7;\n#define RXD        (*(char *) (0)) //= P0^7;\n#define P06        (*(char *) (0)) //= P0^6;\n#define TXD        (*(char *) (0)) //= P0^6;\n#define P05        (*(char *) (0)) //= P0^5;\n#define P04        (*(char *) (0)) //= P0^4;\n#define STADC      (*(char *) (0)) //= P0^4;\n#define P03        (*(char *) (0)) //= P0^3;\n#define P02        (*(char *) (0)) //= P0^2;\n#define RXD_1      (*(char *) (0)) //= P0^2;\n#define P01        (*(char *) (0)) //= P0^1;\n#define MISO       (*(char *) (0)) //= P0^1;\n#define P00        (*(char *) (0)) //= P0^0;\n#define MOSI       (*(char *) (0)) //= P0^0;\n\n#endif /* __SDCC */\n\n#endif /* __MAIN_H__ */\n```\n\n对于寄存器定义处理，可以直接 copy原来的 include文件内容，然后直接把 `sfr`、`sbit` 替换成 `#define` ，再把 `=` 替换成 `(*(char *) (0)) //=` 这样就好，是不是很 nice。\n\n\n\n# Makefile程序化管理\n\nSDCC并不支持同时编译多个源代码文件，所以多文件项目的编译需要分步进行。假如你的项目包含 `foo1.c` `foo2.c` `main.c` 三个文件，那么编译过程如下：\n\n```shell\nsdcc -c foo1.c\nsdcc -c foo2.c\nsdcc main.c foo1.rel foo2.rel\n```\n\n还可以使用以下方式编译:\n\n```shell\nsdcc -c main.c\nsdcc main.rel foo1.rel foo2.rel\n```\n\n值得一提的是，sdcc与 gcc的命令支持还是有点出入的，但大部分都兼容，因此具体支持哪些命令，需要去翻看 sdcc的手册。\n\n对于多文件项目最好是写一个 Makefile文件来维护或者写一个 bat批处理文件。这里就直接给出我所用的 Makefile文件吧，分析什么的，可以看以前的链接：https://arachnid.cc/makefile-summarize/；如果你是 Linux用户，应该很清楚这些命令，若果诸位大佬有懂得多的，还请在评论区不吝赐教：\n\n```makefile\n######################################\n# target path\n######################################\nTARGET = MS51FB\n\n#######################################\n# Build path\n#######################################\nBUILD_DIR = build\n\n######################################\n# source\n######################################\nSRCDIR = App\nLIB_SRC = #Libraries/StdDriver/src\n\nUSER_SRC = source#/bsp.c \\\nsource/bsp_time.c \\\nsource/bsp_uart.c\n\n# C sources\nC_SOURCES := $(wildcard $(SRCDIR)/*.c $(LIB_SRC)/*.c)\nC_SOURCES += $(wildcard $(USER_SRC)/*.c)\nASM_SOURCES = $(wildcard $(SRCDIR)/*.asm)\n\nC_SRC_FILE = $(notdir $(C_SOURCES))\nC_OBJ_FILE = $(C_SRC_FILE:%.c=%.c.rel)\n\nASM_SRC_FILE = $(notdir $(ASM_SOURCES))\nASM_OBJ_FILE = $(ASM_SRC_FILE:%.asm=%.asm.rel)\n\n######################################\n# building variables\n######################################\n# debug build?\nDEBUG = 1\n# optimization\nOPT = \n\n#######################################\n# cross compile\n#######################################\nPREFIX = \n\nCC = $(PREFIX)sdcc \nAS = $(PREFIX)sdas8051\n\nMCU_MODEL = -mmcs51\n\nRM = -rm -rf \nMAKE = make \n\n# ------------------------------------------------------\n# Usually SDCC's small memory model is the best choice.  If\n# you run out of internal RAM, you will need to declare\n# variables as \"xdata\", or switch to larger model\n\n# Memory Model (small, medium, large, huge)\nMODEL  = --model-small\n# ------------------------------------------------------\n# Memory Layout\n# PRG Size = 4K Bytes\n#CODE_SIZE = --code-loc 0x0000 --code-size 18432\nCODE_SIZE = --code-size 18432\n# INT-MEM Size = 256 Bytes\n#IRAM_SIZE = --idata-loc 0x0000  --iram-size 256\nIRAM_SIZE = --iram-size 256\n# EXT-MEM Size = 4K Bytes\n#XRAM_SIZE = --xram-loc 0x0000 --xram-size 768\nXRAM_SIZE = --xram-size 768\n\n# ------------------------------------------------------\n\n#######################################\n# FLAGS\n#######################################\n# macros for gcc\n# AS defines\nAS_DEFS = \n\n# C defines\nC_DEFS = \n\n\n# AS includes\nAS_INCLUDES = \n\n# C includes\nC_INCLUDES =  \\\n-IApp \\\n-ILibraries/Device/Include \\\n-ILibraries/StdDriver/inc \\\n-Iinclude\n\n# libraries\nLIBS = \nLIBDIR = \n\n# compile gcc flags\nASFLAGS = -l -s\n\nCFLAGS = $(MCU_MODEL) $(C_DEFS) $(C_INCLUDES) $(MODEL) --out-fmt-ihx --no-xinit-opt --peep-file tools/peep.def\n\nifeq ($(DEBUG), 1)\nCFLAGS += \nelse\nCFLAGS += $(OPT)\nendif\n\n\n#######################################\n# LDFLAGS\n#######################################\nLDFLAGS = $(LIBDIR) $(LIBS) $(MCU_MODEL) $(MODEL) $(CODE_SIZE) $(IRAM_SIZE) $(XRAM_SIZE) --out-fmt-ihx\n\n# default action: build all\n.PHONY: all\nall: $(BUILD_DIR)/$(TARGET).hex\n\n#######################################\n# build the application\n#######################################\n# list of objects\nOBJECTS = $(addprefix $(BUILD_DIR)/,$(C_OBJ_FILE))\n# list of ASM program objects\nOBJECTS += $(addprefix $(BUILD_DIR)/,$(ASM_OBJ_FILE))\n\n$(BUILD_DIR)/%.c.rel: $(USER_SRC)/%.c\n\t$(CC) -o $@ $(CFLAGS) -c $^\n\n$(BUILD_DIR)/%.c.rel: $(LIB_SRC)/%.c\n\t$(CC) -o $@ $(CFLAGS) -c $^\n\n$(BUILD_DIR)/%.c.rel: $(SRCDIR)/%.c\n\t$(CC) -o $@ $(CFLAGS) -c $^\n\n$(BUILD_DIR)/%.asm.rel: $(SRCDIR)/%.asm\n\t$(AS) $(ASFLAGS) -o $@ $^ \n\n$(BUILD_DIR)/%.ihx: $(OBJECTS)\n\t$(CC) -o $@ $(LDFLAGS) $^\n\n$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.ihx | $(BUILD_DIR)\n\tpackihx $^ > $@\n\n$(BUILD_DIR):\n\tmkdir $@\n\n\n#######################################\n# clean up\n#######################################\n.PHONY: clean\nclean:\n\t$(RM)$(BUILD_DIR)/*\n\n#######################################\n# build asm\n#######################################\nHEADER_FILE = MS51_16K.h\nHEADER_PATH = App\n\ndisasm: $(BUILD_DIR)/$(TARGET).hex\n\t./tools/mcs51-disasm.pl -M $(HEADER_FILE) -I $(HEADER_PATH) -fl -rj -as $(BUILD_DIR)/$(TARGET).hex > $(BUILD_DIR)/$(TARGET).a51\n\n# *** EOF ***\n\n```\n\n这里说一下，sdcc特有的 `packihx` 命令是用来产生 Intel HEX文件的；`mkdir` 命令在 sdcc中是不支持，可以把他删掉，由于这一点，所以得保留着 build文件夹存放编译文件，如果删除的话，执行会出错；执行 `disasm` 命令需要工具链 mcs51-disasm.pl的支持，它的说明如下：\n\n![image-20201028231938212](image-20201028231938212.png)；另外，`+=` 好像也不支持单文件添加，看 USER_SRC处，只能通过 `wildcard` 扫描添加。。。不知为啥，望大佬解答一二。\n\n\n\n# 程序编译\n\n```c\n#include \"main.h\"\n#include \"bsp.h\"\n#include \"bsp_uart.h\"\n#include \"bsp_time.h\"\n#include \"bsp_eeprom.h\"\n#include \"bsp_adc.h\"\n#include \"bsp_pwm.h\"\n#include \"bsp_wdt.h\"\n\n\n__bit BIT_TMP;\t\t\t//EA暂存（对应官方库）\n\n#define ENABLE_WDT\t\t\t\t1\n\n/* ISR中断函数原型声明（原因看手册 P3.8章节） */\nvoid UART0_ISR(void) __interrupt (4);\nvoid Timer3_ISR(void) __interrupt (16);\n\n\n/************************************************\n函数名称 ： System_Start\n功    能 ： 系统初始化\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid System_Start(void)\n{\n    clr_EA;\n\n    Bsp_Init();\n    UART0_Timer1_Init();\n    Timer3_Init(TIME_DIV16, 15000);  // 10ms\n\t// Timer0_Init();\n\t// ADC_Config();\n\t// PWM0_Init();\n\n#if ENABLE_WDT\n    WDT_Init();\n#endif /* ENABLE_WDT */\n\n    set_EA;\n}\n\n/************************************************\n函数名称 ： main\n功    能 ： 主函数入口\n参    数 ： 无\n返 回 值 ： int\n*************************************************/\nint main(void)\n{\n    uint16_t i = 0;\n\n    System_Start();\n\n\tP12_QUASI_MODE;\n    P12 = 1;\n    for(i=0; i<3; i++)\n    {\n        P12 ^= 1;\n        SoftwareDelay_ms(0xFF);\n    }\n\n#if ENABLE_WDT\n\tWDT_EnableOpen();\n\t\n#else\n\tWDT_DisableClose();\n\t\n#endif /* ENABLE_WDT */\n\t\n    while(1)\n    {\n#if ENABLE_WDT\n        WDT_ReloadCounter();\n#endif /* ENABLE_WDT */\n\n        printf_small(\"\\n Hello world!\");\n        SoftwareDelay_ms(0xFF);\n    }\n}\n\n\n/*---------------------------- END OF FILE ----------------------------*/\n\n\n\n```\n\n然后 `make` 编译，最终输出（方框处显示成功）：\n\n![image-20201028233905135](image-20201028233905135.png)\n\n下载进去，就可以看到 hello world在不停的打印输出了。\n\n在这里，需要注意以下几点：\n\n1、中断函数必须在 main函数文件中给出 ISR原型，不然就无法进中断。详细请看手册的 P3.8章节。以下摘自部分解释：\n\n![image-20201028234927141](image-20201028234927141.png)\n\n2、一般，我们在 C程序中打印输出是调用 `printf` 语句进行输出的，但在 sdcc上，比较建议使用 `printf_small` 输出，因为对于 8位微控制起来说，资源是很紧缺的，使用 `printf_small` 已经可以满足一般输出需求了，当然以上仅限于输出整型以及字符型变量；对于浮点型变量，需要使用特殊的指令对程序进行编译才能得到输出效果，具体的介绍可以看手册的 P3.14.1章节。\n\n3、如果是使用 bin文件烧写到芯片上，可以用 sdcc自带的 makebin.exe 命令行工具进行转换（不过这个转换出来文件比较大），路径可以在 ...\\SDCC\\bin下找到，通过以下命令：`makebin xxx.ihx > xxx.bin`\n\n或者利用 hex2bin，下载地址：https://sourceforge.net/projects/hex2bin/files/latest/download，这个的命令则是：`hex2bin xxx.hex > xxx.bin`\n\nMakefile下的 bin文件生成命令：\n\n![image-20201029233621896](image-20201029233621896.png)\n\n两者相比之下，由于前者是做了剩余空间填充处理的，所以转换出来的文件比较大，个人更倾向于后者。\n\n\n\n# 总结\n\n1、不能使用 double数据类型，否则报错。\n2、make编译只能根据法则编译对应文件夹的全部源文件，不能选择编译相应源文件。\n3、中断函数这里是要在 main函数所在文件处进行原型声明，否者是无法进入中断程序，原因不声明是并没用把中断函数的向量地址加载到执行文件中。\n4、sdcc使用的关键字是跟 keilC51里面的关键字不同的；对于一些非 ANSI C的关键字，SDCC均采用双下滑线开头的方式定义，具体可看 sdcc手册。\n5、sdcc支持的命令行命令，跟我们平常用的 gcc命令行命令有所不同，具体翻看 sdcc手册。\n6、一般串口重定向后，是使用 printf函数输出，但在 sdcc编译器中要改用 printf_small这个函数进行替代。\n\n7、sdcc在编译文件时，会把用不到的代码也编译进来，所以如果空间紧张，建议注释掉一些无关的代码，避免代码空间膨胀。\n\n\n\n# 相关链接\n\n[SDCC Compiler User Guide](http://fivedots.coe.psu.ac.th/~cj/masd/resources/sdcc-doc/SDCCUdoc.html#toc28)\n\n[8051 C Development Using SDCC(Small Device C Compiler)](http://about.uuspider.com/2019/03/05/sdcc.html)\n\n[Nuvoton N76E003 with SDCC](https://github.com/wkaster/N76E003)\n\n[新唐 N76E003 8051 1T 单片机入坑记录](https://whycan.com/t_1275.html)\n\n[SDCC编译器简明使用教程](https://whchen.net/blog/sdcc-simple-to-use-tutorial/)\n\n[使用免费的SDCC C编译器开发DS89C430/450系列微控制器固件](https://www.maximintegrated.com/cn/design/technical-documents/app-notes/3/3477.html)\n\n[51单片机之开发环境使用VSCode结合SDCC取代Keil](https://www.webaun.cn/passages/7/)\n\n[使用Visual Studio Code + CMake + SDCC 进行C51 开发的一次尝试](https://my.oschina.net/etberzin/blog/4561391)\n\n[台湾同胞对 SDCC的使用介绍](http://www.formosaos.url.tw/)\n\n[sdcc man阅读笔记](https://adamsq.github.io/blog/tags/嵌入式/)\n\n[SDCC printf 函數介紹](http://jyhshin3.blogspot.com/2009/04/sdcc-printf.html)\n\n","tags":["history","IDE"]},{"title":"GDB 调试器 + VSCode 开发","url":"/gdb-debuging/","content":"\n\n\n# 软件下载\n\nOpenOCD：https://gnutoolchains.com/arm-eabi/openocd/\n\n一个开源的片上调试器(Open On-Chip Debugger)。在其他平台上，OpenOCD 是要自己 Configure 并且自己编译的，但是 Windows平台上提供了编译好的二进制文件，所以只需要下载下来后随便解压出来就好了。安装完成后添加系统环境变量，可以利用 cmd 命令：openocd -v 测试。\n\n介绍：https://www.berlios.de/software/openocd/\n\n\n\n# 搭建调试链接\n\n在这里需要说明的是，OpenOCD 文件夹下的 `share/openocd/scripts` 里面放的就是 openocd 在运行时所需要用到的各种配置文件，其中 interface文件夹下放的是关于调试器的配置文件，而 `target` 文件夹放的是目标平台的配置文件，这里我们需要的是 `interface/stlink.cfg` 和 `target/stm32l1.cfg`，不过不需要复制出来。注：`stm32l1.cfg` 是要选择你的目标芯片对应的文件，可以进入 `...\\OpenOCD-20200729-0.10.0\\share\\openocd\\scripts\\target` 路径下查找。\n\n连接好 STLink 和板子，如果板子的调试接口正常的话；然后在终端控制台里键入命令：`openocd -f interface/stlink.cfg -f target/stm32l1.cfg` 回车，得到以下信息，即搭建了一个 GDB Server，连通了硬件调试器和 GDB，通过 USB 和硬件调试器连接，并且通过 TCP 和 GDB 连接：\n\n![在这里插入图片描述](20201003000802158.png)\n\n\n\n\n# 下载配置\n\n当你能正确实现以上操作时，那么，关闭终端显示的窗口，使之退出搭建的 GDB Server 链接；然后回到 `tasks.json` 文件里，在原本的 “tasks” 任务标签里再追加以下内容：\n\n```json\n{\n    \"dependsOn\":\"Build\",          // 任务依赖\n    \"label\": \"Build and Download\",\n    \"type\": \"shell\",\n    \"command\": \"openocd\", \n    \"args\": [\n    \"-f\",\n    \"interface/stlink.cfg\",\n    \"-f\",\n    \"target/stm32l1.cfg\",\n    \"-c\",\n    \"program ./build/${workspaceFolderBasename}.elf verify reset exit\"\n    ],\n    \"problemMatcher\": []\n}\n```\n\n最后变成：\n\n![在这里插入图片描述](20201003000817141.png)\n\n\n这个任务要求先进行 Build 任务，然后通过命令打开 openocd，加载两个配置文件（`-f interface/stlink.cfg` 和 `-f target/stm32l1.cfg`），同时，这个 `-c` 的选项后面跟着的就是 openocd 成功加载后执行的内置命令，这里我们让它下载、验证、reset，然后直接退出，这样就实现了一条龙式的下载。运行这个任务的方法就跟 Build 一样，在此就不过多介绍了，最后运行该任务你会发现，这小破板跑起来。\n\n这里其实是经过了进入调试处理的操作，只不过我们让它自动退出了调试模式而已；因为下载和调试的区别是，下载只是把代码加载到芯片里，而不进行调试，也不会切换到调试页面，其实调试就已经会将代码下载到板子上了，所以这里所设置的下载，其实并不是单纯的下载，而是经过了进入调试，退出调试这样的操作，使我们人为的觉得是下载操作。\n\n\n\n# 调试配置\n\n在窗口里点击 运行 -> 添加配置：\n\n![在这里插入图片描述](2020100300084420.png)\n\n\n接着，如果根据上一篇安装了 Cortex Debug 插件，就会出现如下选项（ps：如果窗口打开的是 `.c` 文件或者 `.h` 文件，只会显示前面两个选项，不知道是我电脑问题还是咋的，可以试着切换打开到 `.json` 文件或者打开 `makefile` 文件）：\n\n![在这里插入图片描述](20201003000854507.png)\n\n\n点击框选的选项，在 `.vscode` 文件里会创建一个 `launch.json` 文件，然后把里面的内容修改成以下样子：\n\n```json\n{\n    // 使用 IntelliSense 了解相关属性。 \n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Cortex Debug\",\n            \"cwd\": \"${workspaceRoot}\",  // 输出路径\n            \"executable\": \"./build/${workspaceRootFolderName}.elf\",    // 要调试的程序\n            \"request\": \"launch\",\n            \"type\": \"cortex-debug\",\n            \"servertype\": \"openocd\",    // 调试器选择\n            \"device\": \"STM32L151CB\",    // 使用J-link GDB Server时必须；其他GBD Server时可选（有可能帮助自动选择 SVD文件）。支持的设备见 https://www.segger.com/downloads/supported-devices.php\n            //\"svdFile\": \"./STM32L15xC.svd\",  // svd文件，有这个文件才能查看寄存器的值，每个单片机都不同。可以在以下地址找到 https://github.com/posborne/cmsis-svd下载\n            \"interface\": \"swd\",\n            \"configFiles\": [\n                //\"${workspaceRoot}/openocd.cfg\",\t// *可以通过加载该文件来配置\n                \"interface/stlink.cfg\",\n                \"target/stm32l1.cfg\"\n            ],\n            \"runToMain\": false,\n            \"preLaunchTask\": \"Build\",   // 在调试前预先执行的任务，此处是tasks.json中的\n            //\"armToolchainPath\": \"C:\\\\Program Files (x86)\\\\GNU Tools ARM Embedded\\\\5.4 2016q3\\\\bin\"    // 如果没有把 arm工具链路径添加到系统环境变量，则需要这条指令添加你的路径\n        }\n    ]\n}\n```\n\n这里主要就是指定 `preLaunchTask`，顾名思义就是先运行某个任务后再启动调试，我们这里要先运行前面配置的 `Build` 任务，意为先编译再进行调试操作；`servertype` 调试器这里，我们就使用 `openocd` 就好了，因为它支持各种不同的调试器，若是仅使用Jink，不用其他的调试器，那么，你可以改成 jlink，然后参考：[https://zhuanlan.zhihu.com/p/163771273](https://zhuanlan.zhihu.com/p/163771273)；`device` 是指定 STM32 的芯片型号，如果支持，则可以帮助调试器显示外设寄存器的值；`configFiles` 就是前面说到需要加载的那两个配置文件了（类似于键入命令：`openocd –f interface/jlink.cfg –f target/stm32f4.cfg`）；`runToMain` 就是选择程序是从 main 函数开始加载，还是从汇编代码开始加载，stm32 启动都是从 `startup_stm32xxx.s` 开始的，所以这里得选择 `false`。\n\n然后在这里说一下，在 `configFiles` 中，注释了一行，在正常情况下，如果我们不带参数启动（即所谓的单纯键入命令：`openocd`），openocd 就会默认自动查找当前目录下有没有名为 openocd.cfg的文件，并把它作为配置文件来启动。若是你想在利用 `openocd.cfg` 来加载配置，那么就要在工程路径下（对应你在 `configFiles` 所填的路径文件）创建一个 `openocd.cfg` 文件，并添加以下内容：\n\n```cfg\n# 选择调试器为JLink or CMSIS-DAP or STlink\n#source [find interface/jlink.cfg]\n#source [find interface/cmsis-dap.cfg]\nsource [find interface/stlink.cfg]\n\n# 选择接口为SWD，jlink下打开\n#transport select swd\n\n# 选择目标芯片\nsource [find target/stm32l1.cfg]\n```\n\n实际上并不推荐这种方式，因为又要创建，又把 `launch.json` 的配置分开了，当整体移植 `.vscode` 文件夹并更换目标芯片时容易出现漏改参数。\n\n\n\n# DEBUG 调试\n\n在配置完成以上的 `launch.json` 调试参数后，点击窗口 运行 -> 启动调试（或者直接按 f5），就可以进入 debug 模式了：\n\n![在这里插入图片描述](20201003000740708.png)\n\nVSCode 监视窗口 16 进制查看表达式，只需要在表达式后面加 `,h` ，eg：\n`buf,h`，则以 16 进制显示 `buf` 的值。\n\n\n\n# GDB 常用命令\n\n- 显示内存值 `x/<n><f><u> <addr>` （以 `<f>` 格式打印从 `<addr>` 开始的 `<n>` 个长度单元为 `<u>` 的内存值）：\n  - `<n>` 表示要查看几个内存单元\n  - `<f>` 表示显示的格式，`x` 以十六进制输出，`d` 以十进制输出，`u` 以十六进制无符号输出，`o` 以八进制输出，`t` 以二进制输出，`c` 以字符格式输出，`s` 以字符串格式输出，`f` 以浮点型数据输出\n  - `<u>` 表示内存单元的大小，`b` 是 1 byte，`h` 是 2 byte（halfword），`w` 是 4 byte（word），`g` 是 8 byte（giant word）\n  - `<addr>` 可以是地址，也可以是变量名\n\n- 查找函数地址 `info address <func_name>`\n\n- 反找函数名 `info symbol <func_addr>`\n\n\n\nhttps://sourceware.org/gdb/current/onlinedocs/gdb.html/index.html#SEC_Contents\n\nhttps://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html\n\n对于使用 gdb server 调试，可看：https://openocd.org/doc/html/Server-Configuration.html\n\n","tags":["history","IDE"]},{"title":"GCC 编译器 + VSCode 开发","url":"/gcc-develop/","content":"\n\n\n# 程序安装\n\n1、VSCode：https://code.visualstudio.com/Download\n\n好用到爆的文本编辑器，配合强大的插件，使你的开发效率大大提高。\n\n2、Java：https://www.java.com/zh-CN/download/\n\nSTM32CubeMX的安装需要 JAVA 运行环境（jre）。\n\n3、STM32CubeMX：https://my.st.com/content/my_st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html\n\n支持最新的 HAL 库及 LL 库，工程代码配置与生成工具，支持生成 IAR、Keil、STM32CubeIDE、Makefile 等工程，这里使用其生成的 Makefile 工程。\n\n4、MinGW-w64：https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/\n\n一个强大并实用的 C/C++ 编译器。安装完成后需要添加系统环境变量，可以利用 cmd 命令：gcc -v 测试。\n\n5、arm-none-eabi-gcc：https://launchpad.net/gcc-arm-embedded/+download\n\nGUN的 arm的通用交叉编译链工具，基本上常用的 arm 处理器均支持。同样的，安装完成后需要添加系统环境变量，可以利用 cmd命令：arm-none-eabi-gcc -v 测试。\n\n\n\n# CubeMX工程生成\n\n目前 STM32 现在主推的库是 HAL 库，当然还有个 LL库用于操作底层寄存器；对于 HAL 库，官方专门推出了图形化软件 CubeMX 来简化 HAL库下 STM32 的初始化代码；我们只需要配置好相应的外设功能以及时钟树，点击生成代码，CubeMX 便会生成相应工程文件，并且还支持多种 IDE 工具，实乃居家旅行出门必备啊。咳，偏题！\n\n首先，选择你的目标芯片，启动工程配置，这里就简单的弄个 LED 控制跟 DEBUG 配置。\n\n串口配置就像下图那样，像我们平常一样，异步通讯，Baud rate:115200、8Bit、1Stop Bit\n\n![在这里插入图片描述](20201001010129515.png)\n\n接着就配置 LED IO 引脚，直接点击对应引脚进行配置，如下图所示：\n\n![在这里插入图片描述](20201001010143209.png)\n\n这软件怎么用在这里就不多赘述了，还有就是稍微注意一下：\n\n如果要使用 STLink 等在线调试器，那么需要在下图的指示处选择你所需要调试方式：\n\n![在这里插入图片描述](2020100101015795.png)\n\n对于时钟树，像我们一般是有使用 HSE 高速外部晶振，那么你就需要在 RCC 那里打开相应的配置：\n\n![在这里插入图片描述](20201001010208659.png)\n\n\n接着在时钟配置那里配置相应的外设时钟：\n\n![在这里插入图片描述](20201001010221464.png)\n\n\n最后，由于我们是想要在 VSCode 上开发，就直接选择生成 `Makefile` 就可以了。需要特别说明的是，这一步并不是必须的，完全可以不用 CubeMX，自己写 `Makefile` 也是可以的。然后输出生成工程文件。\n\n![在这里插入图片描述](20201001010233796.png)\n\n\n\n# VSCode环境部署\n\n**1、插件安装**\n\n| 插件                                                      | 功能                                                         |\n| --------------------------------------------------------- | ------------------------------------------------------------ |\n| Chinese (Simplified) Language Pack for Visual Studio Code | 中文（简体）语言包                                           |\n| Comment Translate                                         | VSCode 注释翻译                                              |\n| C/C++                                                     | C / C ++的语言支持,语法智能感知、加亮及调试功能，当然需要系统安装 arm-none-eabi-gcc 编译器 |\n| Cortex Debug                                              | 提供 jlink、stlink 等调试接口功能                            |\n| ARM                                                       | arm 汇编语言支持                                             |\n| vscode-icons                                              | 文件图标，可快速查看文件类型                                 |\n\n**2、配置 VS Code**\n\n首先，把从 STM32CubeMX 创建出来的工程导入到 VS Code 里面，得到：\n\n![在这里插入图片描述](20201001010251349.png)\n\n\n默认情况下，工程中是不含 `.vscode` 的文件夹的，通过操作以下三种方式时会自动创建：\n\n打开命令窗口进行编辑配置（Ctrl+Shitf+P > Edit Configurations(JSON)）\n\n![在这里插入图片描述](20201001010320901.png)\n\n\n或点击窗口栏的 终端 -> 配置任务 -> 使用模板创建 `task.json` -> Other\n\n![在这里插入图片描述](20201001010335263.png)\n\n或修改工作区里的 `settings.json` 文件（窗口 File--Preferences--Settings--Features--Terminal 的 Terminal > Integrated > Automation Shell: Windows 栏中进行编辑）\n\n![在这里插入图片描述](20201001010345892.png)\n\n\n这三个创建出来的效果如下：\n\n![在这里插入图片描述](20201001010401423.png)\n\n\n先说前面两个文件：\n\n- **c_cpp_properties.json**\n\n主要有添加 include 路径，编译器路径，宏定义等；设置好后，索引、编译就跟 keil 一样方便。然后，它的配置修改如下：\n\n```json\n{\n    \"configurations\": [\n        {\n            \"name\": \"STM32\",\t\t// 创建一个名为\"STM32\"的配置\n            \"includePath\": [\t\t// 声明这个工作区的 C/C++工程包含了哪些头文件目录\n                \"${workspaceFolder}/**\",\n                \"${workspaceFolder}/Drivers/CMSIS/Device/ST/STM32L1xx/Include\",\n                \"${workspaceFolder}/Drivers/CMSIS/Include\",\n                \"${workspaceFolder}/Drivers/STM32L1xx_HAL_Driver/Inc\",\n                \"${workspaceFolder}/Drivers/STM32L1xx_HAL_Driver/Inc/Legacy\",\n                \"${workspaceFolder}/Core/Inc\"\n            ],\n            \"defines\": [\t\t\t// 全局的预处理宏定义\n                \"STM32L151xB\",\n                \"USE_HAL_DRIVER\"\n            ],\n            \"compilerPath\": \"gcc.exe\",\t\t// 如果添加了环境变量，可以像这样表示；否则就得加绝对路径，如：C:\\\\Program Files\\\\mingw64\\\\bin\\\\gcc.exe\n            \"cStandard\": \"c11\",\t\t\t\t// 使用的 C标准\n            \"cppStandard\": \"c++17\",\t\t\t// 使用的 C++标准\n            \"intelliSenseMode\": \"gcc-x64\"\t// 语言风格\n        }\n    ],\n    \"version\": 4\n}\n```\n\n注意：这个 json 不允许有注释，所以，如果是像复制到你的文件里，记得把注释删了。\n\n- **tasks.json**\n\n这个文件下 tasks 数组里的每一个对象都代表着一个任务。\n\n```json\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n          \"label\": \"Build\",\t\t\t// 标签名\n          \"type\": \"shell\",\t\t\t// 终端（shell）型的任务\n          \"command\": \"make\",\t\t// *执行的命令\n          \"args\": [\t\t\t\t\t// 命令的参数\n            \"-j6\"\t\t\t\t\t// 表示六线程同时编译\n          ],\n          \"problemMatcher\": [\"$gcc\"],\t// 表示如果出现了编译报错，问题面板会显示 gcc类型的错误\n          \"group\": {\n            \"kind\": \"build\",\n            \"isDefault\": true\n          }\n        }\n      ]\n}\n```\n\n注意：上面的 \"command\" 选项中填的是 \"make\"；实际上，在我们下载的 MinGW-w64 编译器中，执行的是 mingw32-make.exe；但是，这里可以看到 mingw32-make.exe 文件名太长，并且不好记，因此我们可以将其复制并重命名为 make.exe 这样就与 Linux下的 make 命令保持一致了；如果没有像前面说的那样复制出 make.exe，那么，在 \"command\" 选项中填则是 \"mingw32-make\"，同样的在执行编译操作时，键入的命令则是 mingw32-make。\n\n- **settings.json**\n\n这个留着后面结合实例来说。\n\n\n\n# 工程编译\n\n当你配置完成上面的操作后，最最最好就是先保存所有文件，然后关闭 VS Code，再重新打开工程。\n\n编译有两种：\n\n1、点击窗口栏的 终端 -> 运行生成任务（快捷键 Ctrl+Shitf+B）\n\n![在这里插入图片描述](20201001010428974.png)\n\n2、点击窗口栏的 终端 -> 新终端，选择 cmd\n\n![在这里插入图片描述](2020100101044477.png)\n\n\n没有的话，那就点击一下它，然后点 “选择默认 Shell”，再点击旁边的垃圾桶，再重新打开一下。\n\n键入 `make`，最后按回车键。当编译完成后就会像下图这样显示编译文件大小：\n\n![在这里插入图片描述](20201001010458669.png)\n\n\n\n# 编译清除\n\n编译文件清除，只需要在终端命令台里键入 `make clean` 就可以了，但是，但是，如果使用的是 cmd 的 shell，你会发现：\n\n![在这里插入图片描述](20201001010520846.png)\n\n\n并没有清除掉编译出来的文件。这是为什么呢？可以在这里得到答案：https://github.com/STAT545-UBC/Discussion/issues/55\n\n根据里面的描述可以总结为：\n\n解决方法1：使用 Windows版本的 `rm` 是 `del` ，因此可以简单地用 `rm` 替换成 `del` 。但是要注意，这样做意味着您将无法使用 Git Bash shell，因为它不支持 `del` 命令程序；\n\n解决方案2：假设你已安装 Git Bash（没有那就安装 [Git](https://git-scm.com/)呗，都 0202了，不会还有人不用 Git 吧，实在实在不想用 Git，那么就找个支持 `rm` 的终端命令台，例如：[msys2](http://www.msys2.org/)），那么你可以把终端命令台切换到 Bash上面\n\n第一个就简单了，在 makefile 里把 `rm` 替换成 `del` ，如下图所示：\n\n![在这里插入图片描述](20201001010543269.png)\n\n第二个，就像上面那样重新点击 “选择默认 Shell”，然后选择 Git bash\n\n![在这里插入图片描述](20201001010616688.png)\n\n![在这里插入图片描述](20201001010555724.png)\n\n\n然后，用这种操作去修改终端 Shell，不同项目对于选择不同的终端，有时候需要经常切换，不方便；那么就有了工作区 `settings.json` 文件配置的作用了。\n\n在 `settings.json` 文件中，我们只需要配置如下操作：\n\n```json\n{\n\t/* 终端在Windows上使用的shell的路径 */\n    \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\",\t// 如果添加了环境变量可以去掉路径\n    \"terminal.external.windowsExec\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\"\t\t// 与上面同理\n}\n```\n\n如此一来，那么就只在该项目工作区内产生作用效果。\n\n你看，颜色都不一样的：\n\n![在这里插入图片描述](20201001010634906.png)\n\n\n\n# 其他\n\n下一篇，下载&调试环境搭建：[GDB 调试器 + VSCode 开发](https://arachnid.cc/gdb-debuging/)","tags":["history","IDE"]},{"title":"CPU、MPU、MCU、SoC、MCM 介绍","url":"/cpu-soc-mcu/","content":"\n\n\n# CPU\n\n**中央处理器** （英语：Central Processing Unit，缩写：CPU）是计算机的主要设备之一，功能主要是解释计算机指令以及处理计算机软件中的数据。计算机的可编程性主要是指对中央处理器的编程。1970年代以前，中央处理器由多个独立单元构成，后来发展出由集成电路制造的中央处理器，这些高度收缩的组件就是所谓的微处理器，其中分出的中央处理器最为复杂的电路可以做成单一微小功能强大的单元，也就是所谓的核心。\n\n![在这里插入图片描述](202009051713285.png)\n\n它是一台计算机的运算核心和控制核心。CPU 由运算器、控制器和寄存器及实现它们之间联系的数据、控制及状态的总线构成。差不多所有的 CPU 的运作原理可分为四个阶段：提取(Fetch)、解码(Decode)、执行(Execute)和写回(Writeback)。 CPU 从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，并执行指令。所谓的计算机的可编程性主要是指对 CPU 的编程。\n\n详细介绍可看：[中央处理器](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8)\n\n\n# MPU\n\n**微处理器**（英语：Microprocessor，缩写：µP 或 uP）是可编程特殊集成电路。一种处理器，其所有组件小型化至一块或数块集成电路内。一种集成电路，可在其一端或多端接受编码指令，执行此指令并输出描述其状态的信号。这些指令能在内部输入、集中或存放起来。是微型计算机的一个主要部件。\n\n![在这里插入图片描述](20200905171349110.png)\n\n其通常代表一个功能强大的 CPU(暂且理解为增强版的 CPU 吧)，但不是为任何已有的特定计算目的而设计的芯片。这种芯片往往是个人计算机和高端工作站的核心 CPU。Intel X86，ARM 的一些 Cortex-A 芯片如飞思卡尔 i.MX6、全志 A20、TI AM335X 等都属于 MPU。\n\n详细介绍可看：[微处理器](https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8)\n\n\n# MCU\n\n**微控制器**（英语：Microcontroller），又称**单片机**，全称单片微型计算机（single-chip microcomputer），是把中央处理器、存储器、定时/计数器（timer/counter）、各种输入输出接口等都集成在一块集成电路芯片上的微型计算机。与应用在个人电脑中的通用型微处理器相比，它更强调自供应（不用外接硬件）和节约成本。它的最大优点是体积小，可放在仪表内部，但存储量小，输入输出接口简单，功能较低。\n\n![在这里插入图片描述](20200905171402420.png)\n\n随着大规模集成电路的出现及其发展，将计算机的 CPU、RAM、ROM、定时计数器和多种 I/O 接口集成在一片芯片上，形成芯片级的芯片，比如 51，AVR、Cortex-M 这些芯片，内部除了 CPU 外还有 RAM、ROM，可以直接加简单的外围器件(电阻，电容)就可以运行代码了。而如 x86、ARM 这些 MPU 就不能直接放代码了，它只不过是增强版的 CPU，所以得添加 RAM，ROM。\n\n详细介绍可看：[微控制器](https://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E6%9C%BA)\n\n\n# SoC\n\n**单片系统**或**片上系统**（英语：System on a Chip，缩写：SoC）是一个将电脑或其他电子系统集成到单一芯片的集成电路。单片系统可以处理数字信号、模拟信号、混合信号甚至更高频率的信号。单片系统常常应用在嵌入式系统中。单片系统的集成规模很大，一般达到几百万门到几千万门。\n\n![在这里插入图片描述](20200905171425101.png)\n\nMCU 只是芯片级的芯片，而 SOC 是系统级的芯片，它既 MCU(51，avr) 那样有内置 RAM、ROM 同时又像 MPU 那样强大，不单单是放简单的代码，可以放系统级的代码，也就是说可以运行操作系统(将就认为是 MCU 集成化与 MPU 强处理力各优点二合一)。\n\n详细介绍可看：[片上系统](https://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E7%B3%BB%E7%BB%9F)\n\n\n# MCM\n\n**多芯片模组**（英语：Multi-Chip Module，缩写：MCM），是一种裸晶（die）、芯片、集成电路的包装、封装技术（Package），此种封装技术能在一个封装内容纳两个或两个以上的裸晶，而在此技术未发创前，一个封装内多半只有一个裸晶。\n\n![在这里插入图片描述](20200905171445347.png)\n\nMCM依据制造方式的不同而有不同的类型，差别主要在于高密度互连（High Density Inteconnection；HDI）基板（Substrate）的形成方式：\n\n - MCM-L（Laminated MCM）层压式 MCM，基板部分用多层的薄型印刷电路板（Printed Circuit\n   Board；PCB）所构成。\n - MCM-D（Deposited MCM）堆积式 MCM，将多片使用薄膜技术制成的基板加以叠堆而成。\n - MCM-C（Ceramic Substrate MCM）陶瓷基板式 MCM。\n\n详细介绍可看：[多芯片模组](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%99%B6%E7%89%87%E6%A8%A1%E7%B5%84)\n\n\n# 对比\n\n![在这里插入图片描述](20200905171640349.jpg)\n\n视频讲解（需要科学上网）：[Difference between CPU, MPU, MCU, SOC, and MCM](https://www.youtube.com/watch?v=ntNkN6dGv_0&vl=ar)\n\n网上流传的一张脑图，可以详细地了解它们之间联系以及特性：\n\n![在这里插入图片描述](cpu、mpu、mcu、soc、mcm.png)\n\n脑图链接（可放大观看）：https://www.processon.com/view/link/5c91f1b6e4b09a16b9a9acfe#map","tags":["history"]},{"title":"常用滤波算法（纯C实现）","url":"/filtering-algorithm/","content":"\n\n\n# 限幅滤波法（又称程序判断滤波法）\n## A、方法：\n\n 1. 根据经验判断，确定两次采样允许的最大偏差值（假设设为 A）\n 2. 每次检测到新值时判断：\n 如果本次值与上次值之差 <= A,则本次值有效\n 如果本次值与上次值之差 > A，则本次值无效，放弃本次值，用上次值代替本次值\n## B、优点：\n 1. 能有效克服因偶然因素引起的脉冲干扰\n## C、缺点：\n 1. 无法抑制那种周期性的干扰\n 2. 平滑度差\n\n## D、代码：\n```c\n#if LIMITING\nData_Typedef Limiting_Filter( Data_Typedef Value, int Range )\n{\n    Data_Typedef new_value;\n\n    new_value = Get_AD();\n    DUBUG_PRINTF(\"A%f\\r\\n\", new_value);\n    if((new_value - Value > Range)\n            || (Value - new_value > Range))\n    {\n        return Value;\n    }\n\n    return new_value;\n}\n\n#endif /* LIMITING */\n\n```\n\n\n# 中位值滤波法\n## A、方法：\n 1. 连续采样N次（N取奇数）\n 2. 把N次采样值按大小排列\n 3. 取中间值为本次有效值\n\n## B、优点：\n 1. 能有效克服因偶然因素引起的波动干扰\n 2. 对温度、液位的变化缓慢的被测参数有良好的滤波效果\n\n## C、缺点：\n 1. 对流量、速度等快速变化的参数不宜\n\n## D、代码：\n```c\n#if MEDIAN\nData_Typedef Median_Filter( int Count )\n{\n    int i,j;\n    Data_Typedef temp;\n    Data_Typedef *str;\n\n    if(0 == Count % 2)\n        Count++;\n\n    str = (Data_Typedef*)malloc(Count * sizeof(Data_Typedef));\n\n    if(str != NULL) {\n        for(i = 0; i < Count; i++) {\n            temp = Get_AD();\n            *(str + i) = temp;\n            DUBUG_PRINTF(\"A%f\\r\\n\", temp);\n            Delay(0x10F);\n        }\n        /* 冒泡排序 */\n        for(j = 0; j < Count - 1; j++) {\n            for(i = 0; i < Count - j - 1; i++) {\n                if(*(str + i) > *(str + i + 1)) {\n                    temp = *(str + i);\n                    *(str + i) = *(str + i + 1);\n                    *(str + i + 1) = temp;\n                }\n            }\n        }\n    } else {\n        return -1;\n    }\n\n    temp = *(str + (Count-1)/2);\n\n    free(str);\n\n    return temp;\n}\n\n#endif /* MEDIAN */\n\n```\n\n\n\n# 算术平均滤波法\n## A、方法：\n 1. 连续取N个采样值进行算术平均运算\n 2. N值较大时：信号平滑度较高，但灵敏度较低\n 3. N值较小时：信号平滑度较低，但灵敏度较高\n 4. N值的选取：一般流量，N=12；压力：N=4\n\n## B、优点：\n 1. 适用于对一般具有随机干扰的信号进行滤波\n 2. 这样信号的特点是有一个平均值，信号在某一数值范围附近上下波动\n\n## C、缺点：\n 1. 对于测量速度较慢或要求数据计算速度较快的实时控制不适用\n 2. 比较浪费RAM\n\n## D、代码：\n```c\n#if MEAN\nData_Typedef Mean_Filter( int Count )\n{\n    int i;\n    Data_Typedef temp;\n    Data_Typedef sum = 0;\n\n    for(i = 0; i < Count; i++) {\n        temp = Get_AD();\n        sum += temp;\n        DUBUG_PRINTF(\"A%f\\r\\n\", temp);\n        Delay(0x10F);\n    }\n\n    return (Data_Typedef)(sum / Count);\n}\n\n#endif /* MEAN */\n\n```\n\n\n\n# 递推平均滤波法\n## A、方法：\n 1. 把连续取N个采样值看成一个队列\n 2. 队列的长度固定为N\n 3. 每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)\n 4. 把队列中的N个数据进行算术平均运算,就可获得新的滤波结果\n 5. N值的选取：流量，N=12；压力：N=4；液面，N=4 ~ 12；  温度，N=1 ~ 4\n\n## B、优点：\n 1. 对周期性干扰有良好的抑制作用，平滑度高\n 2. 适用于高频振荡的系统\n\n## C、缺点：\n 1. 灵敏度低\n 2. 对偶然出现的脉冲性干扰的抑制作用较差\n 3. 不易消除由于脉冲干扰所引起的采样值偏差\n 4. 不适用于脉冲干扰比较严重的场合\n 5. 比较浪费RAM\n\n## D、代码：\n```c\n#if RECURSIVE_MEAN\nData_Typedef Recursive_Mean_Filter( int Count )\n{\n    static int Start = 0;\n    static int Num = 0;\n    int i;\n    Data_Typedef temp;\n    Data_Typedef sum = 0;\n    Data_Typedef *str;\n\n    if(0 == Start) {\n        Start = Count;\n        str = (Data_Typedef*)calloc(Count, sizeof(Data_Typedef));\n    } else if(Start != Count) {\n        Start = Count;\n        str = (Data_Typedef*)realloc(str, Count);\t\t// 重新分配\n    }\n\n    if(str != NULL) {\n        temp = Get_AD();\n        *(str + Num++) = temp;\n        DUBUG_PRINTF(\"A%f\\r\\n\", temp);\n        // 覆盖最早采样的数据，相当于递推数据 FIFO\n        if(Num >= Count)\n            Num = 0;\n\n        for(i = 0; i < Count; i++) {\n            sum += *(str + i);\n        }\n    } else {\n        return -1;\n    }\n\n    return (Data_Typedef)(sum / Count);\n}\n\n#endif /* RECURSIVE_MEAN */\n\n```\n\n\n\n# 中位值平均滤波法\n## A、方法：\n 1. 相当于“中位值滤波法” + “算术平均滤波法”\n 2. 连续采样N个数据，去掉一个最大值和一个最小值\n 3. 然后计算N-2个数据的算术平均值\n 4. N值的选取：3~14\n\n## B、优点：\n 1. 融合了两种滤波法的优点\n 2. 对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差\n\n## C、缺点：\n 1. 测量速度较慢，和算术平均滤波法一样\n 2. 比较浪费RAM\n\n## D、代码：\n```c\n#if MEDIAN_MEAN\nData_Typedef Median_Mean_Filter( int Count )\n{\n    int i,j;\n    Data_Typedef temp;\n    Data_Typedef sum = 0;\n    Data_Typedef *str;\n\n    if(0 == Count % 2)\n        Count++;\n\n    str = (Data_Typedef*)malloc(Count * sizeof(Data_Typedef));\n\n    if(str != NULL) {\n        for(i = 0; i < Count; i++) {\n            temp = Get_AD();\n            *(str + i) = temp;\n            DUBUG_PRINTF(\"A%f\\r\\n\", temp);\n            Delay(0x10F);\n        }\n        for(j = 0; j < Count - 1; j++) {\n            for(i = 0; i < Count - j - 1; i++) {\n                if(*(str + i) > *(str + i + 1)) {\n                    temp = *(str + i);\n                    *(str + i) = *(str + i + 1);\n                    *(str + i + 1) = temp;\n                }\n            }\n        }\n    } else {\n        return -1;\n    }\n\n    /* 去除最大最小极值后求平均 */\n    for(i = 1; i < Count - 1; i++)\n        sum += *(str + i);\n\n    free(str);\n\n    return (Data_Typedef)(sum / (Count - 2));\n}\n\n#endif /* MEDIAN_MEAN */\n\n```\n\n\n\n# 限幅平均滤波法\n## A、方法：\n 1. 相当于“限幅滤波法” + “递推平均滤波法”\n 2. 每次采样到的新数据先进行限幅处理\n 3. 再送入队列进行递推平均滤波处理\n\n## B、优点：\n 1. 融合了两种滤波法的优点\n 2. 对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差\n\n## C、缺点：\n 1. 比较浪费RAM\n\n## D、代码：\n```c\n#if LIMITING_MEAN\nData_Typedef Limiting_Mean_Filter( int Range, int Count )\n{\n    static int Start = 0;\n    static int Num = 0;\n    static Data_Typedef Value = 0;\n    int i;\n    Data_Typedef new_value;\n    Data_Typedef sum = 0;\n    Data_Typedef *str;\n\n    if(0 == Start) {\n        Start = Count;\n        Value = Get_AD();\n        str = (Data_Typedef*)calloc(Count, sizeof(Data_Typedef));\n    } else if(Start != Count) {\n        Start = Count;\n        Value = Get_AD();\n        str = (Data_Typedef*)realloc(str, Count);\t\t// 重新分配\n    }\n\n    if(str != NULL) {\n        new_value = Get_AD();\n        if((new_value - Value > Range)\n                || (Value - new_value > Range))\n        {\n            *(str + Num++) = Value;\n        } else {\n            *(str + Num++) = new_value;\n            Value = new_value;\n        }\n        DUBUG_PRINTF(\"A%f\\r\\n\", Value);\n\n        if(Num >= Count)\n            Num = 0;\n\n        for(i = 0; i < Count; i++) {\n            sum += *(str + i);\n        }\n    } else {\n        return -1;\n    }\n\n    return (Data_Typedef)(sum / Count);\n}\n\n#endif /* LIMITING_MEAN */\n\n```\n\n\n\n# 一阶滞后滤波法\n## A、方法：\n\n 1. 取滤波系数 a=0~1\n 2. 本次滤波结果=（1-a）×上次滤波结果 + a×本次采样值\n\n## B、优点：\n\n 1. 对周期性干扰具有良好的抑制作用\n 2. 适用于波动频率较高的场合\n\n## C、缺点：\n\n 1. 相位滞后，灵敏度低\n 2. 滞后程度取决于a值大小\n 3. 不能消除滤波频率高于采样频率的1/2的干扰信号\n\n## D、代码：\n```c\n#if LOW_PASS\nData_Typedef Low_Pass_Filter( Data_Typedef Value, float Factor )\n{\n    Data_Typedef new_value;\n\n    new_value = Get_AD();\n    DUBUG_PRINTF(\"A%f\\r\\n\", new_value);\n    new_value = (Data_Typedef)(new_value * Factor + (1.0f - Factor) * Value);\n\n    return new_value;\n}\n\n#endif /* LOW_PASS */\n\n```\n\n\n\n# 加权递推平均滤波法\n## A、方法：\n\n 1. 是对递推平均滤波法的改进，即不同时刻的数据加以不同的权\n 2. 通常是，越接近现时刻的数据，权取得越大。\n 3. 给予新采样值的权系数越大，则灵敏度越高，但信号平滑度越低\n\n## B、优点：\n\n 1. 适用于有较大纯滞后时间常数的对象\n 2. 和采样周期较短的系统\n\n## C、缺点：\n\n 1. 对于纯滞后时间常数较小，采样周期较长，变化缓慢的信号\n 2. 不能迅速反应系统当前所受干扰的严重程度，滤波效果差\n\n## D、代码：\n```c\n#if WEIGHTED_RECURSIVE_MEAN\nData_Typedef Weighted_Recursive_Mean_Filter( char *Weight_factor, int Count )\n{\n    static int Sum_coe;\n    static int Start = 0;\n    static int Num = 0;\n    int i;\n    Data_Typedef temp;\n    Data_Typedef sum = 0;\n    Data_Typedef *str;\n\n    if(0 == Start) {\n        Start = Count;\n        str = (Data_Typedef*)calloc(Count, sizeof(Data_Typedef));\n        for(i = 0; i < Count; i++) {\n            Sum_coe += *(Weight_factor + i);\n        }\n    } else if(Start != Count) {\n        Start = Count;\n        str = (Data_Typedef*)realloc(str, Count);\t\t// 重新分配\n        for(i = 0; i < Count; i++) {\n            Sum_coe += *(Weight_factor + i);\n        }\n    }\n\n    if(str != NULL) {\n        temp = Get_AD();\n        *(str + Num++) = temp;\n        DUBUG_PRINTF(\"A%f\\r\\n\", temp);\n        // 覆盖最早采样的数据，相当于递推数据 FIFO\n        if(Num >= Count)\n            Num = 0;\n\n        for(i = 0; i < Count; i++) {\n            sum += *(str + i) * *(Weight_factor + i);\n        }\n    } else {\n        return -1;\n    }\n\n    return (Data_Typedef)(sum / Sum_coe);\n}\n\n#endif /* WEIGHTED_RECURSIVE_MEAN */\n\n```\n\n\n\n# 消抖滤波法\n## A、方法：\n\n 1. 设置一个滤波计数器\n 2. 将每次采样值与当前有效值比较：\n如果采样值＝当前有效值，则计数器清零\n如果采样值< >当前有效值，则计数器+1，并判断计数器是否>=上限N(溢出)\n如果计数器溢出,则将本次值替换当前有效值,并清计数器\n\n## B、优点：\n\n 1. 对于变化缓慢的被测参数有较好的滤波效果\n 2. 可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动\n\n## C、缺点：\n\n 1. 对于快速变化的参数不宜\n 2. 如果在计数器溢出的那一次采样到的值恰好是干扰值，则会将干扰值当作有效值导入系统\n\n## D、代码：\n```c\n#if DEBOUNCE\nData_Typedef Debounce_Filter( Data_Typedef Value, int Count )\n{\n    static int Num = 0;\n    Data_Typedef new_value;\n\n    new_value = Get_AD();\n\tDUBUG_PRINTF(\"A%f\\r\\n\", new_value);\n    if(Value != new_value) {\n        Num++;\n        if(Num > Count) {\n            Num = 0;\n            Value = new_value;\n        }\n    }\n    else\n        Num = 0;\n\n    return Value;\n}\n\n#endif /* DEBOUNCE */\n\n```\n\n\n\n# 限幅消抖滤波法\n## A、方法：\n\n 1. 相当于“限幅滤波法” + “消抖滤波法”\n 2. 先限幅,后消抖\n\n## B、优点：\n\n 1. 继承了“限幅”和“消抖”的优点\n 2. 改进了“消抖滤波法”中的某些缺陷,避免将干扰值导入系统\n\n## C、缺点：\n\n 1. 对于快速变化的参数不宜\n\n## D、代码：\n```c\n#if LIMITING_DEBOUNCE\nData_Typedef Limiter_Debounce_Filter( Data_Typedef Value, int Range, int Count )\n{\n    static int Num = 0;\n    Data_Typedef new_value;\n\n    new_value = Get_AD();\n    DUBUG_PRINTF(\"A%f\\r\\n\", new_value);\n    if((new_value - Value > Range)\n            || (Value - new_value > Range))\n    {\n        new_value = Value;\n    }\n\n\tif(Value != new_value) {\n        Num++;\n        if(Num > Count) {\n            Num = 0;\n            Value = new_value;\n        }\n    }\n    else\n        Num = 0;\n\n    return Value;\n}\n\n#endif /* LIMITING_DEBOUNCE */\n\n```","tags":["history","算法"],"categories":["算法"]},{"title":"排序算法（Sorting algorithm）","url":"/sorting-algorithm/","content":"\n\n\n# 算法分类\n\n![img](20200521192232637.png)\n\n- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。\n- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 \n\n\n\n# 算法比较\n\n![img](20200521192506781.png)\n\n**稳定排序算法：**会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是**稳定**的，当有两个相等键值的纪录 R和 S，且在原本的列表中 R出现在 S之前，在排序过的列表中 R也将会是在 S之前。\n\n\n\n# 算法实现分析\n\n## 1、冒泡排序（Bubble Sort）\n\n**冒泡排序**（英语：Bubble Sort）又称为**泡式排序**，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n### 1.1 执行流程：\n\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个；\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；\n- 针对所有的元素重复以上的步骤，除了最后一个；\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n### 1.2 动图演示：\n\n![img](20200521193936809.gif)\n\n### 1.3 代码实现：\n\n```cpp\nvoid Bubble_Sort(int *arr, int len) {\n    int i, j, temp;\n    for (i = 0; i < len - 1; i++)\n        for (j = 0; j < len - 1 - i; j++)\n            if (arr[j] > arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n}\n```\n\n\n\n## 2、直接**选择排序**（Straight Selection sort）\n\n***下称选择排序***\n\n**选择排序**（Selection Sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n### 2.1 执行流程：\n\n- 初始状态：无序区为 R[1..n]，有序区为空；\n- 第一趟：在无序区 R[1..n]中选出最小元素，将他 R[1]交换，R[1]为有效区；\n- 第二趟：在无序区 R[2..n]中选出最小元素，将他 R[1]交换，R[1..2]为有效区；\n- 第 n-1趟：在无序区 R[n-1..n]中选出最小元素，将他 R[n-1]交换，R[1..n-1]为有效区；\n- n-1趟结束，区间 R[1..n]中记录按递增有序排列。\n\n### 2.2 动图演示：\n\n![img](20200521201218459.gif)\n\n### 2.3 代码实现：\n\n```cpp\nvoid Selection_Sort(int *arr, int len)\n{\n    int i, j, k, temp;\n    for (i = 0; i < len - 1; i++) {\n        k = i;\n        for (j = i + 1; j < len; j++)\n            if (arr[j] < arr[k])\n                k = j;\n        if(k != i){\n            temp = arr[k];\n            arr[k] = arr[i];\n            arr[i] = temp;\t\n        }\n    }\n}\n```\n\n\n\n## 3、直接插入排序（Straight Insertion Sort）\n\n***下称插入排序***\n\n**插入排序**（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**插入排序**在实现上，通常采用 in-place排序（即只需用到 {O(1)} 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n### 3.1 执行流程：\n\n- 从第一个元素开始，该元素可以认为已经被排序\n- 取出下一个元素，在已经排序的元素序列中从后向前扫描\n- 如果该元素（已排序）大于新元素，将该元素移到下一位置\n- 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置\n- 将新元素插入到该位置后\n- 重复步骤 2~5\n\n### 3.2 动图演示：\n\n![img](20200521203532982.gif)\n\n### 3.3 代码实现：\n\n```cpp\nvoid Insertion_Sort(int *arr, int len)    \n{    \n    int i, j, temp;    \n    for (i = 1; i < len; i++)\n        if (arr[i] < arr[i-1]) {    \n            temp = arr[i];    \n            for (j = i - 1; j >= 0 && arr[j] > temp; j--)\n                arr[j+1] = arr[j];\n            arr[j+1] = temp;    \n        }\n}\n```\n\n\n\n## 4、希尔排序（Shell Sort）\n\n**希尔排序**（Shell Sort），也称**递减增量排序算法**，是直接插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。\n\n希尔排序是基于直接插入排序的以下两点性质而提出改进方法的：\n\n- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率\n- 但直接插入排序一般来说是低效的，因为直接插入排序每次只能将数据移动一位\n\n### 4.1 执行流程：\n\n- 取增量，一般取数组长度 / 2；\n- 按增量取得子序列，对子序列进行插入排序；\n- 将增量递减，重复 1、2步骤；\n- 直至增量均为 0，数列已经排好序。\n\n![img](20200521212801860.jpg)\n\n### 4.2 动图演示：\n\n![img](20200523120326840.gif)\n\n### 4.3 代码实现：\n\n```cpp\nvoid Shell_Sort(int *arr, int len) {\n    int gap, i, j;\n    int temp;\n    for (gap = len >> 1; gap > 0; gap >>= 1)\n        for (i = gap; i < len; i++) {\n            temp = arr[i];\n            for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap)\n                arr[j + gap] = arr[j];\n            arr[j + gap] = temp;\n        }\n}\n```\n\n\n\n## 5、二路归并排序（Two-way Merge Sort）\n\n***下称归并排序***\n\n**归并排序**（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n- 自下而上的迭代。\n\n### 5.1 执行流程（以递归过程为例）：\n\n- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n- 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n- 重复步骤 3 直到某一指针达到序列尾；\n- 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n总执行分解图：\n\n![img](20200521220340920.png)\n\n合并过程如下（以第 2趟归并为例）：\n\n![img](20200521220811136.png)\n\n### 5.2 动图演示：\n\n![img](20200521215041376.gif)\n\n### 5.3 代码实现：\n\n```cpp\n#define MIN(x,y)     ((x) < (y) ? (x) : (y))\n\nvoid Merge_Sort(int *arr, int len) {\n    int *a = arr;\n    int *b = (int *) malloc(len * sizeof(int));\n    int seg, start;\n    \n    for (seg = 1; seg < len; seg += seg) {\n        for (start = 0; start < len; start += seg * 2) {\n            int low = start, mid = MIN(start + seg, len), high = MIN(start + seg * 2, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        int *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        int i;\n        for (i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    free(b);\n}\n```\n\n\n\n## 6、**快速排序**（Quick Sort）\n\n**快速排序**（英语：Quick Sort），又称**分区交换排序**（partition-exchange sort），简称**快排**，是对冒泡排序的一种改进，亦是分而治之思想在排序算法上的典型应用。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列的目的。\n\n### 6.1 执行流程：\n\n快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。\n\n- 从数列中挑出一个元素，称为 “基准”（pivot）;\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n![img](20200523144821475.png)\n\n递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\n\n### 6.2 动图演示：\n\n![img](20200523150848413.gif)\n\n### 6.3 代码实现：\n\n```cpp\nvoid Quick_Sort(int *arr, int low, int high)\n{\n    int i = low;\n    int j = high;\n    int pivot = arr[i];\n\n    if(low > high) {\n        return ;\n    }\n    while(i < j) {\n        while((arr[j] >= pivot) && (i < j)) {\n            j--;\n        }\n        arr[i] = arr[j];\n        while((arr[i] <= pivot) && (i < j)) {\n            i++;\n        }\n        arr[j]= arr[i];\n    }\n    arr[i] = pivot;\n    Quick_Sort(arr, low, i-1);\n    Quick_Sort(arr, j+1, high);\n}\n```\n\n\n\n## 7、堆排序（Heap Sort）\n\n**堆排序**（英语：Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足**堆的性质**：即子节点的键值或索引总是小于（或者大于）它的父节点。\n\n![img](20200523160442531.png)\n\n### 7.1 执行流程：\n\n- 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;\n- 将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端;\n- 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。\n\n假设给定无序序列结构如下（以大顶堆为例）：\n\n![img](20200523182009324.png)\n\n**1) 构造大顶堆**\n\na. 从最后一个非叶子结点开始，从左至右，从下至上进行调整。叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6结点；在[6, 5, 9]这个小堆里边，父节点 97最大，所以 6和 9交换。\n\n![img](20200523181909328.png)\n\nb. 找到第二个非叶节点 4，由于[4, 9, 8]中 9元素最大，4和 9交换。\n\n![img](20200523181921590.png)\n\nc. 这时，交换导致了子根[4, 5, 6]结构混乱，继续调整，在[4, 5, 6]这个小堆里边，父节点 6最大，所以 4和 6交换。\n\n![img](20200523181934279.png)\n\n至此，一个无序序列已经构造成一个大顶堆。\n\n**2) 堆排序**\n\na. 将堆顶元素 9和末尾元素 4进行交换\n\n![img](20200523183703440.png)\n\nb. 重新调整结构，使其继续满足堆定义\n\n![img](20200523183726240.png)\n\nc. 再将堆顶元素 8与末尾元素 5进行交换，得到第二大元素 8\n\n![img](20200523183827566.png)\n\nd. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序\n\n![img](20200523183840200.png)\n\n### 7.2 动图演示：\n\n![img](2020052318542415.gif)\n\n### 7.3 代码实现：\n\n```cpp\nvoid swap(int *a, int *b)\n{\n    int temp = *b;\n    *b = *a;\n    *a = temp;\n}\n\nvoid Heapify(int *arr, int start, int end)\n{\n#if 1\n    int i, temp;\n\n    temp = arr[start];\n    for (i = 2*start + 1; i < end; i = 2*i + 1) {// 左孩子 2*i + 1，右孩子 2*i + 2\n        if (i + 1 < end && arr[i] < arr[i+1]) {// 如果左子结点小于右子结点，i指向右子结点\n            i++;\n        }\n        if (temp < arr[i]) {\n            arr[start] = arr[i];// 将根节点设置为子节点的较大值\n            start = i;// 继续往下\n        } else\n            break;// 已经满足大根堆\n    }\n    arr[start] = temp;// 将temp值放到最终的位置\n\n#else\n    // 建立父節點指標和子節點指標\n    int dad = start;\n    int son = dad * 2 + 1;\n\n    while (son < end) { // 若子節點指標在範圍內才做比較\n        if (son + 1 < end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的\n            son++;\n        if (arr[dad] >= arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數\n            return;\n        else { // 否則交換父子內容再繼續子節點和孫節點比較\n            swap(&arr[dad], &arr[son]);\n            dad = son;\n            son = dad * 2 + 1;\n        }\n    }\n\n#endif\n}\n\nvoid Heap_Sort(int *arr, int len)\n{\n    int i;\n\n\t// 先将数组构造成大顶堆\n    for (i = len / 2 - 1; i >= 0; i--)\n        Heapify(arr, i, len);// 从第一个非叶子结点从下至上，从右至左调整结构\n\n    // 调整堆结构+交换堆顶元素与末尾元素\n    for (i = len - 1; i > 0; i--) {\n        swap(&arr[0], &arr[i]);// 将堆顶元素与末尾元素进行交换\n        Heapify(arr, 0, i);// 重新对堆进行调整\n\t}\n}\n```\n\n\n\n## 8、计数排序（Counting Sort）\n\n**计数排序**（Counting Sort）是一种稳定的线性时间排序算法。该算法于1954年由 Harold H. Seward 提出。比较适合数值跨度比较小的， 也就是数组中最大值减去最小值得到的值尽量小， 同时数组元素又比较多的情况下用计数排序效率比较高。计数排序使用一个额外的数组 C，其中第 i个元素是待排序数组 A中值等于 i的元素的个数。然后根据数组 C来将 A中的元素排到正确的位置。\n\n### 8.1 执行流程：\n\n- 找出待排序的数组中最大的元素；\n- 设置一个定量的数组 counts，最大范围为 max（max为步骤 1求得的最大值）；\n- 统计数组中每个值为 i的元素出现的次数，存入数组 counts的第 i项；\n- 对所有的计数累加（从 counts中的第一个元素开始，每一项和前一项相加）；\n- 反向填充目标数组：将每个元素 i放在新数组的第 counts[i]项，每放一个元素就将 counts[i]减去 1。\n\n### 8.2 动图演示：\n\n![img](20200523204828571.gif)\n\n### 8.3 代码实现：\n\n```cpp\nint Counting_Sort(DataType *arr, int len)\n{\n    DataType *counts,\n             *temp;\n\n    int i;\n    int max_val = arr[0];\n\n    for(i = 1; i < len; i++)\n        if(arr[i] > max_val)\n            max_val = arr[i];\n\n    /*为计数器数组分配空间*/\n    counts = (DataType *)malloc((max_val+1) * sizeof(DataType));\n    /*为已排序元素临时存放数组分配空间*/\n    temp = (DataType *)malloc(len * sizeof(DataType));\n\n    if(counts == NULL)\n        return -1;\n\n    if(temp == NULL)\n        return -1;\n\n    /* 初始化计数数组 */\n    for(i = 0; i < max_val+1; i++)\n        counts[i] = 0;\n\n    /* 统计每个元素出现的次数（counts的下标索引即是要统计的元素本身）*/\n    for(i = 0; i < len; i++)\n        counts[arr[i]]++;\n\n    /* 将元素本身的次数加上它前一个元素的次数(得到元素偏移量) */\n    for(i = 1; i < max_val+1; i++)\n        counts[i] += counts[i - 1];\n\n    /* 关键代码：使用上面得到的计数数组去放置每个元素要排序的位置 */\n    for(i = len - 1; i >= 0; i--) {\n        temp[counts[arr[i]] -1] = arr[i];      /* counts的值是元素要放置到 temp中的偏移量 */\n        counts[arr[i]]--;  /* counts的计数减 1 */\n\n//        temp[--counts[arr[i]]] = arr[i];\n    }\n\t\n    /* 将 Counting_Sort已排序的元素从 temp拷贝回 data */\n    memcpy(arr, temp, len * sizeof(DataType));\n\n    /*释放前面分配的空间*/\n    free(counts);\n    free(temp);\n\n    return 0;\n}\n```\n\n\n\n## 9、**桶排序**（Bucket Sort）\n\n**桶排序**（Bucket Sort）或所谓的**箱排序**，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。\n\n为了使桶排序更加高效，我们需要做到这两点：\n\n- 在额外空间充足的情况下，尽量增大桶的数量\n- 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\n\n### 9.1 执行流程：\n\n- 找出待排序数组 arr中的最大值 max、最小值 min；\n- 设置一个定量的数组当作空桶，范围为 min~max（min、max为步骤 1求得的最小值、最大值）；\n- 遍历待排序数组 arr，计算每个元素 arr[i]放的桶，把数据放到对应的桶里；\n- 如果桶不为空，对桶中的数据进行排序；\n- 遍历桶数组，把所有桶中排序好的元素放到一个新的数组里。\n\n### 9.2 动图演示：\n\n![img](20200524000628312.gif)\n\n### 9.3 代码实现：\n\n```cpp\nint Bucket_Sort(DataType *arr, int len)\n{\n    int i, j, n;\n    DataType *buckets;\n\n    int max_val = arr[0];\n\tint min_val = arr[0];\n\n    for(i = 1; i < len; i++) {\n        if(arr[i] > max_val)\n            max_val = arr[i];\n        else if(arr[i] < min_val)\n            min_val = arr[i];\n    }\n\t\n    n = max_val - min_val + 1;\n\n    buckets = (DataType *)malloc((n) * sizeof(DataType));\n\n    if(buckets == NULL)\n        return -1;\n\n    memset(buckets, 0, (n) * sizeof(DataType));\n\n    for (i = 0; i < len; i++)\n        buckets[arr[i] - min_val]++;\n\n    for (i = 0, j = 0; i < n; i++)\n        while((buckets[i]--) > 0)\n            arr[j++] = i + min_val;\n\t\n    return 0;\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n## 10、基数排序（Radix Sort）\n\n**基数排序**（英语：Radix Sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。\n\n它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。\n\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n### 10.1 执行流程：\n\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成 radix数组；\n- 对 radix进行计数排序（利用计数排序适用于小范围数的特点）。\n\n### 10.2 动图演示：\n\n![img](20200524172027453.gif)\n\n### 10.3 代码实现：\n\n```cpp\n#define BASE            10\n\nint Radix_Sort(DataType *arr, int len)\n{\n    DataType *temp,\n\t         *counts; //计数器\n    int i, j, k;\n    int radix = 1;\n\n    int max_val = arr[0];\n\n    for(i = 1; i < len; i++)\n        if(arr[i] > max_val)\n            max_val = arr[i];\n\n\t/* 为计数器数组分配空间 */\n    counts = (DataType *)malloc((BASE+1) * sizeof(DataType));\n    /* 为已排序元素临时存放数组分配空间 */\n    temp = (DataType *)malloc(len * sizeof(DataType));\n\n    if(counts == NULL)\n        return -1;\n\n    if(temp == NULL)\n        return -1;\n\n    while (max_val / radix > 0) {\n        for(j = 0; j < BASE+1; j++)\n            counts[j] = 0; // 每次分配前清空计数器\n\n        for(j = 0; j < len; j++) {\n            k = (arr[j] / radix) % BASE; // 统计每个桶中的记录数\n            counts[k]++;\n        }\n\n        for(j = 1; j < BASE+1; j++)\n            counts[j] += counts[j - 1]; // 将 temp中的位置依次分配给每个桶\n\n        for(j = len - 1; j >= 0; j--) { // 将所有桶中记录依次收集到 temp中\n            k = (arr[j] / radix) % BASE;\n            temp[counts[k] - 1] = arr[j];\n            counts[k]--;\n        }\n\n        for(j = 0; j < len; j++) // 将临时数组的内容复制到 data中\n            arr[j] = temp[j];\n\n        radix *= 10;\n    }\n\n    /*释放前面分配的空间*/\n    free(counts);\n    free(temp);\n\n    return 0;\n}\n```\n\n\n\n# 十大经典排序算法 C语言总代码实现\n\n```cpp\n/* 排序算法 */\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef int DataType;\n\n#define SIZEOF(x,y)\t\t(sizeof(x)/sizeof(y))\n#define LEN\t\t\t\tSIZEOF(buffer,DataType)\n\nint buffer[10] = {3,6,13,1,78,35,22,11,32,60};\n\nvoid Bubble_Sort(DataType *arr, int len)\n{\n\tint i, j, temp;\n\n\tfor (i = 0; i < len - 1; i++)\n\t\tfor (j = 0; j < len - 1 - i; j++)\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\ttemp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n}\n\nvoid Selection_Sort(DataType *arr, int len)\n{\n\tint i, j, k, temp;\n\n\tfor (i = 0; i < len - 1; i++) {\n\t\tk = i;\n\t\tfor (j = i + 1; j < len; j++)\n\t\t\tif (arr[j] < arr[k])\n\t\t\t\tk = j;\n\t\tif(k != i) {\n\t\t\ttemp = arr[k];\n\t\t\tarr[k] = arr[i];\n\t\t\tarr[i] = temp;\n\t\t}\n\t}\n}\n\nvoid Insertion_Sort(DataType *arr, int len)\n{\n\tint i, j, temp;\n\n\tfor (i = 1; i < len; i++)\n\t\tif (arr[i] < arr[i-1]) {\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - 1; j >= 0 && arr[j] > temp; j--)\n\t\t\t\tarr[j+1] = arr[j];\n\t\t\tarr[j+1] = temp;\n\t\t}\n}\n\nvoid Shell_Sort(DataType *arr, int len)\n{\n\tint gap, i, j;\n\tint temp;\n\n\tfor (gap = len >> 1; gap > 0; gap >>= 1)\n\t\tfor (i = gap; i < len; i++) {\n\t\t\ttemp = arr[i];\n\t\t\tfor (j = i - gap; j >= 0 && arr[j] > temp; j -= gap)\n\t\t\t\tarr[j + gap] = arr[j];\n\t\t\tarr[j + gap] = temp;\n\t\t}\n}\n\n#define MIN(x,y)     ((x) < (y) ? (x) : (y))\n\nint Merge_Sort(DataType *arr, int len)\n{\n\tDataType *a = arr;\n\tDataType *b = (DataType *) malloc(len * sizeof(DataType));\n\tint seg, start;\n\n\tif(b == NULL)\n\t\treturn -1;\n\n\tfor (seg = 1; seg < len; seg += seg) {\n\t\tfor (start = 0; start < len; start += seg * 2) {\n\t\t\tint low = start, mid = MIN(start + seg, len), high = MIN(start + seg * 2, len);\n\t\t\tint k = low;\n\t\t\tint start1 = low, end1 = mid;\n\t\t\tint start2 = mid, end2 = high;\n\t\t\twhile (start1 < end1 && start2 < end2)\n\t\t\t\tb[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n\t\t\twhile (start1 < end1)\n\t\t\t\tb[k++] = a[start1++];\n\t\t\twhile (start2 < end2)\n\t\t\t\tb[k++] = a[start2++];\n\t\t}\n\t\tDataType *temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n\tif (a != arr) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tb[i] = a[i];\n\t\tb = a;\n\t}\n\tfree(b);\n\n\treturn 0;\n}\n\nvoid Quick_Sort(DataType *arr, int low, int high)\n{\n\tint i = low;\n\tint j = high;\n\tint pivot = arr[i];\n\n\tif(low > high) {\n\t\treturn ;\n\t}\n\twhile(i < j) {\n\t\twhile((arr[j] >= pivot) && (i < j)) {\n\t\t\tj--;\n\t\t}\n\t\tarr[i] = arr[j];\n\t\twhile((arr[i] <= pivot) && (i < j)) {\n\t\t\ti++;\n\t\t}\n\t\tarr[j]= arr[i];\n\t}\n\tarr[i] = pivot;\n\tQuick_Sort(arr, low, i-1);\n\tQuick_Sort(arr, j+1, high);\n}\n\nvoid swap(DataType *a, DataType *b)\n{\n\tDataType temp = *b;\n\t*b = *a;\n\t*a = temp;\n}\n\nvoid Heapify(DataType *arr, int start, int end)\n{\n#if 0\n\tint i, temp;\n\n\ttemp = arr[start];\n\tfor (i = 2*start + 1; i < end; i = 2*i + 1) {// 左孩子 2*i + 1，右孩子 2*i + 2\n\t\tif (i + 1 < end && arr[i] < arr[i+1]) {// 如果左子结点小于右子结点，i指向右子结点\n\t\t\ti++;\n\t\t}\n\t\tif (temp < arr[i]) {\n\t\t\tarr[start] = arr[i];// 将根节点设置为子节点的较大值\n\t\t\tstart = i;// 继续往下\n\t\t} else\n\t\t\tbreak;// 已经满足大根堆\n\t}\n\tarr[start] = temp;// 将temp值放到最终的位置\n\n#else\n\t// 建立父節點指標和子節點指標\n\tint dad = start;\n\tint son = dad * 2 + 1;\n\n\twhile (son < end) { // 若子節點指標在範圍內才做比較\n\t\tif (son + 1 < end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的\n\t\t\tson++;\n\t\tif (arr[dad] >= arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數\n\t\t\treturn;\n\t\telse { // 否則交換父子內容再繼續子節點和孫節點比較\n\t\t\tswap(&arr[dad], &arr[son]);\n\t\t\tdad = son;\n\t\t\tson = dad * 2 + 1;\n\t\t}\n\t}\n\n#endif\n}\n\nvoid Heap_Sort(DataType *arr, int len)\n{\n\tint i;\n\n\t// 先将数组构造成大顶堆\n\tfor (i = len / 2 - 1; i >= 0; i--)\n\t\tHeapify(arr, i, len);// 从第一个非叶子结点从下至上，从右至左调整结构\n\n\t// 调整堆结构+交换堆顶元素与末尾元素\n\tfor (i = len - 1; i > 0; i--) {\n\t\tswap(&arr[0], &arr[i]);// 将堆顶元素与末尾元素进行交换\n\t\tHeapify(arr, 0, i);// 重新对堆进行调整\n\t}\n}\n\nint Counting_Sort(DataType *arr, int len)\n{\n\tDataType *counts,\n\t         *temp;\n\n\tint i;\n\tint max_val = arr[0];\n\n\tfor(i = 1; i < len; i++)\n\t\tif(arr[i] > max_val)\n\t\t\tmax_val = arr[i];\n\n\t/*为计数器数组分配空间*/\n\tcounts = (DataType *)malloc((max_val+1) * sizeof(DataType));\n\t/*为已排序元素临时存放数组分配空间*/\n\ttemp = (DataType *)malloc(len * sizeof(DataType));\n\n\tif(counts == NULL)\n\t\treturn -1;\n\n\tif(temp == NULL)\n\t\treturn -1;\n\n\t/* 初始化计数数组 */\n\tfor(i = 0; i < max_val+1; i++)\n\t\tcounts[i] = 0;\n\n\t/* 统计每个元素出现的次数（counts的下标索引即是要统计的元素本身）*/\n\tfor(i = 0; i < len; i++)\n\t\tcounts[arr[i]]++;\n\n\t/* 将元素本身的次数加上它前一个元素的次数(得到元素偏移量) */\n\tfor(i = 1; i < max_val+1; i++)\n\t\tcounts[i] += counts[i - 1];\n\n\t/* 关键代码：使用上面得到的计数数组去放置每个元素要排序的位置 */\n\tfor(i = len - 1; i >= 0; i--) {\n\t\ttemp[counts[arr[i]] -1] = arr[i];      /* counts的值是元素要放置到 temp中的偏移量 */\n\t\tcounts[arr[i]]--;  /* counts的计数减 1 */\n\n//\t\ttemp[--counts[arr[i]]] = arr[i];\n\t}\n\n\t/* 将 Counting_Sort已排序的元素从 temp拷贝回 data */\n\tmemcpy(arr, temp, len * sizeof(DataType));\n\n\t/*释放前面分配的空间*/\n\tfree(counts);\n\tfree(temp);\n\n\treturn 0;\n}\n\nint Bucket_Sort(DataType *arr, int len)\n{\n\tint i, j, n;\n\tDataType *buckets;\n\n\tint max_val = arr[0];\n\tint min_val = arr[0];\n\n\tfor(i = 1; i < len; i++) {\n\t\tif(arr[i] > max_val)\n\t\t\tmax_val = arr[i];\n\t\telse if(arr[i] < min_val)\n\t\t\tmin_val = arr[i];\n\t}\n\n\tn = max_val - min_val + 1;\n\n\tbuckets = (DataType *)malloc((n) * sizeof(DataType));\n\n\tif(buckets == NULL)\n\t\treturn -1;\n\n\tmemset(buckets, 0, (n) * sizeof(DataType));\n\n\tfor (i = 0; i < len; i++)\n\t\tbuckets[arr[i] - min_val]++;\n\n\tfor (i = 0, j = 0; i < n; i++)\n\t\twhile((buckets[i]--) > 0)\n\t\t\tarr[j++] = i + min_val;\n\n\treturn 0;\n}\n\n#define BASE            10\n\nint Radix_Sort(DataType *arr, int len)\n{\n\tDataType *temp,\n\t         *counts; //计数器\n\tint i, j, k;\n\tint radix = 1;\n\n\tint max_val = arr[0];\n\n\tfor(i = 1; i < len; i++)\n\t\tif(arr[i] > max_val)\n\t\t\tmax_val = arr[i];\n\n\t/*为计数器数组分配空间*/\n\tcounts = (DataType *)malloc((BASE+1) * sizeof(DataType));\n\t/*为已排序元素临时存放数组分配空间*/\n\ttemp = (DataType *)malloc(len * sizeof(DataType));\n\n\tif(counts == NULL)\n\t\treturn -1;\n\n\tif(temp == NULL)\n\t\treturn -1;\n\n\twhile (max_val / radix > 0) {\n\t\tfor(j = 0; j < BASE+1; j++)\n\t\t\tcounts[j] = 0; // 每次分配前清空计数器\n\n\t\tfor(j = 0; j < len; j++) {\n\t\t\tk = (arr[j] / radix) % BASE; // 统计每个桶中的记录数\n\t\t\tcounts[k]++;\n\t\t}\n\n\t\tfor(j = 1; j < BASE+1; j++)\n\t\t\tcounts[j] += counts[j - 1]; // 将 temp中的位置依次分配给每个桶\n\n\t\tfor(j = len - 1; j >= 0; j--) { // 将所有桶中记录依次收集到 temp中\n\t\t\tk = (arr[j] / radix) % BASE;\n\t\t\ttemp[counts[k] - 1] = arr[j];\n\t\t\tcounts[k]--;\n\t\t}\n\n\t\tfor(j = 0; j < len; j++) // 将临时数组的内容复制到 data中\n\t\t\tarr[j] = temp[j];\n\n\t\tradix *= 10;\n\t}\n\n\t/*释放前面分配的空间*/\n\tfree(counts);\n\tfree(temp);\n\n\treturn 0;\n}\n\n\nint main(void)\n{\n\tint i;\n\n//\tBubble_Sort(buffer, LEN);\n//\tSelection_Sort(buffer, LEN);\n//\tInsertion_Sort(buffer, LEN);\n//\tShell_Sort(buffer, LEN);\n//\tMerge_Sort(buffer, LEN);\n//\tQuick_Sort(buffer, 0, LEN-1);\n//\tHeap_Sort(buffer, LEN);\n//\tCounting_Sort(buffer, LEN);\n//\tBucket_Sort(buffer, LEN);\n//\tRadix_Sort(buffer, LEN);\n\n\n\tfor(i = 0; i < LEN; i++)\n\t\tprintf(\"buffer[%d]=%3d\\n\", i, *(buffer+i));\n\n\treturn 0;\n}\n\n\n/* -------------------- END OF FILE -------------------- */\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n\n\n\n\n\n\n\n\n# 附录\n\n**参考来源：**\n\n[https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/排序算法)\n\n[GitHub - hustcc/JS-Sorting-Algorithm: 一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。](https://github.com/hustcc/JS-Sorting-Algorithm)\n\n[数据结构与算法 - 随笔分类 - 鹿呦呦 - 博客园](https://www.cnblogs.com/sunshineliulu/category/1139260.html)\n\nhttps://www.smslit.top/2018/11/07/algorithm-sort/\n\nhttps://zoharyip.club/posts/Sort-Algorithms.html\n\n[图解排序算法(三)之堆排序 - dreamcatcher-cx - 博客园](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\n[堆排序 - Don'tYouSee - 博客园](https://www.cnblogs.com/dyg0826/p/11369450.html)\n\n**模型建立：**\n\n[数据结构和算法动态可视化 (Chinese) - VisuAlgo](https://visualgo.net/zh)\n\n[GitHub - algorithm-visualizer/algorithm-visualizer: Interactive Online Platform that Visualizes Algorithms from Code](https://github.com/algorithm-visualizer/algorithm-visualizer)\n\n","tags":["history","算法"],"categories":["算法"]},{"title":"分区分配算法（Partitioning Placement Algorithm）","url":"/partitioning-placement-algorithm/","content":"\n\n\n\n# 简述\n\n**首次适应算法（first-fit）** ：从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法的目的在于减少查找时间。\n\n**最佳适应算法（best-fit）** ：从全部空闲区中找出能满足作业要求的，且大小最小的空闲分区，这种方法能使碎片尽量小。\n\n**最差适应算法（worst-fit）** ：它从全部空闲区中找出能满足作业要求的、且大小最大的空闲分区，从而使链表中的节点大小趋于均匀。\n\n\n\n# 例子\n\n## 文字描述\n\n> 下面先来看一个实例：\n>\n> ***Given five memory partitions of 100 KB, 500 KB, 200 KB, 300 KB, and 600 KB (in order), how would each of the first-fit, best-fit, and worst-fit algorithms place processes of 212 KB, 417 KB, 112 KB, and 426 KB (in order)? Which algorithm makes the most efficient use of memory?***\n\n\n\n**1、首次适应算法：**\n\n- 为 212k分配空间：\n\n​    依次找寻，找到第一个大于 212k的空闲区；\n\n​    找到第二个空闲区 500k > 212k，分配给 212k，剩余 288k空闲区；\n\n- 为 417k分配空间：\n\n​    依次找寻，找到第一个大于 417k的空闲区；\n\n​    找到第五个空闲区 600k > 417k，分配给 417k，剩余 183k空闲区\n\n- 为 112k分配空间：\n\n​    依次找寻，找到第一个大于 112k的空闲区；\n\n​    找到第二个空闲区 288k > 112k，分配给 112k，剩余 176k空闲区\n\n- 为 426k分配空间：\n\n​    依次找寻，找到第一个大于 426k的空闲区；\n\n​    未找到，此作业将等待释放空间\n\n\n\n**2、最佳适应算法：**\n\n- 为 212k分配空间：\n\n​    找到第一个跟 212k大小最接近的空闲区\n\n​    找到第四个空闲区 300k > 212k，剩余 88k空闲区\n\n- 为 417k分配空间：\n\n​    找到第一个跟 417k大小最接近的空闲区\n\n​    找到第二个空闲区 500k > 417k，剩余 83k空闲区\n\n- 为 112k分配空间：\n\n​    找到第一个跟 112k大小最接近的空闲区\n\n​    找到第三个空闲区 200k > 112k，剩余 88k空闲区\n\n- 为 426k分配空间：\n\n​    找到第一个跟 426k大小最接近的空闲区\n\n​    找到第五个空闲区 600k > 426k，剩余 174k空闲区\n\n\n\n**3、最差适应算法：**\n\n- 为212k分配空间：\n\n​    找到第一个大小最大的空闲区\n\n​    找到第五个空闲区 600k > 212k，剩余 388k空闲区\n\n- 为 417k分配空间：\n\n​    找到第一个大小最大的空闲区\n\n​    找到第二个空闲区 500k > 417k，剩余 83k空闲区\n\n- 为 112k分配空间：\n\n​    找到第一个大小最大的空闲区\n\n​    找到第三个空闲区 388k > 112k，剩余 276k空闲区\n\n- 为426k分配空间：\n\n​    找到第一个大小最大的空闲区\n\n​    达到大小最大的空闲区 300k < 426k，所以不分配\n\n\n\n**Answer**\n\n| Free partition | 100  | 500     | 200  | 300  | 600     | Not satisfied |\n| -------------- | ---- | ------- | ---- | ---- | ------- | ------------- |\n| First-fit      |      | 212,112 |      |      | 417     | 426           |\n| Best-fit       |      | 417     | 112  | 212  | 426     |               |\n| Worst-fit      |      | 417     |      |      | 212,112 | 426           |\n\n\n\n## 动图分析\n\n文字图表看不懂，那接着配合动图来了解：\n\n这次我们考虑六个大小为 200 KB，400 KB，600 KB，500 KB，300 KB和 250 KB的内存分区；这些分区需要按此顺序分配给四个进程，大小分别为 357 KB，210 KB，468 KB和 491 KB。\n\n![img](2020051523471962.png)\n\n依次执行：\n\n- 首次适应算法\n- 最佳适应算法\n- 最差适应算法\n\n\n\n**1、首次适应算法：**\n\n![img](20200515235334677.gif)\n\n- 进程 P4无法分配内存，这是因为没有大于或等于处理 P4的大小的分区可用。\n\n\n\n\n**2、最佳适应算法：**\n\n![img](20200516000153918.gif)\n\n\n\n**3、最差适应算法：**\n\n![img](20200516000532204.gif)\n\n- 无法为进程 P3和进程 P4分配内存，这是因为没有大于或等于处理 P3和处理 P4的大小的分区可用。\n\n\n\n# 参考\n\n[https://blog.csdn.net/u011070169/article/details/53177987](https://blog.csdn.net/u011070169/article/details/53177987)\n\n[https://www.gatevidyalay.com/contiguous-memory-allocation-practice-problems/](https://www.gatevidyalay.com/contiguous-memory-allocation-practice-problems/)\n\n","tags":["history","算法"],"categories":["算法"]},{"title":"三大无源器件之电感","url":"/inductor/","content":"\n\n\n> 下面用三个篇章解释\n\n# 视频篇\n\n{% raw %}\n\n<iframe width=\"560\" height=\"315\" src=\"//player.bilibili.com/player.html?aid=99004423&bvid=BV1U741127Vd&cid=168998616&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" controls=\"controls\" allowfullscreen=\"true\"> </iframe>\n\n{% endraw %}\n\n\n\n# 漫画篇\n\n![img](clip_image002.jpg)\n\n![img](clip_image004.jpg)\n\n![img](clip_image006.jpg)\n\n![img](clip_image008.jpg)\n\n图片提取自 [TDK株式会社](https://www.jp.tdk.com/corp/zh/index.htm)\n\n \n\n# 文字篇\n\n**1、电感器与电感**\n\n**电感器**（inductor）是一种电路元件；电感器一词在口语上也会被简称为电感，但如需严谨表达为实体物件的情况，仍宜称为电感器\n\n**电感**（Inductance）是闭合回路的一种属性，即当通过闭合回路的电流改变时，会出现电动势来抵抗电流的改变\n\n**2、自感和互感**\n\n·     自感：当电感这种属性现象出现在自身回路中，那么这种电感称为**自感**（self-inductance），是闭合回路自己本身的属性\n\n通常自感是以字母“L”标记，这可能是为了纪念物理学家海因里希·楞次的贡献\n\n·     互感：假设一个闭合回路的电流改变，由于感应作用在另外一个闭合回路中产生电动势，这种电感称为**互感**（mutual inductance）\n\n互感是以字母“M”标记，是其英文（Mutual Inductance）的第一个字母\n\n**3、表达式**\n\n![img](clip_image010.png)\n\n其中：\n\nε 是电动势\n\nL 是电感\n\ni 是电流\n\nt 是时间\n\n**4、电感单位和转换**\n\n采用国际单位制，电感的单位是亨利（henry），标记为 “H”，是因美国科学家约瑟·亨利命名。1 H = 1 Wb /A\n\n常用单位有：亨 (H)、毫亨(mH)、微亨 (μH)、纳亨（nH）\n\n单位转换：1H = 1000mH = 10^6μH = 10^9nH\n\n**5、电感的串联和并联**\n\n- 并联电路中的电感元件每个都有相同的电势差。其总的等效电感（*L*eq）：\n\n![img](clip_image012.png)\n\n![img](clip_image014.png)\n\n- 通过串联电感的电流保持不变，但每个电感元件上的电压可不同。其电压之和等于总电压。总电感：\n\n![img](clip_image016.png)\n\n![img](clip_image018.png)\n\n这种简单的关系只有在没有磁场互耦（mutual coupling）的条件下才成立\n\n**6、电感的应用**\n\n·     功率电感：主要用于电压转换，常用的DCDC电路都要使用功率电感\n\n·     去耦电感：主要用于滤除电源线或信号线上的噪声\n\n·     高频电感：主要用于射频电路，实现偏置、匹配、滤波等电路\n\n电感在射频电路中用途最多\n\n**7、感性负载电压电流的超前滞后**\n\n首先要提醒，相位的概念是针对正弦信号而言的，直流信号、非周期变化信号等都没有相位的概念\n\n由于 Sin[ωt]在求导或积分后会出现 Sin[ωt ± 90°]，所以对于接上了正弦波的感性负载，通过接上理想的直流电压表、直流电流表，可以观察到波形超前滞后的现象\n\n![img](clip_image020.png)\n\n如果还表现的还不够生动，可以用动态图演示，其用红色表示电压，蓝色表示电流：\n\n![img](clip_image021.gif)\n\n电压的变化超前于电流，电流的变化滞后于电压，所以若电感器通入交流的信号，相角为 90度，亦即电流滞后电压 90度\n\n![img](clip_image022.gif)\n\n用不同的颜色描述电压的大小，蓝色>黄色>红色；用不同的粗细和箭头描述电流的大小和方向，电流最大时电感磁场能最大\n\n**8、感抗**\n\n因为电路中存在电感电路（如线圈），由此产生的变化的电磁场，会产生相应的阻碍电流变化的感生电动势。这个作用称为**感抗** 。电流变化越大，即电路频率越大，感抗越大；当频率变为0，即成为直流电时，感抗也变为0。感抗会引起电流与电压之间的相位差。感抗可由下面公式计算而来：\n\n![img](clip_image024.png)\n\n复数分析中：\n\n![img](clip_image026.png)\n\n其中\n\n·     j 是复数单位\n\n·     Xl 就是感抗，单位为欧姆\n\n·     ω = 2πf 是角速度，单位为 弧度/每秒\n\n·     f 是频率，单位为赫兹\n\n·     L 是线圈电感，单位为亨利\n\n**9、电感的特性总结**\n\n·     通直流隔交流\n\n·     通低频阻高频\n\n·     电感两端的电流不能够突变，电压能突变\n\n**10、电感选型主要参数**\n\n·     电感量（也称自感系数，是表示电感器产生自感应能力的一个物理量）\n\n·     允许误差（电感器上标称的电感量与实际电感的允许误差值）\n\n·     品质因数 Q（指电感器处于某一特定频率时，它的电感电抗和电阻之间的比例）\n\n·     额定电流（电感器在允许的工作环境下能承受的最大电流值）\n\n**11、品质因数** **Q**\n\n一个理想的电感元件是不会因流经线圈的电流的大小而改变其敏感度。但是于实际环境下，线圈内的金属线会令电感元件带有绕组电阻；由于绕组电阻是以串联著电感元件的电阻形式出现，所以亦被称为串联电阻。由于串联电阻的存在，实际电感元件的特性会不同于理想电感，可以用品质因数表示电感和电阻之的比例\n\n电感元件的品质因数 Q能由以下方程式可得，R是电感元件的内部电抗：\n\n![img](clip_image028.png)\n\n相同条件下内阻越大，品质因数越小。品质因数可以看做是衡量电感元件好坏的标准之一，品质因数越高通常意味着电感的质量越好；电感器品质因数的高低与线圈导线的直流电阻、线圈骨架的介质损耗及铁心、屏蔽罩等引起的损耗等有关\n\n ","tags":["电子","history"]},{"title":"三大无源器件之电容","url":"/capacitor/","content":"\n\n\n> 下面用三个篇章解释\n>\n\n# 视频篇\n\n {% raw %}\n\n<iframe width=\"560\" height=\"315\" src=\"//player.bilibili.com/player.html?aid=99000126&bvid=BV11741127TT&cid=168986778&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n{% endraw %}\n\n \n\n# 漫画篇\n\n![img](clip_image002.jpg)\n\n![img](clip_image004.jpg)\n\n![img](clip_image006.jpg)\n\n图片提取自 [TDK株式会社](https://www.jp.tdk.com/corp/zh/index.htm)\n\n\n\n# 文字篇\n\n**1、电容器与电容**\n\n**电容器**（英文：**capacitor**，又称为**condenser**）是将电能储存在电场中的被动电子元件。电容器的储能特性可以用电容表示。在电路中邻近的导体之间即存在电容，而电容器是为了增加电路中的电容量而加入的电子元件\n\n电容器包括二个电极，二个电极储存的电荷大小相等，符号相反。电极本身是导体，二个电极之间由称为介电质的绝缘体隔开。电极的金属片通常用的是铝片或是铝箔，若用氧化铝来做介质的就是电解电容器。电荷会储存在电极表面，靠近介电质的部分。由于二个电极储存的电荷大小相等，符号相反，因此电容器中始终保持为电中性\n\n**2、原理**\n\n电容器的电容（*C*）是测量当电容器两端的电势差或电压（*V*）为单位值时，储存在电容器电极的电荷量（*Q*）：\n\n![img](clip_image008.png)\n\n上式的意义是，在一个具有 C法拉的电容两端跨接 V伏的电压时，该电容的一个极板上就有 Q库仑的电荷存储，而另一个极板上也有 -Q库仑的电荷存储；其电荷量的单位为 -- 库仑（C），则此电容器的电容量单位为 -- 法拉（F）\n\n**3、电容的定义式**\n\n由于电容器的总电场，在电容器两端会出现电压。电压V和电容器一端的绝对电荷量Q成正比，而Q是流过电容器的电流对时间的积分。其数学式如下：\n\n![img](clip_image010.png)\n\n其中：\n\n*I* 是流过电容器的电流，单位为[安培](https://zh.wikipedia.org/wiki/安培)。\n\ndV /dt是电压对时间的微分，单位是[伏特](https://zh.wikipedia.org/wiki/伏特)/秒。\n\n*C* 是电容器件的电容值，单位是[法拉](https://zh.wikipedia.org/wiki/法拉)。\n\n**4、电容单位和转换**\n\n电容的单位是法拉，简称 “法”，单位符号为 “F”，是国际单位制导出单位。一般来说，1法拉算是很大的电容，大多数用于电子电路的电容器，其电容会小于法拉几个数量级\n\n常用的单位有：微法拉（microfarad，μF）、纳法拉（nanofarad，nF）、皮法拉（picofarad，pF）\n\n单位转换：\n\n![img](clip_image012.png)\n\n**5、电容种类**\n\n·     瓷片电容（可以耐高压，通常用作安规电容）\n\n·     积层陶瓷电容（其标准化封装，尺寸小，适用于自动化高密度贴片生产）\n\n·     铝电解电容（优点：电容量大、额定电压高、便宜；缺点：寿命较短、温度特性不好、ESR和ESL较大）\n\n·     钽电容（频率特性及温度特比比铝电解电容要好，但介电吸收及漏电流都较大）\n\n一般地，陶瓷与聚酯薄膜类用于大多数不太重要的电路中；钽电容用于需要较大电容量的场合，而电解质电容则用于电源滤波的场合\n\n**6、电容的串联与并联**\n\n·     [并联](https://zh.wikipedia.org/wiki/並聯)的数个电容有相同的电压。其总电容（*Ceq*）如下：\n\n![img](clip_image014.png)\n\n![img](clip_image016.png)\n\n​       一般而言，电容并联的目的是增加储存的总能量。电容储存的能量如下：\n\n![img](clip_image018.png)\n\n·     [串联](https://zh.wikipedia.org/wiki/串聯)的数个电容会流过相同电流，但各个电容的电势差（电压）可能不同，而电容的电压的和会等于总电压，电容串联后的电容值如下：\n\n![img](clip_image020.png)\n\n![img](clip_image022.png)\n\n·     在电容并联时，电容电极的有效面积变大，因此电容值增加；而在电容串联时，相当于电容电极的距离变大，因此电容值减小\n\n·     电容串联后，电容减小了，但是耐压能力提高了，所以要承受较高的电压，可以把电容串联起来；电容并联后，电容增大了，耐压能力并没有提高，所以在需要大电容时，可以把电容并联起来\n\n**7、电容的代换注意**\n\n·     电容并联时，每个电容所承受的工作电压相等，并等于总电压；因此，如果工作电压不同的几只电容并联，必须把其中最低的工作电压作为并联后的工作电压\n\n·     电容串联后，电容的工作电压在电容量相等的条件下，等于每个电容的工作电压之和；故串联后的电容工作电压升高\n\n**8、电容选型主要参数**\n\n·     电容值\n\n·     允许误差\n\n·     额定电压（一般要求比输入电压高 20%）\n\n**9、容性负载电压电流的超前滞后**\n\n首先要提醒，相位的概念是针对正弦信号而言的，直流信号、非周期变化信号等都没有相位的概念\n\n由于 Sin[ωt]在求导或积分后会出现 Sin[ωt ± 90°]，所以对于接上了正弦波的容性负载，通过接上理想的直流电压表、直流电流表，可以观察到波形超前滞后的现象\n\n![img](clip_image024.png)\n\n如果还表现的还不够生动，可以用动态图演示，其用红色表示电压，蓝色表示电流：\n\n![img](clip_image025.gif)\n\n电压的变化滞后于电流，电流的变化超前于电压，所以若电容器通入交流的信号，相角为 90度，亦即电流领先电压 90度。电压的大小和电流成正比，和频率和电容量 C的乘积成反比\n\n![img](clip_image026.gif)\n\n用不同的颜色描述电压的大小，蓝色>黄色>红色；用不同的粗细和箭头描述电流的大小和方向，电流最大时电容电场能最小\n\n**10、容抗**\n\n**容抗**的概念反映了交流电可以通过电容器这一特性，交流电频率越高，容抗越小，即电容的阻碍作用越小。容抗同样会引起电流与电容两端电压的相位差；当频率等于零，容抗无限大，即直流电不能流过电容器。\n\n容抗可由下面公式计算而来：\n\n![img](clip_image028.png)\n\n在交流电的复数分析中，容抗表示为：\n\n![img](clip_image030.png)\n\n其中\n\n·     j 是复数单位\n\n·     Xc 是容抗，单位为欧姆\n\n·     ω = 2πf 是角速度，单位为 弧度/每秒\n\n·     f 是频率，单位为赫兹\n\n·     C 是电容，单位为法拉\n\n**11、电容和频率的关系**\n\n·     电容值越大，频率点就越低\n\n·     频率点和电容的材质有关系\n\n·     频率点和温度有关系\n\n所以，通常我们说：电容 “通高阻低”，不能一概而论，要根据实际应用，和电容相关手册\n\n**12、电容的 \"通交阻直\" 分析**\n\n·     电容器接在交流电路中，由于交流电电压的大小和方向随时间不断变化，致使电容器进行反复充放电，电路中相应不断出现交流电流，使得自由电子通过电路在电容器的两个极板上来回运动，自由电子的相对运动形成电流，因此，交流电流能通过电容器，即通交流；这里所指的交流电流是电容器反复充放电所形成的电流，并非电荷直接通过电容器中的介质。\n\n·     电容器接通直流电源时，仅仅在刚接通的短暂时间内发生充电过程，只在这一短暂过程电流流过电容器；此后由于直流电源电压恒定不变，电容器两端电压也恒定不变，电容器与电源负极相连的极板上负电荷占多数，并马上达到电路中各个点的电势都相等，没有电位差，因此电容器中不会有电流流过，相当于电容器把直流电流隔断，所以电容器可以起到隔直流的作用。\n\n根据电容的电抗特性，电容可近似地看成一个依赖频率的电阻元件，因此，所谓的 “通交阻直” 其实更多的是反应频率的效果\n\n**13、电容的特性总结**\n\n·     隔直流通交流，通高频阻低频\n\n·     电容两端的电压不能够突变，电流能突变\n\n·     大容值电容滤低频噪声，小容值电容滤高频噪声\n\n·     电容在充放电过程中并不消耗能量\n\n**14、电容器的主要用途**\n\n·     电源滤波（几乎所有的电源电路中都用到，通过电容以滤除直流电源中不需要的交流成分，使直流电变平滑）\n\n·     去耦和旁路（基于的是电容的阻抗随频率升高而降低的原理）拓展一下：去耦电容和旁路电容都是起到抗干扰的作用。对于同一电路来说，旁路电容是把输入信号中的高频噪声作为滤除对象，把前级携带的高频杂波滤除；而去耦电容也称退耦电容，是把输出信号的干扰作为滤除对象。去耦电容用在放大电路中不需要交流的地方，用来消除自激，使放大器稳定工作\n\n·     滤波器（低通滤波器、高通滤波器）\n\n·     LC谐振电路（带通滤波、陷波滤波）\n\n·     微分电路和积分电路\n\n·     电路耦合\n\n**15、RC无源滤波器**\n\n·     低通滤波器\n\n![img](clip_image032.jpg)\n\n容许低频信号通过，但减弱（或减少）频率高于截止频率信号通过的滤波器。对于不同滤波器而言，每个频率的信号的减弱程度不同\n\n·     高通滤波器\n\n![img](clip_image034.jpg)\n\n容许高频信号通过、但减弱（或减少）频率低于截止频率信号通过的滤波器。对于不同滤波器而言，每个频率的信号的减弱程度不同\n\n高通、低通滤波器利用电容在频率响应上的特点，将一个电容或电感与一个电阻相配合，产生一个分压器，以将不需要的分量衰减掉，而容许所需的分量通过\n\n ","tags":["电子","history"]},{"title":"三大无源器件之电阻","url":"/resistor/","content":"\n\n\n> 下面用三个篇章解释\n\n# 视频篇\n\n{% raw %}\n\n<iframe width=\"560\" height=\"315\" src=\"//player.bilibili.com/player.html?aid=99019699&bvid=BV1r741127C1&cid=169028314&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n{% endraw %}\n\n \n\n# 漫画篇\n\n![img](clip_image002.jpg)\n\n图片取自网络\n\n \n\n# 文字篇\n\n**电阻，作为最基础的无源器件之一，在电子电路中的应用十分广泛。**\n\n**1、电阻器与欧姆定律**\n\n**电阻器**（Resistor），泛指所有用以产生电阻的电子或电机配件。电阻器的运作跟随**欧姆定律**，其电阻值定义为其电压与电流相除所得的比值。\n\n![img](clip_image004.png)\n\n其中\n\n·     I 是流过导体的电流，单位是[安培](https://zh.wikipedia.org/wiki/安培)（A）。\n\n·     V 是导体两端的电位差，单位是[伏特](https://zh.wikipedia.org/wiki/伏特)（V）。\n\n·     R 是导体的电阻，单位是[欧姆](https://zh.wikipedia.org/wiki/歐姆)（Ω）。\n\n**2、电阻单位和转换**\n\n采用国际单位制，电阻的单位为欧姆（Ω，Ohm）。电阻的倒数为电导G，单位为西门子（S）。\n\n其还有其他转换单位：千欧(KΩ) 、兆欧(MΩ)\n\n单位转换：1兆欧(MΩ) = 1000千欧(KΩ) = 1000000欧姆(Ω)\n\n**3、电阻器的电路标志**\n\n![img](clip_image006.png)\n\n![img](clip_image008.png)\n\n**4、电阻器的主要用途**\n\n·     在放大器中，他被用做有源器件的负载、偏置电路或反馈元件；\n\n·     它与电容结合使用即可形成时间常数，并作为滤波器使用；\n\n·     它也可由于设置工作电流与信号电平；\n\n·     在电源电路中用于损耗功率，以减少相应电压；\n\n·     也用于测量电流以及在电源撤去后使电容放电；\n\n·     还用于在精准电路中建立电流，提供准确的电压比，以及设置准确的增益值；\n\n·     在逻辑电路中，作为总线和线路终端以及 “上拉” 与 “下拉” 电阻；\n\n·     在高压电路中，用于测量电压与均衡串接中的二极管或电容的泄漏电流；\n\n·     在射频电路中，甚至可以用来作为线圈，取代电感。\n\n**5、电阻的串联与并联**\n\n·     以下是一列[串联](https://zh.wikipedia.org/wiki/串聯)起来的电阻器：\n\n![img](clip_image010.png)\n\n​       电路两端的总电阻值为各电阻器的电阻之和，即\n\n![img](clip_image012.png)\n\n因此，利用电阻的串联，总可以得到一个阻值较大的电阻。\n\n·     以下是一组[并联](https://zh.wikipedia.org/wiki/並聯)的电阻器：\n\n![img](clip_image014.png)\n\n由于所有电阻的电压相同，根据欧姆定律，它们的电流与电阻成反比，故\n\n![img](clip_image016.png)\n\n因此，利用电阻的并联，总可以得到一个阻值较小的电阻。\n\n·     在对电子电路进行分析时，我们往往更喜欢利用对电路的直觉与简化来分析问题，而不是习惯于复杂的代数公式\n\n当简要分析电路是，对于串并联的分析，我们可以简化成：一个较大的电阻与一个较小的电阻串联（或并联）后其阻值接近于较大的（或较小）的电阻\n\n而为了培养我们的直觉，我们也使用 电导G = 1 /R一词来理解记忆，一个较小的电阻反而是一个较大的电导，在所加的电压作用下可通过较大的电流\n\n**6、电阻色环阻值**\n\n![img](clip_image017.jpg)\n\n**7、电阻种类**\n\n·     碳膜电阻（主要是在陶瓷棒上形成一层碳混合物膜）\n\n·     金属膜电阻（主要是利用真空沉积技术在陶瓷棒上形成一层镍铬合金镀膜）\n\n·     金属氧化膜电阻（主要是在陶瓷棒形成一层锡氧化物膜）\n\n·     绕线电阻（是将镍铬合金导线绕在氧化铝陶瓷基底上，一圈一圈控制电阻大小）\n\n·     可变电阻（可经由滑动而改变滑动端与两个固定端间电阻值的电子零件）\n\n·     压敏电阻（电阻值会随外部电压而改变）\n\n·     光敏电阻（利用光电导效应的一种特殊的电阻，与入射光的强弱有直接关系）\n\n·     热敏电阻（其阻值随温度的变化有极为显著的变化）\n\n**8、电阻参数**\n\n·     标称阻值：电阻器上面所标示的阻值\n\n·     允许误差：标称阻值与实际阻值的差值跟标称阻值之比的百分数称阻值偏差，它表示电阻器的精度\n\n·     额定功率：在正常的大气压力90-106.6KPa及环境贴片电阻参数温度为－55℃～＋70℃的条件下，电阻器长期工作所允许耗散的较大功率\n\n·     额定电压：由阻值和额定功率换算贴片电阻参数出的电压\n\n·     温度系数：温度每变化1℃所引起的电阻值的相对变化，温度系数越小，电阻的稳定性越好，阻值随温度升高而增大的为正温度系数，反之为负温度系数\n\n·     老化系数：电阻器在额定功率长期负荷下，阻值相对变化的百分数，贴片电阻,贴片电阻参数它是表示电阻器寿命长短的参数\n\n·     电压系数：在规定的电压范围内，电压每变化1伏，电阻器的相对变化量\n\n·     噪声：产生于电阻器中的一种不规则的电压起伏，包括热噪声贴片电阻,贴片电阻参数和电流噪声两部分，热噪声是由于导体内部不规则的电子自由运动，使导体任意两点的电压不规则变化\n\n平常我们一般只关注阻值、精度、额度功率，这三个指标合适即可。在数字电路中，我们无需关注太多的细节，毕竟只有 1和 0的数字里面，不必计较其微乎其微的影响；但是在模拟电路中，当我们使用精准的电压源，或者对信号进行模数转换，又或者放大一个微弱的信号时，阻值的小小变动都会带来很大的影响了\n\n**9、0 欧电阻**\n\n·     可以做跳线调试用\n\n·     在高频信号下，充当电感或电容用\n\n·     单点接地（模拟地和数字地单点接地）\n\n·     熔丝作用\n\n·     配置电路（eg：STM32的 BOOT）\n\n·     布线时作跨线处理（1206封装的电阻）\n\n**10、上拉电阻和下拉电阻**\n\n·     上拉就是将不确定的信号通过一个电阻嵌位在高电平，电阻同时起限流作用！下拉同理\n\n·     上拉是对器件注入电流，下拉是输出电流\n\n·     上拉电阻是用来解决总线驱动能力不足时提供电流的，一般说法是拉电流；下拉电阻是用来吸收电流的，也就是我们通常所说的灌电流\n\n·     弱强只是上拉电阻的阻值不同，没有什么严格区分\n\n**11、纯阻性负载电压电流的超前滞后**\n\n首先要提醒，相位的概念是针对正弦信号而言的，直流信号、非周期变化信号等都没有相位的概念\n\n对于接上了正弦波的阻性负载，通过接上理想的直流电压表、直流电流表，可以观察到波形超前滞后的现象\n\n![说明: 在这里插入图片描述](clip_image018.gif)\n\n如果还表现的还不够生动，可以用动态图演示，其用红色表示电压，蓝色表示电流：\n\n![说明: 在这里插入图片描述](clip_image019.gif)\n\n纯阻性负载其超前角是 0度，这个时候功率因数为 1\n\n \n\n# 附录：\n\n![E-96 阻值表](E_96.jpg)\n\n![E-24 阻值表](E_24.png)","tags":["电子","history"]},{"title":"git 应用速查","url":"/using-git-command/","content":"\n\n\n> **前言：git用的好，删库不用跑，记一下踩过的坑**\n\n\n\n# vim 命令\n\n## vim 插入模式命令\n\n| **命令** | **说明**                                |\n| -------- | --------------------------------------- |\n| **i**    | **实现的是在光标之前的插入**            |\n| **I**    | **大写的i实现在光标所在行的最前面插入** |\n| **a**    | **实现在光标后插入**                    |\n| **A**    | **实现在光标所在行的行尾插入**          |\n| **o**    | **实现在光标所在行的上方插入新行**      |\n| **O**    | **是现在光标坐在行的下方插入新行**      |\n\n## git 中 vim 的命令\n\n| **命令**          | **说明**                                                     |\n| ----------------- | ------------------------------------------------------------ |\n| **:w**            | 保存编辑后的文件内容，但不退出 vim 编辑器。这个命令的作用是把内存缓冲区中的数据写到启动 vim 时指定的文件中。 |\n| **:w!**           | 强制写文件，即强制覆盖原有文件。如果原有文件的访问权限不允许写入文件，例如，原有的文件为只读文件，则可使用这个命令强制写入。但是，这种命令用法仅当用户是文件的属主时才适用，而超级用户则不受此限制。 |\n| **:wq**           | 保存文件内容后退出 vim 编辑器。这个命令的作用是把内存缓冲区中的数据写到启动 vim 时指定的文件中，然后退出 vim 编辑器。另外一种替代的方法是用 `ZZ` 命令。 |\n| **:wq!**          | 强制保存文件内容后退出 vim 编辑器。这个命令的作用是把内存缓冲区中的数据强制写到启动 vim 时指定的文件中，然后退出 vim 编辑器。 |\n| **ZZ**            | 使用 `ZZ` 命令时，如果文件已经做过编辑处理，则把内存缓冲区中的数据写到启动 vim 时指定的文件中，然后退出 vim 编辑器。否则只是退出 vim 而已。注意，`ZZ` 命令前面无需加冒号 `:`，也无需按 Enter 键。 |\n| **:q**            | 在未做任何编辑处理而准备退出 vim 时，可以使用此命令。如果已做过编辑处理，则 vim 不允许用户使用 `:q` 命令退出，同时还会输出下列警告信息：No write since last change (:quit! overrides)。 |\n| **:q!**           | 强制退出 vim 编辑器，放弃编辑处理的结果。如果确实不需要保存修改后的文件内容，可输入 `:q!` 命令，强行退出 vim 编辑器。 |\n| **:w filename**   | 把编辑处理后的结果写到指定的文件中保存。                     |\n| **:w! filename**  | 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有的文件。 |\n| **:wq! filename** | 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件，并退出 vim 编辑器。 |\n\n\n\n***\n\n\n\n# git 流程图\n\n ![img](20200426223848910.png)\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n***\n\n\n\n# git 添加文件\n\n- `git add -u`\n\n添加已跟踪的被修改（modified）和被删除（deleted）文件，**不包括新文件（new）**（即：表示只添加暂存区已有的文件（包括删除操作），但不添加未跟踪的新增文件）。\n\n- `git add .`\n\n添加未跟踪的新文件（new）和已跟踪的被修改（modified）文件，**不包括被删除（deleted）文件**（注意：只能够提交当前目录或者它后代目录下相应文件）。\n\n- `git add -A`\n\n（ `git add --all` 的缩写）  添加所有变化；**是上面两个功能的合集**，可以提交未跟踪、修改和删除文件。\n\n\n\n***\n\n\n\n# git 远程强制推送\n\n- `git push -f origin master`\n\n  强制更新到 GitHub，`--force` 假如遇到冲突也让 git 强制执行\n\n\n\n***\n\n\n\n# git 删除当前分支下的所有历史版本与 log 并同步至 GitHub\n\n1. 切换到 latest_branch 分支下：\n\n   `git checkout --orphan latest_branch`\n\n2. 添加所有文件：\n\n   `git add –A`\n\n3. 提交更改：\n\n   `git commit -m '清除所有历史版本以减少仓库大小'`\n\n4. 删除分支：\n\n   `git branch -D master`\n\n5. 将当前分支重命名：\n\n   `git branch -m master`\n\n6. 最后，强制更新存储库：\n\n   `git push -f origin master`\n\n\n\n***\n\n\n\n# git 出现 \"fatal: refusing to merge unrelated histories\"\n\n**背景**：在本地初始化了一个 git 代码仓库，关联到 Github上新建的仓库，第一次执行 `git pull origin master` 拉取远程分支时，出现标题上的问题（ Git 2.9之后的版本才会出现此问题）。\n\n需要添加 `--allow-unrelated-histories` 告诉 git 允许不相关历史合并，即写成 `git pull origin master --allow-unrelated-histories` 。\n\n\n\n***\n\n\n\n# git 撤销 commit\n\n## 方法一\n\n1. 找到你想要撤销的 commit id：\n\n   `git log`\n\n2. 撤销到当前 commit id 的位置：\n\n- `--soft` ：不删除工作空间改动代码，撤销 commit，不撤销 `git add` 。\n\n  `git reset --soft commit id`\n\n**或者**\n\n- `--mixed` ：不删除工作空间改动代码，撤销 commit，并且撤销 `git add` 操作，这个为默认参数；`git reset --mixed HEAD^` 和 `git reset HEAD^` 效果是一样的。\n\n  `git reset -- mixed commit id`\n\n**亦或者**\n\n- `--hard` ：删除工作空间改动代码，撤销 commit，撤销 `git add`（即时光穿梭-版本回退）。\n\n  `git reset --hard commit id`\n\n## 方法二\n\n如果你刚执行完 commit 后，想撤回 commit，可以直接：\n\n`git reset --soft HEAD^`\n\n这样就成功的撤销了你的 commit；注意，仅仅是撤回 commit 操作。\n\n`HEAD^` 的意思是上一个版本，也可以写成 `HEAD~1` ；如果你进行了 2 次 commit，想都撤回，可以使用 `HEAD~2` ，以此类推。\n\n## 方法三\n\n如果 commit 注释写错了，想改一下注释。\n\n`git commit --amend`\n\n此时会进入默认 vim 编辑器，修改注释完毕后保存就好了，当然你也可以直接：\n\n`git commit --amend –m '新命名'`\n\n\n\n***\n\n\n\n# git 重写历史\n\n1、修改多个提交信息，可以通过给 `git rebase` 增加 `-i` 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 `git rebase -i` 命令，例如你想修改倒数第三次的历史，即 `HEAD~2^` 或 `HEAD~3`（两者是一样的），亦或者通过 commit id来操作。 记住 `~3` 可能比较容易，因为你正尝试修改最后三次提交，但是注意实际上指定了以前的四次提交；那么我们只需要修改提交的父提交：\n\n`git rebase -i HEAD~3`\n\n再次记住这是一个变基命令 —— 在 `HEAD~3 … HEAD` 范围内的每一个修改了提交信息的提交及其 **所有后裔** 都会被重写。 不要涉及任何已经推送到中央服务器的提交 —— 这样做会产生一次变更的两个版本，因而使他人困惑。\n\n2、在文本编辑器上找到想要修改的历史信息，修改 pick 为 edit；需要重点注意的是相对于正常使用的 `log` 命令，这些提交显示的顺序是相反的。\n\n3、当保存并退出编辑器时，git 将你带回到列表中的最后一次提交，然后输入 `git commit –amend` ，接着修改提交信息，然后退出编辑器；最后，运行 `git rebase --continue` ，这个命令将会自动地应用另外两个提交，然后就完成了。\n\n\n\n***\n\n\n\n# git rebase 后出现 (master|REBASE –i n/m)\n\n只需要：`git rebase --abort` ，放弃当前操作退出 rebase-merge 目录。\n\n\n\n***\n\n\n\n# git 合并多次commit，然后在保存时出现 \"error: cannot 'squash' without a previous commit\" \n\n注意不要合并先前提交过的东西，也就是已经提交远程分支的纪录。\n\n\n\n***\n\n\n\n# git rebase 报错：error: cannot rebase: You have unstaged changes. error: Please commit or stash them.\n\n有两种方法：\n\n- 一种是使用 commit 把未暂存的文件进行一次提交，但我们并不想增加一个脏的提交，虽然说可以进行 commit 合并，可这不是自找麻烦吗，那么你可以考虑第二种；\n- 第二种就是使用 `git stash` （git 储藏），`git stash` 会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录；使用该命令后会推送一个新的储藏，当前的工作目录就干净了，这样就可以接着使用 `git rebase` 了；需要说明一点，`stash` 是本地的，不会通过 `git push` 命令上传到 `git server` 上；然后想重新应用缓存的 `stash` ，可以通过 `git stash pop` 命令恢复之前缓存的工作目录。\n\n\n\n***\n\n\n\n# git stash\n\n## 常用操作\n\n- `git stash save 'save message'`\n\n  执行存储时，添加备注，方便查找，使用 `git stash` 可以，但查找时不方便识别。 \n\n- `git stash list`\n\n  查看 `stash`了哪些存储。\n\n- `git stash show`\n\n  显示做了哪些改动，默认 show 第一个存储，如果要显示其他存贮，后面加 `stash@{$num}` ，例如显示第二个： `git stash show stash@{1}` 。 \n\n- `git stash apply`\n\n  应用某个存储，但不会把存储从存储列表中删除；默认使用第一个存储，即 `stash@{0}` ；如果要应用其它，则后面加 `stash@{$num}` ， 例如应用第二个： `git stash apply stash@{1}` 。  \n\n- `git stash pop`\n\n  用于恢复之前缓存的工作目录文件，将暂存起来的文件对应修改应用到当前的工作目录下，同时将缓存堆栈中的对应 stash 删除；默认为第一个存储，即 `stash@{0}` ；如果要应用并删除其他 stash，则后面加 `stash@{$num}`  ，例如应用并删除第二个： `git stash pop stash@{1}` 。\n\n- `git stash drop stash@{$num}` \n\n  丢弃 `stash@{$num}` 存储，从列表中删除这个存储 。\n\n- `git stash clear` \n\n  删除所有缓存的 stash。\n\n## 暂存部分文件\n\n```bash\ngit add file1 file2 # 保留不想备份的文件至工作区\ngit stash save -k # 暂存未 add 的更改文件\ngit reset # 恢复工作区文件，至此，只有未 add 的更改文件被储藏\n```\n\n\n\n***\n\n\n\n# git 基于当前工作区新开一个本地分支，并把远程仓库的文件强制覆盖本地某一分支的文件\n\n有时候我们在 master 分支上 commit 了多次，但是后面觉得这些东西应该另外开一个分支 dev 存储比较好，并且想保留之前已经 push 上远程仓库的代码，那么需要以下操作：\n\n1. 先把当前的所有文件放到暂存区里面：\n\n   `git add –A`\n\n2. 新建一个分支 dev，并切换到该分支：\n\n   `git checkout -b dev`\n\n3. 把所有未提交的修改（包括暂存的和非暂存的）都保存起来：\n\n   `git stash`\n\n4. 切换回去 master 分支：\n\n   `git checkout master`\n\n5. 从远程分支拉取代码，但是不同步合并本地分支：\n\n   `git fetch –all`\n\n6. 设置本地的 master 与远程 master 的 commit 一致：\n\n   `git reset --hard origin/master`\n\n7. 回到我们工作的 dev 分支：\n\n   `git checkout dev`\n\n8. 恢复之前缓存的工作目录：\n\n   `git stash pop`\n\n\n\n***\n\n\n\n# git 删除远程分支后，仍能在本地中看到该分支\n\n1. 使用 `git push origin --delete <name>` 删除远程分之后（ `<name>` 为要删除的分支名）。\n\n2. 执行 `git branch -a` 查看远程和本地所有分之，发现还会显示已删除分支。\n\n3. 执行 `git remote show origin` 查看远程库，可看到远程分支，本地分支相对应的关系。\n\n4. 执行 `git remote prune origin` 删除远程没有本地有的分支。\n\n\n\n***\n\n\n\n# git 指定版本\n\n此时只需要三步走：\n\n1、克隆代码：`git clone xxxx.git`\n\n2、进入项目目录：`cd <项目文件夹名称>`\n\n3、切换到指定版本：`git checkout <commit SHA>`\n\n注： `<commit SHA>` 可通过 `git log` 查看。\n\n在 git submodule中也可以指定子模块的版本，方法就是：\n\n首先添加子模块，然后 cd 到子模块，checkout 到指定的版本，然后提交就可以了，跟上面的操作一样。\n\n还有一种方法，使用 `git clone -b <branch/label> xxxx.git ` 即可下载指定的分支/版本。\n\n\n\n***\n\n\n\n# 使用 .gitignore 忽略 target、.idea 文件夹等\n\n```txt\n#忽略所有.svn目录\n.svn/\n\n#忽略所有target目录\ntarget/\n\n#忽略所有.idea目录\n.idea/\n\n#忽略所有.iml文件\n*.iml\n```\n\n| 语法 | 含义                             |\n| :--- | :------------------------------- |\n| /    | 目录                             |\n| *    | 多个字符                         |\n| ?    | 单个字符                         |\n| []   | 多个可选字符匹配单个字符         |\n| !    | 不忽略（跟踪）匹配到的文件或目录 |\n\nnote：`.gitignore` 只能忽略那些**原来没有被 track（之前没有 add 过）**的文件，如果某些文件已经被纳入了版本管理中，则修改 `.gitignore` 是无效的。\n\n要想解决，就是先把本地缓存删除（改变成未 track 状态），然后再提交（假设 target 文件已被添加）：\n\n`git rm -r --cached target`\n\n此时将不再追踪 target 这个文件了。\n\n\n\n***\n\n\n\n# git 代理设置\n\n## 前提条件\n\n- 首先你得一个可用的梯子（代理）\n- 其次，确认你的梯子的代理端口号\n\n## 设置 Github上的 https 协议代理\n\nGit 代理有两种设置方式，分别是全局代理和只对 Github 代理，建议只对 Github 代理。\n\n代理协议也有两种，分别是使用 `http` 代理和使用 `socks5` 代理，建议使用 `socks5` 代理。\n\n```bash\n#使用 socks5 代理（推荐）\ngit config --global https.https://github.com.proxy socks5://127.0.0.1:[proxy_port]\n# 使用 http 代理（不推荐）\ngit config --global https.https://github.com.proxy http://127.0.0.1:[proxy_port]\n\n# note：其中 [proxy_port] 为你使用的代理端口号\n\n# 查看配置\ngit config --global --get https.https://github.com.proxy\n# or\ngit config --global -e\n```\n\n如果要取消 `https` 代理，注释掉配置或者输入以下命令：\n\n```bash\ngit config --global --unset https.https://github.com.proxy\n```\n\n## 设置 Github上的 ssh 协议代理\n\n`https` 代理存在一个局限，那就是没有办法做身份验证，每次拉取私库或者推送代码时，都需要输入 Github 的账号和密码，非常痛苦。\n\n在设置 `ssh` 代理前，请确保你已经设置 `ssh key` 。\n\n```bash\n# 编辑或创建 `~/.ssh/config` 文件\nvim ~/.ssh/config\n\n# 添加如下配置信息\n# github\nHost github.com\n    HostName github.com\n    PreferredAuthentications publickey\n    # [github_rsa] 为你的\n    IdentityFile ~/.ssh/[github_rsa]\n    # 主要是下面这一行，其中 [proxy_port] 为你使用的代理端口号\n    ProxyCommand connect -S 127.0.0.1:[proxy_port] %h %p\n    \n# 测试配置\nssh -T git@github.com\n```\n\n如果要取消 `ssh` 代理，注释掉配置或者删除文件即可。\n\n\n\n# github actions workflow 使用\n\n官方教程：https://docs.github.com/zh/actions/quickstart\n\n比较实用的：\n\nhttps://github.com/mqyqingfeng/Blog/issues/237\n\nhttps://mrseawave.github.io/blogs/articles/2021/12/17/github-actions-manual-trigger/\n\nhttps://blog.hszofficial.site/introduce/2020/11/30/%E4%BD%BF%E7%94%A8GithubActions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81/\n\n\n\n# git 子模块\n\n其命令为：`git submodule add <remote repo url> <local repo url>`\n\n- `remote repo url` 指远程仓库的 url。\n- `local repo url` 指本地仓库的路径 url。\n\neg：\n\n```shell\n// 在主库中添加 ModuleA\n$ git submodule add ./module-a.git ModuleA\n\n// 在主库中添加 ModuleB\n$ git submodule add ./module-b.git ModuleB\n```\n\n在添加了子模块后，会有一个 `.gitmodules` 配置文件，它保存了远程仓库 url 与本地仓库 url 路径的映射：\n\n```shell\n[submodule \"ModuleA\"]\n    path = ModuleA\n    url = ./module-a.git\n[submodule \"ModuleB\"]\n    path = ModuleB\n    url = ./module-b.git\n```\n\n每条记录对应一个子模块信息，path 和 url 对应远程仓库 url 和本地仓库路径。\n\n\n\n# git 分支合并提交 commit\n\n一般来说，如果使用 `git merge` ，对于分支签出往前开发后合并（fast forward merge），是没有任何合并指示的，如下图右方；若使用 `--no-ff` 选项可确保一个 fast forward merge 不会发生，而是产生一个新的提交来记录该次合并请求，如下图左方。\n\n![fast forward merge vs explicit merge](FMD5h.png)\n\n论述：https://stackoverflow.com/questions/9069061/what-effect-does-the-no-ff-flag-have-for-git-merge\n\n\n\n还有一种合并是只对某次提交进行合并，可以使用 `git cherry-pick -e <commit id>` 。\n\n\n\n# git log 导出\n\n参考：[Git 基础 - 查看提交历史](https://git-scm.com/book/zh/v2/Git-基础-查看提交历史)\n\n命令项：\n\n- --pretty 格式化输出\n\n  常见选项：\n\n  | 选项 | 说明                                          |\n  | :--: | --------------------------------------------- |\n  |  %H  | 提交的完整哈希值                              |\n  |  %h  | 提交的简写哈希值                              |\n  |  %T  | 树的完整哈希值                                |\n  |  %t  | 树的简写哈希值                                |\n  |  %P  | 父提交的完整哈希值                            |\n  |  %p  | 父提交的简写哈希值                            |\n  | %an  | 作者名字                                      |\n  | %ae  | 作者的电子邮件地址                            |\n  | %ad  | 作者修订日期（可以用 --date=选项 来定制格式） |\n  | %ar  | 作者修订日期，按多久以前的方式相对时间显示    |\n  | %cn  | 提交者的名字                                  |\n  | %ce  | 提交者的电子邮件地址                          |\n  | %cd  | 提交日期                                      |\n  | %cr  | 提交日期（距今多长时间）                      |\n  |  %s  | 提交说明                                      |\n\n- --no-merges 不显示合并的提交\n\neg：`git log --no-merges --pretty=format:\"%ai: %s\" HEAD > CHANGELOG.txt`\n\n\n\n# git 文件目录区分大小写\n\n在某些时候，如果仓库中已存在并监视了某个文件夹，然后你想把该文件夹更改一下大小转换，，而某个文件里的链接需要调用这个文件夹路径，同时你也一起更改了；当你提交到远程后，但你会发现，这样会导致修改文件夹大小写后，git 提交不生效，导致文件引用失效。\n\n其实 git 在提交的文件的时候，默认是不区分大小写更改的，可以通过以下命令查看（正常应回应 true，意味着不区分大小写）：\n\n```bash\ngit config core.ignorecase\ntrue\n```\n\n然后，我们可以使用 `git config core.ignorecase false` 使其区分大小写，值得注意的是，该操作是对这项工程起作用，并非所有 git 操作，因此在使用该命令时，必须在想要修改的 git 工程里面操作。\n\n\n\n# 附\n\n[Learn Git Branching](https://learngitbranching.js.org/?locale=zh_CN)\n\n[常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n\n[Git教程](https://www.liaoxuefeng.com/wiki/896043488029600#0)","tags":["history","git"]},{"title":"FreeRTOS 篇章之事件位和事件组","url":"/freertos-event/","content":"\n\n\n# 事件位（或标志）与事件组\n\n事件位：用于指示事件是否发生；事件位通常称为事件标志。\n\n事件组：是一组事件位；事件组中的各个事件位由位号引用（即每一 bit 代表某个事件）\n\n\n\n# 事件组和事件位数据类型\n\n事件组由 `EventGroupHandle_t` 类型的变量引用\n\n如果 `configUSE_16_BIT_TICKS` 设置为 `1` ，则事件组中存储的位数（或标志）为 8；如果 `configUSE_16_BIT_TICKS` 设置为 `0` ，则为 24；对 `configUSE_16_BIT_TICKS` 的依赖性是由于在内部实现中用于线程本地存储的数据类型任务。\n\n`configUSE_16_BIT_TICKS` 的具体的描述可以看 [FreeRTOS篇章之 FreeRTOSConfig.h分析](https://arachnid.cc/freertos-config/) 。\n\n事件组中的所有事件位都存储在 `EventBits_t` 类型的单个无符号变量中。事件位 0 存储在位位置 0，事件位 1 存储在位位置 1，依此类推。\n\n下图显示了一个 24 位事件组，该组使用三个位来保存已描述的三个示例事件。在图像中，仅事件位 2 被设置。\n\n![](20200302151607721.png)\n\n\n\n# 使用事件组必须克服的问题\n\n实施事件组时，RTOS 必须克服的两个主要挑战是：\n\n1、避免在用户的应用程序中创建竞争条件：\n\n在以下情况下，事件组的实现将会在应用程序中创建竞争条件：\n\n- 目前尚不清楚谁负责清除单个位（或标志）。\n- 尚不清楚何时清除一点。\n- 尚不清楚在任务退出测试该位值的 API函数时是否设置了位或清除了位（这可能是因为另一个任务或中断已更改了位的状态）。\n\nFreeRTOS事件组的实现通过智能的建立来确保设置、测试和清除位的原子性，从而消除了竞争条件的可能性。线程本地存储和谨慎使用 API 函数返回值使这成为可能。\n\n2、避免不确定性：\n\n事件组的概念隐含了不确定性行为，因为它不知道事件组上有多少个任务被阻止，因此，当设置了事件位时，也不知道需要测试多少条件或解除多少任务阻塞。\n\nFreeRTOS 质量标准不允许不确定的行为在中断禁用或者中断服务中发生。为确保在设置事件位时不会违反这些严格的质量标准，需要以下两点：\n\n- RTOS 调度器的锁定机制用于确保从 RTOS 任务设置事件位时，中断保持启用状态。\n- 中央延迟中断机制用于在试图从中断服务例程设置事件位时，将设置位的动作延迟到任务。\n\n\n\n# 事件组的 RTOS API 函数\n\n事件组的 API 函数允许任务或者其他事项来设置事件组中的一个或多个事件位，清除事件组中的 一个或多个事件位，并暂挂（进入“阻止”状态，因此任务不会占用任何处理时间）以等待一个或多个事件位在事件组中被置位。\n\n事件组还可用于同步任务，创建通常称为任务 “会合” 的任务。任务同步点是应用程序代码中的一个位置，在这个位置上，任务将处于阻塞状态(不消耗任何 CPU 时间)等待，直到参与同步的所有其他任务也到达它们的同步点。\n\n需要 `#include \"event_groups.h\"`\n\n| 功能                       | API 接口                      | 实际执行函数                    | 其它                 |\n| :------------------------- | :---------------------------- | :------------------------------ | :------------------- |\n| 事件组创建（动态）         | xEventGroupCreate()           |                                 |                      |\n| 事件组响应等待             | xEventGroupWaitBits()         |                                 |                      |\n| 事件组位清除               | xEventGroupClearBits()        |                                 |                      |\n| 事件组位清除（用于中断中） | xEventGroupClearBitsFromISR() | xTimerPendFunctionCallFromISR() | 实际执行函数由宏决定 |\n| 事件组置位                 | xEventGroupSetBits()          |                                 |                      |\n| 事件组置位（用于中断中）   | xEventGroupSetBitsFromISR()   | xTimerPendFunctionCallFromISR() | 实际执行函数由宏决定 |\n| 事件组位获取               | xEventGroupGetBits()          | xEventGroupClearBits()          |                      |\n| 事件组位获取（用于中断中） | xEventGroupGetBitsFromISR()   |                                 |                      |\n| 事件组释放删除             | vEventGroupDelete()           |                                 |                      |\n| 事件组创建（静态）         | xEventGroupCreateStatic()     |                                 |                      |\n\n**1、xEventGroupCreate() API 函数**\n\n```c\nEventGroupHandle_t  xEventGroupCreate( void );\n```\n\n返回参数（此返回值应当保存下来，以作为操作此队列的句柄）：\n\n- **NULL**：表示事件组创建失败。原因是内存堆空间不足导致 FreeRTOS 无法为互斥量分配结构数据空间。\n- **非 NULL**：值表示事件组创建成功。返回值应当保存起来作为该事件组的句柄。\n\n**2、xEventGroupWaitBits() API 函数**\n\n```c\nEventBits_t  xEventGroupWaitBits( EventGroupHandle_t  xEventGroup,\n                                  const EventBits_t   uxBitsToWaitFor,\n                                  const BaseType_t    xClearOnExit,\n                                  const BaseType_t    xWaitForAllBits,\n                                  const TickType_t    xTicksToWait );\n```\n\n传入参数：\n\n- **xEventGroup**：事件组的目标句柄。这个句柄即是调用 `xEventGroupCreate()` 创建该事件组时的返回值。\n- **uxBitsToWaitFor**：一个按位的值，表示在事件组中可设置的事件位（或标志）。\n- **xClearOnExit**：如果设置为 `pdTRUE` ，那么如果满足了等待条件(如果函数返回的原因不是超时)，则在事件组中设置的 `uxBitsToWaitFor` 中的任何位都将在 `xEventGroupWaitBits()` 返回之前被清除；否则，如果设置为 `pdFALSE` ，那么当调用 `xEventGroupWaitBits()` 返回时，事件组中设置的位不会改变。\n- **xWaitForAllBits**：如果设置为 `pdTRUE` ，那么当 `uxBitsToWaitFor` 中的所有位被设置或者指定的块时间过期时，`xEventGroupWaitBits()` 将返回；否则，如果设置为 `pdFALSE` ，那么当 `uxBitsToWaitFor` 中设置的任何一个位或者指定的块时间过期时，`xEventGroupWaitBits()` 将返回。\n- **xTicksToWait**：阻塞超时时间。\n\n返回参数：\n\n- 事件组中事件位的设置情况。如果 `xEventGroupWaitBits()` 因为超时而返回，则不会设置所有正在等待的事件位；在 `xClearOnExit` 参数被设置为 `pdTRUE` 的情况下，如果 `xEventGroupWaitBits()` 是因为它正在等待的位被设置而返回，那么返回的值就是在任何位被自动清除之前的事件组值。\n\n**3、xEventGroupClearBits() API 函数**\n\n```c\nEventBits_t  xEventGroupClearBits( EventGroupHandle_t  xEventGroup,\n                                   const EventBits_t   uxBitsToClear );\n```\n\n传入参数：\n\n- **xEventGroup**：要清除其中位的事件组。\n- **uxBitsToClear** ：位值。表示在事件组中要清除的事件位（或标志）。\n\n返回参数：\n\n- 清除指定位之前的事件组的值\n\n**4、xEventGroupClearBitsFromISR() API 函数**\n\n```c\nBaseType_t  xEventGroupClearBitsFromISR( EventGroupHandle_t  xEventGroup,\n                                         const EventBits_t   uxBitsToClear );\n```\n\n传入参数：\n\n- **xEventGroup**：要清除其中位的事件组。\n- **uxBitsToClear** ：位值。表示在事件组中要清除的事件位（或标志）。\n\n返回参数（有两个可能的返回值）：\n\n- **pdPASS**：成功发送请求。\n- **pdFALSE**：发送请求失败。计时器服务队列已满。\n\n**5、xEventGroupSetBits() API 函数**\n\n```c\nEventBits_t  xEventGroupSetBits( EventGroupHandle_t  xEventGroup,\n                                 const EventBits_t   uxBitsToSet );\n```\n\n传入参数：\n\n- **xEventGroup**：要在其中位设置的事件组。\n- **uxBitsToSet** ：一个按位的值，表示要设置的事件位（或标志）。\n\n返回参数：\n\n- 事件组在调用 `xEventGroupSetBits()` 时的值。\n\n注意：用户通过参数 `uxBitsToSet` 设置的标志位并不一定会保留到此函数的返回值中，返回的值可能清除有以下两种情况：\n 　a. 调用此函数的过程中，其它高优先级的任务就绪了，并且也修改了事件标志，此函数返回的事件标志位会发生变化。\n 　b. 调用此函数的任务是一个低优先级任务，通过此函数设置了事件标志后，让一个等待此事件标志的高优先级任务就绪了，会立即切换到高优先级任务去执行，相应的事件标志位会被函数 `xEventGroupWaitBits` 清除掉，等从高优先级任务返回到低优先级任务后，函数 `xEventGroupSetBits` 的返回值已经被修改。\n\n**6、xEventGroupSetBitsFromISR() API 函数**\n\n```c\nBaseType_t  xEventGroupSetBitsFromISR( EventGroupHandle_t  xEventGroup,\n                                       const EventBits_t   uxBitsToSet,\n                                       BaseType_t          *pxHigherPriorityTaskWoken );\n```\n\n传入参数：\n\n- **xEventGroup**：要在其中位设置的事件组。\n- **uxBitsToSet** ：一个按位的值，表示要设置的事件位（或标志）。\n- **pxHigherPriorityTaskWoken**：用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 `pdTRUE` ，说明有高优先级任务要执行，否则没有；必须将 `xHigherPriorityTaskWoken` 初始化为 `pdFALSE` 。\n\n返回参数（有两个可能的返回值）：\n\n- **pdPASS**：成功发送请求。\n- **pdFALSE**：发送请求失败。计时器服务队列已满。\n\n**7、xEventGroupGetBits() API 函数**\n\n```c\nEventBits_t  xEventGroupGetBits( EventGroupHandle_t  xEventGroup );\n```\n\n传入参数：\n\n- **xEventGroup**：需要查询的事件组。\n\n返回参数：\n\n- 调用 `xEventGroupGetBits()` 时的事件组位。\n\n**8、xEventGroupGetBitsFromISR() API 函数**\n\n```c\nEventBits_t  xEventGroupGetBitsFromISR( EventGroupHandle_t  xEventGroup );\n```\n\n传入参数：\n\n- **xEventGroup**：需要查询的事件组。\n\n返回参数：\n\n- 调用 `xEventGroupGetBitsFromISR()` 时的事件组位。\n\n**9、xEventGroupDelete() API 函数**\n\n```c\nvoid xEventGroupDelete( EventGroupHandle_t  xEventGroup );\n```\n\n传入参数：\n\n- **xEventGroup**：需要删除的事件组。\n\n**10、xEventGroupCreateStatic() API 函数**\n\n```c\nEventGroupHandle_t  xEventGroupCreateStatic( EventGroupHandle_t  *pxEventGroupBuffer );\n```\n\n该函数是用于在静态的时候，利用该函数创建一个事件组，具体可以去看他的注释，这里就不说了。\n\n\n\n# 实例代码\n\n相关的实例代码及文档，参看保存在官方文件路径 `FreeRTOS/Demo/Common/Minimal` 下的 `EventGroupsDemo.c` 文件","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之临界区与调度器","url":"/freertos-critical-scheduler/","content":"\n\n\n# 临界区简述\n\n**临界区**指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性；当有线程进入临界区时，其他线程或是进程必须等待。总的概括来说就是在执行该程序片段区间，不允许其他东西干扰到。\n\n像我们在 MCU 上面跑实时操作系统，一般都是单核单进程的，而一个进程可以拥有多个线程；FreeRTOS 是主要以抢占式任务调度为主（通过 PendSV 中断），以时间片轮转调度任务为辅（通过 SysTick 系统节拍器中断）的实时操作系统，并且可支持同等优先级切换，具体配置可以看 [FreeRTOS 篇章之 FreeRTOSConfig.h 分析](https://arachnid.cc/freertos-config/) ；而刚讲的线程其实就相当于我们用 xTaskCreate 函数创建的各种任务。在这里，我们要实现临界区操作，那么就相当于要保证当前所处在的需要保护的代码片段不要受其他任务（线程）的干扰（例如同等优先级的切换、中断的触发）。\n\n在 FreeRTOS 中，实现临界区操作有临界段操作和调度器操作两种，一般常用临界段来实现实现临界区操作。\n\n\n\n------\n\n\n\n# 临界段的特性\n\n临界段是提供互斥功能的一种非常原始的实现方法。临界段的工作仅仅是简单地把任务切换和在 `configKERNEL_INTERRUPT_PRIORITY` 至 `configMAX_SYSCAL_INTERRUPT_PRIORITY` 之间的中断关掉 —— 依赖于具体使用的 FreeRTOS 移植。\n\n临界段的使用必须只具有很短的时间，否则会反过来影响中断响应时间；在每次调用 `taskENTER_CRITICAL()` 之后，必须尽快地配套调用一个 `taskEXIT_CRITICAL()` 。\n\n临界段嵌套是安全的，因为内核有维护一个嵌套深度计数。临界段只会在嵌套深度为 0时才会真正退出 —— 即在为每个之前调用的 `taskENTER_CRITICAL()` 都配套调用了 `taskEXIT_CRITICAL()` 之后。\n\n\n\n# 与临界段相关的 API 函数\n\n| 功能                            | API函数              | 其它 |\n| :------------------------------ | :------------------- | :--- |\n| 进入临界段                      | taskENTER_CRITICAL() |      |\n| taskENTER_CRITICAL_FROM_ISR()   | 用于中断中           |      |\n| 退出临界段                      | taskEXIT_CRITICAL()  |      |\n| taskEXIT_CRITICAL_FROM_ISR( x ) | 用于中断中           |      |\n\n```c\n/**\n * task. h\n *\n * Macro to mark the start of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * NOTE: This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\defgroup taskENTER_CRITICAL taskENTER_CRITICAL\n * \\ingroup SchedulerControl\n */\n#define taskENTER_CRITICAL()\t\tportENTER_CRITICAL()\n#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()\n\n/**\n * task. h\n *\n * Macro to mark the end of a critical code region.  Preemptive context\n * switches cannot occur when in a critical region.\n *\n * NOTE: This may alter the stack (depending on the portable implementation)\n * so must be used with care!\n *\n * \\defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL\n * \\ingroup SchedulerControl\n */\n#define taskEXIT_CRITICAL()\t\t\tportEXIT_CRITICAL()\n#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )\n```\n\n\n\n------\n\n\n\n# 临界段的使用\n\n在 FreeRTOS 中，临界段一般是指宏 `taskENTER_CRITICAL()` 与 `taskEXIT_CRITICAL()` 之间的代码区间，而在中断中则是 `taskENTER_CRITICAL_FROM_ISR()` 和 `taskEXIT_CRITICAL_FROM_ISR()` 之间。\n\n例如，在 [FreeRTOS篇章之二值信号量](https://arachnid.cc/freertos-binary-semaphore/) 中的 `USART1_IRQHandler(void)` 中断函数中，我们可以加入临界区操作，变成：\n\n```c\n/************************************************************************/\n/*            STM32F10x USART Interrupt Handlers                        */\n/************************************************************************/\n\n/**\n  * @brief  This function handles USART1 global interrupt request.\n  * @param  None\n  * @retval None\n  */\nvoid USART1_IRQHandler(void)\n{\n    uint32_t ulReturn;\n    BaseType_t xHigherPriorityTaskWoken = pdFALSE;\n\n\t\n    /* 为了保证在对 DMA数据进行处理不被打断，将此操作放入临界区 */\n    ulReturn = taskENTER_CRITICAL_FROM_ISR();    // 进入临界段，可以嵌套\n\n    /* 在 taskENTER_CRITICAL_FROM_ISR()与 taskEXIT_CRITICAL_FROM_ISR()之间或\n       在 taskENTER_CRITICAL()与 taskEXIT_CRITICAL()之间并不会切换到其它任务，\n       同时，在 configKERNEL_INTERRUPT_PRIORITY至 configMAX_SYSCAL_INTERRUPT_PRIORITY 之间\n       的中断将会被关掉，但对于优先级高于 configMAX_SYSCALL_INTERRUPT_PRIORITY的中断\n       并没有关掉，而且这些中断不允许访问 FreeRTOS API函数. */\n    if(USART_GetITStatus(EVAL_COM1, USART_IT_IDLE)!=RESET)\n    {\t\t\n        DMA_Cmd(USART1_RX_DMA_CHANNEL, DISABLE);\n        DMA_ClearFlag(DMA1_FLAG_TC5);\n        Usart1.RxCounter = RxBUFFER_SIZE - DMA_GetCurrDataCounter(USART1_RX_DMA_CHANNEL);\n        USART1_RX_DMA_CHANNEL->CNDTR = RxBUFFER_SIZE;\n        DMA_Cmd(USART1_RX_DMA_CHANNEL, ENABLE);\n\t\t\t\t\n        xSemaphoreGiveFromISR(xBinarySemaphore, &xHigherPriorityTaskWoken);\n        portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);\n        USART_ReceiveData(EVAL_COM1);\t\t\t// Clear IDLE interrupt flag bit\n    }\n  \n    /* 退出临界段 */\n    taskEXIT_CRITICAL_FROM_ISR( ulReturn );\n\n\n//  if(USART_GetITStatus(EVAL_COM1, USART_IT_TXE) != RESET)\n//  {\n//    /* Write one byte to the transmit data register */\n//    USART_SendData(EVAL_COM1, TxBuffer[TxCounter++]);\n\n//    if(TxCounter == RxBUFFER_SIZE)\n//    {\n//      /* Disable the EVAL_COM1 Transmit interrupt */\n//      USART_ITConfig(EVAL_COM1, USART_IT_TXE, DISABLE);\n//    }\n//  }\n}\n```\n\n\n\n# 用挂起调度器来创建临界区\n\n调度器总是在所有处于就绪态的任务中选择具有最高优先级的任务来执行的（这就是 FreeRTOS 的优先级调度算法）。\n\n因此创建临界区也可以通过挂起调度器来实现；挂起调度器有些时候也被称为锁定调度器。\n\n临界段保护一段代码区间不被其它任务或中断打断（此处的中断是指归 FreeRTOS 管理的中断）。通过挂起调度器实现的临界区只可以保护一段代码区间不被其它任务打断，因为这种方式下，中断是使能的（此处的中断是指所有的中断，包含归 FreeRTOS 管理的中断）。\n 如果一个临界区太长而不适合简单地关中断来实现，可以考虑采用挂起调度器的方式；但是唤醒（resuming, or un-suspending）调度器却是一个相对较长的操作，所以评估哪种是最佳方式需要结合实际情况。\n\n利用 `vTaskSuspendAll();` 把调度器挂起，这样可以停止上下文切换而没有关中断；如果某个中断在调度器挂起过程中要求进行上下文切换，则个这请求也会被挂起，直到调度器被唤醒后才会得到执行（即调用 `xTaskResumeAll();` 恢复调度器）。\n\n注意：在调度器处于挂起状态时（即 `vTaskSuspendAll();` 至 `xTaskResumeAll();` 之间），不能调用 FreeRTOS API 函数。\n\n\n\n**1、vTaskSuspend() API 函数**\n\n```c\nvoid vTaskSuspend( TaskHandle_t  xTaskToSuspend );\n```\n\n输入参数：\n\n- 需要挂起的某个任务的句柄，这个句柄是创建任务时所引用出来的；当传递空值句柄时，将导致当前调用任务暂停；当任务暂停时，将永远无法获得任何微控制器的处理时间，无论其优先级如何。\n\n**2、vTaskResume() API 函数**\n\n```c\nvoid vTaskResume( TaskHandle_t  xTaskToResume );\n```\n\n输入参数：\n\n- 需要恢复成就绪状态的任务的句柄\n\n**3、xTaskResumeFromISR() API 函数**\n\n```c\nBaseType_t  xTaskResumeFromISR( TaskHandle_t  xTaskToResume );\n```\n\n输入参数：\n\n- 需要恢复成就绪状态的任务的句柄。\n\n返回参数：\n\n- 如果恢复任务，则为 `pdTRUE` ，否则为 `pdFALSE` 。ISR 使用它来确定是否需要在 ISR 之后进行上下文切换。\n\n**4、vTaskSuspendAll() API 函数**\n\n```c\nvoid vTaskSuspendAll( void );\n```\n\n说明：挂起调度器而不禁用中断。当调度器挂起时，上下文切换将不会发生。在调用 `vTaskSuspendAll()` 之后，调用任务将继续执行；在调用 `xTaskResumeAll()` 之前，不会有被切换出去的风险，直到对 `xTaskResumeAll()` 的调用完成。当调度器被挂起时，不能调用可能导致上下文切换的 API函数（例如， `vTaskDelayUntil()` 、 `xQueueSend()` 等）。\n\n**5、xTaskResumeAll() API 函数**\n\n```c\nBaseType_t  xTaskResumeAll( void );\n```\n\n返回参数：\n\n- 在调度器挂起过程中，上下文切换请求也会被挂起，直到调度器被唤醒后才会得到执行。如果一个挂起的上下文切换请求在 `xTaskResumeAll()` 返回前得到执行，则函数返回 `pdTRUE` 。在其它情况下，`xTaskResumeAll()` 返回 `pdFALSE` 。\n\n说明：在调用 `vTaskSuspendAll()` 挂起调度程序活动后，恢复该活动。`xTaskResumeAll()` 只恢复调度程序。它不会解除先前通过调用 `vTaskSuspend()` 挂起的任务。\n\n\n\n嵌套调用 `vTaskSuspendAll()` 和 `xTaskResumeAll()` 是安全的，因为内核有维护一个嵌套深度计数。调度器只会在嵌套深度计数为 0 时才会被唤醒 —— 即在为每个之前调用的 `vTaskSuspendAll()` 都配套调用了 `xTaskResumAll()` 之后\n\n\n\n# 与调度器相关的 API\n\n| 功能                     | API函数               |\n| :----------------------- | :-------------------- |\n| 启动调度器               | vTaskStartScheduler() |\n| 停止调度器               | vTaskEndScheduler()   |\n| 挂起某个任务             | vTaskSuspend()        |\n| 恢复某个任务             | vTaskResume()         |\n| 恢复某个任务（用于中断） | xTaskResumeFromISR()  |\n| 挂起所有调度器           | vTaskSuspendAll()     |\n| 恢复所有调度器           | xTaskResumeAll()      |","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之互斥量","url":"/freertos-mutex-semaphore/","content":"\n\n\n# 与二值量区别及应用\n\n互斥量是一种特殊的二值信号量，用于控制在两个或多个任务间访问共享资源。\n\n访问一个被多任务共享，或是被任务与中断共享的资源时，需要采用 “互斥” 技术以保证数据在任何时候都保持一致性。这样做的目的是要确保任务从开始访问资源就具有排它性，直至这个资源又恢复到完整状态。\n\n在用于互斥的场合，互斥量从概念上可看作是与共享资源关联的令牌。一个任务想要合法地访问资源，其必须先成功地得到（Take）该资源对应的令牌（成为令牌持有者）。当令牌持有者完成资源使用，其最好马上归还（Give）令牌，因为只有归还了令牌，其它任务才可能成功持有，也才可能安全地访问该共享资源。一个任务除非持有了令牌，否则不允许访问共享资源。\n\n它的特性场景：\n\n![img](2020022418230370.gif)\n\n这种机制纯粹是工作于应用程序作者制定的规则之下。任务不是在任何时候都可以访问资源是不需要理由的，因为这是所有任务达成的一致，除非它们能成为互斥量的持有者。\n\n可以对比一下上一篇 [FreeRTOS篇章之二值信号量](https://arachnid.cc/freertos-binary-semaphore/) 的特性图。\n\n虽然互斥量与二值信号量之间具有很多相同的特性，但两者间最大的区别在于信号量在被获得之后所发生的事情：\n\n- 用于互斥的信号量需要归还。\n- 用于同步的信号量通常是完成同步之后便丢弃，不用归还。\n\n值得注意的是，互斥量不能在中断中使用：\n\n- 互斥量的优先级继承属性意味着只能在任务间使用\n- 中断在等待一个互斥量保护的资源的时候，不能阻塞\n\n\n\n# 优先级反转\n\n假设我们创建了两个任务，任务一跟任务二，任务二的优先级高于任务一的优先级，同时还创建了一个互斥量；当运行的时候，任务一获取了这个互斥量（成为令牌持有者），紧接着任务二也需要这个互斥量来共享资源（此时任务一并没有执行完成，释放互斥量），对于正常情况向下，高优先级任务的可以打断低优先任务，但是，由于互斥量的特性（只有归还了令牌，其它任务才可能成功持有，否则不允许访问共享资源，进入阻塞等待令牌归还），高优先级的任务二竟然必须等待低优先级的任务一放弃对互斥量的持有权。因此，高优先级任务被低优先级任务阻塞推迟的行为被称为 “优先级反转” 。\n\n如果把这种行为再进一步放大，当高优先级任务正等待信号量的时候，一个介于两个任务优先之间的中等优先级任务开始执行 —— 这就会导致一个高优先级任务在等待一个低优先级任务，而低优先级任务却无法执行！\n\n如下图：\n\n![img](20200225112317242.png)\n\n\n\n# 优先级继承\n\nFreeRTOS 中互斥量与二值信号量十分相似 —— 唯一的区别就是互斥量自动提供了一个基本的 ”优先级继承” 机制。\n\n优先级继承是最小化优先级反转负面影响的一种方案 —— 其并不能修正优先级反转带来的问题，仅仅是减小优先级反转的影响。优先级继承使得系统行为的数学分析更为复杂，所以如果可以避免的话，并不建议系统实现对优先级继承有所依赖。\n\n优先级继承暂时地将互斥量持有者的优先级提升至所有等待此互斥量的任务所具有的最高优先级；持有互斥量的低优先级任务 “继承” 了等待互斥量的任务的优先级；互斥量持有者在归还互斥量时，优先级会自动设置为其原来的优先级。\n\n优先级继承最小化优先级反转的影响：\n\n![img](20200225112349522.png)\n\n\n\n# 死锁\n\n死锁是利用互斥量提供互斥功能的另一个潜在缺陷。Deadlock 有时候会被更戏剧性地称为 “deadly embrace（抱死）”。\n\n当两个任务都在等待被对方持有的资源时，两个任务都无法再继续执行，这种情况就被称为死锁。考虑如下情形，任务 A 与任务 B 都需要获得互斥量 X 与互斥量 Y 以完成各自的工作：\n\n1. 任务 A 执行，并成功获得了互斥量 X。\n2. 任务 A 被任务 B 抢占。\n3. 任务 B 成功获得了互斥量 Y，之后又试图获取互斥量 X —— 但互斥量 X 已经被任务 A 持有，所以对任务 B 无效。任务 B 选择进入阻塞态以等待互斥量 X 被释放。\n4. 任务 A 得以继续执行。其试图获取互斥量 Y ——但互斥量 Y已经被任务 B 持有而对任务 A 无效。任务 A 也选择进入阻塞态以等待互斥量 Y被释放。\n\n这种情形的最终结局是，任务 A在等待一个被任务 B持有的互斥量，而任务 B也在等待一个被任务 A持有的互斥量。死锁于是发生，因为两个任务都不可能再执行下去了。\n\n和优先级反转一样，避免死锁的最好方法就是在设计阶段就考虑到这种潜在风险，这样设计出来的系统就不应该会出现死锁的情况。于实践经验而言，对于一个小型嵌入式系统，死锁并不是一个大问题，因为系统设计者对整个应用程序都非常清楚，所以能够找出发生死锁的代码区域，并消除死锁问题。\n\n\n\n# API函数\n\n需要 `#include \"semphr.h\"`\n\n| 功能               | API 接口                      | 实际执行函数              | 其它 |\n| :----------------- | :---------------------------- | :------------------------ | :--- |\n| 互斥量创建（动态） | xSemaphoreCreateMutex()       | xQueueCreateMutex()       |      |\n| 互斥量获取         | xSemaphoreTake()              | xQueueGenericReceive()    |      |\n| 互斥量释放         | xSemaphoreGive()              | xQueueGenericSend()       |      |\n| 互斥量创建（静态） | xSemaphoreCreateMutexStatic() | xQueueCreateMutexStatic() |      |\n\n**1、xSemaphoreCreateMutex() API 函数**\n\n```c\nSemaphoreHandle_t  xSemaphoreCreateMutex( void );\n```\n\n返回参数：\n\n- **NULL**：表示互斥量创建失败。原因是内存堆空间不足导致 FreeRTOS 无法为互斥量分配结构数据空间。\n- **非 NULL**：值表示互斥量创建成功。返回值应当保存起来作为该互斥量的句柄。\n\n**2、xSemaphoreTake() API 函数**\n\n```c\nBaseType_t  xSemaphoreTake( SemaphoreHandle_t  xSemaphore,\n                            TickType_t         xBlockTime );\n```\n\n传入参数：\n\n- **xSemaphore**：获取得到的信号量。信号量由定义为 xSemaphoreHandle类型的变量引用；信号量在使用前必须先创建\n- **xTicksToWait**：阻塞超时时间。任务进入阻塞态以等待信号量有效的最长时间。如果 `xTicksToWait` 为 `0` ，则 `xSemaphoreTake()` 在信号量无效时会立即返回；如果把 `xTicksToWait` 设置为 `portMAX_DELAY` ，那么阻塞等待将没有超时限制。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：成功获得信号量。\n- **pdFALSE**：未能获得信号量。\n\n**3、xSemaphoreGive() API 函数**\n\n```c\nBaseType_t  xSemaphoreGive( SemaphoreHandle_t  xSemaphore );\n```\n\n传入参数：\n\n- **xSemaphore**：给出的信号量。信号量由定义为 `xSemaphoreHandle` 类型的变量引用；信号量在使用前必须先创建。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：信号量被释放。\n- **pdFALSE**：信号量已经有效，无法给出。\n\n**4、xSemaphoreCreateMutexStatic() API函数**\n\n```c\nSemaphoreHandle_t  xSemaphoreCreateMutexStatic( StaticSemaphore_t  *pxMutexBuffer );\n```\n\n该函数是用于在静态的时候，利用该函数创建一个互斥量的，具体可以去看他的注释，这里就不说了。\n\n值得注意的是：当用 `xSemaphoreCreateMutexStatic` 创建一个静态互斥量后，该互斥量量是默认 “Give” 给出去了的，所以在 `xSemaphoreCreateMutexStatic` 创建后没有立即调用 `xSemaphoreTake` ，那么，它将通过你的第一次阻塞处理。\n\n\n\n# 其他\n\n这里就不放整个例程了，跟 [FreeRTOS篇章之队列管理](https://arachnid.cc/freertos-queue/) 中差不多，只不过用互斥量来处理；像我们常用的多线程 printf 输出会出现乱码现象，可以如以下处理：\n\n```c\nextern SemaphoreHandle_t MuxSem_UartPrintf;\n#define USER_DEBUG\t\t\t\t1\n#define DEBUG_PRINTF(fmt,arg...)\t\t\tdo{\\\n\t\t\t\t\t\t\t\t\t\t\tif(USER_DEBUG)\\\n\t\t\t\t\t\t\t\t\t\t\t\txSemaphoreTake(MuxSem_UartPrintf, portMAX_DELAY);\\\n\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"<<-DEBUG INFO->> %s > \"fmt\"\",__FUNCTION__, ##arg);\\\n\t\t\t\t\t\t\t\t\t\t\t\txSemaphoreGive(MuxSem_UartPrintf);\\\n\t\t\t\t\t\t\t\t\t\t\t}while(0)\n```\n\n\n\n然后，我们只需要在硬件初始化化的创建好互斥量，后面就可以用 `DEBUG_PRINTF` 宏来打印无乱码现象的数据输出了，而且还可以通过 USER_DEBUG宏来选择时候显示调试信息。\n\n前面也都说了，为了避免在 RTOS 中多个任务同时访问公用数据共享资源（或者同一硬件），因此，当有一个任务在访问处理共享资源时，其他的任务要停止对共享资源的访问，以避免出现数据访问（或处理）出错，所以可以用互斥量来处理这些问题；当然在使用互斥量的时候要注意上面所说的那一些缺陷。\n\n\n\n最后，说一下递归互斥量：\n\n递归互斥量（ `Recursive Mutexes` ）是互斥量的一个特例，与互斥量基本相同；除了：递归互斥量可以由拥有者多次获取，但是也要求拥有者释放相同次数。比如，一个递归互斥量被获取了 5 次，那么同样需要释放 5 次。","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之二值信号量","url":"/freertos-binary-semaphore/","content":"\n\n\n# 采用二值信号量同步\n\n二值信号量可以在某个特殊的中断发生时，让任务解除阻塞，相当于让任务与中断同步。这样就可以让中断事件处理量大的工作在同步任务中完成，中断服务例程 (ISR)中只是快速处理少部份工作。\n\n如果某个中断处理要求特别紧急，其延迟处理任务的优先级可以设为最高，以保证延迟处理任务随时都抢占系统中的其它任务。\n\n在这种中断同步的情形下，信号量可以看作是一个深度为 1 的队列。这个队列由于最多只能保存一个数据单元，所以其非空则满（所谓 “二值” 即二进制，只有 0 / 1）。延迟处理任务调用 `xSemaphoreTake()` 时，等效于带阻塞时间地读取队列，如果队列为空的话任务则进入阻塞态。当事件发生后，ISR 简单地通过调用 `xSemaphoreGiveFromISR()` 放置一个令牌（信号量）到队列中，使得队列成为满状态。这也使得延迟处理任务切出阻塞态，并移除令牌，使得队列再次成为空。\n\n其演示过程：\n\n![img](20200220173730247.gif)\n\n\n\n# API 函数\n\n要想调用以下函数，需要 `#include \"semphr.h\"`\n\n| 功能                         | API 接口                       | 实际执行函数                | 其它 |\n| :--------------------------- | :----------------------------- | :-------------------------- | :--- |\n| 二值信号量创建（动态）       | vSemaphoreCreateBinary()       |                             | 弃用 |\n| 二值信号量创建（动态）       | xSemaphoreCreateBinary()       | xQueueGenericCreate()       |      |\n| 二值信号量获取               | xSemaphoreTake()               | xQueueGenericReceive()      |      |\n| 二值信号量释放               | xSemaphoreGive()               | xQueueGenericSend()         |      |\n| 二值信号量获取（用于中断中） | xSemaphoreTakeFromISR()        | xQueueReceiveFromISR()      |      |\n| 二值信号量释放（用于中断中） | xSemaphoreGiveFromISR()        | xQueueGiveFromISR()         |      |\n| 二值信号量创建（静态）       | xSemaphoreCreateBinaryStatic() | xQueueGenericCreateStatic() |      |\n\n**1、vSemaphoreCreateBinary() API 函数（弃用）**\n\n```c\nvoid vSemaphoreCreateBinary( xSemaphore )\n```\n\n传入参数：\n\n- **xSemaphore**：创建的二值信号量\n\n需要说明的是 `vSemaphoreCreateBinary()` 在实现上是一个宏，所以信号量变量应当直接传入，而不是传址。\n\n注意：在新的版本中一般是通过 `xSemaphoreCreateBinary(void)` 函数返回一个 `SemaphoreHandle_t` 值，并以此创建一个二值信号量。\n\n**2、SemaphoreHandle_t xSemaphoreCreateBinary() API 函数**\n\n```c\n#define xSemaphoreCreateBinary()  xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )\n```\n\n返回参数：\n\n- **SemaphoreHandle_t**：创建的二值信号量\n\n为什么放弃 `vSemaphoreCreateBinary()` 函数以及它们之间的区别我们可以看一下它的注释：\n\n```c\n/* \n  This old vSemaphoreCreateBinary() macro is now deprecated in favour of \n  the xSemaphoreCreateBinary() function. Note that binary semaphores created using \n  the vSemaphoreCreateBinary() macro are created in a state such \n  that the first call to 'take' the semaphore would pass, \n  whereas binary semaphores created using xSemaphoreCreateBinary() are created \n  in a state such that the the semaphore must first be 'given' before it can be 'taken'.\n*/\n```\n\n**3、xSemaphoreTake() API 函数**\n\n```c\nBaseType_t  xSemaphoreTake( SemaphoreHandle_t  xSemaphore,\n                            TickType_t         xBlockTime );\n```\n\n传入参数：\n\n- **xSemaphore**：获取得到的信号量。信号量由定义为 `xSemaphoreHandle` 类型的变量引用；信号量在使用前必须先创建。\n- **xTicksToWait**：阻塞超时时间。任务进入阻塞态以等待信号量有效的最长时间。如果 `xTicksToWait` 为 `0` ，则 `xSemaphoreTake()` 在信号量无效时会立即返回；如果把 `xTicksToWait` 设置为 `portMAX_DELAY` ，那么阻塞等待将没有超时限制。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：成功获得信号量。\n- **pdFALSE**：未能获得信号量。\n\n**4、xSemaphoreGive() API 函数**\n\n```c\nBaseType_t  xSemaphoreGive( SemaphoreHandle_t  xSemaphore );\n```\n\n传入参数：\n\n- **xSemaphore**：给出的信号量。信号量由定义为 `xSemaphoreHandle` 类型的变量引用；信号量在使用前必须先创建。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：信号量被释放。\n- **pdFALSE**：信号量已经有效，无法给出。\n\n**5、xSemaphoreTakeFromISR() API 函数**\n\n```c\nBaseType_t  xSemaphoreTakeFromISR( SemaphoreHandle_t  xSemaphore,\n                                   BaseType_t         *pxHigherPriorityTaskWoken );\n```\n\n传入参数：\n\n- **xSemaphore**：给出的信号量。信号量由定义为 `xSemaphoreHandle` 类型的变量引用；信号量在使用前必须先创建。\n- **pxHigherPriorityTaskWoken**：如果获取该信号量导致一个任务解除阻塞，并且被解除阻塞的任务的优先级高于当前运行的任务，那么 `xSemaphoreTakeFromISR()` 将把 `*pxHigherPriorityTaskWoken` 设置为 `pdTRUE` 。如果 `xSemaphoreTakeFromISR()` 将该值设置为 `pdTRUE` ，则应该在退出中断之前请求上下文切换。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**： `xSemaphoreTakeFromISR()` 调用成功。\n- **pdFALSE**：信号量释放失败。\n\n**6、xSemaphoreGiveFromISR() API 函数**\n\n```c\nBaseType_t  xSemaphoreGiveFromISR( SemaphoreHandle_t  xSemaphore,\n                                   BaseType_t         *pxHigherPriorityTaskWoken );\n```\n\n传入参数：\n\n- **xSemaphore**：给出的信号量。信号量由定义为 `xSemaphoreHandle` 类型的变量引用；信号量在使用前必须先创建。\n- **pxHigherPriorityTaskWoken**：如果调用 `xSemaphoreGiveFromISR()` 使得一个任务解除阻塞，并且这个任务的优先级高于当前任务（也就是被中断的任务），那么 `xSemaphoreGiveFromISR()` 会在函数内部将 `*pxHigherPriorityTaskWoken` 设为 `pdTRUE` 。如果 `xSemaphoreGiveFromISR()` 将此值设为 `pdTRUE` ，则在中断退出前应当进行一次上下文切换。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**： `xSemaphoreGiveFromISR()` 调用成功。\n- **errQUEUE_FULL**：信号量已经有效，无法给出。\n\n**7、xSemaphoreCreateBinaryStatic() API 函数**\n\n```c\nSemaphoreHandle_t  xSemaphoreCreateBinaryStatic( StaticSemaphore_t  *pxSemaphoreBuffer );\n```\n\n该函数是用于在静态的时候，利用该函数创建一个二值信号量的，具体可以去看他的注释，这里就不说了。\n\n\n\n# 演示例程\n\n二值信号量多用于 1v1 这种情况，因为它只有两个值（0 / 1），非空则满，有点类似于在非 RTOS 中定义的标志位；由于可以在任务与中断同步，并且存在超时机制，那本次例程就可以把它应用到串口 DMA 接收中。\n\n```c main.c\n/*\n    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.\n\n    ***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n    ***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n    the FAQ page \"My application does not run, what could be wrong?\".  Have you\n    defined configASSERT()?\n\n    http://www.FreeRTOS.org/support - In return for receiving this top quality\n    embedded software for free we request you assist our global community by\n    participating in the support forum.\n\n    http://www.FreeRTOS.org/training - Investing in training allows your team to\n    be as productive as possible as early as possible.  Now you can receive\n    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n    Ltd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n/* Standard includes. */\n#include <stdio.h>\n#include <string.h>\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n#include \"semphr.h\"        // 信号量相关的头文件\n\n/* Library includes. */\n#include \"stm32f10x_it.h\"\n\n/* Private app includes. */\n#include \"bsp_uart.h\"\n#include \"bsp_gpio.h\"\n\n\n/* Task priorities. */\n#define mainCREATOR_TASK_PRIORITY           ( tskIDLE_PRIORITY + 1 )\n\n/*----------------------------- End -----------------------------*/\n\n/*\n * User Private Task.\n */\nstatic void prvUser_Task( void *pvParameters );\n\n/*\n * Configure the clocks, GPIO and other peripherals as required by the demo.\n */\nstatic void prvSetupHardware( void );\n\n/*----------------------------- End -----------------------------*/\n\n\n/************************************************\n函数名称 ： main\n功    能 ： 主函数入口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nint main( void )\n{\n#ifdef DEBUG\n  debug();\n#endif\n\n\tprvSetupHardware();\n\t\n\t/* Start the tasks defined within this file/specific to this demo. */\n\txTaskCreate( prvUser_Task, \"prvUser_Task\", configMINIMAL_STACK_SIZE, NULL, mainCREATOR_TASK_PRIORITY, NULL );\n\t\n\t/* Start the scheduler. */\n\tvTaskStartScheduler();\n\n\t/* Will only get here if there was not enough heap space to create the\n\tidle task. */\n\treturn 0;\n}\n/*----------------------------- End -----------------------------*/\n\n/************************************************\n函数名称 ： prvSetupHardware\n功    能 ： 为了方便管理，所有的用户任务都放在该函数里面\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nstatic void prvUser_Task( void *pvParameters )\n{\t\n\t/* User-defined private tasks */\n\t\n\tprintf(\">>>>> delete user task\\r\\n\");\n\tvTaskDelete(NULL);\t\t// 删除自己\n}\n\n/************************************************\n函数名称 ： prvSetupHardware\n功    能 ： 硬件接口初始化配置\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nstatic void prvSetupHardware( void )\n{\n\t/* Start with the clocks in their expected state. */\n\tRCC_DeInit();\n\n\t/* Enable HSE (high speed external clock). */\n\tRCC_HSEConfig( RCC_HSE_ON );\n\n\t/* Wait till HSE is ready. */\n\twhile( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET )\n\t{\n\t}\n\n\t/* 2 wait states required on the flash. */\n\t*( ( unsigned long * ) 0x40022000 ) = 0x02;\n\n\t/* HCLK = SYSCLK */\n\tRCC_HCLKConfig( RCC_SYSCLK_Div1 );\n\n\t/* PCLK2 = HCLK */\n\tRCC_PCLK2Config( RCC_HCLK_Div1 );\n\n\t/* PCLK1 = HCLK/2 */\n\tRCC_PCLK1Config( RCC_HCLK_Div2 );\n\n\t/* PLLCLK = 8MHz * 9 = 72 MHz. */\n\tRCC_PLLConfig( RCC_PLLSource_HSE_Div1, RCC_PLLMul_9 );\n\n\t/* Enable PLL. */\n\tRCC_PLLCmd( ENABLE );\n\n\t/* Wait till PLL is ready. */\n\twhile(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n\t{\n\t}\n\n\t/* Select PLL as system clock source. */\n\tRCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK );\n\n\t/* Wait till PLL is used as system clock source. */\n\twhile( RCC_GetSYSCLKSource() != 0x08 )\n\t{\n\t}\n\n\t/* Configure HCLK clock as SysTick clock source. */\n\tSysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );\n\t\n\t/*\n\t * STM32中断优先级分组为 4，即 4bit都用来表示抢占优先级，范围为：0~15\n\t * 优先级分组只需要分组一次即可，以后如果有其他的任务需要用到中断，\n\t * 都统一用这个优先级分组，千万不要再分组，切忌。\n\t */\n\tNVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );\n\t\n\t/* Other peripheral configuration */\n//\tvSetupTimer();\n\tvSetupUSART();\n\tvSetupParPort();\n}\n/*----------------------------- End -----------------------------*/\n```\n\n主程序没什么好解释的，初始化硬件的配置，建立所需的任务；真正实现的任务在下面的源文件中，主要是方便分类，规范一点便于管理。\n\n```c bsp_uart.c\n#include \"bsp_uart.h\"\n\n#include <string.h>\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n#include \"semphr.h\"\n\n\n#define BAUDRATE_1\t\t115200;\t\t\t// 波特率设置\t支持的波特率：115200,19200,9600,38400,57600,1200,2400,4800\n#define BAUDRATE_2\t\t115200;\t\t\t// 波特率设置\t支持的波特率：115200,19200,9600,38400,57600,1200,2400,4800\n\nUartRx_Buff_TypeDef Usart1;\n\nQueueHandle_t xQueueUartTx;\nQueueHandle_t xQueueUart1_Rx;\n\nSemaphoreHandle_t xBinarySemaphore = NULL;      // 定义一个二值信号量\n\n\nstatic void Uart_DMA_RxConfig( DMA_Channel_TypeDef*DMA_CHx,uint32_t PeripheralBaseAddr,uint32_t MemoryBaseAddr,uint16_t Bufsize,uint32_t Priority,uint32_t Mode );\n\n\nstatic void prvUart1_Rx_Task( void *pvParameters )\n{\t\n\tfor( ; ; )\n\t{\n\t\txSemaphoreTake(xBinarySemaphore, portMAX_DELAY);    // 无超时阻塞，等待成功获取信号量；此处也没有必要检测返回值\n\t\tif(Usart1.RxCounter > 0)\n\t\t{\n\t\t\tprintf(\"len=%d 收到数据:%s\\n\",Usart1.RxCounter,Usart1.RxBuffer);\n\t\t\tmemset(Usart1.RxBuffer, 0, RxBUFFER_SIZE);\n\t\t}\n\t}\n}\n\n/************************************************\n函数名称 ： vSetupUSART\n功    能 ： UART初始化接口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid vSetupUSART( void )\n{\n\tUART1_Config();\n//\tUART2_Config();\n\t\n//\tvSemaphoreCreateBinary(xBinarySemaphore);            \n\txBinarySemaphore = xSemaphoreCreateBinary();        // 创建二值信号量\n\tmemset(Usart1.RxBuffer, 0, RxBUFFER_SIZE);\n\t\n\txTaskCreate( prvUart1_Rx_Task, \"prvUart1_Rx_Task\", 500, NULL, tskIDLE_PRIORITY + 3, NULL );\n}\n\n/************************************************\n函数名称 ： UART1_Config\n功    能 ： UART1端口配置\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid UART1_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n\t/* config GPIOA clock */\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n    /* config USART1 clock */\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\n    /* USART1 GPIO config */\n    /* Configure USART1 Tx (PA.09) as alternate function push-pull */\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\n\n    /* Configure USART1 Rx (PA.10) as input floating */\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\n\n    /* Enable the USART1 Interrupt */\n    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;\n\tNVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 7;\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    /* USART1 mode config */\n    USART_InitStructure.USART_BaudRate = BAUDRATE_1;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    USART_Init(EVAL_COM1, &USART_InitStructure);\n\n\t/* DMA config */\n\tUart_DMA_RxConfig(USART1_RX_DMA_CHANNEL,\n\t\t\t\t\t(uint32_t)&USART1->DR,\n\t\t\t\t\t(uint32_t)Usart1.RxBuffer,\n\t\t\t\t\tRxBUFFER_SIZE,\n\t\t\t\t\tDMA_Priority_Medium,\n\t\t\t\t\tDMA_Mode_Circular);\n\n\tUSART_ITConfig(EVAL_COM1, USART_IT_IDLE, ENABLE);          // 这里使能的是空闲中断\n\tUSART_DMACmd(EVAL_COM1, USART_DMAReq_Rx, ENABLE);\n    USART_Cmd(EVAL_COM1, ENABLE);\n}\n\n/************************************************\n函数名称 ： Uart_DMA_RxConfig\n功    能 ： 串口 DMA接收配置（限串口 1/2/3）\n参    数 ： DMA_CHx ---- \n\t\t\tPeripheralBaseAddr ---- Specifies the peripheral base address for DMAy Channelx\n\t\t\tMemoryBaseAddr ---- Specifies the memory base address for DMAy Channelx\n\t\t\tBufsize ---- Specifies the buffer size, in data unit, of the specified Channel\n\t\t\tPriority ---- @ref DMA_priority_level\n\t\t\tMode ---- @ref DMA_circular_normal_mode\n返 回 值 ： 无\n*************************************************/\nstatic void Uart_DMA_RxConfig( DMA_Channel_TypeDef* DMA_CHx,\t\\\n\t\t\t\t\t\t\t uint32_t PeripheralBaseAddr,\t\\\n\t\t\t\t\t\t\t uint32_t MemoryBaseAddr,\t\\\n\t\t\t\t\t\t\t uint16_t Bufsize,\t\\\n\t\t\t\t\t\t\t uint32_t Priority,\t\\\n\t\t\t\t\t\t\t uint32_t Mode )\n{\n\tDMA_InitTypeDef DMA_InitStructure;\n\t\n\t/* USARTx RX DMA1 Channel (triggered by USARTx Rx event) Config */\n \tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);\n\t\n    DMA_DeInit(DMA_CHx);\n   \tDMA_InitStructure.DMA_PeripheralBaseAddr = PeripheralBaseAddr;\n\tDMA_InitStructure.DMA_MemoryBaseAddr = MemoryBaseAddr;\n\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;\n\tDMA_InitStructure.DMA_BufferSize = Bufsize;\n\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\n\tDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;\n\tDMA_InitStructure.DMA_Mode = Mode;\n\tDMA_InitStructure.DMA_Priority = Priority;\n\tDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n\tDMA_Init(DMA_CHx, &DMA_InitStructure);\n\t\n\tDMA_ClearFlag(DMA1_FLAG_GL3 | DMA1_FLAG_GL5 | DMA1_FLAG_GL6);\n\tDMA_ITConfig(DMA_CHx, DMA_IT_TE, ENABLE);\n\tDMA_Cmd (DMA_CHx,ENABLE);\n}\n\n/************************************************\n函数名称 ： USART_SendByte\n功    能 ： 串口字符发送\n参    数 ： c ---- 发送的数据\n返 回 值 ： 无\n*************************************************/\nvoid USART_SendByte( USART_TypeDef* USARTx, uint8_t c )\n{     \n\tUSART_SendData(USARTx, c);\n\t\n\twhile (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET);\n}\n\n/************************************************\n函数名称 ： USART_SendString\n功    能 ： 串口字符串发送\n参    数 ： USARTx ---- 串口\n\t\t\tpData ---- 字符串\n\t\t\tLength ---- 长度\n返 回 值 ： 无\n*************************************************/\nvoid USART_SendString( USART_TypeDef* USARTx, const uint8_t *pData, uint16_t Length )\n{\n    while(Length--)\n    {\n        USART_SendByte(USARTx, *pData);\n        pData++;\n    }\n}\n\n/************************************************\n函数名称 ： USART_Printf\n功    能 ： 串口打印输出\n参    数 ： USARTx ---- 串口\n\t\t\tString\t---- 字符串\n返 回 值 ： 无\n*************************************************/\nvoid USART_Printf( USART_TypeDef* USARTx, char *String )\n{\n    do\n    {\n        USART_SendByte(USARTx, *String);\n        String++;\n    }while((*String) != '\\0');\n}\n\n\n/************************************************\n函数名称 ： fputc\n功    能 ： 重定向 c库函数 printf到 DEBUG_UART\n参    数 ： ch\n返 回 值 ： 无\n*************************************************/\nint fputc(int ch, FILE *f)\n{\n    /* 发送一个字节数据到 DEBUG_UART */\n    USART_SendData(DEBUG_UART, (uint8_t) ch);\n\n    /* 等待发送完毕 */\n    while (USART_GetFlagStatus(DEBUG_UART, USART_FLAG_TXE) == RESET);\n\n    return (ch);\n}\n\n/************************************************\n函数名称 ： fgetc\n功    能 ： 重定向 c库函数 scanf到 DEBUG_UART\n参    数 ： f ---- 文件\n返 回 值 ： 无\n*************************************************/\nint fgetc(FILE *f)\n{\n    /* 等待 DEBUG_UART输入数据 */\n    while (USART_GetFlagStatus(DEBUG_UART, USART_FLAG_RXNE) == RESET);\n\n    return (int)USART_ReceiveData(DEBUG_UART);\n}\n\n\n/************************************************************************/\n/*            STM32F10x USART Interrupt Handlers                        */\n/************************************************************************/\n\n/**\n  * @brief  This function handles USART1 global interrupt request.\n  * @param  None\n  * @retval None\n  */\nvoid USART1_IRQHandler(void)\n{\n\tBaseType_t xHigherPriorityTaskWoken = pdFALSE;\n\n\n\tif(USART_GetITStatus(EVAL_COM1, USART_IT_IDLE)!=RESET)\n\t{\n\t\tDMA_Cmd(USART1_RX_DMA_CHANNEL, DISABLE);\n\t\tDMA_ClearFlag(DMA1_FLAG_TC5);\n\t\tUsart1.RxCounter = RxBUFFER_SIZE - DMA_GetCurrDataCounter(USART1_RX_DMA_CHANNEL);    // 获取接收长度\n\t\tUSART1_RX_DMA_CHANNEL->CNDTR = RxBUFFER_SIZE;\n\t\tDMA_Cmd(USART1_RX_DMA_CHANNEL, ENABLE);\n\t\t\t\t\n\t\txSemaphoreGiveFromISR(xBinarySemaphore, &xHigherPriorityTaskWoken);    // 'Give' the semaphore to unblock the task\n\t\tportEND_SWITCHING_ISR(xHigherPriorityTaskWoken);        // 上下切换\n\t\tUSART_ReceiveData(EVAL_COM1);\t\t\t// Clear IDLE interrupt flag bit\n\t}\n\t\n\n//  if(USART_GetITStatus(EVAL_COM1, USART_IT_TXE) != RESET)\n//  {\n//    /* Write one byte to the transmit data register */\n//    USART_SendData(EVAL_COM1, TxBuffer[TxCounter++]);\n\n//    if(TxCounter == RxBUFFER_SIZE)\n//    {\n//      /* Disable the EVAL_COM1 Transmit interrupt */\n//      USART_ITConfig(EVAL_COM1, USART_IT_TXE, DISABLE);\n//    }\n//  }\n}\n\n\n/*---------------------------- END OF FILE ----------------------------*/\n```\n\n这里跟往常中的配置不一样，是使用了 DMA + IDLE 来进行串口接收处理，因为 DMA 并不占用 CPU，DMA 只需在传输完成的时候产生一个中断，告诉 CPU 我已经完成了，然后 CPU 知道了就去处理数据，这样子提高了 CPU 的利用率，可以更好的让出硬件资源；若是像在 [STM32笔记之 USART（串口）](https://blog.csdn.net/qq_42992084/article/details/104098531) 中那样直接用接收中断来接收，那样的话，每接收一个数据就要进入中断，这样频繁的进出中断，打断程序的执行，只会让跑起来的程序变得不那么实时性；而且，既然 ST 有这个 DMA 资源可以使用，并且是不占 CPU 的，那我们没必要不使用啊，使用操作系统，无非就是为了提高实时性，榨干 CPU 的资源，又怎会让这串口接收而使得效率降低呢？\n\n1、串口 DMA 接收的流程：\n\n串口 DMA 接收在初始化的时候就处于开启状态，一直等待数据的到来，在软件上无需做任何事情，只要在初始化配置的时候设置好配置就可以了。\n\n2、数据接收完成后处理：\n\n这里主要通过串口空闲中断来判断接收完成（主要是为了实现串口 DMA 不定长数据的接收），即当串口数据流停止后，就会产生 IDLE 中断。\n\n然后我们只需要在中断中做以下操作：\n\n- 关闭串口接收 DMA 通道（防止数据未处理又接收到数据；为 DMA 重新赋值）。\n- 清除 DMA 所有标志位。\n- 从 DMA 寄存器中获取接收到的数据字节数。\n- 重新设置 DMA 下次要接收的数据字节数（这里是给 DMA 寄存器重新设置接收的计数值，这个数量只能大于或者等于可能接收的字节数，否则当 DMA 接收计数器递减到 0 的时候，就会重载这个计数值，重新循环递减计数，造成接收缓冲区的数据被覆盖丢失。）注意：对 DMA 的相关寄存器配置写入，必须要在关闭 DMA 的条件进行，否则操作无效。\n- 开启 DMA 通道，等待下一次的数据接收。\n\n说明一下，STM32 的 IDLE 的中断在串口无数据接收的情况下，并不会一直产生的，产生的条件是：当清除 IDLE 标志位后，必须有接收到至少一个数据后，才开始触发；当一段时间没有接收到数据，便产生 IDLE 中断。\n\n```c bsp_uart.h\n#ifndef __BSP_UART_H\n#define __BSP_UART_H\n\n\n#include <stdio.h>\n#include \"stm32f10x.h\"\n\n\n#define DEBUG_UART\t\t\t\tUSART1\n#define EVAL_COM1\t\t\t\tUSART1\n#define EVAL_COM2\t\t\t\tUSART2\n\n#define USART1_RX_DMA_CHANNEL\tDMA1_Channel5\n#define USART2_RX_DMA_CHANNEL\tDMA1_Channel6\n\n#define TxBUFFER_SIZE  \t \t\t100\n#define RxBUFFER_SIZE  \t\t \t100\n\n#define UART_QUEUE_RX_LENGTH\t2\n#define UART_QUEUE_TX_LENGTH\t2\n\ntypedef struct\n{\n\tuint8_t Receiving_Time;\t\t\t\t\t// 接收时间\n\tuint8_t Frame_flag;\t\t\t\t\t\t// 一帧完成标志\n}EVAL_COMx_TypeDef;\n\ntypedef struct\n{\n\tuint8_t RxBuffer[RxBUFFER_SIZE];\t\t// 接收暂存缓冲区\n\t__IO uint8_t RxCounter;\t\t\t\t\t// 接收数据个数\n}UartRx_Buff_TypeDef;\nextern UartRx_Buff_TypeDef Usart1;\n\ntypedef struct\n{\n\tuint8_t TxBuffer[TxBUFFER_SIZE];\t\t// 发送暂存缓冲区\n\t__IO uint8_t TxCounter;\t\t\t\t\t// 发送数据个数\n\tUSART_TypeDef* COMx;\t\t\t\t\t// 串口号\n}UartTx_Buff_TypeDef;\n\nvoid vSetupUSART( void );\nvoid UART1_Config(void);\nvoid UART2_Config(void);\nvoid USART_SendByte( USART_TypeDef* USARTx, uint8_t c );\nvoid USART_SendString( USART_TypeDef* USARTx, const uint8_t *pData, uint16_t Length );\nvoid USART_Printf( USART_TypeDef* USARTx, char *String );\n\n\n#endif\t/* __BSP_UART_H */\n\n\n/*---------------------------- END OF FILE ----------------------------*/\n```\n\n","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之队列管理","url":"/freertos-queue/","content":"\n\n\n# 队列特性\n\n队列可以保存有限个具有确定长度的数据单元。队列可以保存的最大单元数目被称为队列的 “ 深度 ” ；在队列创建时需要设定其深度和每个单元的大小。\n\n通常情况下，队列被作为 FIFO（先进先出）使用，即数据由队列尾写入，从队列首读出；当然，由队列首写入也是可能的。\n\n然后我们看一下队列的处理过程：\n\n![img](20200219230912853.gif)\n\n\n\n# 队列的 API 函数\n\n要想调用以下函数，需要 `#include \"queue.h\"`\n\n**1、队列创建**\n\n| 属性 | API 接口             | 实际执行函数                |\n| :--- | :------------------- | :-------------------------- |\n| 动态 | xQueueCreate()       | xQueueGenericCreate()       |\n| 静态 | xQueueCreateStatic() | xQueueGenericCreateStatic() |\n\n**2、队列发送**\n\n| 入队方式                            | API 接口                   | 实际执行函数               | 其他                      |\n| ----------------------------------- | -------------------------- | -------------------------- | :------------------------ |\n| 从队列尾部入队                      | xQueueSend()               | xQueueGenericSend()        |                           |\n| 同上                                | xQueueSendToBack()         | 同上                       |                           |\n| 同上                                | xQueueOverwrite()          | 同上                       | 仅用于消息数目为 1 的队列 |\n| 从队列首部入队                      | xQueueSendToFront()        | 同上                       |                           |\n|                                     |                            |                            |                           |\n| 从队列尾部入队 <br/> （用于中断中） | xQueueSendFromISR()        | xQueueGenericSendFromISR() |                           |\n| 同上                                | xQueueSendToBackFromISR()  | 同上                       |                           |\n| 同上                                | xQueueOverwriteFromISR()   | 同上                       | 仅用于消息数目为 1 的队列 |\n| 从队列首部入队 <br/> （用于中断中） | xQueueSendToFrontFromISR() | 同上                       |                           |\n\n**3、队列接收**\n\n| 出队方式                        | API 接口               | 实际执行函数           |\n| :------------------------------ | :--------------------- | :--------------------- |\n| 出队并删除                      | xQueueReceive()        | xQueueGenericReceive() |\n| 出队不删除                      | xQueuePeek()           | 同上                   |\n|                                 |                        |                        |\n| 出队并删除 <br/> （用于中断中） | xQueueReceiveFromISR() | xQueueReceiveFromISR() |\n| 出队不删除 <br/> （用于中断中） | xQueuePeekFromISR()    | xQueuePeekFromISR()    |\n\n**4、队列复位及删除**\n\n| 功能         | API 接口       | 实际执行函数         |\n| :----------- | :------------- | :------------------- |\n| 复位清空内存 | xQueueReset()  | xQueueGenericReset() |\n| 删除释放内存 | vQueueDelete() | vQueueDelete()       |\n\n\n\n# 常用队列函数分析\n\n**1、xQueueCreate() API 函数**\n\n```c\nQueueHandle_t  xQueueCreate( UBaseType_t  uxQueueLength,\n                             UBaseType_t  uxItemSize );\n```\n\n传入参数：\n\n- **uxQueueLength**：队列项长度；即队列能够存储的最大消息数目，也称为队列深度。\n- **uxItemSize**：信息大小；即队列中每个消息数目的数据大小，以字节为单位。\n\n返回参数（此返回值应当保存下来，以作为操作此队列的句柄）：\n\n- **NULL**：表示没有足够的堆空间分配给队列而导致创建失败。\n- **非 NULL**：表示队列创建成功。\n\n**2、xQueueSendToBack() 与 xQueueSendToFront() API 函数**\n\n```c\nBaseType_t  xQueueSendToBack( QueueHandle_t  xQueue,\n                              const void     *pvItemToQueue,\n                              TickType_t     xTicksToWait );\n```\n\n```c\nBaseType_t  xQueueSendToFront( QueueHandle_t  xQueue,\n                               const void     *pvItemToQueue,\n                               TickType_t     xTicksToWait );\n```\n\n`xQueueSendToFront()` 与 `xQueueSendToBack()` 函数参数及返回值。\n\n传入参数：\n\n- **xQueue**：目标队列的句柄。这个句柄即是调用 `xQueueCreate()` 创建该队列时的返回值。\n- **pvItemToQueue**：发送数据的指针。其指向将要复制到目标队列中的数据单元。\n- **xTicksToWait**：阻塞超时时间。如果在发送时队列已满，这个时间即是任务处于阻塞态等待队列空间有效的最长等待时间；如果 `xTicksToWait` 设为 `0` ， 则 `xQueueSendToFront()` 与 `xQueueSendToBack()` 均会立即返回；如果把 `xTicksToWait` 设置为 `portMAX_DELAY`，那么阻塞等待将没有超时限制。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：数据被成功发送到队列中。\n- **errQUEUE_FULL**：由于队列已满而无法将数据写入。\n\n**3、xQueueReceive() 与 xQueuePeek() API 函数**\n\n```c\nBaseType_t  xQueueReceive( QueueHandle_t  xQueue,\n                           void           *pvBuffer,\n                           TickType_t     xTicksToWait );\n```\n\n```c\nBaseType_t  xQueuePeek( QueueHandle_t  xQueue,\n                        void           *pvBuffer,\n                        TickType_t     xTicksToWait );\n```\n\n`xQueueReceive()` 与 `xQueuePeek()` 函数参数与返回值。\n\n传入参数：\n\n- **xQueue**：被读队列的句柄。这个句柄即是调用 `xQueueCreate()` 创建该队列时的返回值\n- **pvBuffer**：接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据\n- **xTicksToWait**：阻塞超时时间。如果在接收时队列为空，则这个时间是任务处于阻塞状态以等待队列数据有效的最长等待时间；如果 `xTicksToWait` 设为 `0` ， 则 `xQueueRecieve()` 与 `xQueuePeek()` 均会立即返回；如果把 `xTicksToWait` 设置为 `portMAX_DELAY` ，那么阻塞等待将没有超时限制。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：成功地从队列中读到数据。\n- **pdFALSE**：在读取时由于队列已空而没有读到任何数据。\n\n\n\n# 大型数据单元处理\n\n如果队列存储的数据单元尺寸较大，那最好是利用队列来传递数据的指针而不是对数据本身在队列上一字节一字节地拷贝进或拷贝出。传递指针无论是在处理速度上还是内存空间利用上都更有效；但是，当你利用队列传递指针时，一定要十分小心地做到以下两点：\n\n**1、指针指向的内存空间的所有权必须明确**\n\n当任务间通过指针共享内存时，应该从根本上保证所不会有任意两个任务同时修改共享内存中的数据，或是以其它行为方式使得共享内存数据无效或产生一致性问题。原则上，共享内存在其指针发送到队列之前，其内容只允许被发送任务访问；共享内存指针从队列中被读出之后，其内容亦只允许被接收任务访问。\n\n**2、指针指向的内存空间必须有效**\n\n如果指针指向的内存空间是动态分配的，只应该有一个任务负责对其进行内存释放。当这段内存空间被释放之后，就不应该有任何一个任务再访问这段空间。\n\n切忌用指针访问任务栈上分配的空间。因为当栈帧发生改变后，栈上的数据将不再有效。\n\n\n\n# 例程测试\n\n```c main.c\n/* Standard includes. */\n#include <stdio.h>\n#include <string.h>\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n\n/* Library includes. */\n#include \"stm32f10x_it.h\"\n\n/* Private app includes. */\n#include \"bsp_time.h\"\n#include \"bsp_uart.h\"\n#include \"bsp_gpio.h\"\n\n\n/* Task priorities. */\n#define mainCREATOR_TASK_PRIORITY           ( tskIDLE_PRIORITY + 3 )\n\n/*----------------------------- End -----------------------------*/\n\n/*\n * User Private Task.\n */\nstatic void prvUser_Task( void *pvParameters );\n\n/*\n * Configure the clocks, GPIO and other peripherals as required by the demo.\n */\nstatic void prvSetupHardware( void );\n\n/*----------------------------- End -----------------------------*/\n\n\n/************************************************\n函数名称 ： main\n功    能 ： 主函数入口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nint main( void )\n{\n#ifdef DEBUG\n  debug();\n#endif\n\n\tprvSetupHardware();\n\n\t/* Start the tasks defined within this file/specific to this demo. */\n\txTaskCreate( prvUser_Task, \"prvUser_Task\", configMINIMAL_STACK_SIZE, NULL, mainCREATOR_TASK_PRIORITY, NULL );\n\t\n\t/* Start the scheduler. */\n\tvTaskStartScheduler();\n\n\t/* Will only get here if there was not enough heap space to create the\n\tidle task. */\n\treturn 0;\n}\n/*----------------------------- End -----------------------------*/\n\nextern QueueHandle_t xQueueUartTx;\nvoid vSender1_Task( void *pvParameters )\n{\t\n\tUartTx_Buff_TypeDef uart_data;\n\t\n\tstrcpy((char *)uart_data.TxBuffer,\"TaskA Running\\r\\n\");\n\n\tuart_data.TxCounter = strlen(\"TaskA running\\r\\n\");\n\tprintf(\"Task A was created successfully....\\r\\n\");\n\tuart_data.COMx = EVAL_COM1;\n\t\t\n\twhile(1){\n\t\t/* 延时 800个tick */\n\t\tvTaskDelay(800);\n\t\txQueueSend(xQueueUartTx, (void *)&uart_data, portMAX_DELAY);\n\t}\n}\n\nvoid vSender2_Task( void *pvParameters )\n{\t\n\tUartTx_Buff_TypeDef uart_data;\n\n\tstrcpy((char *)uart_data.TxBuffer,\"TaskB Running\\r\\n\");\n\n\tuart_data.TxCounter = strlen(\"TaskB running\\r\\n\");\n\tprintf(\"Task B was created successfully....\\r\\n\");\n\tuart_data.COMx = EVAL_COM1;\n\t\t\n\twhile(1){\n\t\t/* 延时 800个tick */\n\t\tvTaskDelay(800);\n\t\txQueueSend(xQueueUartTx, (void *)&uart_data, portMAX_DELAY);\n\t}\n}\n\nstatic void prvUser_Task( void *pvParameters )\n{\t\n\t/* User-defined private tasks */\n\txTaskCreate( vSender1_Task, \"vSender1_Task\", configMINIMAL_STACK_SIZE + 300, NULL, tskIDLE_PRIORITY+2, NULL );\n\txTaskCreate( vSender2_Task, \"vSender2_Task\", configMINIMAL_STACK_SIZE + 300, NULL, tskIDLE_PRIORITY+2, NULL );\n\t\n\tprintf(\"delete user task\\n\");\n\tvTaskDelete(NULL);\t\t// 删除自己\n}\n\nstatic void prvSetupHardware( void )\n{\n\t/* Start with the clocks in their expected state. */\n\tRCC_DeInit();\n\n\t/* Enable HSE (high speed external clock). */\n\tRCC_HSEConfig( RCC_HSE_ON );\n\n\t/* Wait till HSE is ready. */\n\twhile( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET )\n\t{\n\t}\n\n\t/* 2 wait states required on the flash. */\n\t*( ( unsigned long * ) 0x40022000 ) = 0x02;\n\n\t/* HCLK = SYSCLK */\n\tRCC_HCLKConfig( RCC_SYSCLK_Div1 );\n\n\t/* PCLK2 = HCLK */\n\tRCC_PCLK2Config( RCC_HCLK_Div1 );\n\n\t/* PCLK1 = HCLK/2 */\n\tRCC_PCLK1Config( RCC_HCLK_Div2 );\n\n\t/* PLLCLK = 8MHz * 9 = 72 MHz. */\n\tRCC_PLLConfig( RCC_PLLSource_HSE_Div1, RCC_PLLMul_9 );\n\n\t/* Enable PLL. */\n\tRCC_PLLCmd( ENABLE );\n\n\t/* Wait till PLL is ready. */\n\twhile(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n\t{\n\t}\n\n\t/* Select PLL as system clock source. */\n\tRCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK );\n\n\t/* Wait till PLL is used as system clock source. */\n\twhile( RCC_GetSYSCLKSource() != 0x08 )\n\t{\n\t}\n\n\t/* Configure HCLK clock as SysTick clock source. */\n\tSysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );\n\t\n\t/*\n\t * STM32中断优先级分组为 4，即 4bit都用来表示抢占优先级，范围为：0~15\n\t * 优先级分组只需要分组一次即可，以后如果有其他的任务需要用到中断，\n\t * 都统一用这个优先级分组，千万不要再分组，切忌。\n\t */\n\tNVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );\n\t\n\t/* Other peripheral configuration */\n//\tvSetupTimer();\n\tvSetupUSART();\n\tvSetupParPort();\n}\n\n/*----------------------------- End -----------------------------*/\n```\n\n由总工程上看到，我们主要创建了两个 task 作为队列的发送；为什么要多此一举用队列来传输打印数据，而不直接调用 `printf` 函数输出呢？在 RTOS 应用中，我们知道每个任务都相当于是独立的，这样就会出现一种情况就是，Task A 在打印输出数据，而刚好 Task B 也要打印数据，那么在同一时间，输出的数据就可能出现叠加或者丢包乱码了；为了试验一下，所以在代码中把 Task A 和 Task B 的运行例子设计成一样，包括优先级；另外添加像我们以前没用 RTOS 一样直接打印数据，看会有什么情况，然后再贴上队列接收的任务：\n\n```c bsp_uart.c\n#include \"bsp_uart.h\"\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n\n\n#define BAUDRATE_1\t\t115200;\t\t\t// 波特率设置\t支持的波特率：115200,19200,9600,38400,57600,1200,2400,4800\n#define BAUDRATE_2\t\t115200;\t\t\t// 波特率设置\t支持的波特率：115200,19200,9600,38400,57600,1200,2400,4800\n\n\nQueueHandle_t xQueueUartTx;\n\n\nstatic void prvUartTx_Task( void *pvParameters )\n{\n\tUartTx_Buff_TypeDef uart_data;\n\t\n\tfor( ; ; ){\n\t\tif(xQueueReceive(xQueueUartTx, (void *)&uart_data, portMAX_DELAY) == pdPASS){\n\t\t\tif(uart_data.TxBuffer > 0){\n\t\t\t\tprintf(\"len = %d\\n\",uart_data.TxCounter);\n\t\t\t\tUSART_SendString(uart_data.COMx, uart_data.TxBuffer, uart_data.TxCounter);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/************************************************\n函数名称 ： vSetupUSART\n功    能 ： UART初始化接口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid vSetupUSART( void )\n{\n\tUART1_Config();\n//\tUART2_Config();\n\t\n\t/* Create the queue used by the Usart task. */\n\txQueueUartTx = xQueueCreate((unsigned portBASE_TYPE)UART_QUEUE_TX_LENGTH, sizeof(UartTx_Buff_TypeDef));\t// 目标队列的句柄\n//\txQueueUart1_Rx = xQueueCreate((unsigned portBASE_TYPE)UART_QUEUE_RX_LENGTH, sizeof(UartRx_Buff_TypeDef));\t// 目标队列的句柄\n\txQueueUart1_Rx = xQueueCreate((unsigned portBASE_TYPE)20, sizeof(uint8_t));\t// 目标队列的句柄\n\n\txTaskCreate( prvUartTx_Task, \"prvUartTx_Task\", 300, NULL, tskIDLE_PRIORITY + 3, NULL );\n\txTaskCreate( prvUart1_Rx_Task, \"prvUart1_Rx_Task\", 500, NULL, tskIDLE_PRIORITY + 3, NULL );\n}\n\n/************************************************\n函数名称 ： UART1_Config\n功    能 ： UART1端口配置\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid UART1_Config(void)\n{\n    GPIO_InitTypeDef GPIO_InitStructure;\n    NVIC_InitTypeDef NVIC_InitStructure;\n    USART_InitTypeDef USART_InitStructure;\n\n    /* config GPIOA clock */\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n\t\n    /* config USART1 clock */\n    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);\n\n    /* USART1 GPIO config */\n    /* Configure USART1 Tx (PA.09) as alternate function push-pull */\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\n\n    /* Configure USART1 Rx (PA.10) as input floating */\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n    GPIO_Init(GPIOA, &GPIO_InitStructure);\n\n    /* Enable the USART1 Interrupt */\n    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;\n\tNVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 7;\n    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;\n    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n    NVIC_Init(&NVIC_InitStructure);\n\n    /* USART1 mode config */\n    USART_InitStructure.USART_BaudRate = BAUDRATE_1;\n    USART_InitStructure.USART_WordLength = USART_WordLength_8b;\n    USART_InitStructure.USART_StopBits = USART_StopBits_1;\n    USART_InitStructure.USART_Parity = USART_Parity_No ;\n    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n    USART_Init(EVAL_COM1, &USART_InitStructure);\n\n\tUSART_ITConfig(EVAL_COM1, USART_IT_RXNE, ENABLE);\n    USART_Cmd(EVAL_COM1, ENABLE);\n}\n\n/************************************************\n函数名称 ： USART_SendByte\n功    能 ： 串口字符发送\n参    数 ： c ---- 发送的数据\n返 回 值 ： 无\n*************************************************/\nvoid USART_SendByte( USART_TypeDef* USARTx, uint8_t c )\n{     \n\tUSART_SendData(USARTx, c);\n\t\n\twhile (USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET);\n}\n\n/************************************************\n函数名称 ： USART_SendString\n功    能 ： 串口字符串发送\n参    数 ： USARTx ---- 串口\n\t\t\tpData ---- 字符串\n\t\t\tLength ---- 长度\n返 回 值 ： 无\n*************************************************/\nvoid USART_SendString( USART_TypeDef* USARTx, const uint8_t *pData, uint16_t Length )\n{\n    while(Length--)\n    {\n        USART_SendByte(USARTx, *pData);\n        pData++;\n    }\n}\n\n/************************************************\n函数名称 ： USART_Printf\n功    能 ： 串口打印输出\n参    数 ： USARTx ---- 串口\n\t\t\tString\t---- 字符串\n返 回 值 ： 无\n*************************************************/\nvoid USART_Printf( USART_TypeDef* USARTx, char *String )\n{\n    do\n    {\n        USART_SendByte(USARTx, *String);\n        String++;\n    }while((*String) != '\\0');\n}\n\n/************************************************\n函数名称 ： fputc\n功    能 ： 重定向 c库函数 printf到 DEBUG_UART\n参    数 ： ch\n返 回 值 ： 无\n*************************************************/\nint fputc(int ch, FILE *f)\n{\n    /* 发送一个字节数据到 DEBUG_UART */\n    USART_SendData(DEBUG_UART, (uint8_t) ch);\n\n    /* 等待发送完毕 */\n    while (USART_GetFlagStatus(DEBUG_UART, USART_FLAG_TXE) == RESET);\n\n    return (ch);\n}\n\n/************************************************\n函数名称 ： fgetc\n功    能 ： 重定向 c库函数 scanf到 DEBUG_UART\n参    数 ： f ---- 文件\n返 回 值 ： 无\n*************************************************/\nint fgetc(FILE *f)\n{\n    /* 等待 DEBUG_UART输入数据 */\n    while (USART_GetFlagStatus(DEBUG_UART, USART_FLAG_RXNE) == RESET);\n\n    return (int)USART_ReceiveData(DEBUG_UART);\n}\n\n\n/*---------------------------- END OF FILE ----------------------------*/\n```\n\n```c bsp_uart.h\n#ifndef __BSP_UART_H\n#define __BSP_UART_H\n\n\n#include <stdio.h>\n#include \"stm32f10x.h\"\n\n\n#define DEBUG_UART\t\t\t\tUSART1\n#define EVAL_COM1\t\t\t\tUSART1\n#define EVAL_COM2\t\t\t\tUSART2\n\n#define USART1_RX_DMA_CHANNEL\tDMA1_Channel5\n#define USART2_RX_DMA_CHANNEL\tDMA1_Channel6\n\n#define TxBUFFER_SIZE  \t \t\t100\n#define RxBUFFER_SIZE  \t\t \t100\n\n#define UART_QUEUE_RX_LENGTH\t2\n#define UART_QUEUE_TX_LENGTH\t2\n\ntypedef struct\n{\n\tuint8_t Receiving_Time;\t\t\t\t\t// 接收时间\n\tuint8_t Frame_flag;\t\t\t\t\t\t// 一帧完成标志\n}EVAL_COMx_TypeDef;\n\ntypedef struct\n{\n\tuint8_t RxBuffer[RxBUFFER_SIZE];\t\t// 接收暂存缓冲区\n\t__IO uint8_t RxCounter;\t\t\t\t\t// 接收数据个数\n}UartRx_Buff_TypeDef;\n\ntypedef struct\n{\n\tuint8_t TxBuffer[TxBUFFER_SIZE];\t\t// 发送暂存缓冲区\n\t__IO uint8_t TxCounter;\t\t\t\t\t// 发送数据个数\n\tUSART_TypeDef* COMx;\t\t\t\t\t// 串口号\n}UartTx_Buff_TypeDef;\n\nvoid vSetupUSART( void );\nvoid UART1_Config(void);\nvoid UART2_Config(void);\nvoid USART_SendByte( USART_TypeDef* USARTx, uint8_t c );\nvoid USART_SendString( USART_TypeDef* USARTx, const uint8_t *pData, uint16_t Length );\nvoid USART_Printf( USART_TypeDef* USARTx, char *String );\n\n\n#endif\t/* __BSP_UART_H */\n\n\n/*---------------------------- END OF FILE ----------------------------*/\n```\n\n\n\n其实对照之前的 [STM32笔记之 USART（串口）](https://blog.csdn.net/qq_42992084/article/details/104098531) 改动并不大，只是分开处理一下，并且以任务的形式封装起来。\n\n最后我们可以看一下他的测试结果：\n\n![img](2020022014051323.png)\n\n从结果中可以看到，若是直接用 printf 输出，因为两个相同优先级的任务在同一时间输出数据，结果出现了数据叠加（这并不是我们想要的结果），而后面以队列的形式进行输出，数据是可以按照正常打印的（哪怕他们的任务优先级一样，并且运行的流程一样，他都分布好数据位置一并打印；后面测了一下，任务优先级相同，发现会按着任务创建的顺序来处理的；还有其他一些小测试，也会有很多不同的结果，具体可以自己试着探究），这里主要想说的是：为了避免在 RTOS 中多个任务同时访问公用数据（或者同一硬件），最好用队列或者利用后面要说的互斥量等来处理数据（根据实际需求用哪个）。\n\n多任务系统中存在一种潜在的风险。当一个任务在使用某个资源的过程中，即还没有完全结束对资源的访问时，便被切出运行态，使得资源处于非一致，不完整的状态。如果这个时候有另一个任务或者中断来访问这个资源，则会导致数据损坏或是其它相似的错误，也就是像上面的一开始打印出错那样。","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之任务管理","url":"/freertos-task/","content":"\n\n\n\n# 任务状态\n\n任务目前存在四种状态，分为：运行、就绪、阻塞、挂起；\n\n1. **Running — 运行态** \n    这是任务在执行的时候的状态，处在运行态意味着任务获得 CPU 的使用权，对于单核 CPU，此时不存在其他运行态的任务。\n2. **Ready — 就绪态** \n    处在就绪态意味着这个任务是可以执行的，比如某个事件发生、队列数据到来、所请求的资源有效等；但是，因为此时有一个相同优先级或者更高优先级的任务正在运行，此时任务无法执行而处于就绪态。\n3. **Blocked — 阻塞态** \n    如果一个任务正在等待一个时间到来或者外部的事件到来，比如一个调用 `vTaskDelay()` 函数的任务，在延时时间到来之前，任务将处在阻塞状态。当然，任务在等待队列、信号量、事件组、通知、信号量事件时都会处在阻塞态。通常，这些等待都会设置一个超时 timeout 时间，当等待超时是将任务从阻塞态退出，防止任务被无限挂起。处在阻塞态的任务不占用任何 CPU 时间。\n4. **Suspended — 挂起态** \n    挂起态无法进入运行态，同时不像阻塞态有超时时间，挂起态无超时时间，除非调用 `vTaskResume()` 推出挂起态。相应的调用 `vTaskSuspend()` 将一个任务挂起。挂起态可以描述成“冻结”；除非“解冻”，否则无法再有机会被执行到。\n\n它们的状态关系图：\n\n![img](20200228151607721.png)\n\n\n\n# 任务优先级\n\n每个任务在创建的时候都要指定一个从 `0` 到 `configMAX_PRIORITIES - 1` 的优先级，与其他 RTOS 不同之处在于，优先级数值越大，优先级越低。`configMAX_PRIORITIES` 定义在 `freeRTOSConfig.h` 头文件中。\n\n`configMAX_PRIORITIES` 的值可以是任意值，也就是说 FreeRTOS 的任务数量不受限制。事实上，因为 FreeRTOS 允许任务共享同一个优先级，`configMAX_PRIORITIES` 的大小不会限制到任务数量。但是对于实际应用来说，因为 FreeRTOS 中即使未用到的优先级，任然会占用一定的内存，因此优先级的最大数值，应与实际应用贴近。\n\n在 `freeRTOSConfig.h` 头文件中，定义了 `configUSE_PORT_OPTIMISED_TASK_SELECTION` ，拥有某些存在任务选择优化机制的架构，此时最大优先级不能超过 32。\n\nFreeRTOS 中的空闲任务 IDEL Task 总是最低优先级，因此它的优先级为 0。\n\nFreeRTOS 的调度器总是确保当前得到 CPU 时间的任务的优先级是最高的，换句话说，就绪态中高优先级的任务，总是会优先进入运行态。\n\n对于共用同一优先级的任务，如果 `configUSE_TIME_SLICING` 未定义或者定义为 `1` ,则 FreeRTOS 将使用时间片轮询的机制去调度这些任务。\n\n跟多具体的配置信息可以去看 [FreeRTOS 篇章之 FreeRTOSConfig.h分析](https://arachnid.cc/freertos-config/) 。\n\n\n\n# 任务创建 - xTaskCreate()\n\nxTaskCreate() API 函数原型实现：\n\n```c\n#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )\n\n\tBaseType_t xTaskCreate(\tTaskFunction_t pxTaskCode,\n\t\t\t\tconst char * const pcName,\n\t\t\t\tconst uint16_t usStackDepth,\n\t\t\t\tvoid * const pvParameters,\n\t\t\t\tUBaseType_t uxPriority,\n\t\t\t\tTaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */\n\t{\n\tTCB_t *pxNewTCB;\n\tBaseType_t xReturn;\n\n\t\t/* If the stack grows down then allocate the stack then the TCB so the stack\n\t\tdoes not grow into the TCB.  Likewise if the stack grows up then allocate\n\t\tthe TCB then the stack. */\n\t\t#if( portSTACK_GROWTH > 0 )\n\t\t{\n\t\t\t/* Allocate space for the TCB.  Where the memory comes from depends on\n\t\t\tthe implementation of the port malloc function and whether or not static\n\t\t\tallocation is being used. */\n\t\t\tpxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );\n\n\t\t\tif( pxNewTCB != NULL )\n\t\t\t{\n\t\t\t\t/* Allocate space for the stack used by the task being created.\n\t\t\t\tThe base of the stack memory stored in the TCB so the task can\n\t\t\t\tbe deleted later if required. */\n\t\t\t\tpxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n\t\t\t\tif( pxNewTCB->pxStack == NULL )\n\t\t\t\t{\n\t\t\t\t\t/* Could not allocate the stack.  Delete the allocated TCB. */\n\t\t\t\t\tvPortFree( pxNewTCB );\n\t\t\t\t\tpxNewTCB = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#else /* portSTACK_GROWTH */\n\t\t{\n\t\tStackType_t *pxStack;\n\n\t\t\t/* Allocate space for the stack used by the task being created. */\n\t\t\tpxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\n\n\t\t\tif( pxStack != NULL )\n\t\t\t{\n\t\t\t\t/* Allocate space for the TCB. */\n\t\t\t\tpxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */\n\n\t\t\t\tif( pxNewTCB != NULL )\n\t\t\t\t{\n\t\t\t\t\t/* Store the stack location in the TCB. */\n\t\t\t\t\tpxNewTCB->pxStack = pxStack;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* The stack cannot be used as the TCB was not created.  Free\n\t\t\t\t\tit again. */\n\t\t\t\t\tvPortFree( pxStack );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpxNewTCB = NULL;\n\t\t\t}\n\t\t}\n\t\t#endif /* portSTACK_GROWTH */\n\n\t\tif( pxNewTCB != NULL )\n\t\t{\n\t\t\t#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )\n\t\t\t{\n\t\t\t\t/* Tasks can be created statically or dynamically, so note this\n\t\t\t\ttask was created dynamically in case it is later deleted. */\n\t\t\t\tpxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;\n\t\t\t}\n\t\t\t#endif /* configSUPPORT_STATIC_ALLOCATION */\n\n\t\t\tprvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );\n\t\t\tprvAddNewTaskToReadyList( pxNewTCB );\n\t\t\txReturn = pdPASS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;\n\t\t}\n\n\t\treturn xReturn;\n\t}\n\n#endif /* configSUPPORT_DYNAMIC_ALLOCATION */\n```\n\n可以看到，该函数是受宏 `configSUPPORT_DYNAMIC_ALLOCATION` 控制的，该宏位于 `FreeRTOSConfig.h` 文件中。\n\n传入参数：\n\n- **pvTaskCode**：指向任务函数入口的指针，是一个永不退出的 C 函数，实现常通常是一个死循环。\n- **pcName**：具有描述性的任务名。这个参数不会被 FreeRTOS 使用，其只是单纯地用于辅助调试；通过定义常量 `config_MAX_TASK_NAME_LEN` 来定义任务名的最大长度（包括 `\\0` 结束符），该宏位于 `FreeRTOSConfig.h` 文件中。\n- **usStackDepth**：当任务创建时，用于告诉内核为它分配多大的栈空间，这个值指定的是栈空间可以保存多少个字（word），而不是多少个字节（byte）。\n- **pvParameters**：任务函数接受一个指向 void 的指针（void *），即是传递到任务中的值。\n- **uxPriority**：用于指定任务执行的优先级。优先级的取值范围可以从最低优先级( `0` )到最高优先级( `configMAX_PRIORITIES – 1` )；`configMAX_PRIORITIES` 是一个由用户定义的常量，该宏位于 `FreeRTOSConfig.h` 文件中。\n- **pxCreatedTask**：用于传出任务的句柄。这个句柄将在 API 调用中对该创建出来的任务进行引用，比如改变任务优先级，或者删除任务；如果应用程序中不会用到这个任务的句柄，则 `pxCreatedTask` 可以被设为 NULL。\n\n返回参数（有两个可能的返回值）：\n\n- **pdTRUE**：表明任务创建成功。\n- **errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY**：由于内存堆空间不足，FreeRTOS 无法分配足够的空间来保存任务结构数据和任务栈，而无法创建任务。\n\n\n\n# 任务删除 - vTaskDelete()\n\nvTaskDelete() API 函数原型实现：\n\n```c\n#if ( INCLUDE_vTaskDelete == 1 )\n\n\tvoid vTaskDelete( TaskHandle_t xTaskToDelete )\n\t{\n\tTCB_t *pxTCB;\n\n\t\ttaskENTER_CRITICAL();\n\t\t{\n\t\t\t/* If null is passed in here then it is the calling task that is\n\t\t\tbeing deleted. */\n\t\t\tpxTCB = prvGetTCBFromHandle( xTaskToDelete );\n\n\t\t\t/* Remove task from the ready list. */\n\t\t\tif( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )\n\t\t\t{\n\t\t\t\ttaskRESET_READY_PRIORITY( pxTCB->uxPriority );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t}\n\n\t\t\t/* Is the task waiting on an event also? */\n\t\t\tif( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )\n\t\t\t{\n\t\t\t\t( void ) uxListRemove( &( pxTCB->xEventListItem ) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t}\n\n\t\t\t/* Increment the uxTaskNumber also so kernel aware debuggers can\n\t\t\tdetect that the task lists need re-generating.  This is done before\n\t\t\tportPRE_TASK_DELETE_HOOK() as in the Windows port that macro will\n\t\t\tnot return. */\n\t\t\tuxTaskNumber++;\n\n\t\t\tif( pxTCB == pxCurrentTCB )\n\t\t\t{\n\t\t\t\t/* A task is deleting itself.  This cannot complete within the\n\t\t\t\ttask itself, as a context switch to another task is required.\n\t\t\t\tPlace the task in the termination list.  The idle task will\n\t\t\t\tcheck the termination list and free up any memory allocated by\n\t\t\t\tthe scheduler for the TCB and stack of the deleted task. */\n\t\t\t\tvListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );\n\n\t\t\t\t/* Increment the ucTasksDeleted variable so the idle task knows\n\t\t\t\tthere is a task that has been deleted and that it should therefore\n\t\t\t\tcheck the xTasksWaitingTermination list. */\n\t\t\t\t++uxDeletedTasksWaitingCleanUp;\n\n\t\t\t\t/* The pre-delete hook is primarily for the Windows simulator,\n\t\t\t\tin which Windows specific clean up operations are performed,\n\t\t\t\tafter which it is not possible to yield away from this task -\n\t\t\t\thence xYieldPending is used to latch that a context switch is\n\t\t\t\trequired. */\n\t\t\t\tportPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--uxCurrentNumberOfTasks;\n\t\t\t\tprvDeleteTCB( pxTCB );\n\n\t\t\t\t/* Reset the next expected unblock time in case it referred to\n\t\t\t\tthe task that has just been deleted. */\n\t\t\t\tprvResetNextTaskUnblockTime();\n\t\t\t}\n\n\t\t\ttraceTASK_DELETE( pxTCB );\n\t\t}\n\t\ttaskEXIT_CRITICAL();\n\n\t\t/* Force a reschedule if it is the currently running task that has just\n\t\tbeen deleted. */\n\t\tif( xSchedulerRunning != pdFALSE )\n\t\t{\n\t\t\tif( pxTCB == pxCurrentTCB )\n\t\t\t{\n\t\t\t\tconfigASSERT( uxSchedulerSuspended == 0 );\n\t\t\t\tportYIELD_WITHIN_API();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t}\n\t\t}\n\t}\n\n#endif /* INCLUDE_vTaskDelete */\n```\n\n同样的，该函数则是受宏 `INCLUDE_vTaskDelete` 控制的，该宏位于 `FreeRTOSConfig.h` 文件中。\n\n传入参数：\n\n- **pxTaskToDelete**：被删除任务的句柄（目标任务）。若传入 NULL，则是删除当前执行的任务（即删除自己）。\n\n\n\n# 代码搭建\n\n任务（task）是在 FreeRTOS 中执行的基本单位，每个 task 都是由一个 C 函数所组成，意思是你需要先定义一個 C 的函数，然後再用 `xTaskCreate()` 这个 API 來建立一個 task，這個 C 函数有几个特点，它的返回值必須是 void，其中通常是存于无限循环中（while、for），所有关于这个 task 的工作都会在这个无限循环中进行，而且这个函数不会有 return，FreeRTOS 不允許 task 自行结束（使用 return 或执行到函数的最后一行）；task 被建立出來后，它会配置有自己的堆栈空间和 stack variable （就是 function 中定义的变量）。\n\n```c main.c\n/*\n    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.\n\n    ***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n    ***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n    the FAQ page \"My application does not run, what could be wrong?\".  Have you\n    defined configASSERT()?\n\n    http://www.FreeRTOS.org/support - In return for receiving this top quality\n    embedded software for free we request you assist our global community by\n    participating in the support forum.\n\n    http://www.FreeRTOS.org/training - Investing in training allows your team to\n    be as productive as possible as early as possible.  Now you can receive\n    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n    Ltd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n\n/* Standard includes. */\n#include <stdio.h>\n\n/* Scheduler includes. */\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"queue.h\"\n\n/* Library includes. */\n#include \"stm32f10x_it.h\"\n\n/* Private app includes. */\n#include \"bsp_uart.h\"\n#include \"bsp_time.h\"\n#include \"bsp_gpio.h\"\n\n\n/*----------------------------- End -----------------------------*/\n\n/*\n * User Private Task.\n */\nstatic void prvUser_Task( void *pvParameters );\n\n/*\n * Configure the clocks, GPIO and other peripherals as required by the demo.\n */\nstatic void prvSetupHardware( void );\n\n/*----------------------------- End -----------------------------*/\n\n\n/************************************************\n函数名称 ： main\n功    能 ： 主函数入口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nint main( void )\n{\n#ifdef DEBUG\n  debug();\n#endif\n\n\tprvSetupHardware();\n\n\t/* Start the tasks defined within this file/specific to this demo. */\n\txTaskCreate( prvUser_Task, \"prvUser_Task\", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n\t/* Start the scheduler. */\n\tvTaskStartScheduler();\n\n\t/* Will only get here if there was not enough heap space to create the\n\tidle task. */\n\treturn 0;\n}\n/*----------------------------- End -----------------------------*/\n\nstatic void prvUser_Task( void *pvParameters )\n{\n    /* User-defined private tasks */\n\n    while(1){\n        /* do something here */\n    }\n\t\n    /* \n    * 如果你的 task 就是需要离开 loop 并结束\n    * 需要用 vTaskDelete 來刪除自己而非使用 return 或自然结束(执行到最后一行)\n    * 这个参数的 NULL 值是表示自己 \n    */\n    vTaskDelete(NULL);\t\t// 删除自己\n}\n\nstatic void prvSetupHardware( void )\n{\n\t/* Start with the clocks in their expected state. */\n\tRCC_DeInit();\n\n\t/* Enable HSE (high speed external clock). */\n\tRCC_HSEConfig( RCC_HSE_ON );\n\n\t/* Wait till HSE is ready. */\n\twhile( RCC_GetFlagStatus( RCC_FLAG_HSERDY ) == RESET )\n\t{\n\t}\n\n\t/* 2 wait states required on the flash. */\n\t*( ( unsigned long * ) 0x40022000 ) = 0x02;\n\n\t/* HCLK = SYSCLK */\n\tRCC_HCLKConfig( RCC_SYSCLK_Div1 );\n\n\t/* PCLK2 = HCLK */\n\tRCC_PCLK2Config( RCC_HCLK_Div1 );\n\n\t/* PCLK1 = HCLK/2 */\n\tRCC_PCLK1Config( RCC_HCLK_Div2 );\n\n\t/* PLLCLK = 8MHz * 9 = 72 MHz. */\n\tRCC_PLLConfig( RCC_PLLSource_HSE_Div1, RCC_PLLMul_9 );\n\n\t/* Enable PLL. */\n\tRCC_PLLCmd( ENABLE );\n\n\t/* Wait till PLL is ready. */\n\twhile(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)\n\t{\n\t}\n\n\t/* Select PLL as system clock source. */\n\tRCC_SYSCLKConfig( RCC_SYSCLKSource_PLLCLK );\n\n\t/* Wait till PLL is used as system clock source. */\n\twhile( RCC_GetSYSCLKSource() != 0x08 )\n\t{\n\t}\n\n\t/* Configure HCLK clock as SysTick clock source. */\n\tSysTick_CLKSourceConfig( SysTick_CLKSource_HCLK );\n\t\n\t/*\n\t * STM32中断优先级分组为 4，即 4bit都用来表示抢占优先级，范围为：0~15\n\t * 优先级分组只需要分组一次即可，以后如果有其他的任务需要用到中断，\n\t * 都统一用这个优先级分组，千万不要再分组，切忌。\n\t */\n\tNVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );\n\t\n\t/* Other peripheral configuration */\n\tvSetupTimer();\n\tvSetupUSART();\n\tvSetupParPort();\n}\n/*----------------------------- End -----------------------------*/\n\n#ifdef  DEBUG\n/* Keep the linker happy. */\nvoid assert_failed( unsigned char* pcFile, unsigned long ulLine )\n{\n\tfor( ;; )\n\t{\n\t}\n}\n#endif\n\n\n/*---------------------------- END OF FILE ----------------------------*/\n```\n\n首先，`prvSetupHardware()` 函数是配置时钟，并且初始化硬件配置（即 `vSetupTimer();`  `vSetupUSART();`  `vSetupParPort();` 的实现，其实就是封装了一下之前 [stm32笔记中](https://arachnid.cc/categories/STM32/) 的 time、uart、gpio 初始化配置）。\n\n\n\n```c [Other peripheral configuration]\n/************************************************\n函数名称 ： vSetupTimer\n功    能 ： Timer初始化接口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid vSetupTimer( void )\n{\n\tTimer2_Config();\n}\n\n/************************************************\n函数名称 ： vSetupUSART\n功    能 ： UART初始化接口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid vSetupUSART( void )\n{\n\tUART1_Config();\n//\tUART2_Config();\n}\n\n/************************************************\n函数名称 ： vSetupParPort\n功    能 ： 基础 IO初始化接口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nvoid vSetupParPort( void )\n{\n\tLED_Config();\n\tKey_Config();\n}\n```\n\n然后到后面的 `main` 函数的实现调用，调用 `prvSetupHardware()` 初始化所有跟硬件相关的配置，创建一个 `prvUser_Task` 任务，用于管理所有后面创建的任务（其实就是为了方便管理），因为这里面没有创建其他函数，所以放了个 while循环在里面，最后再调用 `vTaskDelete(NULL);` 把自己删除；\n\n这里可能有个疑问，明明有个 `while` 死循环，执行不到 `vTaskDelete()` 函数，没什么意义啊，虽然道理是这样，但是最好在每个任务的结尾放上 `vTaskDelete()` 函数，以确保安全（特殊情况除外）；还有就是，因为在 `prvUser_Task` 任务中有个死循环，那在 `while` 之后的程序应该都执行不了啊，包括 `prvUser_Task` 任务后面的 `vTaskStartScheduler();` ，如果是按正常的思维是这样的；但是，这里是在使用 RTOS，调用 `xTaskCreate()` 创建任务并不表示就已经执行了，只是告诉内核，我创建了这么一个任务，真正使系统开始执行是在调用了 `vTaskStartScheduler();` 启动调度器之后。","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之 FreeRTOSConfig.h 分析","url":"/freertos-config/","content":"\n\n\n# 移植修改\n\n在 [FreeRTOS 篇章之系统移植](https://arachnid.cc/freertos-system-transplant/) 中，我们有把 `FreeRTOSv9.0.0\\FreeRTOS\\Demo\\CORTEX_STM32F103_Keil` 路径下的 `FreeRTOSConfig.h` 文件复制到我们用户可修改的 `App` 文件夹下，并且导入了工程，但是，该 `FreeRTOSConfig.h` 文件的内容并不是我们真正想要了内容，需要我们进行更改，而源文件内容就只有下面这么点内容\n\n![img](20200216134014732.png)\n\n虽然能满足 FreeRTOS 跑起来，但是往往随着功能的添加，我们需要 FreeRTOS 的更多支持，而这里也只是展示了个别裁剪功能；为了物尽其用，避免以后还要继续添加，所以我们直接就导入 FreeRTOS 所提供的功能选择，修改成如下内容：\n\n```c\n#ifndef FREERTOS_CONFIG_H\n#define FREERTOS_CONFIG_H\n\n/* Here is a good place to include header files that are required across\nyour application. */\n#include \"something.h\"\n\n#define configUSE_PREEMPTION                    1\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0\n#define configUSE_TICKLESS_IDLE                 0\n#define configCPU_CLOCK_HZ                      60000000\n#define configTICK_RATE_HZ                      250\n#define configMAX_PRIORITIES                    5\n#define configMINIMAL_STACK_SIZE                128\n#define configMAX_TASK_NAME_LEN                 16\n#define configUSE_16_BIT_TICKS                  0\n#define configIDLE_SHOULD_YIELD                 1\n#define configUSE_TASK_NOTIFICATIONS            1\n#define configUSE_MUTEXES                       0\n#define configUSE_RECURSIVE_MUTEXES             0\n#define configUSE_COUNTING_SEMAPHORES           0\n#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */\n#define configQUEUE_REGISTRY_SIZE               10\n#define configUSE_QUEUE_SETS                    0\n#define configUSE_TIME_SLICING                  0\n#define configUSE_NEWLIB_REENTRANT              0\n#define configENABLE_BACKWARD_COMPATIBILITY     0\n#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5\n#define configSTACK_DEPTH_TYPE                  uint16_t\n#define configMESSAGE_BUFFER_LENGTH_TYPE        size_t\n\n/* Memory allocation related definitions. */\n#define configSUPPORT_STATIC_ALLOCATION         1\n#define configSUPPORT_DYNAMIC_ALLOCATION        1\n#define configTOTAL_HEAP_SIZE                   10240\n#define configAPPLICATION_ALLOCATED_HEAP        1\n\n/* Hook function related definitions. */\n#define configUSE_IDLE_HOOK                     0\n#define configUSE_TICK_HOOK                     0\n#define configCHECK_FOR_STACK_OVERFLOW          0\n#define configUSE_MALLOC_FAILED_HOOK            0\n#define configUSE_DAEMON_TASK_STARTUP_HOOK      0\n\n/* Run time and task stats gathering related definitions. */\n#define configGENERATE_RUN_TIME_STATS           0\n#define configUSE_TRACE_FACILITY                0\n#define configUSE_STATS_FORMATTING_FUNCTIONS    0\n\n/* Co-routine related definitions. */\n#define configUSE_CO_ROUTINES                   0\n#define configMAX_CO_ROUTINE_PRIORITIES         1\n\n/* Software timer related definitions. */\n#define configUSE_TIMERS                        1\n#define configTIMER_TASK_PRIORITY               3\n#define configTIMER_QUEUE_LENGTH                10\n#define configTIMER_TASK_STACK_DEPTH            configMINIMAL_STACK_SIZE\n\n/* Interrupt nesting behaviour configuration. */\n#define configKERNEL_INTERRUPT_PRIORITY         [dependent of processor]\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY    [dependent on processor and application]\n#define configMAX_API_CALL_INTERRUPT_PRIORITY   [dependent on processor and application]\n\n/* Define to trap errors during development. */\n#define configASSERT( ( x ) ) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )\n\n/* FreeRTOS MPU specific definitions. */\n#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0\n\n/* Optional functions - most linkers will remove unused functions anyway. */\n#define INCLUDE_vTaskPrioritySet                1\n#define INCLUDE_uxTaskPriorityGet               1\n#define INCLUDE_vTaskDelete                     1\n#define INCLUDE_vTaskSuspend                    1\n#define INCLUDE_xResumeFromISR                  1\n#define INCLUDE_vTaskDelayUntil                 1\n#define INCLUDE_vTaskDelay                      1\n#define INCLUDE_xTaskGetSchedulerState          1\n#define INCLUDE_xTaskGetCurrentTaskHandle       1\n#define INCLUDE_uxTaskGetStackHighWaterMark     0\n#define INCLUDE_xTaskGetIdleTaskHandle          0\n#define INCLUDE_eTaskGetState                   0\n#define INCLUDE_xEventGroupSetBitFromISR        1\n#define INCLUDE_xTimerPendFunctionCall          0\n#define INCLUDE_xTaskAbortDelay                 0\n#define INCLUDE_xTaskGetHandle                  0\n#define INCLUDE_xTaskResumeFromISR              1\n\n/* A header file that defines trace macro can be included here. */\n\n#endif /* FREERTOS_CONFIG_H */\n```\n\n当然，这只是官方提供的，较为完整的配置模版；具体实现什么功能还是要我们对相应的宏进行修改的。\n\n\n\n# 配置项详解\n\n**1、configUSE_PREEMPTION**\n\n置 `1` ：RTOS 使用抢占式调度器，即当进程位于内核空间时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起，执行优先级更高的进程；\n\n置 `0` ：RTOS 使用协作式调度器（时间片），协作式操作系统是任务主动释放 CPU 后，切换到下一个任务，任务切换的时机完全取决于正在运行的任务，因此，高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占 CPU 运行。\n\n**2、configUSE_PORT_OPTIMISED_TASK_SELECTION**\n\n一些 FreeRTOS 硬件端口在选择下一个要执行的任务，具有两种的方法：通用方法和特定于该硬件端口的方法。\n\n通用方法：\n\n- 在 `configUSE_PORT_OPTIMISED_TASK_SELECTION` 设置为 `0` （显式）或未实现特定于硬件端口的方法（隐式）时使用。\n- 可以与所有 FreeRTOS 硬件端口一起使用。\n- 完全用 C 编写，使其效率低于使用特定硬件端口的方法。\n- 不限制可用优先级的最大数量。\n\n特定于硬件端口的方法：\n\n- 不适用于所有硬件端口。\n- 在 `configUSE_PORT_OPTIMISED_TASK_SELECTION` 设置为 `1` 时使用。\n- 依赖于一个或多个特定于体系结构的汇编指令（通常为计数前导零 [CLZ] 或等效指令），因此只能与专门为其编写的体系结构一起使用。\n- 比通用方法更有效。\n- 通常，最大可用优先级数限制为 32。\n\n**3、configUSE_TICKLESS_IDLE**\n\n置 `1` ：使能低功耗 tickless 模式；\n\n置 `0` ：保持系统节拍（tick）中断一直运行。\n\n在低功耗 tickless 模式，通常使用空闲钩子函数设置 CPU 进入低功耗模式来达到省电的目的。\n\n**4、configUSE_IDLE_HOOK**\n\n置 `1` ：使用空闲钩子（Idle Hook类似于回调函数）；\n\n置 `0` ：忽略空闲钩子。\n\n空闲任务钩子是一个函数，这个函数由用户来实现，FreeRTOS 规定了函数的名字和参数： `void vApplicationIdleHook(void)` ，这个函数在每个空闲任务周期都会被调用。\n\n**5、configUSE_MALLOC_FAILED_HOOK**\n\n每次创建任务，队列或信号量时，内核都会使用对 `pvPortMalloc()` 的调用从堆中分配内存。FreeRTOS 的官方下载包中包含五个堆内存分配方案；这些方案分别在 `heap_1.c` ，`heap_2.c` ，`heap_3.c` ，`heap_4.c` 和 `heap_5.c` 源文件中进行实现； `configUSE_MALLOC_FAILED_HOOK` 仅在使用这五个堆内存分配方案之一时才有意义。\n\n如果定义并正确配置 `malloc()` 申请失败的钩子函数，则这个函数会在 `pvPortMalloc()` 函数返回 NULL 时被调用；注意：仅当 FreeRTOS 在响应内存分配请求时发现堆内存不足时，才返回 NULL。\n\n置 `1` ：则应用程序必须定义一个 `malloc()` 申请失败的挂钩函数；\n\n置 `0` ：则忽略 `malloc()` 申请失败的挂钩函数，即使定义了这个挂钩函数。\n\n`malloc()` 申请失败的挂钩函数必须具有如下所示的名称和原型：\n\n```c\nvoid vApplicationMallocFailedHook( void );\n```\n\n**6、configUSE_DAEMON_TASK_STARTUP_HOOK**\n\n置 `1` ：则应用程序必须定义一个具有确切名称和原型的钩子函数；\n\n置 `0` ：则忽略该钩子函数。\n\n其名称和原型如下所示：\n\n```c\nvoid vApplicationDaemonTaskStartupHook( void );\n```\n\n首次执行 RTOS 守护程序任务（也称为 [计时器服务任务](https://www.freertos.org/RTOS-software-timer-service-daemon-task.html) ）时，钩子函数将被精确调用一次 。任何需要运行 RTOS 的应用程序初始化代码都可以放在挂钩函数中。\n\n**7、configUSE_TICK_HOOK**\n\n置 `1` ：使用时间片钩子（Tick Hook）；\n\n置 `0` ：忽略时间片钩子。\n\n时间片钩子是一个函数，这个函数由用户来实现，FreeRTOS 规定了函数的名字和参数：`void vApplicationTickHook(void)`，时间片中断可以周期性的调用。\n\n**8、configCPU_CLOCK_HZ**\n\n输入以 Hz 为单位的频率，该驱动频率将用于系统滴答中断的外设驱动的内部时钟，通常与驱动内部 CPU 时钟的时钟相同；配置此值是为了正确的配置系统节拍中断周期。\n\n**9、configTICK_RATE_HZ**\n\n配置 RTOS 滴答中断的频率；用于测量时间，即一秒中断的次数，每次中断 RTOS 都会进行任务调度。\n\n更高的滴答频率意味着同一时间下可以测量到更高的分辨率；但是，较高的滴答频率也意味着 RTOS 内核将使用更多的 CPU 时间，因此使得效率降低。RTOS 演示例程均使用 1000Hz 的滴答频率，这是为了测试 RTOS 内核，因此比实际使用的高得多。（实际使用时不用这么高的系统节拍中断频率）\n\n多个任务可以共享相同的优先级。通过在每个 RTOS 系统节拍中断到来时切换任务，RTOS 调度程序将在优先级相同的任务之间共享处理器时间；因此，较高的滴答频率会减少分配给每个任务的 “ 时间片 ” 。\n\n**10、configMAX_PRIORITIES**\n\n配置应用程序任务可用的优先级数；任何数量的任务都可以共享相同的优先级。协同例程的优先级是分开的，详情见 `configMAX_CO_ROUTINE_PRIORITIES` 。\n\n每个可用的优先级都会消耗 RTOS 内核中的 RAM，因此该值不应设置为高于应用程序实际需要的值。\n\n每一个任务都会被分配一个优先级，优先级值在 0 ~ (configMAX_PRIORITIES - 1) 之间。低优先级数表示低优先级任务，空闲任务的优先级为 0（tskIDLE_PRIORITY），因此它是最低优先级任务。\n\n**11、configMINIMAL_STACK_SIZE**\n\n空闲任务使用的堆栈大小。通常此值不应小于对应处理器演示例程文件 `FreeRTOSConfig.h` 中定义的数值\n\n就像 [xTaskCreate()](https://www.freertos.org/a00125.html) 和 [xTaskCreateStatic()](https://www.freertos.org/xTaskCreateStatic.html) 函数的堆栈大小参数一样，堆栈大小以字为单位而不是字节；如果在 32 位处理器上，当堆栈大小为 100 则表示 400 字节的空间大小。\n\n**12、configMAX_TASK_NAME_LEN**\n\n创建任务时，描述任务信息的字符串的最大允许长度。长度包括 `\\0` 字符串结束符。\n\n**13、configUSE_TRACE_FACILITY**\n\n置 `1` ：表示启动可视化跟踪调试，会激活一些其他的结构成员和函数；\n\n置 `0` ：忽略。\n\n**14、configUSE_STATS_FORMATTING_FUNCTIONS**\n\n将 `configUSE_TRACE_FACILITY ` 和 `configUSE_STATS_FORMATTING_FUNCTIONS` 都设置为 `1` ，则再构建中包含编译 `vTaskList()` 和 `vTaskGetRunTimeStats()` 函数；\n\n否则，其中一个宏为 `0` ，就会从构建中省略这两个函数，不进行编译；通常只是在调试时才使用，用来观察各任务，跟 13 的宏连用。\n\n**15、configUSE_16_BIT_TICKS**\n\n时间是以 “ ticks ” 来衡量的，这是自 RTOS 内核启动以来滴答中断执行的次数；tick 计数保存在 `TickType_t` 类型的变量中。\n\n置 `1` ：`TickType_t` 被定义为无符号的 16 位类型；\n\n置 `0` ：`TickType_t` 被定义为无符号的 32 位类型。\n\n使用 16 位类型将大大提高 8 位和 16 位处理器系统的性能，但会将最大的可指定时间段限制为 65535 个 “ ticks ” 。因此，假设滴答频率为 250Hz，则使用 16 位计数器时任务可以延迟或阻止的最长时间为 262 秒，而使用 32 位计数器时为 17179869 秒。\n\n**16、configIDLE_SHOULD_YIELD**\n\n此参数控制处于空闲优先级的任务的行为。它仅在以下情况下起作用：\n\n- 正在使用抢占式调度程序。\n- 该应用程序创建以空闲优先级运行的任务。\n\n如果 `configUSE_TIME_SLICING` 被设置为 `1` （或未定义），则具有相同优先级的任务将共享使用时间片。如果具有相同优先级的任务，它的优先级高于空闲优先级，并且没有一个任务被抢占，则可以假定这些具有相同优先级的任务，它们分配等量的处理时间；\n\n但当任务共享空闲优先级时，情况会稍微有些不同。如果 `configIDLE_SHOULD_YIELD` 设置为 `1` ，则任何跟空闲优先级相同的用户任务就绪时，空闲任务会立刻让出 CPU，使用户任务得以运行，这样确保了能最快响应用户任务。但是，此行为可能会产生不良影响（取决于您的应用程序的需求），如下所示：\n\n![img](20200217156805236.png)\n\n上图描述了四个处于空闲优先级的任务的执行模式。任务 `A` ，`B` 和 `C` 是应用程序任务；任务 `I` 是空闲任务。在时间 T0，T1，…，T6 定期进行上下文切换；在空闲任务运行中，当任务 `A` 任务产生时，空闲任务立刻让出 CPU，开始执行任务 `A` ，但此刻空闲任务 `I` 已经消耗了当前时间片的一些时间了，这样的结果就是空闲任务 `I` 和任务 `A` 共享同一时间片。因此，应用程序任务 `B` 和 `C` 比应用程序任务 `A` 获得更多的处理时间。\n\n可以通过以下方式避免这种情况：\n\n- 如果合适，请使用空闲钩子函数代替空闲优先级的单独任务。\n- 以高于空闲优先级的优先级创建所有应用程序任务。\n- 将 `configIDLE_SHOULD_YIELD` 设置为 `0` 。\n\n将 `configIDLE_SHOULD_YIELD` 设置为 `0` 可以防止空闲任务产生处理时间，直到其时间片结束为止。这样可以确保为所有处于空闲优先级的任务分配相等的处理时间（如果没有一个任务被抢占），但代价是将更大比例的总处理时间分配给空闲任务。\n\n**17、configUSE_TASK_NOTIFICATIONS**\n\n置 `1` （或未定义）：开启任务通知功能，有关的 API 函数会被包含编译；\n\n置 `0` ：直接从程序中关闭任务通知功能及其关联的 API。\n\n该功能默认是开启的。开启后，每个任务多增加 8 字节 RAM。\n\n**18、configUSE_MUTEXES**\n\n置 `1` ：使用互斥量；\n\n置 `0` ：不使用互斥量。\n\n读者应该了解在 FreeRTOS 中互斥量和二值信号量的区别。\n\n**19、configUSE_RECURSIVE_MUTEXES**\n\n置 `1` ：使用递归互斥量；\n\n置 `0` ：不使用递归互斥量。\n\n**20、configUSE_COUNTING_SEMAPHORES**\n\n置 `1` ：使用计数信号量；\n\n置 `0` ：不使用计数信号量。\n\n**21、configUSE_ALTERNATIVE_API**\n\n置 `1` ：使用 “ alternative ” 队列函数；\n\n置 `0` ：不使用 “ alternative ” 队列函数。\n\n“ alternative ” API 队列函数在 `queue.h` 头文件中有详细描述；**“ alternative ”API已被弃用，在新的设计中请不要使用它！**\n\n**22、configCHECK_FOR_STACK_OVERFLOW**\n\n在 [Stack Usage and Stack Overflow Checking](https://www.freertos.org/Stacks-and-stack-overflow-checking.html) 链接中有详细描述堆栈使用情况和堆栈溢出检查的方法，这里就不详细说了。\n\n**23、configQUEUE_REGISTRY_SIZE**\n\n通过此定义来设置可以注册的信号量和消息队列个数。\n\n队列注册表具有两个目的，这两个目的都与 RTOS 内核调试相关联：\n\n- 它允许将文本名称与队列关联，以便在调试 GUI 中轻松识别队列。\n- 它包含调试器查找每个已注册队列和信号量所需的信息。\n\n除了进行内核调试外，队列注册表没有其它任何目的；只有注册后的队列和信号量才可以使用 RTOS 内核调试器查看，有关更多信息，请参见 [vQueueAddToRegistry()](https://www.freertos.org/vQueueAddToRegistry.html) 和 [vQueueUnregisterQueue()](https://www.freertos.org/vQueueUnregisterQueue.html) 的 API 参考文档。\n\n**24、configUSE_QUEUE_SETS**\n\n置 `1` ：使能队列集功能（可以阻塞、挂起到多个队列和信号量）；\n\n置 `0` ：忽略队列集功能。\n\n**25、configUSE_TIME_SLICING**\n\n置 `1` （或未定义）：默认情况下，FreeRTOS 使用基于时间片的优先级抢占式调度器，这意味着 RTOS 调度器将始终运行处于最高优先级的 “ 就绪 ” 状态任务，并会在每个 RTOS 滴答中断时对在优先级相同的任务之间进行切换；\n\n置 `0` ：RTOS 调度程序仍将运行处于最高优先级的 “ 就绪 ” 状态任务，但不会由于发生了滴答中断而在优先级相同的任务之间切换。\n\n**26、configUSE_NEWLIB_REENTRANT**\n\n置 `1` ：将为每个创建的任务分配一个 [newlib](http://sourceware.org/newlib/)（一个嵌入式 C 库）进入结构；\n\n置 `0` ：不分配。\n\n注意 Newlib 支持是已经包含在普遍需求中了，但 FreeRTOS 维护者本身并未使用。FreeRTOS 是不负责由此产生的 newlib 操作的，因此用户必须熟悉 newlib，并且必须提供必要存根的系统级实现。请注意，（在撰写本文时）当前的 newlib 设计实现了一个系统级的 `malloc()` ，这个 `malloc()` 必须锁上。\n\n**27、configENABLE_BACKWARD_COMPATIBILITY**\n\n`FreeRTOS.h` 头文件包含一组 #define 宏，这些宏将在 V8.0.0 之前的 FreeRTOS 版本中使用的数据类型的名称映射到在 FreeRTOS 的 V8.0.0 版本中使用的名称，这些宏可以确保 RTOS 内核升级到 V8.0.0 或以上版本时，不用对之前的应用代码做任何修改。\n\n置 `1` ：包含这些 #define 宏；\n\n置 `0` ：排除这些宏，从而允许进行验证，以确保未使用 V8.0.0 之前的版本。\n\n各类型定义如下：\n\n```c\n#if configENABLE_BACKWARD_COMPATIBILITY == 1\n\t#define eTaskStateGet eTaskGetState\n\t#define portTickType TickType_t\n\t#define xTaskHandle TaskHandle_t\n\t#define xQueueHandle QueueHandle_t\n\t#define xSemaphoreHandle SemaphoreHandle_t\n\t#define xQueueSetHandle QueueSetHandle_t\n\t#define xQueueSetMemberHandle QueueSetMemberHandle_t\n\t#define xTimeOutType TimeOut_t\n\t#define xMemoryRegion MemoryRegion_t\n\t#define xTaskParameters TaskParameters_t\n\t#define xTaskStatusType\tTaskStatus_t\n\t#define xTimerHandle TimerHandle_t\n\t#define xCoRoutineHandle CoRoutineHandle_t\n\t#define pdTASK_HOOK_CODE TaskHookFunction_t\n\t#define portTICK_RATE_MS portTICK_PERIOD_MS\n\t#define pcTaskGetTaskName pcTaskGetName\n\t#define pcTimerGetTimerName pcTimerGetName\n\t#define pcQueueGetQueueName pcQueueGetName\n\t#define vTaskGetTaskInfo vTaskGetInfo\n\n\t/* Backward compatibility within the scheduler code only - these definitions\n\tare not really required but are included for completeness. */\n\t#define tmrTIMER_CALLBACK TimerCallbackFunction_t\n\t#define pdTASK_CODE TaskFunction_t\n\t#define xListItem ListItem_t\n\t#define xList List_t\n#endif /* configENABLE_BACKWARD_COMPATIBILITY */\n```\n\n**28、configNUM_THREAD_LOCAL_STORAGE_POINTERS**\n\n设置每个任务的线程本地存储指针数组大小；详情请看链接 [Thread Local Storage Pointers](https://www.freertos.org/thread-local-storage-pointers.html) 。\n\n**29、configSTACK_DEPTH_TYPE**\n\n设置用于在调用 [xTaskCreate()](https://www.freertos.org/a00125.html) 时指定堆栈深度的类型，并使用其他各种堆栈大小（例如，在返回 [堆栈高位标记时](https://www.freertos.org/uxTaskGetStackHighWaterMark.html) ）。\n\n在较旧的版本中，FreeRTOS 使用 `UBaseType_t` 类型的变量来指定堆栈大小，但是发现这对 8 位微控制器的限制太大。因此，`configSTACK_DEPTH_TYPE` 允许应用程序开发人员指定要使用的类型，从而消除了这个限制。\n\n**30、configMESSAGE_BUFFER_LENGTH_TYPE**\n\n[FreeRTOS消息缓冲区](https://www.freertos.org/RTOS-message-buffer-example.html) 使用 `configMESSAGE_BUFFER_LENGTH_TYPE` 类型的变量来存储每个消息的长度；如果未定义 `configMESSAGE_BUFFER_LENGTH_TYPE` ，则默认为 `size_t` 。\n\n如果存储在消息缓冲区中的消息永远不会大于 255 个字节，那么在 32 位微控制器上将 `configMESSAGE_BUFFER_LENGTH_TYPE` 定义为 `uint8_t` 将为每个消息节省 3 个字节；同样，如果存储在消息缓冲区中的消息永远不会大于 65535 字节，则在 32 位微控制器上将 `configMESSAGE_BUFFER_LENGTH_TYPE` 定义为 `uint16_t` 将为每条消息节省 2 个字节。\n\n**31、configSUPPORT_STATIC_ALLOCATION**\n\n置 `1` ：可以使用应用程序编写者提供的 RAM 创建 RTOS 对象；\n\n置 `0` （或未定义）：只能使用从 FreeRTOS 堆分配的 RAM 创建 RTOS 对象。\n\n如果将 `configSUPPORT_STATIC_ALLOCATION` 设置为 `1` ，则应用程序编写者还必须提供两个回调函数：`vApplicationGetIdleTaskMemory()` 提供用于 RTOS 空闲任务的内存，以及（如果 `configUSE_TIMERS` 设置为 `1` ）`vApplicationGetTimerTaskMemory()` 提供用于以下目的的内存： RTOS 守护程序 / 计时器服务任务。\n\n下面官方提供了示例：\n\n```c\n/* configSUPPORT_STATIC_ALLOCATION is set to 1, so the application must provide an\nimplementation of vApplicationGetIdleTaskMemory() to provide the memory that is\nused by the Idle task. */\nvoid vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,\n                                    StackType_t **ppxIdleTaskStackBuffer,\n                                    uint32_t *pulIdleTaskStackSize )\n{\n/* If the buffers to be provided to the Idle task are declared inside this\nfunction then they must be declared static – otherwise they will be allocated on\nthe stack and so not exists after this function exits. */\nstatic StaticTask_t xIdleTaskTCB;\nstatic StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];\n\n    /* Pass out a pointer to the StaticTask_t structure in which the Idle task’s\n    state will be stored. */\n    *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;\n\n    /* Pass out the array that will be used as the Idle task’s stack. */\n    *ppxIdleTaskStackBuffer = uxIdleTaskStack;\n\n    /* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.\n    Note that, as the array is necessarily of type StackType_t,\n    configMINIMAL_STACK_SIZE is specified in words, not bytes. */\n    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;\n}\n/*———————————————————–*/\n\n/* configSUPPORT_STATIC_ALLOCATION and configUSE_TIMERS are both set to 1, so the\napplication must provide an implementation of vApplicationGetTimerTaskMemory()\nto provide the memory that is used by the Timer service task. */\nvoid vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,\n                                     StackType_t **ppxTimerTaskStackBuffer,\n                                     uint32_t *pulTimerTaskStackSize )\n{\n/* If the buffers to be provided to the Timer task are declared inside this\nfunction then they must be declared static – otherwise they will be allocated on\nthe stack and so not exists after this function exits. */\nstatic StaticTask_t xTimerTaskTCB;\nstatic StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];\n\n    /* Pass out a pointer to the StaticTask_t structure in which the Timer\n    task’s state will be stored. */\n    *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;\n\n    /* Pass out the array that will be used as the Timer task’s stack. */\n    *ppxTimerTaskStackBuffer = uxTimerTaskStack;\n\n    /* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.\n    Note that, as the array is necessarily of type StackType_t,\n    configTIMER_TASK_STACK_DEPTH is specified in words, not bytes. */\n    *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;\n}\n\n/*\n * Examples of the callback functions that must be provided by the application to\n * supply the RAM used by the Idle and Timer Service tasks if \n * configSUPPORT_STATIC_ALLOCATION is set to 1.\n */\n```\n\n有关更多信息，请参见 [Static Vs Dynamic Memory Allocation](https://www.freertos.org/Static_Vs_Dynamic_Memory_Allocation.html) 页面。\n\n**32、configSUPPORT_DYNAMIC_ALLOCATION**\n\n置 `1` （或未定义）：可以使用从 FreeRTOS 堆自动分配的 RAM 创建 RTOS 对象；\n\n置 `0` ：只能使用应用程序编写器提供的 RAM 创建 RTOS 对象。\n\n有关更多信息，请参见 [Static Vs Dynamic Memory Allocation](https://www.freertos.org/Static_Vs_Dynamic_Memory_Allocation.html) 页面。\n\n**33、configTOTAL_HEAP_SIZE**\n\nFreeRTOS 堆中可用的 RAM 总量；仅当 [configSUPPORT_DYNAMIC_ALLOCATION](https://www.freertos.org/a00110.html#configSUPPORT_DYNAMIC_ALLOCATION) 设置为 `1` 且应用程序使用 FreeRTOS 源代码下载中的四个堆内存分配方案之一（ `heap_1.c` 、`heap_2.c` 、`heap_4.c` 或 `heap_5.c` ）时，才使用此值。\n\n注意，当使用 `heap_3` 时，该值的设置无效。\n\n有关更多详细信息，请参见 [内存配置](https://www.freertos.org/a00111.html) 部分。\n\n**34、configAPPLICATION_ALLOCATED_HEAP**\n\n默认情况下，[FreeRTOS堆](https://www.freertos.org/a00111.html) 由 FreeRTOS 声明，并由链接器放置在内存中；将 `configAPPLICATION_ALLOCATED_HEAP` 设置为 `1` 可以使堆改为由应用程序编写者声明，这允许应用程序编写者将堆放置在内存中任意位置。\n\n如果使用 `heap_1.c` 、`heap_2.c` 或 `heap_4.c` ，并且 `configAPPLICATION_ALLOCATED_HEAP` 设置为 `1` ，那么应用程序编写者必须提供一个 `uint8_t` 类型的数组，其名称和维数如下所示；该数组将用作 FreeRTOS 堆：\n\n```c\nuint8_t ucHeap [configTOTAL_HEAP_SIZE];\n```\n\n如何将数组放置在特定的内存位置取决于所使用的编译器，请参阅编译器的文档。\n\n**35、configGENERATE_RUN_TIME_STATS**\n\n该 [Run Time Stats](https://www.freertos.org/rtos-run-time-stats.html) 页面描述了此参数的用法。\n\n**36、configUSE_CO_ROUTINES**\n\n置 `1` ：使用协程；\n\n置 `0` ：不使用协程。\n\n如果使用协程，必须在工程中包含 `croutine.c` 文件。\n\n注意：协程（Co-routines）主要用于资源发非常受限的嵌入式系统（RAM 非常少），通常不会用于 32 位微处理器；**在当前嵌入式硬件环境下，不建议使用协程，FreeRTOS 的开发者早已经停止开发协程** 。\n\n**37、configMAX_CO_ROUTINE_PRIORITIES**\n\n[应用程序协程（Co-routines）的有效优先级数目](https://www.freertos.org/co-routine-priorities.html) 。任意数量的协同例程可以共享相同的优先级，使用协程可以单独的分配给任务优先级，请参阅 `configMAX_PRIORITIES` 。\n\n**38、configUSE_TIMERS**\n\n置 `1` ：使用软件定时器；\n\n置 `0` ：不使用软件定时器\n\n有关完整说明，请参见 [FreeRTOS software timers](https://www.freertos.org/RTOS-software-timer.html) 页面。\n\n**39、configTIMER_TASK_PRIORITY**\n\n设置软件计时器服务 /守护程序任务的优先级。\n\n有关完整说明，请参见 [FreeRTOS software timers](https://www.freertos.org/RTOS-software-timer.html) 页面。\n\n**40、configTIMER_QUEUE_LENGTH**\n\n设置软件计时器命令队列的长度。\n\n有关完整说明，请参见 [FreeRTOS software timers](https://www.freertos.org/RTOS-software-timer.html) 页面。\n\n**41、configTIMER_TASK_STACK_DEPTH**\n\n设置分配给软件计时器服务/守护程序任务的堆栈深度。\n\n有关完整说明，请参见 [FreeRTOS software timers](https://www.freertos.org/RTOS-software-timer.html) 页面。\n\n**42、configKERNEL_INTERRUPT_PRIORITY 、configMAX_SYSCALL_INTERRUPT_PRIORITY和 configMAX_API_CALL_INTERRUPT_PRIORITY**\n\n包含 `configKERNEL_INTERRUPT_PRIORITY` 设置的硬件端口有 ARM Cortex-M3，PIC24，dsPIC，PIC32，SuperH 和 RX600。\n\n包含 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置的硬件端口有 PIC32，RX600，ARM Cortex-A 和 ARM Cortex-M。\n\n`configMAX_API_CALL_INTERRUPT_PRIORITY` 是 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的新名称，仅由较新的端口使用，两者是等效的。\n\n`configKERNEL_INTERRUPT_PRIORITY` 应该设置为最低优先级。\n\n请注意，在以下讨论中，只能从中断服务例程中调用以 “ FromISR ” 结尾的 API 函数。\n\n对于仅支持 `configKERNEL_INTERRUPT_PRIORITY` 的硬件端口：\n `configKERNEL_INTERRUPT_PRIORITY` 设置 RTOS 内核本身使用的中断优先级。调用 API 函数的中断也必须以此优先级执行。不调用 API 函数的中断可以以更高的优先级执行，因此不会因 RTOS 内核活动（在硬件本身的限制内）而延迟执行。\n\n对于同时支持 `configKERNEL_INTERRUPT_PRIORITY` 和 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的硬件端口：\n `configKERNEL_INTERRUPT_PRIORITY` 设置 RTOS 内核本身使用的中断优先级。`configMAX_SYSCALL_INTERRUPT_PRIORITY` 设置最高的中断优先级，从中可以调用中断安全的 FreeRTOS API 函数。\n\n通过设置 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的优先级级别高于 `configKERNEL_INTERRUPT_PRIORITY` 可以实现完整的中断嵌套模式；**这意味着即使在关键部分内部，FreeRTOS 内核也不会完全禁用中断** 。\n\n此外，这对于分段内核架构的微处理器是有利的。但是请注意，当一个新的中断被接受时，某些微控制器体系结构（在硬件中）将禁用中断，这意味着在硬件接受中断和 FreeRTOS 代码重新启用中断之间的短时间内不可避免地禁用中断。\n\n不调用 API 函数的中断可以以高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的优先级执行，因此不会因 RTOS 内核执行而延迟。\n\n例如：假设一个微控制器有 8 个中断优先级别：0 表示最低优先级，7 表示最高优先级（Cortex-M3 和 Cortex-M4 内核优先数和优先级别正好与之相反，后续文章会专门介绍它们）下在图描述了如果将两个配置常量设置为 4 和 0，则在每个优先级上可以做什么和不能做什么，如下所示：\n\n![img](20200217155104470.png)\n\n这些配置参数允许非常灵活的中断处理：\n\n- 在系统中可以像其它任务一样为中断处理任务分配优先级。这些任务通过一个相应中断唤醒。中断服务程序（ISR）本身应写得尽可能短，仅用于更新数据然后唤醒高优先级任务；然后，ISR 退出后，直接运行被唤醒的任务，因此中断处理（根据中断获取的数据来进行的相应处理）在时间上是连续的，就像 ISR 在完成这些工作。这样做的好处是，在执行处理程序任务时，所有中断都保持启用状态。\n- 支持 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的硬件端口将进一步扩展：允许使用完全嵌套的模型，其中 RTOS 内核中断优先级和 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 之间的中断可以嵌套并允许调用 API 函数；而优先级高于`configMAX_SYSCALL_INTERRUPT_PRIORITY` 的中断不会因 RTOS 内核活动而延迟。\n- 在最高系统调用优先级之上运行的 ISR（大于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 的优先级中断）不会被 RTOS 内核本身掩盖，因此它们的响应能力不受 RTOS 内核功能的影响。对于要求非常高的时间精度的中断（例如，执行电机转向的中断）而言，这是理想的选择；但是，在这类中断的中断服务例程中绝不可以调用 FreeRTOS 的 API 函数。\n\n要使用此方案，您的应用程序设计必须遵守以下规则：**使用 FreeRTOS API 的任何中断必须设置为与 RTOS 内核相同的优先级（由 `configKERNEL_INTERRUPT_PRIORITY` 宏配置）；或者对于包含支持 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 功能的硬件端口，设置低于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 定义的优先级**\n\n针对 ARM Cortex-M3 和 ARM Cortex-M4 用户的特别说明：请阅读 [专门介绍ARM Cortex-M设备上的中断优先级设置的页面](https://www.freertos.org/RTOS-Cortex-M3-M4.html) 。至少要记住，ARM Cortex-M3 内核使用数字低优先级数字来表示高优先级中断，这看起来似乎违反直觉，而且很容易忘记！如果您希望为中断分配一个低优先级，请不要为其分配优先级 0（或其他低数值），因为这可能导致在系统中实际上是具有最高优先级中断的；因此，如果这个优先级高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY` ，将会导致系统崩溃。\n\n实际上，ARM Cortex-M3 内核的最低优先级为 255，但是，不同的 ARM Cortex-M3 供应商实现了不同数量的优先级位，并提供了期望以不同方式指定优先级的库函数。例如，在 STM32 上，您可以在 ST 驱动程序库调用中，根据实际情况把最低优先级指定为 15，而最高优先级为 0。\n\n总结一下就是，在 FreeRtos 中调用中断关闭和中断开启 API 函数（例如在临界区区域内），其控制只对 `configKERNEL_INTERRUPT_PRIORITY` 到 `configMAX_SYSCALL_INTERRUPT_PRIORITY` 之间的优先级有效，其余的中断不受影响\n\n**43、configASSERT**\n\n`configASSERT()` 宏的语义与标准 C `assert()` 宏相同。如果传递给 `configASSERT()` 的参数为零，则触发断言。\n\n在整个 FreeRTOS 源文件中都会调用 `configASSERT()` 来检查应用程序是如何使用 FreeRTOS；因此强烈建议使用定义的 `configASSERT()` 开发 FreeRTOS 应用程序。\n\n举一个例子，我们想把非法参数所在的文件名和代码行数打印出来，可以先定义一个函数 `vAssertCalled` ，并传入触发 `configASSERT()` 调用的文件名和行号（__FILE__和 __LINE__是大多数编译器提供的标准宏）：\n\n```c\n/* Define configASSERT() to call vAssertCalled() if the assertion fails.  The assertion\nhas failed if the value of the parameter passed into configASSERT() equals zero. */\n#define configASSERT( ( x ) )     if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )\n```\n\n这里只是为了演示，因为 `vAssertCalled()` 不是 FreeRTOS 里面的函数，可以将 `configASSERT()` 定义为采取应用程序编写者认为适当的任何操作。通常以这样的方式定义 `configASSERT()` ，它可以防止应用程序进一步执行；这有两个原因：在断言停止的地方，应用程序编写者可以调试产生断言的原因；若继续执行触发断言之后的程序可能会导致系统崩溃。\n\n请注意，定义 `configASSERT()` 会增加应用程序代码的大小和执行时间；当应用程序稳定后，只需注释掉 `FreeRTOSConfig.h` 中的 `configASSERT()` 定义，就可以消除额外的开销了。\n\n如果在调试器的控制下运行 FreeRTOS，则可以把 `configASSERT()` 定义为禁用中断并处于循环中的状态，如下所示。这将导致在断言测试失败的行上停止代码的运行，应用程序编写者只需要暂停调试器，就会立即将您带到有问题的行，以便您查看失败的原因。\n\n```c\n/* Define configASSERT() to disable interrupts and sit in a loop. */\n#define configASSERT( ( x ) )     if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }\n```\n\n**44、configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS**\n\n`configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS` 仅由 FreeRTOS MPU 使用。\n\n如果 `configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS` 设置为 `1` ，则应用程序编写者必须提供一个名为 “ `application_defined_privileged_functions.h` ” 的头文件，可以在其之中实现应用程序编写者需要以特权模式执行的功能。请注意，尽管扩展名为 `.h` ，但头文件应包含 C 函数的实现，而不仅仅是函数的原型。\n\n在 “ `application_defined_privileged_functions.h` ” 中实现的函数必须分别使用 `prvRaisePrivilege()` 函数和 `portRESET_PRIVILEGE()` 宏来保存和恢复处理器的特权状态.\n\n例如，如果库提供的打印功能访问了应用程序编写者无法控制的 RAM，因此无法分配给受内存保护的用户模式任务，则可以使用以下代码将打印功能封装在特权功能中：\n\n```c\nvoid MPU_debug_printf( const char *pcMessage )\n{\n/* State the privilege level of the processor when the function was called. */\nBaseType_t xRunningPrivileged = prvRaisePrivilege();\n\n    /* Call the library function, which now has access to all RAM. */\n    debug_printf( pcMessage );\n\n    /* Reset the processor privilege level to its original value. */\n    portRESET_PRIVILEGE( xRunningPrivileged );\n}\n```\n\n该技术只能在开发过程中使用，而不能在部署过程中使用，因为它会绕过内存保护。\n\n\n\n# 包含参数\n\n以 “ INCLUDE ” 开头的宏允许将实时内核中那些未被应用程序使用的组件从构建中排除，这样可以确保 RTOS 使用的 ROM 或 RAM 不会超出特定嵌入式应用程序所需的数量\n\n每个宏采用以下形式：\n\n```c\nINCLUDE_FunctionName\n```\n\n其中 FunctionName 表示可以选择排除的 API 函数（或函数集）\n\n置 `1` ：使用该 API 函数；\n\n置 `0` ：不使用该 API 函数。\n\n例如，包含 `vTaskDelete()` API 函数，请使用：\n\n```c\n#define INCLUDE_vTaskDelete    1\n```\n\n要从构建中排除 `vTaskDelete()` ，请使用：\n\n```c\n#define INCLUDE_vTaskDelete    0\n```\n\n\n\n# 配置项裁剪\n\n在了解完上面的各项参数后，就可以配置了，具体如下：\n\n```c\n/*\n    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.\n    All rights reserved\n\n    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.\n\n    This file is part of the FreeRTOS distribution.\n\n    FreeRTOS is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License (version 2) as published by the\n    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.\n\n    ***************************************************************************\n    >>!   NOTE: The modification to the GPL is included to allow you to     !<<\n    >>!   distribute a combined work that includes FreeRTOS without being   !<<\n    >>!   obliged to provide the source code for proprietary components     !<<\n    >>!   outside of the FreeRTOS kernel.                                   !<<\n    ***************************************************************************\n\n    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY\n    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n    FOR A PARTICULAR PURPOSE.  Full license text is available on the following\n    link: http://www.freertos.org/a00114.html\n\n    ***************************************************************************\n     *                                                                       *\n     *    FreeRTOS provides completely free yet professionally developed,    *\n     *    robust, strictly quality controlled, supported, and cross          *\n     *    platform software that is more than just the market leader, it     *\n     *    is the industry's de facto standard.                               *\n     *                                                                       *\n     *    Help yourself get started quickly while simultaneously helping     *\n     *    to support the FreeRTOS project by purchasing a FreeRTOS           *\n     *    tutorial book, reference manual, or both:                          *\n     *    http://www.FreeRTOS.org/Documentation                              *\n     *                                                                       *\n    ***************************************************************************\n\n    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading\n    the FAQ page \"My application does not run, what could be wrong?\".  Have you\n    defined configASSERT()?\n\n    http://www.FreeRTOS.org/support - In return for receiving this top quality\n    embedded software for free we request you assist our global community by\n    participating in the support forum.\n\n    http://www.FreeRTOS.org/training - Investing in training allows your team to\n    be as productive as possible as early as possible.  Now you can receive\n    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers\n    Ltd, and the world's leading authority on the world's leading RTOS.\n\n    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,\n    including FreeRTOS+Trace - an indispensable productivity tool, a DOS\n    compatible FAT file system, and our tiny thread aware UDP/IP stack.\n\n    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.\n    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.\n\n    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High\n    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS\n    licenses offer ticketed support, indemnification and commercial middleware.\n\n    http://www.SafeRTOS.com - High Integrity Systems also provide a safety\n    engineered and independently SIL3 certified version for use in safety and\n    mission critical applications that require provable dependability.\n\n    1 tab == 4 spaces!\n*/\n\n#ifndef FREERTOS_CONFIG_H\n#define FREERTOS_CONFIG_H\n\n/*-----------------------------------------------------------\n * Application specific definitions.\n *\n * These definitions should be adjusted for your particular hardware and\n * application requirements.\n *\n * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE\n * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. \n *\n * See http://www.freertos.org/a00110.html.\n *----------------------------------------------------------*/\n\n/* Here is a good place to include header files that are required across\nyour application. */\n// #include \"stm32f10x.h\"\n\n\n#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)\n    /* Clock manager provides in this variable system core clock frequency */\n    #include <stdint.h>\n\t#include <stdio.h>\n    extern uint32_t SystemCoreClock;\n#endif\n\n#define configUSE_PREEMPTION                    1\n#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1\n#define configUSE_TICKLESS_IDLE                 0\n#define configCPU_CLOCK_HZ                      ( ( unsigned long ) SystemCoreClock )\n#define configTICK_RATE_HZ                      ( ( TickType_t ) 1000 )\n#define configMAX_PRIORITIES                    ( 5 )\n#define configMINIMAL_STACK_SIZE                ( ( unsigned short ) 128 )\n#define configMAX_TASK_NAME_LEN                 ( 16 )\n#define configUSE_16_BIT_TICKS                  0\n#define configIDLE_SHOULD_YIELD                 1\n#define configUSE_TASK_NOTIFICATIONS            1\n#define configUSE_MUTEXES                       0\n#define configUSE_RECURSIVE_MUTEXES             0\n#define configUSE_COUNTING_SEMAPHORES           0\n#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */\n#define configQUEUE_REGISTRY_SIZE               10\n#define configUSE_QUEUE_SETS                    0\n#define configUSE_TIME_SLICING                  1\n#define configUSE_NEWLIB_REENTRANT              0\n#define configENABLE_BACKWARD_COMPATIBILITY     0\n#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5\n#define configSTACK_DEPTH_TYPE                  uint16_t\n#define configMESSAGE_BUFFER_LENGTH_TYPE        size_t\n\n/* Memory allocation related definitions. */\n#define configSUPPORT_STATIC_ALLOCATION         0\n#define configSUPPORT_DYNAMIC_ALLOCATION        1\n#define configTOTAL_HEAP_SIZE                   ( ( size_t ) ( 17 * 1024 ) )\n#define configAPPLICATION_ALLOCATED_HEAP        0\n\n/* Hook function related definitions. */\n#define configUSE_IDLE_HOOK                     0\n#define configUSE_TICK_HOOK                     0\n#define configCHECK_FOR_STACK_OVERFLOW          0\n#define configUSE_MALLOC_FAILED_HOOK            0\n#define configUSE_DAEMON_TASK_STARTUP_HOOK      0\n\n/* Run time and task stats gathering related definitions. */\n#define configGENERATE_RUN_TIME_STATS           0\n#define configUSE_TRACE_FACILITY                0\n#define configUSE_STATS_FORMATTING_FUNCTIONS    1\n\n/* Co-routine related definitions. */\n#define configUSE_CO_ROUTINES                   0\n#define configMAX_CO_ROUTINE_PRIORITIES         ( 2 )\n\n/* Software timer related definitions. */\n#define configUSE_TIMERS                        0\n#define configTIMER_TASK_PRIORITY               (configMAX_PRIORITIES-1)\n#define configTIMER_QUEUE_LENGTH                10\n#define configTIMER_TASK_STACK_DEPTH            (configMINIMAL_STACK_SIZE*2)\n\n/* Interrupt nesting behaviour configuration. */\n#ifdef __NVIC_PRIO_BITS\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* user add */\n\t#define configPRIO_BITS       \t\t\t__NVIC_PRIO_BITS\n#else\n\t#define configPRIO_BITS       \t\t\t4                  \n#endif /* __NVIC_PRIO_BITS */\n/* This is the value being used as per the ST library which permits 16\npriority values, 0 to 15.  This must correspond to the\nconfigKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest\nNVIC value of 255. */\n#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY\t\t15\t\t\t\t\t\t\t\t// user add\n#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY\t11\t\t\t\t\t\t\t\t// user add\n/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255\n(lowest) to 0 (1?) (highest). */\n/* equivalent to 0xf0, or NVIC 240. */\n#define configKERNEL_INTERRUPT_PRIORITY         (configLIBRARY_KERNEL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))//[dependent of processor]\n/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!! */\n/* equivalent to 0xb0, or priority 11. */\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY    (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))//[dependent on processor and application]\n#define configMAX_API_CALL_INTERRUPT_PRIORITY   //[dependent on processor and application]\n\n/* Define to trap errors during development. */\n#define vAssertCalled(char, int)\t\t\tprintf(\"Error:%s,%d\\r\\n\",char,int)\t\t// user add\n//#define configASSERT( ( x ) ) if( ( x ) == 0 )\tvAssertCalled( __FILE__, __LINE__ )\n#define configASSERT( x )\t  if( ( x ) == 0 ) \tvAssertCalled(__FILE__,__LINE__)\t\t// The user needs to modify\n\n/* FreeRTOS MPU specific definitions. */\n#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0\n\n/* Optional functions - most linkers will remove unused functions anyway. */\n#define INCLUDE_vTaskPrioritySet                1\n#define INCLUDE_uxTaskPriorityGet               1\n#define INCLUDE_vTaskDelete                     1\n#define INCLUDE_vTaskSuspend                    1\n#define INCLUDE_xResumeFromISR                  1\n#define INCLUDE_vTaskDelayUntil                 1\n#define INCLUDE_vTaskDelay                      1\n#define INCLUDE_xTaskGetSchedulerState          1\n#define INCLUDE_xTaskGetCurrentTaskHandle       1\n#define INCLUDE_uxTaskGetStackHighWaterMark     0\n#define INCLUDE_xTaskGetIdleTaskHandle          0\n#define INCLUDE_eTaskGetState                   1\n#define INCLUDE_xEventGroupSetBitFromISR        1\n#define INCLUDE_xTimerPendFunctionCall          0\n#define INCLUDE_xTaskAbortDelay                 0\n#define INCLUDE_xTaskGetHandle                  0\n#define INCLUDE_xTaskResumeFromISR              1\n\n/* A header file that defines trace macro can be included here. */\n\n#define xPortPendSVHandler   \t\t\tPendSV_Handler\n#define xPortSysTickHandler \t\t\tSysTick_Handler\n#define vPortSVCHandler      \t\t\tSVC_Handler\n\n\n#endif /* FREERTOS_CONFIG_H */\n```\n\n然后，值得注意的是，在 Cortex-M3 硬件端口下，FreeRTOS 使用 SysTick 作为系统节拍时钟，使用 SVC 和 PendSVC 进行上下文切换；异常中断服务代码位于 port.c 文件中，FreeRTOS 的作者已经为各种架构的 CPU 写好了这些代码，可以直接拿来用，因此我们只需要进行更改调用；这里有两种方法：\n\n- **第一种是在 Cortex-M3 启动文件中进行替换，将这些异常中断入口地址挂接到启动代码中**\n\n![img](20200217153706659.png)\n\n```text\nDCD     SVC_Handler            换成：   DCD     vPortSVCHandler\nDCD     PendSV_Handler         换成：   DCD     xPortPendSVHandler\nDCD     SysTick_Handler        换成：   DCD     xPortSysTickHandler\n```\n\n在方框中，按照上面的信息把向量地址名替换掉\n\n- **第二种是利用宏重定义一下，并且要把 ST 官方预留的中断屏蔽掉，转而使用 FreeRTOS中实现的函数功能**\n\n```c\n#define xPortPendSVHandler   \t\t\tPendSV_Handler\n#define xPortSysTickHandler \t\t\tSysTick_Handler\n#define vPortSVCHandler      \t\t\tSVC_Handler\n```\n\n在 `FreeRTOSConfig.h` 头文件中添加以上宏，看上面给出的应用代码，然后再注释掉 ST 预留的中断函数：\n\n![img](20200217154404470.png)\n\n在这里是利用了宏 `_FreeRTOS` 来管理，当然你也可以直接注释，又或者设置成弱定义函数，随你喜欢，只要不出现重命名就好了。","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之 heap 堆内存分配分析","url":"/freertos-heap/","content":"\n\n\n# FreeRTOS内存分配选择\n\n在 FreeRTOS 中，可以用静态（不使用 FreeRTOS 堆）或动态来分配 RTOS 的对象； 因此 FreeRTOS 中提供了 5 种堆管理方案，这些方案的复杂性和功能使得它的使用范围广泛，当然用户也可以自己实现堆管理；在官方的例程中，动静态的使用选择可以通过使能宏 `configSUPPORT_STATIC_ALLOCATION` 和宏 `configSUPPORT_DYNAMIC_ALLOCATION` 来进行决定（官方默认是使用动态内存进行分配的），当然，前提是使用 FreeRTOS 提供的 heap 堆分配的其中一个文件，而不是用自己实现的堆管理；甚至你还可以两种方法都在同一 RTOS 应用程序中使用。\n\n\n\n# 静态与动态内存分配\n\nV9.0.0 之前的 FreeRTOS 版本是从特殊的 FreeRTOS 堆中（也就是这几个 `heap` 文件）分配下面列出的 RTOS 对象使用的内存。而在 FreeRTOS V9.0.0 及更高版本中，人们可以自己实现堆管理提供内存，从而可以选择创建以下对象，而无需动态分配任何内存：\n\n- 任务\n- 软件计时器\n- 队列\n- 事件\n- 二值信号量\n- 计数信号量\n- 递归信号量\n- 互斥量\n\n**1、使用动态分配的 RAM 创建 RTOS 对象**\n\n动态创建 RTOS 对象的好处是可以更加简单、并有可能尽最大程度地减少应用程序的最大 RAM使用量\n\n如果 `configSUPPORT_DYNAMIC_ALLOCATION` 设置为 1 或未定义，以下 API 函数将使用动态分配的 RAM 创建 RTOS 对象：\n\n- [xTaskCreate()](https://www.freertos.org/a00125.html)\n- [xQueueCreate()](https://www.freertos.org/a00116.html)\n- [xTimerCreate()](https://www.freertos.org/FreeRTOS-timers-xTimerCreate.html)\n- [xEventGroupCreate()](https://www.freertos.org/xEventGroupCreate.html)\n- [xSemaphoreCreateBinary()](https://www.freertos.org/xSemaphoreCreateBinary.html)\n- [xSemaphoreCreateCounting()](https://www.freertos.org/CreateCounting.html)\n- [xSemaphoreCreateMutex()](https://www.freertos.org/CreateMutex.html)\n- [xSemaphoreCreateRecursiveMutex()](https://www.freertos.org/xSemaphoreCreateRecursiveMutex.html)\n\n**2、使用静态分配的 RAM 创建 RTOS 对象**\n\n使用静态分配的 RAM 创建 RTOS 对象的好处是为应用程序编写者提供了更多控制权\n\n下列 API 函数（如果 `configSUPPORT_STATIC_ALLOCATION` 设置为 1 时可用）允许使用应用程序编写者实现的堆管理创建 RTOS 对象。为了提供内存，应用程序编写者只需要声明一个适当对象类型的变量，然后将变量的地址传递给 RTOS API 函数即可。官方也提供了 [StaticAllocation.c](https://sourceforge.net/p/freertos/code/HEAD/tree/trunk/FreeRTOS/Demo/Common/Minimal/StaticAllocation.c) 标准的演示/测试任务来演示如何使用这些功能：\n\n- [xTaskCreateStatic()](https://www.freertos.org/xTaskCreateStatic.html)\n- [xQueueCreateStatic()](https://www.freertos.org/xQueueCreateStatic.html)\n- [xTimerCreateStatic()](https://www.freertos.org/xTimerCreateStatic.html)\n- [xEventGroupCreateStatic()](https://www.freertos.org/xEventGroupCreateStatic.html)\n- [xSemaphoreCreateBinaryStatic()](https://www.freertos.org/xSemaphoreCreateBinaryStatic.html)\n- [xSemaphoreCreateCountingStatic()](https://www.freertos.org/xSemaphoreCreateCountingStatic.html)\n- [xSemaphoreCreateMutexStatic()](https://www.freertos.org/xSemaphoreCreateMutexStatic.html)\n- [xSemaphoreCreateRecursiveMutexStatic()](https://www.freertos.org/xSemaphoreCreateRecursiveMutexStatic.html)\n\n\n\n# 内存管理\n\n如果 RTOS 对象是动态创建的，则有时可以使用标准 C 库 `malloc()` 和 `free()` 函数来实现此目的，但是 …\n\n1. 它们并不总是在嵌入式系统上可用；\n2. 他们占用了宝贵的代码空间；\n3. 它们不是线程安全的；\n4. 它们不是确定性的（执行函数所花费的时间因调用而异）。\n\n因此，通常需要另一种内存分配实现。\n\n一个嵌入式 /实时系统可能具有与另一个系统不同的 RAM 和时序要求；因此，单个 RAM 分配算法仅适用于部分应用程序。\n\n为了解决这个问题，FreeRTOS 将内存分配 API 保留在其可移植层中；当 RTOS 内核需要 RAM 时，它不调用 `malloc()`，而是调用 `pvPortMalloc()` ；当释放 RAM 时，RTOS 内核将调用 `vPortFree()` 而不是调用 `free()` 。\n\n在 `FreeRTOSv9.0.0\\FreeRTOS\\Source\\portable\\MemMang` 文档中，FreeRTOS 提供了五个内存分配实现：\n\n- [heap_1](https://www.freertos.org/a00111.html#heap_1) – 最简单，不允许释放内存。\n- [heap_2](https://www.freertos.org/a00111.html#heap_2) – 允许释放内存，但不合并相邻的空闲块。\n- [heap_3](https://www.freertos.org/a00111.html#heap_3) – 简单包装标准 `malloc()` 和 `free()` 以确保线程安全。\n- [heap_4](https://www.freertos.org/a00111.html#heap_4) – 合并相邻的空闲块以避免碎片；包括绝对地址放置选项。\n- [heap_5](https://www.freertos.org/a00111.html#heap_5) – 参照 `heap_4`，能够跨多个不相邻的内存区域扩展堆。\n\n\n\n## heap_1.c\n\n在这个文件中有这么一项注释： **The simplest possible implementation of pvPortMalloc().  Note that this implementation does NOT allow allocated memory to be freed again.** 也就是表明了 `heap_1.c` 这个文件的功能只能进行分配，不支持释放内存。\n\n它的分配函数实现：\n\n```c\nvoid *pvPortMalloc( size_t xWantedSize )\n{\nvoid *pvReturn = NULL;\nstatic uint8_t *pucAlignedHeap = NULL;\n\n\t/* Ensure that blocks are always aligned to the required number of bytes. */\n\t#if( portBYTE_ALIGNMENT != 1 )\n\t{\n\t\tif( xWantedSize & portBYTE_ALIGNMENT_MASK )\n\t\t{\n\t\t\t/* Byte alignment required. */\n\t\t\txWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n\t\t}\n\t}\n\t#endif\n\n\tvTaskSuspendAll();\n\t{\n\t\tif( pucAlignedHeap == NULL )\n\t\t{\n\t\t\t/* Ensure the heap starts on a correctly aligned boundary. */\n\t\t\tpucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n\t\t}\n\n\t\t/* Check there is enough room left for the allocation. */\n\t\tif( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n\t\t\t( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )\t)/* Check for overflow. */\n\t\t{\n\t\t\t/* Return the next free byte then increment the index past this\n\t\t\tblock. */\n\t\t\tpvReturn = pucAlignedHeap + xNextFreeByte;\n\t\t\txNextFreeByte += xWantedSize;\n\t\t}\n\n\t\ttraceMALLOC( pvReturn, xWantedSize );\n\t}\n\t( void ) xTaskResumeAll();\n\n\t#if( configUSE_MALLOC_FAILED_HOOK == 1 )\n\t{\n\t\tif( pvReturn == NULL )\n\t\t{\n\t\t\textern void vApplicationMallocFailedHook( void );\n\t\t\tvApplicationMallocFailedHook();\n\t\t}\n\t}\n\t#endif\n\n\treturn pvReturn;\n}\n```\n\n\n\n既然这么简单，就稍微分析一下吧！\n\n1、首先是对内存对齐的判断，这里，如果内存对齐有效，则执行；如果要分配的内存不是对齐字节(通常是 8，根据 `portBYTE_ALIGNMENT` 来确定对齐字节)的整数倍，则补齐，所以 `xWantedSize` 要加上要补齐的长度。\n\n```c\n/* Ensure that blocks are always aligned to the required number of bytes. */\n#if( portBYTE_ALIGNMENT != 1 )\n{\n\tif( xWantedSize & portBYTE_ALIGNMENT_MASK )\n\t{\n\t\t/* Byte alignment required. */\n\t\txWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n\t}\n}\n#endif\n```\n\n\n\n2、接着挂起所有的调度器，防止在分配内存的过程中被打断。\n\n```c\nvTaskSuspendAll();\n```\n\n\n\n3、判断是否为第一次分配，若是，则检查初分配的内存是否有对齐，这里 `uheap` 是一个静态数组（是 FreeRTOS 为我们申请的一个内存堆，大小由宏 `configTOTAL_HEAP_SIZE` 决定），首先要确保它是否对齐，因为 `uheap` 的首地址可能不是 8 的倍数，若是没有对齐，那么进行对齐处理，以确保实际开始分配的地址是对齐的，值得留意的是，这个对齐处理只做一次。\n\n```c\nif( pucAlignedHeap == NULL )\n{\n\t/* Ensure the heap starts on a correctly aligned boundary. */\n\tpucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n}\n```\n\n\n\n4、在正式分配前进行溢出检查，如果空间够用，则记录新分配空间的首地址到 `pvReturn` ，并重新记录新的空闲空间的首地址到 `NextFreeByte` 。\n\n```c\n/* Check there is enough room left for the allocation. */\nif( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n\t( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )\t)/* Check for overflow. */\n{\n\t/* Return the next free byte then increment the index past this\tblock. */\n\tpvReturn = pucAlignedHeap + xNextFreeByte;\n\txNextFreeByte += xWantedSize;\n}\n```\n\n\n\n5、`traceMALLOC( pvReturn, xWantedSize )` 是一个宏，用于输出内存分配的调试信息，这个宏定义在 `FreeRTOS.h` 中，默认为空，如果需要将这些调试信息输出到串口或其它东西，就可以修改这个宏将信息输出到所需要的地方。\n\n```c\ntraceMALLOC( pvReturn, xWantedSize );\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n6、最后，恢复之前挂起的调度器\n\n```c\n( void ) xTaskResumeAll();\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n7、这个取决于宏 `configUSE_MALLOC_FAILED_HOOK` 是否使能，如果开启了分配失败 `hook` 函数，就调用该 `hook` 。\n\n```c\n#if( configUSE_MALLOC_FAILED_HOOK == 1 )\n{\n\tif( pvReturn == NULL )\n\t{\n\t\textern void vApplicationMallocFailedHook( void );\n\t\tvApplicationMallocFailedHook();\n\t}\n}\n#endif\n```\n\n\n\n适用环境以及功能简介：\n\n- 如果您的应用程序从不删除任务，队列，信号量，互斥锁等，则可以使用它（实际上涵盖了使用 FreeRTOS 的大多数应用程序）。\n- 始终是确定性的（总是花费相同的时间来执行），并且不会导致内存碎片。\n- 它是非常简单的，可以从静态分配的数组中分配内存，这意味着它通常适用于不允许真正的动态内存分配的应用程序。\n\n\n\n## heap_2.c\n\n此方案使用了最佳适应算法（best fit algorithm），并且与**方案 1** 不同，它允许释放以前分配的块；它不会将相邻的空闲块合并成一个大块。\n\n同样的，文件里的注释： **A sample implementation of pvPortMalloc() and vPortFree() that permits allocated blocks to be freed, but does not combine adjacent free blocks into a single larger block (and so will fragment memory).** 也就是说现在支持分配和释放内存，但对内存碎片不做处理。\n\n1、在实现堆分配之前，有一个堆初始化的过程 `prvHeapInit()` ，并且只调用一次（就是第一次进入该函数的时候）\n\n```c\nstatic void prvHeapInit( void )\n{\nBlockLink_t *pxFirstFreeBlock;\nuint8_t *pucAlignedHeap;\n\n\t/* Ensure the heap starts on a correctly aligned boundary. */\n\tpucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n\n\t/* xStart is used to hold a pointer to the first item in the list of free\n\tblocks.  The void cast is used to prevent compiler warnings. */\n\txStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;\n\txStart.xBlockSize = ( size_t ) 0;\n\n\t/* xEnd is used to mark the end of the list of free blocks. */\n\txEnd.xBlockSize = configADJUSTED_HEAP_SIZE;\n\txEnd.pxNextFreeBlock = NULL;\n\n\t/* To start with there is a single free block that is sized to take up the\n\tentire heap space. */\n\tpxFirstFreeBlock = ( void * ) pucAlignedHeap;\n\tpxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;\n\tpxFirstFreeBlock->pxNextFreeBlock = &xEnd;\n}\n```\n\n这里用到了 `BlockLink_t` 结构体，这个结构有两个成员，第一个是节点 Next 指针 `pxNextFreeBlock` ，第二个是空闲块大小。结构体成员如下：\n\n```c\n/* Define the linked list structure.  This is used to link free blocks in order\nof their size. */\ntypedef struct A_BLOCK_LINK\n{\n\tstruct A_BLOCK_LINK *pxNextFreeBlock;\t/*<< The next free block in the list. */\n\tsize_t xBlockSize;\t\t\t/*<< The size of the free block. */\n} BlockLink_t;\n```\n\n首先，对开辟的堆进行地址对齐工作，对齐的原因的原理与 `heap_1` 一样，在获取堆的首地址后，对 `xStart` 链表头和 `xEnd` 链表尾进行初始化赋值；在 `heap_2` 中，与 `heap_1` 不同的是，由于 FreeRTOS 用空闲块对内存堆进行管理，于是用 `BlockLink_t` 这一个结构来形成一条空闲块链表对空闲块进行组织和管理。\n\n\n\n2、好了，现在回到 `pvPortMalloc()` 函数中。\n\n```c\nvoid *pvPortMalloc( size_t xWantedSize )\n{\nBlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;\nstatic BaseType_t xHeapHasBeenInitialised = pdFALSE;\nvoid *pvReturn = NULL;\n\n\tvTaskSuspendAll();\n\t{\n\t\t/* If this is the first call to malloc then the heap will require\n\t\tinitialisation to setup the list of free blocks. */\n\t\tif( xHeapHasBeenInitialised == pdFALSE )\n\t\t{\n\t\t\tprvHeapInit();\n\t\t\txHeapHasBeenInitialised = pdTRUE;\n\t\t}\n\n\t\t/* The wanted size is increased so it can contain a BlockLink_t\n\t\tstructure in addition to the requested amount of bytes. */\n\t\tif( xWantedSize > 0 )\n\t\t{\n\t\t\txWantedSize += heapSTRUCT_SIZE;\n\n\t\t\t/* Ensure that blocks are always aligned to the required number of bytes. */\n\t\t\tif( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n\t\t\t{\n\t\t\t\t/* Byte alignment required. */\n\t\t\t\txWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n\t\t\t}\n\t\t}\n\n\t\tif( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n\t\t{\n\t\t\t/* Blocks are stored in byte order - traverse the list from the start\n\t\t\t(smallest) block until one of adequate size is found. */\n\t\t\tpxPreviousBlock = &xStart;\n\t\t\tpxBlock = xStart.pxNextFreeBlock;\n\t\t\twhile( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n\t\t\t{\n\t\t\t\tpxPreviousBlock = pxBlock;\n\t\t\t\tpxBlock = pxBlock->pxNextFreeBlock;\n\t\t\t}\n\n\t\t\t/* If we found the end marker then a block of adequate size was not found. */\n\t\t\tif( pxBlock != &xEnd )\n\t\t\t{\n\t\t\t\t/* Return the memory space - jumping over the BlockLink_t structure\n\t\t\t\tat its start. */\n\t\t\t\tpvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n\n\t\t\t\t/* This block is being returned for use so must be taken out of the\n\t\t\t\tlist of free blocks. */\n\t\t\t\tpxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n\t\t\t\t/* If the block is larger than required it can be split into two. */\n\t\t\t\tif( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n\t\t\t\t{\n\t\t\t\t\t/* This block is to be split into two.  Create a new block\n\t\t\t\t\tfollowing the number of bytes requested. The void cast is\n\t\t\t\t\tused to prevent byte alignment warnings from the compiler. */\n\t\t\t\t\tpxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\n\t\t\t\t\t/* Calculate the sizes of two blocks split from the single\n\t\t\t\t\tblock. */\n\t\t\t\t\tpxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n\t\t\t\t\tpxBlock->xBlockSize = xWantedSize;\n\n\t\t\t\t\t/* Insert the new block into the list of free blocks. */\n\t\t\t\t\tprvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n\t\t\t\t}\n\n\t\t\t\txFreeBytesRemaining -= pxBlock->xBlockSize;\n\t\t\t}\n\t\t}\n\n\t\ttraceMALLOC( pvReturn, xWantedSize );\n\t}\n\t( void ) xTaskResumeAll();\n\n\t#if( configUSE_MALLOC_FAILED_HOOK == 1 )\n\t{\n\t\tif( pvReturn == NULL )\n\t\t{\n\t\t\textern void vApplicationMallocFailedHook( void );\n\t\t\tvApplicationMallocFailedHook();\n\t\t}\n\t}\n\t#endif\n\n\treturn pvReturn;\n}\n```\n\n同样的，在每次分配空间之前，先挂起调度器，这是没得说的，然后如果是第一次调用 `pvPortMalloc()` ，则调用 `prvHeapInit()` 对内存堆和空闲块链表进行初始化；而下面这段 code：\n\n```c\n/* The wanted size is increased so it can contain a BlockLink_t\nstructure in addition to the requested amount of bytes. */\nif( xWantedSize > 0 )\n{\n\txWantedSize += heapSTRUCT_SIZE;\n\n\t/* Ensure that blocks are always aligned to the required number of bytes. */\n\tif( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n\t{\n\t\t/* Byte alignment required. */\n\t\txWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n\t}\n}\n```\n\n在用户每申请一次内存，FreeRTOS 都会在申请的空间前加上空闲块头部 `BlockLink_t` ，用于记录分配出去的空间的大小，因此，实际分配的内存空间大小就等于用户申请的内存空间大小加上空闲块头部的大小；最后再加上头部之后，还要对整个大小进行对齐。\n\n下一个 `if` 判断：\n\n```c\nif( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n{\n\t/* Blocks are stored in byte order - traverse the list from the start\n\t(smallest) block until one of adequate size is found. */\n\tpxPreviousBlock = &xStart;\n\tpxBlock = xStart.pxNextFreeBlock;\n\twhile( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n\t{\n\t\tpxPreviousBlock = pxBlock;\n\t\tpxBlock = pxBlock->pxNextFreeBlock;\n\t}\n\n\t/* If we found the end marker then a block of adequate size was not found. */\n\tif( pxBlock != &xEnd )\n\t{\n\t\t/* Return the memory space - jumping over the BlockLink_t structure\n\t\tat its start. */\n\t\tpvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n\n\t\t/* This block is being returned for use so must be taken out of the\n\t\tlist of free blocks. */\n\t\tpxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n\t\t/* If the block is larger than required it can be split into two. */\n\t\tif( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n\t\t{\n\t\t\t/* This block is to be split into two.  Create a new block\n\t\t\tfollowing the number of bytes requested. The void cast is\n\t\t\tused to prevent byte alignment warnings from the compiler. */\n\t\t\tpxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\n\t\t\t/* Calculate the sizes of two blocks split from the single\n\t\t\tblock. */\n\t\t\tpxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n\t\t\tpxBlock->xBlockSize = xWantedSize;\n\n\t\t\t/* Insert the new block into the list of free blocks. */\n\t\t\tprvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n\t\t}\n\n\t\txFreeBytesRemaining -= pxBlock->xBlockSize;\n\t}\n}\n```\n\n先是判断用户申请的空间大小是否存在（不等于零）以及是否已经超过堆空间大小，若是不符合那就直接 pass 掉了；在这里，块的大小是按从小到大的顺序排列的，因此从一开始遍历列表(最小的)块，直到找到一个合适的大小，最后把位置记录下来。\n\n```c\n/* If we found the end marker then a block of adequate size was not found. */\nif( pxBlock != &xEnd )\n{\n\t/* Return the memory space - jumping over the BlockLink_t structure\n\tat its start. */\n\tpvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n\n\t/* This block is being returned for use so must be taken out of the\n\tlist of free blocks. */\n\tpxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n\t/* If the block is larger than required it can be split into two. */\n\tif( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n\t{\n\t\t/* This block is to be split into two.  Create a new block\n\t\tfollowing the number of bytes requested. The void cast is\n\t\tused to prevent byte alignment warnings from the compiler. */\n\t\tpxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\n\t\t/* Calculate the sizes of two blocks split from the single\n\t\tblock. */\n\t\tpxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n\t\tpxBlock->xBlockSize = xWantedSize;\n\n\t\t/* Insert the new block into the list of free blocks. */\n\t\tprvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n\t}\n\n\txFreeBytesRemaining -= pxBlock->xBlockSize;\n}\n```\n\n紧接着，在上面的一段代码里，先是把返回的空间地址值修改（跳过 `BlockLink_t` 结构），然后把上一个的下一个的节点指向当前下一个的空闲块；后面，若果分配出去的空闲块的剩余空间是比两倍的空闲块头部结构体大小还要大，则将分配出去的这个空闲块分割剩余的空间出来，重新放到空闲块链表中。\n\n值得注意的是 `prvInsertBlockIntoFreeList` 这个是个宏，具体实现如下：\n\n```c\n/*\n * Insert a block into the list of free blocks - which is ordered by size of\n * the block.  Small blocks at the start of the list and large blocks at the end\n * of the list.\n */\n#define prvInsertBlockIntoFreeList( pxBlockToInsert )\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\nBlockLink_t *pxIterator;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\nsize_t xBlockSize;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\txBlockSize = pxBlockToInsert->xBlockSize;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t/* Iterate through the list until a block is found that has a larger size */\t\\\n\t/* than the block we are inserting. */\t\t\t\t\t\t\t\t\t\t\t\\\n\tfor( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock )\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t/* There is nothing to do here - just iterate to the correct position. */\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t/* Update the list to include the block being inserted in the correct */\t\t\\\n\t/* position. */\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tpxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\t\t\t\t\t\\\n\tpxIterator->pxNextFreeBlock = pxBlockToInsert;\t\t\t\t\t\t\t\t\t\\\n}\n```\n\n这个宏的作用就是将新空闲块插入到合适的链表位置中。\n\n后面的代码执行就跟 `heap_1` 一样了，修改剩余空闲块空闲大小 `xFreeBytesRemaining` 、恢复所有挂起的任务等等。\n\n\n\n3、最后剩下的就是 `heap_1` 中不支持的 `vPortFree()`释放函数了。\n\n```c\nvoid vPortFree( void *pv )\n{\nuint8_t *puc = ( uint8_t * ) pv;\nBlockLink_t *pxLink;\n\n\tif( pv != NULL )\n\t{\n\t\t/* The memory being freed will have an BlockLink_t structure immediately\n\t\tbefore it. */\n\t\tpuc -= heapSTRUCT_SIZE;\n\n\t\t/* This unexpected casting is to keep some compilers from issuing\n\t\tbyte alignment warnings. */\n\t\tpxLink = ( void * ) puc;\n\n\t\tvTaskSuspendAll();\n\t\t{\n\t\t\t/* Add this block to the list of free blocks. */\n\t\t\tprvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\n\t\t\txFreeBytesRemaining += pxLink->xBlockSize;\n\t\t\ttraceFREE( pv, pxLink->xBlockSize );\n\t\t}\n\t\t( void ) xTaskResumeAll();\n\t}\n}\n```\n\n这一个函数炒鸡简单，而且非常短，首先判断要释放的内存是否为空；若是不为空，则获取这个内存空间真正的的空闲块（剔除头部的 `BlockLink_t` 结构），然后挂起所有任务，把释放的内存重新插入到空闲块链表中，最后调用调试信息宏，恢复挂起的任务就结束了。\n\n\n\n特点：\n\n即使应用程序反复删除任务，队列，信号量，互斥量等对象，也可以使用，有关内存碎片的警告如下：\n\n- 如果不是，如果被分配和释放内存使用是随机的大小。例如： \n  - 如果应用程序以动态创建和删除任务，并且分配给正在创建的任务的堆栈大小始终相同，则在大多数情况下可以使用 `heap_2.c` ；但是，如果分配给正在创建的任务的堆栈大小并不总是相同，则可用的空闲内存可能会分成许多小块，最终导致分配失败；在这种情况下，`heap_4.c` 会更好\n  - 如果应用程序以动态创建和删除队列，并且每种情况下队列存储区域都相同（队列存储区域指队列项数目乘以每个队列长度），则在大多数情况下都可以使用 `heap_2.c` ；但是，如果队列存储区域在每种情况下都不相同，则可用的空闲内存可能会分成许多小块，最终导致分配失败；在这种情况下，`heap_4.c` 会更好\n  - 该应用程序直接调用 `pvPortMalloc()` 和 `vPortFree()`，而不仅仅是通过其他 FreeRTOS API 函数间接调用。 \t\n- 如果您的应用程序的队列，任务，信号量，互斥量等处于以不可预测的顺序，则可能会导致内存碎片问题；虽然这是小概率事件，但应牢记。\n- 不确定型，但比大多数标准 C 库 `malloc` 实现要有效得多。\n\n\n\n## heap_3.c\n\nheap_3.c 就更简单了，只是简单的包装一下标准函数 `malloc()` 和 `free()` 以确保线程安全，在大多数情况下，这些包装器将需要你的编译器提供，它们依赖于编译器自己的 `malloc()` 和 `free()` 实现；文件说明如下： **Implementation of pvPortMalloc() and vPortFree() that relies on the compilers own malloc() and free() implementations.This file can only be used if the linker is configured to to generate a heap memory area.**\n\n1、封装 `malloc()`\n\n```c\nvoid *pvPortMalloc( size_t xWantedSize )\n{\nvoid *pvReturn;\n\n\tvTaskSuspendAll();\n\t{\n\t\tpvReturn = malloc( xWantedSize );\n\t\ttraceMALLOC( pvReturn, xWantedSize );\n\t}\n\t( void ) xTaskResumeAll();\n\n\t#if( configUSE_MALLOC_FAILED_HOOK == 1 )\n\t{\n\t\tif( pvReturn == NULL )\n\t\t{\n\t\t\textern void vApplicationMallocFailedHook( void );\n\t\t\tvApplicationMallocFailedHook();\n\t\t}\n\t}\n\t#endif\n\n\treturn pvReturn;\n}\n```\n\n和 `heap_1` 、`heap_2` 一样，用 `vTaskSuspendAll()` 挂起所有的任务，以确保分配内存的过程是线程安全的；随后才使用 `malloc()` 进行内存分配，记录内存地址；然后就是调用调试信息宏 `traceMALLOC()` ，最后调用 `xTaskResumeAll()` 恢复所有被挂起的任务；如果在 `FreeRTOS.h` 中使能了勾子函数宏 `configUSE_MALLOC_FAILED_HOOK` ，则在调用勾子函数 `vApplicationMallocFailedHook()` 之后再向用户返回分配内存的首地址。\n\n\n\n2、封装 `free()`\n\n```c\nvoid vPortFree( void *pv )\n{\n\tif( pv )\n\t{\n\t\tvTaskSuspendAll();\n\t\t{\n\t\t\tfree( pv );\n\t\t\ttraceFREE( pv, 0 );\n\t\t}\n\t\t( void ) xTaskResumeAll();\n\t}\n}\n```\n\n一样的，检查指针的有效性、挂起全部任务、调用 `free()` 接口将内存回收、调用调试信息宏、恢复挂起的任务，然后就没了。\n\n\n\n此实现方法及特点：\n\n- 需要链接器设置堆，并且需要编译器库提供 `malloc()` 和 `free()` 实现。\n- 具有不确定性。\n- 可能会大大增加 RTOS 内核代码的大小。\n\n注意，当使用 `heap_3` 时，`FreeRTOSConfig.h` 中的宏 `configTOTAL_HEAP_SIZE` 设置无效。\n\n\n\n## heap_4.c\n\n跟**方案 2** 不一样的是，这个方案使用了首次适应算法（first fit algorithm）；它会将相邻的空闲内存块合并成一个更大的块（包含一个合并算法）。\n\n具体是它们会在释放时合并相邻的内存块，从而限制内存碎片，文件中的注释也有说： **A sample implementation of pvPortMalloc() and vPortFree() that combines (coalescences) adjacent memory blocks as they are freed, and in so doing limits memory fragmentation.**\n\n其实， `heap_4` 的代码基本跟 `heap_2` 的代码实现差不多，只不过增加了些功能（合并算法），而且你别看他代码太长，其实有很多东西都没用到的，就像这个函数 `mtCOVERAGE_TEST_MARKER()` ，其实他是个宏，但是他并没有实现什么，根据他的命名可以认定为只是作者预留的一个调试输出窗口而已；还有 `configASSERT()` 这个也是一个宏，也只是用来调试输出而已，具体配置修改看下一篇。\n\n1、没错，还是我们首要分析的初始化函数。\n\n```c\nstatic void prvHeapInit( void )\n{\nBlockLink_t *pxFirstFreeBlock;\nuint8_t *pucAlignedHeap;\nsize_t uxAddress;\nsize_t xTotalHeapSize = configTOTAL_HEAP_SIZE;\n\n\t/* Ensure the heap starts on a correctly aligned boundary. */\n\tuxAddress = ( size_t ) ucHeap;\n\n\tif( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )\n\t{\n\t\tuxAddress += ( portBYTE_ALIGNMENT - 1 );\n\t\tuxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\n\t\txTotalHeapSize -= uxAddress - ( size_t ) ucHeap;\n\t}\n\n\tpucAlignedHeap = ( uint8_t * ) uxAddress;\n\n\t/* xStart is used to hold a pointer to the first item in the list of free\n\tblocks.  The void cast is used to prevent compiler warnings. */\n\txStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;\n\txStart.xBlockSize = ( size_t ) 0;\n\n\t/* pxEnd is used to mark the end of the list of free blocks and is inserted\n\tat the end of the heap space. */\n\tuxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;\n\tuxAddress -= xHeapStructSize;\n\tuxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );\n\tpxEnd = ( void * ) uxAddress;\n\tpxEnd->xBlockSize = 0;\n\tpxEnd->pxNextFreeBlock = NULL;\n\n\t/* To start with there is a single free block that is sized to take up the\n\tentire heap space, minus the space taken by pxEnd. */\n\tpxFirstFreeBlock = ( void * ) pucAlignedHeap;\n\tpxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;\n\tpxFirstFreeBlock->pxNextFreeBlock = pxEnd;\n\n\t/* Only one block exists - and it covers the entire usable heap space. */\n\txMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;\n\txFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;\n\n\t/* Work out the position of the top bit in a size_t variable. */\n\txBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );\n}\n```\n\n![img](20200215165421587.png)\n\n根据上图现在来对比一下 `head_2` 的，这里对起始地址做字节对齐处理是跟 `head_2` 有点不同，他不止对内存堆进行首地址对齐保存 `pucAlignedHeap` ，并且还算出可用空间大小为 `xTotalHeapSize`；\n\n然后，`xStart` 的初始化是一样的，没什么好说的，注意 `xStart` 是 `BlockLink_t` 的一个实体变量，存储在静态存储区；\n\n接着是 `pxEnd` ，他是一个 `BlockLink_t` 的指针，存储在静态存储区中，却指向了内存堆的最后一个 `BlockLink_t` 大小的位置上。也就是说，内存堆最后的空间是存储着一个 `BlockLink_t` ，用来指示空闲块链表的最后位置，这是和 `heap_2` 所不同的地方：\n\n![img](20200215172529594.png)\n\n因为 `pxEnd` 占用了一个 `BlockLink_t` 大小的空间，所以在整个堆空间，减去 `pxEnd` 占用的空间；\n\n另外，为了安全，`heap_4` 增加一个位（ `BlockLink_t` 中 `xBlockSize` 的最高位）标记某个内存块是否处于空闲状态，因此在初始化的时候设置 `xBlockAllocatedBit` 的值。\n\n\n\n2、在对比分析 `pvPortMalloc()` 内存分布的实现之前，我们先分析一下 `prvInsertBlockIntoFreeList()` 函数。\n\n```c\nstatic void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )\n{\nBlockLink_t *pxIterator;\nuint8_t *puc;\n\n\t/* Iterate through the list until a block is found that has a higher address\n\tthan the block being inserted. */\n\tfor( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )\n\t{\n\t\t/* Nothing to do here, just iterate to the right position. */\n\t}\n\n\t/* Do the block being inserted, and the block it is being inserted after\n\tmake a contiguous block of memory? */\n\tpuc = ( uint8_t * ) pxIterator;\n\tif( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )\n\t{\n\t\tpxIterator->xBlockSize += pxBlockToInsert->xBlockSize;\n\t\tpxBlockToInsert = pxIterator;\n\t}\n\telse\n\t{\n\t\tmtCOVERAGE_TEST_MARKER();\n\t}\n\n\t/* Do the block being inserted, and the block it is being inserted before\n\tmake a contiguous block of memory? */\n\tpuc = ( uint8_t * ) pxBlockToInsert;\n\tif( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )\n\t{\n\t\tif( pxIterator->pxNextFreeBlock != pxEnd )\n\t\t{\n\t\t\t/* Form one big block from the two blocks. */\n\t\t\tpxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;\n\t\t\tpxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpxBlockToInsert->pxNextFreeBlock = pxEnd;\n\t\t}\n\t}\n\telse\n\t{\n\t\tpxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\n\t}\n\n\t/* If the block being inserted plugged a gab, so was merged with the block\n\tbefore and the block after, then it's pxNextFreeBlock pointer will have\n\talready been set, and should not be set here as that would make it point\n\tto itself. */\n\tif( pxIterator != pxBlockToInsert )\n\t{\n\t\tpxIterator->pxNextFreeBlock = pxBlockToInsert;\n\t}\n\telse\n\t{\n\t\tmtCOVERAGE_TEST_MARKER();\n\t}\n}\n```\n\n这个函数就是合并实现的主要环节了；在 `heap_2` 中的链表插入是通过宏实现的，并且是按内存块大小进行插入；而 `heap_4` 的插入操作是写成了一个函数，该函数按内存块地址进行插入（低位前），实际上是将这个空闲块链表里的所有空闲块按地址顺序排列，这么做是为了实现内存块合并；前面也说了，相对于 `heap_2` ，`heap_4` 会将相邻的空闲内存块合并成一个更大的块，若果不这么排列，那么就不能将相邻的空闲块进行合并了。\n\n首先，通过一次链表的遍历，找出内存块插入点（把 `pxIterator` 找出来）；然后判断，正在插入的块（`pxBlockToInsert`）和内存块插入点（`pxIterator`）是否构成一个连续的内存块；其标准为 `pxIterator` 的首地址加上 `pxIterator` 的块大小之后等于 `pxBlockToInsert` 的首地址，相等就说明两个块是相邻的，把这个待插入的空闲块插到 `pxIterator` 的后面，否则就什么事都不做。\n\n```c\n/* Iterate through the list until a block is found that has a higher address\nthan the block being inserted. */\nfor( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )\n{\n\t/* Nothing to do here, just iterate to the right position. */\n}\n\n/* Do the block being inserted, and the block it is being inserted after\nmake a contiguous block of memory? */\npuc = ( uint8_t * ) pxIterator;\nif( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )\n{\n\tpxIterator->xBlockSize += pxBlockToInsert->xBlockSize;\n\tpxBlockToInsert = pxIterator;\n}\nelse\n{\n\tmtCOVERAGE_TEST_MARKER();\n}\n```\n\n然后，再试着将 `pxBlockToInsert` 和 `pxIterator` 指向的下一个空闲块进行合并；这次用 `pxBlockToInsert` 的首地址加上 `pxBlockToInsert` 的块大小与 `pxIterator` 指向的下一个块地址比较，不符合，则要修改 `pxBlockToInsert` 的 Next 指针，指向`pxIterator` 的下一个空闲块；如果符合条件，则再判断 `pxIterator` 指向的下一个块地址是否已经到了空闲块链表的最后位置了，如果已经到了空闲块链表的最后位置，那么就把 `pxIterator` 指向的下一个块地址更改为空闲块链表的最后位置的地址，否则就合并内存并且更新链表的数据。\n\n```c\n/* Do the block being inserted, and the block it is being inserted before\nmake a contiguous block of memory? */\npuc = ( uint8_t * ) pxBlockToInsert;\nif( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )\n{\n\tif( pxIterator->pxNextFreeBlock != pxEnd )\n\t{\n\t\t/* Form one big block from the two blocks. */\n\t\tpxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;\n\t\tpxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;\n\t}\n\telse\n\t{\n\t\tpxBlockToInsert->pxNextFreeBlock = pxEnd;\n\t}\n}\nelse\n{\n\tpxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;\n}\n```\n\n最后，要是 `pxBlockToInsert` 没有和 `pxIterator` 合并，则还要修改 `pxIterator` 的 Next 指针。\n\n```c\n/* If the block being inserted plugged a gab, so was merged with the block\nbefore and the block after, then it's pxNextFreeBlock pointer will have\nalready been set, and should not be set here as that would make it point\nto itself. */\nif( pxIterator != pxBlockToInsert )\n{\n\tpxIterator->pxNextFreeBlock = pxBlockToInsert;\n}\nelse\n{\n\tmtCOVERAGE_TEST_MARKER();\n}\n```\n\n\n\n3、讲了这么多，现在终于到分析 `pvPortMalloc()` 了。\n\n先看总代码：\n\n```c\nvoid *pvPortMalloc( size_t xWantedSize )\n{\nBlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;\nvoid *pvReturn = NULL;\n\n\tvTaskSuspendAll();\n\t{\n\t\t/* If this is the first call to malloc then the heap will require\n\t\tinitialisation to setup the list of free blocks. */\n\t\tif( pxEnd == NULL )\n\t\t{\n\t\t\tprvHeapInit();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t}\n\n\t\t/* Check the requested block size is not so large that the top bit is\n\t\tset.  The top bit of the block size member of the BlockLink_t structure\n\t\tis used to determine who owns the block - the application or the\n\t\tkernel, so it must be free. */\n\t\tif( ( xWantedSize & xBlockAllocatedBit ) == 0 )\n\t\t{\n\t\t\t/* The wanted size is increased so it can contain a BlockLink_t\n\t\t\tstructure in addition to the requested amount of bytes. */\n\t\t\tif( xWantedSize > 0 )\n\t\t\t{\n\t\t\t\txWantedSize += xHeapStructSize;\n\n\t\t\t\t/* Ensure that blocks are always aligned to the required number\n\t\t\t\tof bytes. */\n\t\t\t\tif( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )\n\t\t\t\t{\n\t\t\t\t\t/* Byte alignment required. */\n\t\t\t\t\txWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n\t\t\t\t\tconfigASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t}\n\n\t\t\tif( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )\n\t\t\t{\n\t\t\t\t/* Traverse the list from the start\t(lowest address) block until\n\t\t\t\tone\tof adequate size is found. */\n\t\t\t\tpxPreviousBlock = &xStart;\n\t\t\t\tpxBlock = xStart.pxNextFreeBlock;\n\t\t\t\twhile( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n\t\t\t\t{\n\t\t\t\t\tpxPreviousBlock = pxBlock;\n\t\t\t\t\tpxBlock = pxBlock->pxNextFreeBlock;\n\t\t\t\t}\n\n\t\t\t\t/* If the end marker was reached then a block of adequate size\n\t\t\t\twas\tnot found. */\n\t\t\t\tif( pxBlock != pxEnd )\n\t\t\t\t{\n\t\t\t\t\t/* Return the memory space pointed to - jumping over the\n\t\t\t\t\tBlockLink_t structure at its start. */\n\t\t\t\t\tpvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );\n\n\t\t\t\t\t/* This block is being returned for use so must be taken out\n\t\t\t\t\tof the list of free blocks. */\n\t\t\t\t\tpxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n\n\t\t\t\t\t/* If the block is larger than required it can be split into\n\t\t\t\t\ttwo. */\n\t\t\t\t\tif( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n\t\t\t\t\t{\n\t\t\t\t\t\t/* This block is to be split into two.  Create a new\n\t\t\t\t\t\tblock following the number of bytes requested. The void\n\t\t\t\t\t\tcast is used to prevent byte alignment warnings from the\n\t\t\t\t\t\tcompiler. */\n\t\t\t\t\t\tpxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n\t\t\t\t\t\tconfigASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );\n\n\t\t\t\t\t\t/* Calculate the sizes of two blocks split from the\n\t\t\t\t\t\tsingle block. */\n\t\t\t\t\t\tpxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n\t\t\t\t\t\tpxBlock->xBlockSize = xWantedSize;\n\n\t\t\t\t\t\t/* Insert the new block into the list of free blocks. */\n\t\t\t\t\t\tprvInsertBlockIntoFreeList( pxNewBlockLink );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t\t\t}\n\n\t\t\t\t\txFreeBytesRemaining -= pxBlock->xBlockSize;\n\n\t\t\t\t\tif( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )\n\t\t\t\t\t{\n\t\t\t\t\t\txMinimumEverFreeBytesRemaining = xFreeBytesRemaining;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t\t\t}\n\n\t\t\t\t\t/* The block is being returned - it is allocated and owned\n\t\t\t\t\tby the application and has no \"next\" block. */\n\t\t\t\t\tpxBlock->xBlockSize |= xBlockAllocatedBit;\n\t\t\t\t\tpxBlock->pxNextFreeBlock = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t}\n\n\t\ttraceMALLOC( pvReturn, xWantedSize );\n\t}\n\t( void ) xTaskResumeAll();\n\n\t#if( configUSE_MALLOC_FAILED_HOOK == 1 )\n\t{\n\t\tif( pvReturn == NULL )\n\t\t{\n\t\t\textern void vApplicationMallocFailedHook( void );\n\t\t\tvApplicationMallocFailedHook();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t}\n\t}\n\t#endif\n\n\tconfigASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );\n\treturn pvReturn;\n}\n```\n\n其实相对于 `heap_2` 的变动不大，可以看一下它们的对比图：\n\n![img](20200215194716241.png)\n\n同样的，只在第一次调用该函数的时候才初始化堆管理，看上图。\n\n![img](2020021519500019.png)\n\n接着在这里只是相对于 `heap_2` 多了个标志位 `xBlockAllocatedBit` 的判断来是否执行以下的操作，若是符合，则像 `heap_2` 一样进行块字节对齐，看上图。\n\n而剩下的，主要的不同也就是因为多了个 `xBlockAllocatedBit` 操作，所以使用了 `xBlockSize` 的最高位做标记，因此就添加了相应的操作，如下图：\n\n![img](2020021520080137.png)\n\n至于其他差别不大，此处不做赘述。\n\n\n\n4、`vPortFree()` 实现\n\n```c\nvoid vPortFree( void *pv )\n{\nuint8_t *puc = ( uint8_t * ) pv;\nBlockLink_t *pxLink;\n\n\tif( pv != NULL )\n\t{\n\t\t/* The memory being freed will have an BlockLink_t structure immediately\n\t\tbefore it. */\n\t\tpuc -= xHeapStructSize;\n\n\t\t/* This casting is to keep the compiler from issuing warnings. */\n\t\tpxLink = ( void * ) puc;\n\n\t\t/* Check the block is actually allocated. */\n\t\tconfigASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );\n\t\tconfigASSERT( pxLink->pxNextFreeBlock == NULL );\n\n\t\tif( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )\n\t\t{\n\t\t\tif( pxLink->pxNextFreeBlock == NULL )\n\t\t\t{\n\t\t\t\t/* The block is being returned to the heap - it is no longer\n\t\t\t\tallocated. */\n\t\t\t\tpxLink->xBlockSize &= ~xBlockAllocatedBit;\n\n\t\t\t\tvTaskSuspendAll();\n\t\t\t\t{\n\t\t\t\t\t/* Add this block to the list of free blocks. */\n\t\t\t\t\txFreeBytesRemaining += pxLink->xBlockSize;\n\t\t\t\t\ttraceFREE( pv, pxLink->xBlockSize );\n\t\t\t\t\tprvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );\n\t\t\t\t}\n\t\t\t\t( void ) xTaskResumeAll();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmtCOVERAGE_TEST_MARKER();\n\t\t}\n\t}\n}\n```\n\n相比 `heap_2` ，`heap_4` 只是多了一些检查，使之更加安全，看下图比较：\n\n![img](20200215201418626.png)\n\n\n\n应用场景及特点：\n\n- 即使应用程序反复删除任务，队列，信号量，互斥量等也可以使用。\n- 与 `heap_2` 实现相比，即使将要分配和释放的内存具有随机大小，也很难将堆空间严重分割成多个小块。\n- 不确定性，但比大多数标准 C 库 `malloc` 实现要有效得多。\n\n对于希望直接在应用程序代码中使用便携式层内存分配方案的应用程序，`heap_4.c` 尤其有用（而不是仅通过调用本身调用 `pvPortMalloc()` 和 `vPortFree()` 的 API 函数来间接使用）。\n\n\n\n## heap_5.c\n\n该方案使用与 `heap_4` 相同，使用首次适应算法和内存合并算法，并允许堆跨越多个不相邻（不连续）的内存区域。\n\n这个就不说了，跟 `heap_4` 大同小异，有兴趣可以看看，就只发一下它的文件注释说明吧\n\n```c\n/*\n * A sample implementation of pvPortMalloc() that allows the heap to be defined\n * across multiple non-contigous blocks and combines (coalescences) adjacent\n * memory blocks as they are freed.\n *\n * See heap_1.c, heap_2.c, heap_3.c and heap_4.c for alternative\n * implementations, and the memory management pages of http://www.FreeRTOS.org\n * for more information.\n *\n * Usage notes:\n *\n * vPortDefineHeapRegions() ***must*** be called before pvPortMalloc().\n * pvPortMalloc() will be called if any task objects (tasks, queues, event\n * groups, etc.) are created, therefore vPortDefineHeapRegions() ***must*** be\n * called before any other objects are defined.\n *\n * vPortDefineHeapRegions() takes a single parameter.  The parameter is an array\n * of HeapRegion_t structures.  HeapRegion_t is defined in portable.h as\n *\n * typedef struct HeapRegion\n * {\n *\tuint8_t *pucStartAddress; << Start address of a block of memory that will be part of the heap.\n *\tsize_t xSizeInBytes;\t  << Size of the block of memory.\n * } HeapRegion_t;\n *\n * The array is terminated using a NULL zero sized region definition, and the\n * memory regions defined in the array ***must*** appear in address order from\n * low address to high address.  So the following is a valid example of how\n * to use the function.\n *\n * HeapRegion_t xHeapRegions[] =\n * {\n * \t{ ( uint8_t * ) 0x80000000UL, 0x10000 }, << Defines a block of 0x10000 bytes starting at address 0x80000000\n * \t{ ( uint8_t * ) 0x90000000UL, 0xa0000 }, << Defines a block of 0xa0000 bytes starting at address of 0x90000000\n * \t{ NULL, 0 }                << Terminates the array.\n * };\n *\n * vPortDefineHeapRegions( xHeapRegions ); << Pass the array into vPortDefineHeapRegions().\n *\n * Note 0x80000000 is the lower address so appears in the array first.\n *\n */\n```\n\n\n\n注意：`heap_5` 通过调用 `vPortDefineHeapRegions()` 函数实现初始化，只有在 `vPortDefineHeapRegions()` 执行后才允许使用内存分配和释放。创建 RTOS 对象（任务、队列、信号量等等）会隐含的调用 `pvPortMalloc()` ，因此必须注意：使用 `heap_5` 创建任何对象前，要先执行 `vPortDefineHeapRegions()` 函数。\n\n\n\n# 其他\n\n必须吐槽一下，终于结束了。\n\n官方的这个地址有详细说 [heap堆内存管理](https://www.freertos.org/a00111.html)\n\n然后想要了解 heap 所用到的算法可以查看 ->[分区分配算法（Partitioning Placement Algorithm）](https://arachnid.cc/partitioning-placement-algorithm/)","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之系统移植","url":"/freertos-system-transplant/","content":"\n\n\n> 在移植之前，首先说明一下，该篇章，包括之后的文章都是建立在 CM-3 处理器上（用之前写 STM32 笔记的 STM32F103VET6），并且是用 FreeRTOS 的 V9.0.0 版本的核心文件进行移植，我们只需要把原有的 STM32 基础工程（[STM32的教程链接 ☜](https://arachnid.cc/categories/STM32/)）二次添加我们所需的 FreeRTOS 核心文件就可以了\n\n\n\n  1、开发环境：Keil uVision5 V5.21\n  2、ST外设标准固件库： V3.5\n  3、FreeRTOS版本库：V9.0.0\n  4、目标芯片：STM32F103VET6（Cotrex-M3）\n  5、下载调试工具：J-Link\n\n\n\n# FreeRTOS 核心文件提取\n\n在上一篇 [FreeRTOS 篇章之官方源码文档分析](https://arachnid.cc/freertos-file-analyse/) 已经分析出我们真正需要的文件是在 FreeRTOSv9.0.0/FreeRTOS文件中，那么我们就去提取出需要的东西。\n\n先在工程主目录上建立一个名为 FreeRTOS 的文档\n\n![img](20200212223821860.png)\n\n再在下载下来的 `FreeRTOSv9.0.0\\FreeRTOS\\Source` 文件夹中把下图的这几个文件放进到工程的文档中，而这些零散的源文件我们创一个 `src` 文档来对它们进行管理，具体看后面移植完的文件结构分布图：\n\n![img](20200212224344457.png)\n\n至于 `portable` 文档里面的内容，我们只需拿我们需要的接口就好了，全部拷贝文件太大了，不符合轻量级这个要求；所以进入 `FreeRTOSv9.0.0\\FreeRTOS\\Source\\portable` 文件夹中，你可以发现有好多以编译器命名的文档，由于我们的开发环境是在 `Keil` 中的，所以我们要使用里面的 `Keil` 文档的内容，再让我们进去文档里面瞅瞅有些啥？进去你会发现只有一个 `See also the RVDS directory.txt` 文本，他叫我们查看 `RVDS` 这个目录，那我们就进去看看呗，看下图：\n\n![img](20200212225436312.png)\n\n这下可以了，有支持我们的运行的接口，那就把 `RVDS` 这个目录复制过去呗\n\n其中，我们还需要把 `FreeRTOS/Source/portable/MemMang` 目录也要复制过去，因为我们需要一个对堆进行分配的处理文件，而官方已经为我们提供了几个堆分配方案了，就是里面的几个 `heap_x.c` 文件\n\n最后移植完得到下图这样：\n\n![img](2020021920042663.png)\n\n![img](20200212230410570.png)\n\n\n\n最最最后，还要再把 `FreeRTOSv9.0.0\\FreeRTOS\\Demo\\CORTEX_STM32F103_Keil` 路径下（因为官方 demo 中就这个文档最符合我们当前的移植工程）的 `FreeRTOSConfig.h` 文件复制到我们用户可修改的 `App` 文件夹下。\n\n\n\n# 工程导入及属性修改\n\n保持之前的工程不变，二次修改并添加下图的文件进入工程：\n\n![img](20200219200521981.png)\n\n\n\n~~然后再改一下配置的属性为 ARMCM3，~~ 配置属性不用改，是哪款 M3芯片就选哪个芯片，例如用的是 stm32f103zet6，那就选这个：\n\n![img](20200213160202881.png)\n\n好了，基本的工程移植就完成了，然后你可能会疑问为什么选 `heap_4` 这个堆分配方案的，这个在下一篇再进行解析","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"FreeRTOS 篇章之官方源码文档分析","url":"/freertos-file-analyse/","content":"\n\n\n> FreeRTOS官网：[https://www.freertos.org/index.html](https://www.freertos.org/index.html)\n\n\n\n# V9.0.0源码版本获取\n\n1、官方托管在 SVN的源代码链接：[https://sourceforge.net/projects/freertos/files/FreeRTOS/](https://sourceforge.net/projects/freertos/files/FreeRTOS/)\n\n![img](20200212155522823.png)\n\n\n\n2、官方托管在 GitHub的源代码链接：[https://github.com/FreeRTOS/FreeRTOS](https://github.com/FreeRTOS/FreeRTOS)\n\n![img](20200212155628361.png)\n\n\n\n这里使用 V9.0.0 版本，包括之后都是以 V9.0.0 版本为参考，不要问我为什么，哪个版本成熟稳定用那个。\n\n\n\n# 文件分类\n\n```text\nFreeRTOSv9.0.0\n     │  \n     ├─ New - Direct to Task Notifications\n     ├─ New - FreeRTOS+TCP\n     ├─ Quick_Start_Guide\n     ├─ Upgrading-to-FreeRTOS-9\n     │\n     ├─ FreeRTOS-Plus            // 包含 FreeRTOS+组件(TCP/CLI/IO/UDP)和演示项目\n     │        │\n     │        ├─ Demo\n     │        ├─ Source\n     │        └─ readme.txt      // 当前目录的一些文档说明\n     │\n     ├─ FreeRTOS                 // 包含 FreeRTOS实时内核源代码文件和演示项目(主要移植这个)\n     │      │\n     │      ├─ Demo              // 包含演示应用程序项目\n     │      ├─ License           // 许可说明\n     │      ├─ Source            // 包含实时内核源代码\n     │      ├─ links_to_doc_pages_for_the_demo_projects\n     │      └─ readme.txt        // 当前目录的一些文档说明\n     │\n     └─ readme.txt               // 主目录文档的大致说明\n```\n\n因为之后的实验是以移植 FreeRTOS这个文件为主，所以主要讲解这个文件里面的东西\n\n**1、首先是 FreeRTOS/Source 文件**\n\n```text\nFreeRTOS\n    └─ Source                     // 核心 FreeRTOS内核文件\n           │\n           ├─ include             // 核心 FreeRTOS内核头文件\n           │\n           ├─ portable            // 与处理器相关的特定代码\n           │     │\n           │     ├─ Compiler x    // 编译器x 支持的所有端口\n           │     ├─ Compiler y    // 编译器y 支持的所有端口\n           │     ├─ MemMang       // 堆实现的示例\n           │     └─ readme.txt    // 当前目录的一些文档说明\n           │\n           └─ readme.txt          // 当前目录的一些文档说明\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n`FreeRTOS/Source` 目录包含 FreeRTOS 源代码，并包含它自己的自述文件。\n\n`FreeRTOS/Source/Portable` 目录包含特定于特定微控制器和或编译器的文件。\n\n`FreeRTOS/Source/include` 目录包含实时内核头文件。\n\n核心 RTOS 代码包含在三个文件中，他们分别是 `tasks.c`， `queue.c` 和 `list.c`，这三个文件位于 `FreeRTOS/Source` 目录中；同一目录下还包含两个名为 `timers.c` 和 `croutine.c` 的可选文件，它们分别实现软件计时器和协同例程功能。\n\n同样的，官方提供的几个堆的分配方案也位于可移植层中。各种样本 `heap_x.c` 文件位于 `FreeRTOS/Source/portable/MemMang` 目录中\n\n**2、FreeRTOS/Demo 文件**\n\n```text\nFreeRTOS\n    └─ Demo                       // 演示应用程序项目\n        │\n        ├─ Common                 // 所有演示使用的演示应用程序文件\n        │\n        ├─ Dir x                  // 端口 x的演示应用程序构建文件\n        │\n        ├─ Dir y                  // 端口 y的演示应用程序构建文件\n        │\n        └─ readme.txt             // 当前目录的一些文档说明\n \n```\n\n`FreeRTOS/Demo` 目录包含用于每种处理器体系结构和编译器端口的演示应用程序。演示应用程序的大部分代码对所有端口通用，并且包含在 `FreeRTOS/Demo/Common/Minimal` 目录中（位于 `FreeRTOS/Demo/Common/Full` 目录中的代码是旧代码，仅由 PC 端口使用） 。\n\n其余的 `FreeRTOS/Demo` 子目录包含用于构建单个演示应用程序的预配置项目，目录被命名以指示它们所关联的端口；每个 RTOS 端口目录下包含着自己的 `readme`文件，而且它们还具有其自己的网页，该[网页](https://www.freertos.org/a00090.html)详细说明了可在其中找到该端口的演示应用程序的目录。\n\n\n\n# 其他\n\n具体的关于官方文档解析的更多信息可以看当前目录下的 `readme` 文件以及在官方的这个链接查看：[https://www.freertos.org/a00017.html](https://www.freertos.org/a00017.html)","tags":["history","RTOS","FreeRTOS"],"categories":["FreeRTOS"]},{"title":"C 语言结构体大小及对齐问题","url":"/c-structure-alignment/","content":"\n\n\n\n# 内存大小问题\n\n有时候，我们在不同的编译环境，或者不同的机子上测试编译，会呈现不同的结果，于是我们会陷入疑问，内存的大小是谁分配的呢？\n\n在系统中，系统对内存的识别是以 Byte（字节）为单位，每个字节由 8 位二进制数组成，即 8bit（比特，也称 “位” ）。按照计算机的二进制方式，1Byte = 8bit；1KB = 1024Byte；1MB = 1024KB；1GB = 1024MB；1TB = 1024GB。\n\n我们都知道 Byte（字节）的大小是固定的，但是，我们目前接触的都是以 Word（字长）、HalfWord（半字），而他的解释是：在电脑领域，对于某种特定的计算机设计而言，**字**（英语：word）是用于表示其自然的数据单位的术语。在这个特定电脑中，字是其用来一次性处理事务的一个固定长度的位（bit）组。一个字的位数（即**字长**）是电脑系统结构中的一个重要特性。\n\n来源：[字 (计算机) - 维基百科](https://zh.wikipedia.org/wiki/字_(计算机))\n\n\n\n# 分配问题\n\n我们之所以有可能出现编译的数据内存大小不一样，是因为在不同的处理器和编译器中它所呈现的结果是不一样的，直白的说就是所对应的 Word（字长）不一样，其实字长并非一个十分严格的概念，要从汇编语言的角度理解，就是指令集里面的运算和内存操作时操作数的长度，具体还是看一下关于计算机底层的东西。\n\n在 32 位处理器中 32 位指的就是 CPU GPRs（General-Purpose Registers，通用寄存器）的数据宽度，当然 64 位 CPU 的数据宽度为 64 位，所以 32 位 CPU 的数据宽度指的是 32 位了。\n\n64位指令集就是运行 64 位数据的指令，也就是说处理器一次可以运行 64Bit 数据。这样一来 32 位处理器一次最多只能处理 32 位，也就是 4 个字节的数据，而 64 位处理器一次就能处理 64 位，即 8 个字节的数据。\n\n按照上面总的来说：各种类型的存储大小与系统位数有关。\n\n而至于为什么又跟编译器有关呢？\n\n假设我们在 64 位处理器上运行 32位的编译器来写代码的，这样编译器就只会默认我们的程序是在 32 位系统下运行，因为这编译器最多只能处理 32 位，多了它处理不来啊 [哭笑] \n\n所以，一般严格来说，在进行编译测试后，想要告诉别人结果，也应该把你当时所测试的操作系统以及编译系统告诉别人，同样的例子也有：就像我们在下载一个程序的时候，你可能会看到程序文件名后面带有 x32 或者 x64 等一些标志性文本，这就是要告诉别人它支持的操作环境。\n\n![img](20200208120209731.png)\n\n\n\n# 结构体分配的空间\n\n在进行讨论之前先来看一下程序\n\n```cpp\n/* \n * 操作系统：基于 x64的处理器\n * 编译环境：Dev-C++ V5.11 \n */\n\n#include <stdio.h> \n\n#define SIZE\t\t1\n\nstruct s {\n    char a;\n    short b;\n    int c;\n    double d;\n    char* e;\n    char f[SIZE];\n//    double i;\n};\nstruct s temp;\n\nchar *p = NULL;\n\nint main(void)\n{\n\tprintf(\"char:%d,short:%d,int:%d,double:%d\\n\\n\",sizeof(char),sizeof(short),sizeof(int),sizeof(double));\n\tprintf(\"sizeof = %d\\n\",sizeof(char *));\n\tprintf(\"sizeof = %d\\n\\n\",sizeof(temp));\n\t\n\tprintf(\"temp addr = %p\\n\",&temp);\n\tprintf(\"a    addr = %p,%2d\\n\",&temp.a,sizeof(temp.a));\n\tprintf(\"b    addr = %p,%2d\\n\",&temp.b,sizeof(temp.b));\n\tprintf(\"c    addr = %p,%2d\\n\",&temp.c,sizeof(temp.c));\n\tprintf(\"d    addr = %p,%2d\\n\",&temp.d,sizeof(temp.d));\n\tprintf(\"e    addr = %p,%2d\\n\",&temp.e,sizeof(temp.e));\n\tprintf(\"\\nf    addr = %p\\n\",&temp.f);\n\tprintf(\"f    sizeof = %d\\n\",sizeof(temp.f));\n\t\n//\tprintf(\"\\ni addr = %p,%d\\n\",&temp.i,sizeof(temp.i));\n\n\t\n\treturn 0;\n}\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n我们定义了一个 `struct s` 的结构体，里面有不同数据类型的结构体成员 `.a /.b /.c /.e /.f`（成员 `i` 我们先屏蔽先，这个是关于后面对齐问题测试的）；成员 `f` 为数组，特殊点我们把地址跟大小分开打印；指针我们不知道他的大小，也打印出来；最后我们打印一下输出看下结果：\n\n![img](20200208121340412.png)\n\n先看第一行，我们打印出了 `char /short /int /double` 所对应的数据类型大小；\n\n第二行我们是打印了指针的数据大小，大小为 8Byte（因为指针在实质上是一个内存地址，内存地址的长度跟 CPU 的寻址有关；在 32 位系统上， CPU 用 32 位表示一个内存地址，这样的系统上一个指针占据 4 个字节（32 / 8 = 4）；在 64 位系统上， CPU 用 64 位表示一个内存地址，这样的系统上一个指针占据 8 个字节（64 / 8 = 8））\n\n第三行是打印出结构体总的大小为 32\n\n再到后面的，当前的结构体地址对应着第一个结构体成员地址，这个没问题；后面每个结构体成员所对应的数据类型大小也没问题；但是，当我们一加起来 1 + 2 + 4 + 8 + 8 + 1 = 24 ？？？跟打印出来的总大小不一样啊，这就关系到数据对齐了。\n\n\n\n# 内存大小对齐原则\n\n1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。\n2. 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）。即结构体成员的末地址减去结构体首地址（第一个结构体成员的首地址）得到的偏移量都要是对应成员大小的整数倍。\n3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在成员末尾加上填充字节。\n\n看了以上的原则后，我们来继续分析一下上面的数据类型大小问题\n\n实际上：结构体 s = a(1byte) + 空闲(1byte) + b(2byte) + c(4byte) + d(8byte) + e(8byte) + f * SIZE(1byte *1) + 空闲(7byte) = 32(byte)。\n\n解释一下：上面输出的结构体变量的首地址为 0x0407A20，对于第一个成员 `a` 的地址就是结构体的首地址，占用 1 个字节（符合第一个的原则）；因为成员 `a` 只用了 1 个字节，而成员 `b` 地址要 2 的倍数，中间隔着一个字节，那么就需要把这个一个字节填充进去，为后面的成员 `b` 的地址制造出 2 的倍数的地址数）；成员 `b` 自己的大小为 2byte，他所对的地址必须是 2 的倍数，那么在填充完那一个字节后，他的地址排下去就是 0x0407A22，对应上了 2 的倍数（即上面的第二点原则）；成员 `c` 大小为 4，同样的他所对的地址就得要 4 的倍数，算一下前面一共占用的地址数：a(1byte) + 空闲(1byte) + b(2byte) = 4(byte)，当前的地址就已经是 4 的倍数了，所以不需要填充；后面两个成员也一样；然后再到最后一个成员 `f` 的分析，因为这是最后一个成员了，这样就已经知道在整个结构体 `s` 中他的最宽基本类型成员大小是多小了，没错，是 8byte（double类型或者指针的内存地址大小）；那么按照第三点的原则，我们先能加起来的先加起来，先不考虑最后一项成员需要填充多少个字节： a(1byte) + 空闲(1byte) + b(2byte) + c(4byte) + d(8byte) + e(8byte) + f(1byte) = 25(byte)；25byte明显不是最宽基本类型成员大小 8byte 的倍数了，那么距离 25最近的 8的倍数有两个 24 和 32，若是选 24，内存明显不够放，所以只能取大进行填充 7byte，以便总大小成为 32byte。\n\n\n\n因此简单总结一下（在 x64位机，64位编译器中）：\n\n| 类型   | 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） |\n| ------ | ---------------------------------------------------------- |\n| Char   | 偏移量必须为 sizeof(char) 即 1 的倍数                      |\n| Short  | 偏移量必须为 sizeof(short) 即 2 的倍数                     |\n| int    | 偏移量必须为 sizeof(int) 即 4 的倍数                       |\n| float  | 偏移量必须为 sizeof(float) 即 4 的倍数                     |\n| double | 偏移量必须为 sizeof(double) 即 8 的倍数                    |\n\n各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节会自动填充。同时为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。\n\n\n\n# 其他\n\n案例一（结构体中的成员数组不指定大小，只限于成员数组在结构体尾部）：\n\n```cpp\n/* \n * 操作系统：基于 x64的处理器\n * 编译环境：Dev-C++ V5.11 \n */\n\n#include <stdio.h> \n\n#define SIZE\t\t1\n\nstruct s {\n    char a;\n    short b;\n    int c;\n    double d;\n    char* e;\n    char f[];\n//    double i;\n};\nstruct s temp;\n\nchar *p = NULL;\n\nint main(void)\n{\n\tprintf(\"char:%d,short:%d,int:%d,double:%d\\n\\n\",sizeof(char),sizeof(short),sizeof(int),sizeof(double));\n\tprintf(\"sizeof = %d\\n\",sizeof(char *));\n\tprintf(\"sizeof = %d\\n\\n\",sizeof(temp));\n\t\n\tprintf(\"temp addr = %p\\n\",&temp);\n\tprintf(\"a    addr = %p,%2d\\n\",&temp.a,sizeof(temp.a));\n\tprintf(\"b    addr = %p,%2d\\n\",&temp.b,sizeof(temp.b));\n\tprintf(\"c    addr = %p,%2d\\n\",&temp.c,sizeof(temp.c));\n\tprintf(\"d    addr = %p,%2d\\n\",&temp.d,sizeof(temp.d));\n\tprintf(\"e    addr = %p,%2d\\n\",&temp.e,sizeof(temp.e));\n\tprintf(\"\\nf    addr = %p\\n\",&temp.f);\n//\tprintf(\"f    sizeof = %d\\n\",sizeof(temp.f));\n\t\n//\tprintf(\"\\ni addr = %p,%d\\n\",&temp.i,sizeof(temp.i));\n\n\t\n\treturn 0;\n}\n \n```\n\n运行结果：\n\n![img](2020020814355773.png)\n\n可以发现在程序中，由于没有为结构体成员数组 `f` 指定大小，将不为其分配空间\n\n\n\n案例二（在案例一下，再追加一个结构体成员 i(double类型) ）：\n\n```cpp\n#include <stdio.h> \n\n#define SIZE\t\t1\n\nstruct s {\n    char a;\n    short b;\n    int c;\n    double d;\n    char* e;\n    char f[];\n    double i;\n};\nstruct s temp;\n\nchar *p = NULL;\n\nint main(void)\n{\n\tprintf(\"char:%d,short:%d,int:%d,double:%d\\n\\n\",sizeof(char),sizeof(short),sizeof(int),sizeof(double));\n\tprintf(\"sizeof = %d\\n\",sizeof(char *));\n\tprintf(\"sizeof = %d\\n\\n\",sizeof(temp));\n\t\n\tprintf(\"temp addr = %p\\n\",&temp);\n\tprintf(\"a    addr = %p,%2d\\n\",&temp.a,sizeof(temp.a));\n\tprintf(\"b    addr = %p,%2d\\n\",&temp.b,sizeof(temp.b));\n\tprintf(\"c    addr = %p,%2d\\n\",&temp.c,sizeof(temp.c));\n\tprintf(\"d    addr = %p,%2d\\n\",&temp.d,sizeof(temp.d));\n\tprintf(\"e    addr = %p,%2d\\n\",&temp.e,sizeof(temp.e));\n\tprintf(\"\\nf    addr = %p\\n\",&temp.f);\n//\tprintf(\"f    sizeof = %d\\n\",sizeof(temp.f));\n\t\n\tprintf(\"\\ni addr = %p,%d\\n\",&temp.i,sizeof(temp.i));\n\n\t\n\treturn 0;\n}\n```\n\n这下编译直接报错： [Error] flexible array member not at end of struct，因为成员数组 `f` 并不知道他的大小。","tags":["history","C"]},{"title":"对 C 指针的理解","url":"/c-pointer/","content":"\n\n\n\n> 前排声明一下，本篇是在学习 typedef 高级应用的时候发现对于指针的应用有很多不熟，然后查看了好多资料（参考链接在后面），于是又重新复习了一遍，并把它以自己通俗的语言整理出来，可能会有炒鸡多的不对，内容多来自书本和网络，希望各方大佬进行指正；同样的，在看这篇文章之前，不可全信，请务必持怀疑的态度去思考（我也不敢打保单一定是正确的，毕竟我也在学习中）\n\n\n\n指针这东西，讨人喜爱的同时也惹人烦恼，反正对我而言，谈起指针就脑壳疼，所以别在我面前谈它，不然出来打一架；哈哈哈，开玩笑的\n\n\n\n# 什么是指针？\n\n首先你要明白什么是指针，指针是**一个值为内存地址的变量（或数据对象）**，即，内存位置的直接地址；记住：**指针变量的值并不是它所指向的内存位置所存储的值** 。\n\n\n\n# 指针是用来干什么的？\n\n那么指针是用来干嘛的？简单的说，指针是用来操作内存的，因为内存中的每个位置都是由一个独一无二的地址标识，并且内存的每个位置都包含一个值，所以，我们常说的“谁谁谁指向xxx”，其实就是通过它的地址来找到所需的变量单元（也就是内存）然后再对它进行操作，注意，这个地址它不是固定的，它是由计算机随机安排的。\n\n\n\n# 指针变量的声明\n\n```\ntype * var-name;\n```\n\n在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型（就是 int、char 那些），**var-name** 是指针变量的名称。用来声明指针的星号 ***** 与乘法中使用的星号是相同的（符号一样）。但是，**在这个语句中，星号是用来指定一个变量是指针** 。\n\n例如：\n\n```cpp\nint *ip; /* 一个整型的指针（int *） */\n\ndouble *dp; /* 一个 double 型的指针（double *） */\n\nfloat *fp; /* 一个浮点型的指针（float *） */\n\nchar *ch; /* 一个字符型的指针（char *） */\n\n……\n```\n\n在声明一个指针变量，计算机并不会自动分配用来存储指针所指向的数据的内存，其缺省值是随机的，所以我们必须对指针进行初始化，否则可能会带来严重的危害。\n\n\n\n## 四、指针的初始化及赋值\n\n在进行初始化之前，首先我们需要了解 `&` 、 `*` 这两个与指针相关的运算符，在 C 中，可以**通过 &运算符访问地址，通过 \\*运算符获得地址上的值** 。\n\n在写程序过程中，为每个指针变量初始化赋值是个良好的习惯，会有效的防止指针指向未知的内存（也是野指针的一种）；对指针进行初始化，要让它：①指向现有的内存、②配置成 NULL指针、③或者给它分配动态内存\n\n示例：\n\n1、/* 指向现有内存 */\n\n```cpp\nint q = 25;\n\nint *ptr = &q;    // 定义一个指针变量名为 ptr，并且 *ptr是 int类型的；同时，把 q的地址赋给 ptr（就是我们常说的：把 ptr指向 q）\n```\n\n\n\n2、/* NULL空指针 */\n\n```cpp\nint *ptr = NULL;\n```\n\n\n\n3、/* 分配所需的动态内存空间 */\n\n```cpp\nint *ptr = (int *)calloc(n, sizeof(int));  // 在空闲内存池中分配连续内存n * sizeof(int)个字节的堆内存空间，并自动将这一块的内存之初始化为0；\n\n/* 注意区分 ‘malloc’‘calloc’;若是用malloc函数，则一般还要调用memset函数对内存进行初始化，\n因为memset函数只是向计算机申请了一块内存空间，并没有对这些内存的值进行初始化，虽然说不调\n用 memset这个函数初始化也能通过编译，但是分配内存的值为一些垃圾数值，而且后面也有可能出错，\n所以啊，用到指针就得给它初始化，否则别用，不然得不偿失 */\n\nint *ptr = (int *)calloc(n*sizeof(int));\n\nmemset(ptr, 0, n*sizeof(int));\n```\n\n\n\n另外，稍微拓展一下：对于我们常见的利用 malloc 函数来为指针申请一段空间来存储数据，那么什么时候需要为指针申请空间，什么时候不需要呢？\n\n要知道，C 库函数 `void *malloc(size_t size)` 是用来分配所需的内存空间，并返回一个指向它的指针；**如果定义指针的时候，指针指向一个有空间的数据，这时就不需要分配空间；如果要给指针赋值，则需要分配内存空间** 。\n\n\n\n# 指针和数组\n\n数组表示法其实是在变相地使用指针，**数组名是数组首元素的地址** 。\n\n举个栗子：\n\n```cpp\n/* 我们定义一个数组，把它初始化一下 */\n\nint array[3] = {0};\n\n/* 那么下面的语句是成立的 */\n\n// array == &array[0];\n\n// 你可以测试输出看一下它们的地址，你会发现是一样的\n\nint *temp = array;       // 把数组的地址赋给指针\n\nprintf(\"array = %x\\n\", temp);\n\nprintf(\"array[0] = %x\\n\", &array[0]);\n```\n\n但是，**指针和数组并不是相等的**，虽然数组也可以像指针那样进行间接访问，但还是有很大差别的：\n\n==声明一个数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整形值分配内存空间；而且，指针变量并未被初始化为指向任何现有的内存空间，如果它是一个自动变量，他甚至根本不会被初始化。==\n\n\n\n同样的\n\n```cpp\ntemp + 2 == &array[2];      // 相同的地址\n\n*(temp + 2) == array[2];  // 相同的值\n```\n\n顺带一提，不要混淆 `*(temp + 2)` 和 `*temp + 2` ；间接运算符 `*` 的优先级是高于 `+` 的,所以 `*temp + 2` 相当于 `(*temp)+ 2` 。\n\n```cpp\n*(temp + 2)       // temp第 3个元素的值\n\n*temp + 2         // temp第 1个元素的值加 2\n```\n\n\n\n# 指针与 const\n\n我们知道 const 关键字是用来声明常量的，用于限定一个变量为只读，所以在指针中，由于指针的特殊，有多种情况，这是因为要区分是限定指针本身为 const 还是限定指针指向的值为 const；在指针中，const 常见的用法是声明为函数形参的指针。\n\n在分析之前，我们先来复习一下：\n\n```cpp\nint *pi;   // pi是一个普通的指向整形的指针\n```\n\n然后，下面我们在此基础上，让指针跟 const关键字结合来分析。\n\n\n\n1、指向整形常量的指针 `(int const *pci / const int *pci)`\n\n```cpp\n// 注意其实const int *p跟 int const *p效果一样的\n\nvoid fun1( int const *p )\n{\n    int temp = 3;\n   \n    p = &temp;        // 正确\n    *p = 8;           // 错误\n}\n```\n\n在这种情况下，它的特点就是：**你可以修改指针的值，但你不能修改它所指向的值** 。\n\n\n\n2、指向整形的常量指针 `(int *const cpi)`\n\n```cpp\nvoid fun2( int *const p )\n{\n    int temp = 3;\n   \n    p = &temp;        // 错误\n    *p = 8;           // 正确\n}\n```\n\n而现在这种情况：**此时指针是常量，它的值无法修改，但你可以修改它所指向的整形的值** 。\n\n然后，用个例子验证一下\n\n```cpp\n#include<stdio.h>\n\n\nint temp = 3;\n\nvoid fun1( int const *p )\n{\n    p = &temp;\n//  *p = 8;           // 错误，编译器警报\n\n    printf(\"fun1 -> p = %x\\n\", p);\n    printf(\"fun1 -> *p = %d\\n\", *p);  \n}\n\n\nvoid fun2( int *const p )\n{\n//  p = &temp;        // 错误，编译器警报\n    *p = 8;\n\n    printf(\"fun2 -> p = %x\\n\", p);\n    printf(\"fun2 -> *p = %d\\n\", *p);  \n}\n\n\nint main(void)\n{\n    int value = 11;\n\n    printf(\"&temp = %x\\n\", &temp);\n    printf(\"&value = %x\\n\\n\", &value);\n\n    fun1(&value);\n\n    printf(\"value1 = %d\\n\", value);\n    printf(\"value1 = %x\\n\\n\", &value);\n\n    value = 11;\n    fun2(&value);\n\n    printf(\"value2 = %d\\n\", value);\n    printf(\"value2 = %x\\n\", &value);\n\n    return 0;\n}\n```\n\n\n\n**note：** 既然，在指针和形参声明中使用 const 有以上这两种情况，那么怎么区分呢？\n\n其实细心点可以发现，const 放在 `*` 左侧任意位置，限定了指针指向的数据不能改变；const放在 `*` 的右侧，限定了指针本身不能改变。\n\n\n\n3、指向整形常量的常量指针 `(int const *const cpci)`\n\n根据上面的，我们会想，在指针上能不能同时加 const 呢？可以，这就是第三种：指向整形常量的常量指针。\n\n在这里，**无论是指针本身还是它所指向的值都是常量，都不允许修改** 。\n\n\n\n你可能会问，上面的第一、二种不是常说的 “常量指针” 和 “指针常量” 吗？或许你说的是对的，但对于我目前找到的参考文献中，并没有找到对应出现的这两个词；正如文章开头所说的，请务必持怀疑的态度去思考，所以，我并不打算把上面的两个分点写上 “常量指针” 和 “指针常量”，毕竟，也有可能是大部分人为了叫的好听一点或者区分这个关系而命名的，但相对的，我想如果你理解了上面分点的那两个的特点及应用，比记 “常量指针” 和 “指针常量” 更好理解吧\n\n\n\n# 指向指针的指针\n\n`int **p;` --- 我们从右往左看，首先从 p 开始，先与 `*` 结合, 说明 p 是一个指针 `*p` ，然后再与 `*` 结合 `**p` ，说明指针所指向的元素是指针；然后再与 int 结合，说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中，所以在这里最多只考虑一级指针。\n\n例子：\n\n```cpp\nint a = 12;\n\nint *n = &a;\n\nint **p = &n;\n```\n\n然后，我们来分析一下\n\n| 表达式 |      与之相对应的表达式      |\n| :----: | :--------------------------: |\n|   a    |           == `12`            |\n|   n    |           == `&a`            |\n|   *n   |       == `a` or ==`12`       |\n|   P    |           == `&n`            |\n|   *p   |      == `n` or == `&a`       |\n|  **p   | == `*n` or == `a` or == `12` |\n\n\n\n# 指针与结构体\n\n先来放一个例子：\n\n```cpp\n#include<stdio.h>\n\n\n#define SIZE  10\n\ntypedef struct\n{\n    char name[20];\n    int num;\n    float score;\n}Student_TypeDef;\n\nStudent_TypeDef stu = {\"Tom\", 13, 136.5};                  \n\nStudent_TypeDef *pstu = &stu;\n\nint main(void)\n{\n    // 读取结构体成员的值\n    printf(\"%s的学号是%d，成绩是%.1f！\\n\", (*pstu).name, (*pstu).num, (*pstu).score);\n    printf(\"%s的学号是%d，成绩是%.1f！\\n\", pstu->name, pstu->num, pstu->score);  \n\n    return 0;\n}\n```\n\n输出都是：\n\n```\nTom的学号是13，成绩是136.5！\n```\n\n\n\n先来认识一下结构成员的访问：\n\n直接访问：结构变量的成员是通过点操作符 `.` 访问的\n\n间接访问：利用操作符 `->` （也称箭头操作符）通过结构体指针直接取得结构体成员\n\n值得注意的是：通过结构体指针获取结构体成员，一般形式为：\n\n`(*pointer).memberName`\n\n或者：\n\n`pointer->memberName`\n\n第一种写法中，`.` 的优先级高于 `*`， `(*pointer)` 两边的括号不能少。如果去掉括号写作 `*pointer.memberName` ，那么就等效于 `*( pointer.memberName)` ，这样意义就完全不对了。\n\n\n\n然后我们结合上面的例子来分析一下，为什么在操作结构体指针的时候，这两种输出的情况是一样的\n\n首先，==①== `pstu = &stu;` 指针 pstu 指向了定义为 Student_TypeDef 类型的结构体，这个结构变量名为 stu；和数组不同的是，结构变量名并不是结构的地址；数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，因此得在结构变量名前加上 `&` 运算符。==②== `pointer->memberName` 输出结构先来分析使用 `->` 运算符的，也是最常用的方法；按照上面的，如果 `pstu == &stu` ，那么 `pstu->num` 即是 `stu.num` ；这里 **pstu 是一个指针**，但是 `pstu->num` 是该指针所指向结构的一个成员，所以 `pstu->num` 是一个 int 类型的变量，至于为什么不能写成 `pstu.num` ，因为 **pstu不是结构体**。==③== `(*pointer).memberName` 是等价于 `pointer->memberName` 的，如果 `pstu == &stu` ，那么 `*pstu == stu` ，因为我们从上面学习到 `&` 和 `*` 是一对互逆运算符；因此就有了这样的替代： `stu.num == (*pstu).num` 。\n\n\n\n# 函数和指针\n\n1、返回指针的函数\n\n`int *pf(void)` ：首先执行的是函数调用操作符 () ，因为它的优先级高于间接访问操作符；因此，`pf` 是一个函数，它的返回值是一个指向整形的指针。\n\n\n\n2、指向函数的指针（函数指针）\n\n`int (*pf)(void)` ：这个声明有两对括号，每对的含义各不相同。第二对括号是函数调用操作符，但第一对括号只起聚组的作用；它迫使间接访问在函数调用之前进行，使 pf成为一个函数指针，它所指向的函数返回一个整形值 **（你也可以这样理解： `int pam(void)` 是我们常见的函数声明，它声明了 `pam` 是一个返回整形的函数；如果我们将 `pam` 替换为 `*pf` ，由于 `pam` 是函数，因此 `*pf` 也是函数；而如果 `*pf` 是函数，则 `pf` 就成为指向该类型的指针，也就是函数指针）** 。\n\n\n\n我们知道在声明一个数据指针时，必须声明指针所指向的数据类型。而声明一个函数指针时，必须声明指针指向的函数类型；为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。在声明了函数指针后，可以把类型匹配的函数地址赋给它。\n\n下面来个例子熟悉一遍：\n\n```cpp\n#include<stdio.h>\n#include<stdlib.h>\n\n\n#define NUM1  76\n#define NUM2  83\n\n\nint max( char x, char y )\n{\n    return (x>y ? x:y);\n}\n\n\nint min( char x, char y )\n{\n    return (x<y ? x:y);\n}\n\n\ndouble product( int x, int y)\n\n{\n    return (x * y);\n}\n\n\nchar *pam( char *ptf)       // 返回指针的函数\n\n{\n    return ptf;\n}\n\n\nint main(void)\n{\n    char temp[] = \"hello, world!\";\n\n    char *p = (char *)calloc(sizeof(temp), sizeof(temp[0]));    // 申请空间\n\n    int (*pf)( char a, char b );    // 指向函数的指针\n\n    p = pam(temp); \n\n    printf(\"%s\\n\", p);\n\n//  pf = product;     // 错误，编译器警报；product与指针类型不匹配\n\n    pf = max;\n    printf(\"max = %d\\n\", (*pf)(NUM1, NUM2));\n\n    pf = min;\n    printf(\"min = %d\\n\", pf(NUM1, NUM2));       \n\n    return 0;\n}\n```\n\n从上面可以看到 `(*pf)()` 和 `pf()` ，两种其中一种都可以；先来看第一种：由于 `pf` 指向 `max()` 函数，那么 `*pf` 就相当于 `max()` 函数，表达式 `(*pf)()` 和 `max()` 相同；第二种：由于函数名是指针，那么指针和函数名可以互换使用。但是我们一般都是使用第一种，也就是 `(*pf)()` ，因为它明确指出是通过指针而非函数名来调用函数的，这样我们才好区分函数指针，如果我们用第二种，则看上去和函数调用无异。\n\n\n\n# 参考\n\n*《C Primer Plus》*\n\n*《C++ Primer Plus》*\n\n*《C和指针》*\n\n[C 指针详解](https://www.runoob.com/w3cnote/c-pointer-detail.html)\n\n[C语言指针的初始化和赋值](https://blog.csdn.net/mhjcumt/article/details/7351032)\n\n[内存分配函数malloc 与 calloc的用法及区别](https://blog.csdn.net/linpengbin/article/details/43243549)\n\n[malloc和calloc的区别](https://blog.csdn.net/missuever/article/details/540045)\n\n[C中指针变量何时需要初始化malloc](https://zhidao.baidu.com/question/261858227.html?sort=11&rn=5&pn=0#wgt-answers)\n\n[【C++基础之二】常量指针和指针常量](https://blog.csdn.net/jackystudio/article/details/11519817)\n\n[C语言结构体和指针](http://c.biancheng.net/cpp/html/94.html)\n\n[指针函数与函数指针（C语言）](https://www.jianshu.com/p/20e7c3568a12)","tags":["history","C"]},{"title":"常用逻辑电平标准总结","url":"/logical-level/","content":"\n\n\n\n> TTL、RS-232、RS422、RS-485 是指的电平标准（电信号），很多人把 RS-232、RS-422、RS-485 误称为通讯协议，这是很不应该的，其实它们仅是关于 UART 通讯的一个机械和电气接口标准（顶多是网络协议中的物理层面）；也就是说对 MCU 等控制器编写了 UART 程序，串行数据会通过硬件电路在设备间进行收发，这个硬件电路要遵循一个电平标准，实现设备间的交互。\n\n\n\n# 前言\n\n要了解逻辑电平的内容，首先要知道以下几个概念的含义：\n\n 1. 输入高电平（VIH）：保证逻辑门的输入为高电平时所允许的最小输入高电平，当输入电平高于 VIH 时，则认为输入电平为高电平。\n 2. 输入低电平（VIL）：保证逻辑门的输入为低电平时所允许的最大输入低电平，当输入电平低于 VIL 时，则认为输入电平为低电平。\n 3. 输出高电平（VOH）：保证逻辑门的输出为高电平时的输出电平的最小值，逻辑门的输出为高电平时的电平值都必须大于此 VOH。\n 4. 输出低电平（VOL）：保证逻辑门的输出为低电平时的输出电平的最大值，逻辑门的输出为低电平时的电平值都必须小于此 VOL。\n 5. 阈值电平（VT）：数字电路芯片都存在一个阈值电平，就是电路刚刚勉强能翻转动作时的电平。它是一个界于 VIL、VIH 之间的电压值，对于 CMOS 电路的阈值电平，基本上是二分之一的电源电压值，但要保证稳定的输出，则必须要求输入高电平 > VIH，输入低电平 < VIL。 对于一般的逻辑电平，VIH，VIL，VOH，VOL 以及 VT 的关系可表示如下： VOH > VIH > VT > VIL > VOL。\n 6. IOH：逻辑门输出为高电平时的负载电流（为拉电流）。\n 7. IOL：逻辑门输出为低电平时的负载电流（为灌电流）。\n 8. IIL：逻辑门输入为高电平时的电流（为灌电流）。\n 9. IIL：逻辑门输入为低电平时的电流（为拉电流）。\n\n /------------------------------------------ 我是分割线  ------------------------------------------/\n\n==串口==：串口是一个泛称，UART、TTL、RS232、RS485 都遵循类似的通信时序协议，因此都被通称为串口。\n\n==UART接口==：通用异步收发器（Universal Asynchronous Receiver/Transmitter)，UART 是串口收发的逻辑电路，这部分可以独立成芯片，也可以作为模块嵌入到其他芯片里，单片机、SOC、PC 里都会有 UART 模块。\n\n==COM口==：特指台式计算机或一些电子设备上的 D-SUB 外形（一种连接器结构，VGA 接口的连接器也是 D-SUB）的串行通信口，应用了串口通信时序和 RS232 的逻辑电平。\n\n==USB口==：通用串行总线，和串口完全是两个概念。虽然也是串行方式通信，但由于USB的通信时序和信号电平都和串口完全不同，因此和串口没有任何关系。USB 是高速的通信接口，用于 PC 连接各种外设，U盘、键鼠、移动硬盘、当然也包括 “USB 转串口” 的模块。（USB 转串口模块，就是 USB 接口的 UART 模块）\n\n\n\n# TTL电平标准\n\n**1、TTL**\n\nTTL：Transistor-Transistor Logic 三极管结构。TTL 电平规定，+5V 等价于逻辑 '1'，0V 等价于逻辑 '0'。这样的数据通信及电平规定方式，被称做 TTL（晶体管-晶体管逻辑电平）信号系统。\n\n==Vcc：5V；VOH >= 2.4V；VOL <= 0.5V；VIH >= 2V；VIL <= 0.8V。==\n\n**2、LVTTL**\n\nLVTTL：Low Voltage TTL。\n\n3.3V LVTTL：==Vcc：3.3V；VOH >= 2.4V；VOL <= 0.4V；VIH >= 2V；VIL <= 0.8V。== \n\n2.5V LVTTL：Vcc：2.5V；VOH >= 2.0V；VOL <= 0.2V；VIH >= 1.7V；VIL <= 0.7V。\n\n**3、注意事项**\n\nTTL电平一般过冲都会比较严重，可以在始端串 22 欧或 33 欧电阻； TTL 电平输入脚悬空时是内部认为是高电平。要下拉的话应用 1k 以下电阻下拉。TTL 输出不能驱动 CMOS 输入。\n\n**4、‘0’ 和 ‘1’ 表示**\n\n![在这里插入图片描述](20190827203036406.png)\n\n\n\n# RS-232电平标准\n\n**1、RS-232**\n\nRS-232：是美国电子工业协会 EIA（Electronic Industry Association）制定的一种串行物理接口标准。RS 是英文 “推荐标准” 的缩写，232 为标识号。RS-232 是对电气特性以及物理特性的规定，只作用于数据的传输通路上，它并不内含对数据的处理方式。\n\nRS-232标准是==逻辑 '1' 为 -3V～-15V，逻辑 '0' 为 +3～+15V。==\n\n**2、拓扑结构**\n\n![在这里插入图片描述](20190827203559913.png)\n**3、‘0’ 和 ‘1’ 表示**\n\n![在这里插入图片描述](2019082720294271.png)\n\n\n\n# RS-485电平标准\n\n**1、RS-485**\n\nRS-485：RS-232 接口可以实现点对点的通信方式，但这种方式不能实现联网功能。于是，为了解决这个问题，一个新的标准 RS-485 产生了。RS-485 的数据信号采用差分传输方式，也称作平衡传输，它使用一对双绞线，将其中一线定义为 A，另一线定义为 B。\n\n通常情况下，==驱动器 AB 端口之间的正电平在 +2～+6V 标识为逻辑 '1'，负电平在 -2～-6V 标识为逻辑 '0'（这里的电平指 AB 两线间的电压差）。==\n\nnote：AB 两端的电压差最小为 0.2V 以上时有效，任何不大于 12V 或者不小于－7V 的差值对接受端都被认为是正确的。\n\n**2、拓扑结构**\n\n![在这里插入图片描述](20190827204107750.jpg)\n\n**3、‘0’和‘1’表示**\n\n![在这里插入图片描述](20190827205158528.png)\n\n\n\n# RS-422电平标准\n\nRS-422 的电气性能与 RS-485 完全一样。主要的区别在于：RS-422 有 4 根信号线：两根发送、两根接收。由于 RS-422 的收与发是分开的所以可以同时收和发（全双工），也正因为全双工要求收发要有单独的信道，所以 RS-422 适用于两个站之间通信，星型网、环网，不可用于总线网；RS-485 只有 2 根信号线，所以只能工作在半双工模式，常用于总线网。\n\n\n\n# RS-232、RS-422 与 RS-485 比较\n\n**RS-232** 在 1962 年发布，命名为 EIA-232-E，作为工业标准，以保证不同 厂家产品之间的兼容。\n\n**RS-422** 由 RS-232 发展而来，它是为弥补 RS-232 之不足而提出的。 为改进 RS-232 通信距离短、速率低的缺点，RS-422 定义了一种平衡通信接口，将传输速率提高到 10Mb/s，传输距离延长到 4000 英尺（速率低于 100kb/s 时），并允许在一条平衡总线上连接最多 10 个接收器。RS-422 是一种单机发送、多机接收的单向、平衡传输规范，被命名为 TIA/EIA-422-A 标准。\n\n为扩展应用范围，EIA 又于 1983 年在 RS-422 基础上制定了 **RS-485** 标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上， 同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为 TIA/EIA-485-A 标准。由于 EIA 提出的建议标准都是以 “RS” 作为前缀，所以在通讯工业领域，仍然习惯将上述标准以 RS 作前缀称谓。\n\n|                         |          RS-232          |           RS-422           |            RS-485            |\n| :---------------------: | :----------------------: | :------------------------: | :--------------------------: |\n|          Cable          |       Single ended       |  Single ended multi-drop   |          Multi-drop          |\n|    Number of Devices    | 1 transmitter 1 receiver | 1 transmitter 10 receivers | 32 transmitters 32 receivers |\n|   Communication Mode    |       Full duplex        |  Full duplex, Half duplex  |   Full duplex, Half duplex   |\n|    Maximum Distance     |   50 feet at 19.2 kbps   |   4000 feet at 100 kbps    |    4000 feet at 100 kbps     |\n| Max Data Rate (50 feet) |          1 mbps          |          10 mbps           |           10 mbps            |\n\nRS232：3线制、全双工、点对点通讯（因点对点通讯方式而无法联网，导致出现RS485）\n\nRS422：4线制、全双工、点对多主从通讯（实际上还有一根信号地线，共 5根线）\n\nRS485：2线式、半双工、点对多主从通讯（4线制因只能点对点已经淘汰）\n\n\n\n# CAN总线\n\n**1、CAN**\n\n控制器局域网总线（CAN，Controller Area Network）是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。\n\n==逻辑 '1' ：-1.5V -- 0V ，逻辑 '0' ：+1.5V -- +3V==（这里的电平指 CAN_High、CAN_Low 两线间的电压差。）\n\n**2、拓扑结构**\n\n![在这里插入图片描述](20190827210438778.jpg)\n\n**3、‘0’ 和 ‘1’ 表示**\n\n![在这里插入图片描述](20190827210654200.png)\n\n![在这里插入图片描述](20190827210510722.jpg)\n\n\n\n# CMOS电平标准\n\n**1、CMOS**\n\nCMOS：Complementary Metal Oxide Semiconductor。\n\n==Vcc：5V；VOH >= 4.45V；VOL <= 0.5V；VIH >= 3.5V；VIL <= 1.5V。==\n\n相对 TTL 有了更大的噪声容限，输入阻抗远大于 TTL 输入阻抗。\n\n**2、LVCMOS**\n\nLVCMOS：Low Voltage Complementary Metal Oxide Semiconductor。\n\n==3.3V LVCMOS： Vcc：3.3V；VOH >= 3.2V；VOL <= 0.1V；VIH >= 2.0V；VIL<=0.7V。==\n\n2.5V LVCMOS： Vcc：2.5V；VOH >= 2V；VOL <= 0.1V；VIH >= 1.7V；VIL <= 0.7V。 \n\n**3、注意事项**\n\nLVCMOS 可以与 3.3V 的 LVTTL 直接相互驱动。\n\nCMOS 电路不使用的输入端不能悬空。\n\n\n\n# ECL电平标准\n\n**1、ECL**\n\nECL：Emitter Coupled Logic 发射极耦合逻辑电路（差分结构）。\n\nVcc：0V；Vee：-5.2V；VOH = -0.88V；VOL = -1.72V；VIH = -1.24V；VIL = -1.36V。 \n\n**2、PECL**\n\nPECL：Pseudo / Positive ECL。\n\nVcc：5V；VOH = 4.12V；VOL = 3.28V；VIH = 3.78V；VIL = 3.64V 。\n\n**3、LVPECL**\n\nLVPECL：Low Voltage PECL。\n\nVcc：3.3V；VOH = 2.42V；VOL = 1.58V；VIH = 2.06V；VIL = 1.94V。\n\n**4、注意事项**\n\n射随输出结构，必须有电阻拉到一个直流偏置电压；由于 ECL 需要负电源，为简化电源产生了PECL 和 LVPECL。\n\nECL：速度快，驱动能力强，噪声小，功耗大，很容易达到几百 M 的应用，需要负电源。\n\n\n\n# LVDS电平标准\n\n**1、产生原因**\n\n前面的电平标准摆幅都比较大，为降低电磁辐射，同时提高开关速度又推出 LVDS 电平标准。\n\n**2、LVDS**\n\nLVDS：Low Voltage Differential Signaling。LVDS 物理接口使用 1.2V 偏置电压作为基准，提供大约 400mV 摆幅。\n\nLVDS 信号传输一般由三部分组成：差分信号发送器，差分信号互联器，差分信号接收 器。\n\n**3、注意事项**\n\nPCB要求较高，差分线要求严格等长，差最好不超过 10mil（0.25mm）。\n\n\n\n# GTL电平标准\n\n**1、GTL**\n\n类似 CMOS 的一种结构，输入为比较器结构，比较器一端接参考电平，另一端接输入信号。1.2V 电源供电。 \n\nVcc：1.2V；VOH >= 1.1V；VOL <= 0.4V；VIH >= 0.85V；VIL <= 0.75V 。\n\n**2、PGTL / GTL+**\n\nVcc：1.5V；VOH >= 1.4V；VOL <= 0.46V；VIH>=1.2V；VIL <= 0.8V 。\n\n\n\n# HSTL电平标准\n\nHSTL 是主要用于 QDR 存储器的一种电平标准：一般有 VCCIO = 1.8V 和 VCCIO = 1.5V。\n\n和上面的 GTL 相似，输入为输入为比较器结构，比较器一端接参考电平（VCCIO / 2），另一端接输入信号。对参考电平要求比较高（1%精度）。 \n\n\n\n# SSTL电平标准\n\nSSTL 主要用于 DDR 存储器。和 HSTL 基本相同。VCCIO = 2.5V，输入为输入为比较器结构，比较器一端接参考电平 1.25 V，另一端接输入信号。对参考电平要求比较高（1%精度）。","tags":["history"]},{"title":"DMX512 协议","url":"/dmx512-protocol/","content":"\n\n\n\n>  DMX512（digital multiplex）\n>\n> 其实就是主机向从机整包单向广播发送的协议（protocol），从机自取所需。\n>\n> DMX512 数据协议是美国舞台灯光协会（USITT）于 1990 年发布的一种灯光控制器与灯具设备进行数据传输的标准。它包括电气特性，数据协议，数据格式等方面的内容。\n>  512 协议规定使用的波特率是 250Kbps\n\n\n\n# 链接拓扑（network topology）\n\n根据后面的协议可以知道，其实就是将所有的 slave 挂到线上去。（线最长可以多长？）\n\n![img](20190805215926835.png)\n\n\n\n# 协议（protocol）时序\n\n1） 先说明地址，包的格式是固定的，第一个数据帧就是地址 1（说是 0 也可以），接下来的数据帧，地址逐渐 + 1。\n\n2） 1 slot 或者叫 1 data frame（数据帧）= 1 start bit（低电平） + 8 data bits + 2 stop bits（高电平） = 11bits， 1bit = 4us，1slot = 44us。（下图右下角的蓝色字体部分）\n\n3） 1 packet （数据包）= 1 Break + 1 MAB（mark after break） + 1 SC（start code） + 512 slots + 1 MTBP（mark time between packets） （下图红色字体部分）\n\n- 1 break 典型值 88us\n- MAB 典型值 8us\n- SC 就是一帧 44us，第 0 帧\n- MTBP，高电平有效，0 - 1s 之间\n\ntime = 88us + 8us + 44us + 512 * 44us + 0 = 22668us = 22.668ms 发包频率44.11Hz，也就是控制频率了，如果地址用不完，把 slot 减少，时间也可以节省，然后频率可以更高了。(调光控制台每发送一个信息包，可以对全部 512 个受控通道形成一次全面的控制。发送一个信息包的时间大约是23 ms，每秒钟将对所有 512 个受控通道完成 44 次控制，即受控光路的刷新频率 44 Hz，如果实际受控通道少于 512 个，那么刷新频率将相应提高。)\n\n![img](20190805220038760.png)\n\n每个 slot 对应右下角放大的每帧时序：\n\n![img](20190805220057706.png)\n\n1. START BIT 为开始位，宽度为一个比特，是受控灯具准备接收并解码控制数据的开始标志。\n\n2. STOP BITS为结束位，宽度为两个比特，表示一个指令帧的结束。\n\n3. D0～ D7为8 位控制数据，其电平组合从 00000000 ~ 11111111 共有 256 个状态（对应十进制数的 0～255），控制灯光的亮度时，可产生 256 个亮度等级，00000000 (0) 对应灯光最暗，11111111 (255) 对应灯光最亮。\n\n4. 无校验位。\n\n5. DMX512 指令的位宽（每比特宽度）是 4 us，每一个指令帧 11 位，故指令帧宽度为 44 us，传输速率为 1 / 44us = 250 kbps。\n\n\n\n**note：** 一个完整的 DMX512 信息包（Packet）由一个 Break 位、一个 MAB 位、一个 SC 、512 个数据帧和一个 MTBP 位构成。\n\n1. Break为中断位，对应一个信息包结束后的程序复位阶段，宽度不少于两个帧（22 bit，1bit = 4us）。\n2. 程序复位结束后应发送控制数据，但由于每一个数据帧的第一位（即开始位）为低电平，所以必须用一个高电平脉冲间隔前后两个低电平脉冲，这个起间隔、分离作用的高电平脉冲即 MAB（Mark After Break），此脉冲一到，意味着 “新一轮” 的控制又开始了。\n3. SC（Start Code）意为开始代码帧（slot0），和此后到来的数据帧一样，也是由11 位构成，除两个高电平的结束位之外，其他 9 位全部是低电平，通常将其叫做第 0 帧或第 0 通道，可理解为一个不存在的通道。\n4. MTBP（Mark TimeBetween Packets）标志着一个完整的信息包发送完毕，是下一个信息包即将开始的 “空闲位”，高电平有效。\n\n\n\n# 时序规格标准\n\n在 DMX512-A 草案中，执行的标准如下：\n\n![image-20230112233937497](image-20230112233937497.png)\n\n- Timing Diagram Values for Transmitter\n\n| Designation |           Description           | Min  | Typical |  Max   |     Unit      |\n| :---------: | :-----------------------------: | :--: | :-----: | :----: | :-----------: |\n|      -      |            Bit Rate             | 245  |   250   |  255   |  kbit / sec   |\n|      -      |            Bit Time             | 3.92 |    4    |  4.08  |      µs       |\n|      -      | Min. Update time for 513 slots  |  -   |  22.7   |   -    |      ms       |\n|      -      | Max. Refresh rate for 513 slots |  -   |   44    |   -    | updates / sec |\n|      1      |         SPACE for BREAK         |  92  |   176   |   -    |      µs       |\n|      2      |     MARK after BREAK (MAB)      |  12  |    -    | < 10^6 |      µs       |\n|      9      |     MARK Time between slots     |  0   |    -    | < 1.00 |       s       |\n|     10      |     MARK before BREAK (MBB)     |  0   |    -    | < 1.00 |       s       |\n|     11      |       BREAK to BREAK time       | 1204 |    -    |  10^6  |      µs       |\n|     13      |          DMX512 Packet          | 1204 |    -    |  10^6  |      µs       |\n\n- Timing Diagram Values for Receivers\n\n| Designation |           Description           | Min  | Typical |     Max     |     Unit      |\n| :---------: | :-----------------------------: | :--: | :-----: | :---------: | :-----------: |\n|      -      |            Bit Rate             | 245  |   250   |     255     |  kbit / sec   |\n|      -      |            Bit Time             | 3.92 |    4    |    4.08     |      µs       |\n|      -      | Min. Update time for 513 slots  |  -   |  22.7   |      -      |      ms       |\n|      -      | Max. Refresh rate for 513 slots |  -   |   44    |      -      | updates / sec |\n|      1      |         SPACE for BREAK         |  88  |   176   |      -      |      µs       |\n|      2      |     MARK after BREAK (MAB)      |  8   |    -    |   < 10^6    |      µs       |\n|      9      |     MARK Time between slots     |  0   |    -    |   < 1.00    |       s       |\n|     10      |     MARK before BREAK (MBB)     |  0   |    -    |   < 1.00    |       s       |\n|     11      |       BREAK to BREAK time       | 1196 |    -    | 1.25 * 10^6 |      µs       |\n|     13      |          DMX512 Packet          | 1204 |    -    | 1.26 * 10^6 |      µs       |\n\n\n\n# 通道控制\n\n目前由于灯光种类的多样性，不再是只用单通道控制一款灯亮度这么简单了；像摇头灯、彩色灯等灯光设备，需占几个或几十个控制通道；每个通道对应不同的功能，该功能根据灯厂资料提供，如下所例：\n\n![img](_______1.png)\n\nhttps://www.abolight.com/prod/sort2/s6.php\n\nhttp://www.abolight.com/prod/sort8/lkip-led150c.php\n\n\n\n# 非标程序设计\n\n基于 DMX512 控制协议进行调光控制的灯光系统叫做数字灯光系统。目前，包括摇头灯在内的各种舞台灯、调光控制器、控制台、换色器等各种灯光控制设备，都对 DMX512 协议进行支持，已全面实现调光控制的数字化，并在此基础上，逐渐趋于网络化（ArtNet协议）。那么，根据上面的协议通讯，我们是否可以模拟信号对 DMX512 协议进行非标设计呢？答案是可以的。\n\n\n\n# 参考\n\n《ANSI-ESTA_E1-11_2008R2018.pdf》\n\nhttps://www.erwinrol.com/page/articles/dmx512/\n\nhttps://ww1.microchip.com/downloads/en/Appnotes/01076A.pdf\n\nhttp://picprojects.org.uk/projects/dmx/dmx688/","tags":["history","DMX512"]},{"title":"来学点 Makefile","url":"/makefile-summarize/","content":"\n\n\n**参考链接：**\n\n[跟我一起写Makefile — 跟我一起写Makefile 1.0 文档](https://seisman.github.io/how-to-write-makefile/index.html)\n\n[Makefile简明教程 - FanZheng's blog](https://fanzheng.org/archives/43)\n\nhttps://hacker-yhj.github.io/resources/gun_make.pdf\n\n\n\n> 在使用 gcc编译器开发的时候，会用到 Makefile，那么，就来记录一下 Makefile的学习。\n>\n> 首先呢，先说明一下观看顺序，咳咳，其实就是自己学的时候后面发现这样学更有趣味。\n>\n> **正式入主题：**\n>\n> 1. 先大致看一下上面链接一的内容，先不用深记，只需大概知道有哪些内容，对应在哪个位置就行了，因为后面还要返回去，毕竟大神写的文章细味斟酌，回头品尝又是一番滋味；\n> 2. 链接二的内容可谓是初学者福利啊（至少对于我来说是这样），作者挑了一些常用的内容列举出来，话不多说，结合例子容易理解，然后可以每学一个内容可以回去翻看链接一大神写的内容，相互结合更好学习\n> 3. 链接三是另一个大佬整理出来的 GNU make中文手册\n> 4. 最后，下文是本人觉得有要用到的一些知识的整理\n\n\n\n# Makefile结构说明\n\nMakefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。\n\n1. 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由 Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。\n2. 隐晦规则。由于我们的 make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由 make所支持的。\n3. 变量的定义。在 Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C语言中的宏，当 Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。\n4. 文件指示。其包括了三个部分，一个是在一个 Makefile中引用另一个 Makefile，就像 C语言中的 `include` 一样；另一个是指根据某些情况指定 Makefile中的有效部分，就像 C语言中的预编译 `#if` 一 样；还有就是定义一个多行的命令。\n5. 注释。Makefile中只有行注释，和 UNIX的 Shell脚本一样，其注释是用 `#` 字符，这个就 像 C/ C++中的 `//` 一样。如果你要在你的 Makefile中使用 `#` 字符，可以用反斜杠进行 转义，如：` \\#` 。\n\n\n\n# 文件说明\n\n|          | **WINDOWS** | **LINUX** |\n| :------: | :---------: | :-------: |\n| 目标文件 |    .obj     |    .o     |\n|  静态库  |    .lib     |    .a     |\n|  动态库  |    .dll     |    .so    |\n\n约定俗成，一般开发者使用的 makefile 文件是大写字母开头的 Makefile，使用者使用的是小写的 makefile（*默认的情况下，**make** 命令会在当前目录下按顺序找寻文件名为 **“ GNUmakefile ”** 、 **“ makefile ”** 、 **“ Makefile ”** 的文件，找到了就解析这个文件。在这三个文件名中，最好使用 “ Makefile ” 这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “ GNUmakefile ” ，这个文件是 GNU 的 make 识别的。有另外一些 make 只对全小写的 “ makefile ” 文件名敏感，但是基本上来说，大多数的 make 都支持 **“ makefile ”** 和 **“ Makefile ”** 这两种默认文件名。**我们也可以使用 `make –f filename` 指定所要解释的 Makefile 的文件名***）\n\n\n\n# **make** 的工作方式\n\n\\- 1.读入主 Makefile (主 Makefile中可以引用其他 Makefile)\n\n\\- 2.读入被 include的其他 Makefile\n\n\\- 3.初始化文件中的变量\n\n\\- 4.推导隐晦规则, 并分析所有规则\n\n\\- 5.为所有的目标文件创建依赖关系链\n\n\\- 6.根据依赖关系, 决定哪些目标要重新生成\n\n\\- 7.执行生成命令\n\n\n\n# Makefile 的规则\n\n```text\ntarget ... : prerequisites ...\n\n<tab> command\n\n       ...\n\n       ...\n```\n\n\"目标\" 是必需的，不可省略；\"前置条件\" 和 \"命令\" 都是可选的，但是两者之中必须至少存在一个。\n\n\n\n**Target（目标）**\n\n可以是一个 object file（目标文件），也可以是一个执行文件，还可以是一个标签（label），指明 make命令所要构建的对象。目标（target）后面必须有冒号 `:`\n\n**Prerequisites（前置条件）**\n\n生成该 target所依赖的文件和 / 或 target。前置条件通常是一组文件名，之间用空格分隔。它指定了“目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 late-modification时间戳比目标的时间戳新），“目标”就需要重新构建\n\n**Command（命令）**\n\n该 target要执行的命令（任意的 Shell命令）。表示如何更新目标文件，有一行或多行的 Shell命令组成。它是构建“目标”的具体命令，他是运行结果通常就是生成目标文件。每行命令行必须以 tap键作为开头\n\n注意：\n\n- 必须讲明， **Makefile 的命令是要调用 shell 来运行的** ，而到底是使用的哪个 shell 取决于 Makefile中 SHELL 变量的设置，默认为 `/bin/sh` 就是 bash。\n- **在 Makefile 中使用 bash 的变量。** Makefile中使用 `$()` 引用的是 Makefile 内的变量，如果想使用 bash 环境的变量要使用双美元引用 `$$` ，使用单个 `$` 引用的变量全部被解释为 Makefile 的变量。以此类推，如果要想试图用 bash 中的进程号码就要使用四个 `$` ，即： `$$$$` 。\n- 另外，值得强调的一点是： **Makefile 是一次发送一行命令，每发送一次命令，就会启动一个 subshell 来运行**。这意味着命令之间不能共享变量，而且 bash 中可以使用的 for 和 while，在这里面也不能换行，因为每行会被单独的发送给 bash 来执行。要解决这个问题，要么使用 Makefile 中的换行符 ` \\ ` ，要么写成单行的形式。\n- 在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以 Tab 键开头的，那么 make 会认为其是一个空命令。\n\n\n\n# `#` 注释符\n\n`#` 字符是注释符，Makefile 把 `#` 字符后面的内容作为注释内容处理（shell、perl 脚本也是使用 `#` 字符作为注释符）。如果某行的第一个非空字符为 `#`，则此行会被 make 解释为注释行（命令行除外，如果 Tab 字符之后使用 `#` 字符，则会被 make 解释为命令行）。\n\n注释行的结尾如果存在反斜线 ` \\ `，那么下一行也被作为注释行。\n\n如果需要注视多行，在注释行的结尾加行反斜线(\\),下一行也被注释，可以注释多行。\n\n**建议在书写 Makefile 时将注释作为一个独立的行，而不要和 Makefile 的有效行放在同一行中书写。make 有时候会把 # 字符之前的内容作为有效行的内容（如定义变量的时候）。**\n\n当在 Makefile 中需要使用字符 # 时，可以使用 ` \\ ` 加 ` # `（` \\# ` ）来实现，表示将 ` # ` 字符作为一个普通字符而不是注释符。\n\n\n\n# GCC常用参数\n\n**-c：** 只编译不链接，仅生成目标文件\n\n**-o：** 指定输出文件名\n\n**-l： ** 手动添加链接库\n\n**-E： ** 生成预处理文件\n\n**-S： ** 生成汇编文件\n\n**-I：** 将系统缺省的头文件路径扩展到当前路径\n\n**-O2：** 表示我们希望编译器在编译的时候对我们的程序进行一定程度的优化。2表示我们优化的级别是 2。范围是 1-3（O/ O2/ O3）。不过习惯上我们都使用 2的优化级别\n\n**-g：** 生成调试信息\n\n**-Wall：** 显示警告信息\n\n\n\n# 基础变量\n\n- `=` 递归展开：变量**只在引用时**才确定它的值，因此这句话在Makefile中的任何位置都没有区别，即使它引用了其他变量，除非对自身多次赋值。需要注意避免循环定义\n- `:=` 直接展开：变量的值在写这句话时就已经确定。若它引用了其他变量，则直接用那个变量当前的值，而不管该变量在此之后值如何变化\n- `?=` 条件赋值：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值，**它是递归展开的**\n- `+=` 追加赋值：给变量追加内容，**但会在追加内容之前添加一个空格**。它是直接展开还是递归展开取决于该变量上一次赋值的方式\n\n\n\n# 自动变量（Automatic Variables）\n\n- `$@` ：**表示规则中的目标文件集**。在模式规则中，如果有多个目标，那么， `$@` 就是匹配于目标中模式定义的集合。\n- `$%` ：仅当目标是函数库文件中，**表示规则中的目标成员名**。例如，如果一个目标是 `foo.a(bar.o)`， 那么， `$%` 就是 `bar.o` ， `$@` 就是 `foo.a` 。如果目标不是函数库文件（Unix下是 `.a` ，Windows下是 `.lib` ），那么，其值为空。\n- `$<` ：**依赖目标中的第一个目标名字**。如果依赖目标是以模式（即 `%` ）定义的，那么 `$<` 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。\n- `$?` ：**所有比目标新的依赖目标的集合**。以空格分隔。\n- `$^` ：**所有的依赖目标的集合**。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。\n- `$+` ：这个变量很像 `$^` ，**也是所有依赖目标的集合；只是它不去除重复的依赖目标**。\n- `$*` ：这个变量表示目标模式中 `%` 及其之前的部分。如果目标是 `dir/a.foo.b` ，并且目标的模式是 `a.%.b` ，那么， `$*` 的值就是 `dir/a.foo` 。这个变量对于构造有关联的 文件名是比较有较。如果目标中没有模式的定义，那么 `$*` 也就不能被推导出，但是，如果目标文件的 后缀是 make 所识别的，那么 `$*` 就是除了后缀的那一部分。例如：如果目标是 `foo.c` ，因为 `.c` 是 make所能识别的后缀名，所以， `$*` 的值就是 `foo` 。**这个特性是 GNU make的， 很有可能不兼容于其它版本的 make**，所以，你应该尽量避免使用 `$*` ，除非是在隐含规则或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么 `$*` 就是空值。\n\n\n\n# 隐晦规则\n\n## 关于命令的变量\n\n- AR : 函数库打包程序。默认命令是 `ar`\n- AS : 汇编语言编译程序。默认命令是 `as`\n- CC : C 语言编译程序。默认命令是 `cc`\n- CXX : C++ 语言编译程序。默认命令是 `g++`\n- CO : 从 RCS 文件中扩展文件程序。默认命令是 `co`\n- CPP : C 程序的预处理器（输出是标准输出设备）。默认命令是 `$(CC) –E`\n- FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 `f77`\n- GET : 从 SCCS文件中扩展文件的程序。默认命令是 `get`\n- LEX : Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是 `lex`\n- PC : Pascal 语言编译程序。默认命令是 `pc`\n- YACC : Yacc 文法分析器（针对于 C 程序）。默认命令是 `yacc`\n- YACCR : Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是 `yacc –r`\n- MAKEINFO : 转换 Texinfo 源文件（`.texi`）到 Info 文件程序。默认命令是 `makeinfo`\n- TEX : 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是 `tex`\n- TEXI2DVI : 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是 `texi2dvi`\n- WEAVE : 转换 Web 到 TeX 的程序。默认命令是 `weave`\n- CWEAVE : 转换 C Web 到 TeX 的程序。默认命令是 `cweave`\n- TANGLE : 转换 Web 到 Pascal 语言的程序。默认命令是 `tangle`\n- CTANGLE : 转换 C Web 到 C。默认命令是 `ctangle`\n- RM : 删除文件命令。默认命令是 `rm –f`\n\n\n\n## 关于命令参数的变量\n\n下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。\n\n- ARFLAGS : 函数库打包程序 AR 命令的参数。默认值是 `rv`\n- ASFLAGS : 汇编语言编译器参数。（当明显地调用 `.s` 或 `.S` 文件时）\n- CFLAGS : C 语言编译器参数。\n- CXXFLAGS : C++ 语言编译器参数。\n- COFLAGS : RCS 命令参数。\n- CPPFLAGS : C 预处理器参数。（ C 和 Fortran 编译器也会用到）。\n- FFLAGS : Fortran 语言编译器参数。\n- GFLAGS : SCCS “get” 程序参数。\n- LDFLAGS : 链接器参数。（如： `ld` ）\n- LFLAGS : Lex 文法分析器参数。\n- PFLAGS : Pascal 语言编译器参数。\n- RFLAGS : Ratfor 程序的 Fortran 编译器参数。\n- YFLAGS : Yacc 文法分析器参数。\n\n\n\n# Make 自动推导\n\n```shell\nfoo.o: foo.c foo.h       # foo模块\ngcc -c foo.c\n\nbar.o: bar.c bar.h \ngcc -c bar.c \n\nmain: main.c foo.h bar.h foo.o bar.o \ngcc main.c -o main foo.o bar.o\n```\n\n该例子的场景是：我们要通过 `main.c` 编译一个叫做 `main` 的程序，它需要使用 `foo.c` 和 `bar.c` 里的函数，同时需要引入相关头文件里的声明。该任务通过 `make main` 来执行。\n\n`foo.o` 是我们的目标，`foo.c` 和 `foo.h` 是目标所依赖的源文件，而只有一个命令 `gcc -c foo.c` （以Tab键开头）；`bar.o` 这个目标同理。这个规则告诉我们两件事：\n\n1. 文件的依赖关系， `foo.o` 依赖于 `foo.c` 和 `foo.h` 的文件，如果 foo.c 和 `foo.h` 的文件日期要比 `foo.o` 文件日期要新，或是 `foo.o` 不存在，那么依赖关系发生。\n2. 生成或更新 `foo.o` 文件，就是那个 gcc 命令。它说明了如何生成 `foo.o` 这个文件。 （当然，`foo.c` 文件 include 了 `foo.h` 文件）\n\n而 `main` 的 “依赖” 中有 `foo.o` 和 `bar.o` ，它们两个必须先被构建。当我们执行 `make main` 时，由于 `foo.o` 和 `bar.o`并不存在，`make ` 程序就会在 Makefile 中寻找这两个 “目标” 的构建方法，构建完成后再进行 `main` 的构建。\n\n\n\n再看一下下面的例子，执行的结果同样跟上面的例子一样\n\n```shell\nfoo.o: foo.h \n\nbar.o: bar.h \n\nmain: main.c foo.h bar.h foo.o bar.o \ngcc main.c -o main foo.o bar.o\n```\n\n通过对比发现， `.o` 文件所依赖的 `.c` 文件省略掉了，同时也把命令省略了，这是为什么呢？\n\nmake 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 `.o` 文件后都写上类似的命令，因为，我们的 make 会自动识别，并自己推导命令。\n\n只要 make 看到一个 `.o` 文件，它就会自动的把 `.c` 文件加在依赖关系中，如果 make 找到一个 `bar.o` ，那么 `bar.c` 就会是 `bar.o` 的依赖文件。并且 `gcc -c bar.c` 也会被推导出来，于是，我们的 Makefile 再也不用写得这么复杂；这样就得到了上面第二个例子。这种方法，也就是 make 的 “ 隐晦规则 ” 。\n\n但在日常使用中，我们为什么要像 `foo.o: foo.c foo.h` 一样将必然存在的文件设置成 “依赖” 呢？**因为 make 存在这样一种机制，如果 “目标” 中的某个 “依赖项” 的修改时间晚于上次 make该 “目标” 的时间，就说明该 “目标” 过时了，需要重新构建。如果你不把影响该 “目标” 的所有必要的 “依赖” 都写上，那当你修改某个文件后，make 就会因为 “目标” 已存在而不再构建。**\n\n因此，`foo.c/foo.h` 或 `bar.c/bar.h` 的修改会导致 `foo.o` 或 `bar.o` 过时而重新构建，从而使得 main 也必须重新构建。\n\n\n\n# Makefile 的伪目标（.PHONY）\n\n(1) 伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。\n\n(2) 伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。\n\n(3) 伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用 `.PHONY` 来明确声明它是伪目标。\n\n典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标, 一般格式如下:\n\n```makefile\n.PHONY: clean   # 这句没有也行, 但是最好加上\n\nclean:\n\n    -rm -f *.o\n```\n\n下面列举一些常用的伪目标, 如果在自己项目的 Makefile 合理使用这些伪目标的话, 可以让我们自己的 Makefile 看起来更专业\n\n| 伪目标       | 含义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| all          | 所有目标的目标，其功能一般是编译所有的目标                   |\n| clean        | 删除所有被 make 创建的文件                                   |\n| install      | 安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去 |\n| print        | 列出改变过的源文件                                           |\n| tar          | 把源程序打包备份，也就是一个 tar 文件                        |\n| dist         | 创建一个压缩文件,一般是把 tar 文件压成 z 文件，或是 gz 文件  |\n| TAGS         | 更新所有的目标，以备完整地重编译使用                         |\n| check或 test | 一般用来测试 Makefile 的流程                                 |\n\n\n\n# 条件语句\n\n```text\n<conditional-directive>\n\n<text-if-true>\n\nelse\n\n<text-if-false>\n\nendif\n```\n\n其中 `<conditional-directive>` 表示条件关键字，这个关键字有四个。条件语句的目的是通过判断来决定 Makefile中的相应位置应该有什么内容\n\n- **第一个条件关键字是 `ifeq` 。语法是：**\n\n```html\nifeq (<arg1>, <arg2>)\n\nifeq '<arg1>' '<arg2>'\n\nifeq \"<arg1>\" \"<arg2>\"\n\nifeq \"<arg1>\" '<arg2>'\n\nifeq '<arg1>' \"<arg2>\"\n```\n\n比较参数 `arg1` 和 `arg2` 的值是否相同，相同为真。\n\n- **第二个条件关键字是 `ifneq` 。语法是：**\n\n```html\nifneq (<arg1>, <arg2>)\n\nifneq '<arg1>' '<arg2>'\n\nifneq \"<arg1>\" \"<arg2>\"\n\nifneq \"<arg1>\" '<arg2>'\n\nifneq '<arg1>' \"<arg2>\"\n```\n\n其比较参数 `arg1` 和 `arg2` 的值是否相同，如果不同，则为真；和 `ifeq` 类似。\n\n- **第三个条件关键字是 `ifdef` 。语法是：**\n\n```html\nifdef <variable-name>\n```\n\n如果变量 `<variable-name>` 的值非空，那到表达式为真。否则，表达式为假。当然，`<variable-name>` 同样可以是一个函数的返回值。注意， `ifdef` 只是测试一个变量 是否有值，其并不会把变量扩展到当前位置。\n\n- **第四个条件关键字是 `ifndef` 。其语法是：**\n\n```html\nifndef <variable-name>\n```\n\n如果变量 `<variable-name>` 的值空，那到表达式为真。否则，表达式为假。，和 `ifdef` 是相反的意思。\n\n\n\n# 字符串处理函数\n\n## subst\n\n```html\n$(subst <from>,<to>,<text>)\n```\n\n- 名称：字符串替换函数\n- 功能：把字串 `<text>` 中的 `<from>` 字符串替换成 `<to>` 。\n- 返回：函数返回被替换过后的字符串。\n- 示例：\n\n```makefile\n$(subst ee,EE,feet on the street)\n```\n\n把 `feet on the street` 中的 `ee` 替换成 `EE` ，返回结果是 `fEEt on the strEEt` 。\n\n## patsubst\n\n```html\n$(patsubst <pattern>,<replacement>,<text>)\n```\n\n- 名称：模式字符串替换函数。\n- 功能：查找 `<text>` 中的单词（单词以 “空格”、“Tab” 或 “回车” “换行” 分隔）是否符合模式 `<pattern>` ，如果匹配的话，则以 `<replacement>` 替换。这里， `<pattern>` 可以 包括通配符 `%`，表示任意长度的字串。如果 `<replacement>` 中也包含 `%` ，那么， `<replacement>` 中的这个 `%` 将是 `<pattern>` 中的那个 `%` 所代表的字串。 （可以用 `\\` 来转义，以 `\\%` 来表示真实含义的 `%` 字符）\n- 返回：函数返回被替换过后的字符串。\n- 示例：\n\n```makefile\n$(patsubst %.c,%.o,x.c.c bar.c)\n```\n\n把字串 `x.c.c bar.c` 符合模式 `%.c` 的单词替换成 `%.o` ，返回结果是 `x.c.o bar.o`\n\n- 备注：这和我们前面 “变量章节” 说过的相关知识有点相似。如 `$(var:<pattern>=<replacement>;)` 相当于 `$(patsubst <pattern>,<replacement>,$(var))` ，而 `$(var: <suffix>=<replacement>)` 则相当于 `$(patsubst %<suffix>,%<replacement>,$(var))` 。\n\n例如有:\n\n```makefile\nobjects = foo.o bar.o baz.o，\n```\n\n那么， `$(objects:.o=.c)` 和 ​`$(patsubst %.o,%.c,$(objects))` 是一样的。\n\n## strip\n\n```html\n$(strip <string>)\n```\n\n- 名称：去空格函数。\n- 功能：去掉 `<string>` 字串中开头和结尾的空字符。\n- 返回：返回被去掉空格的字符串值。\n- 示例：\n\n```makefile\n$(strip a b c )\n```\n\n把字串 `a b c<空格> ` 去掉开头和结尾的空格，结果是 `a b c` 。\n\n## findstring\n\n```html\n$(findstring <find>,<in>)\n```\n\n- 名称：查找字符串函数\n- 功能：在字串 `<in>` 中查找 `<find>` 字串。\n- 返回：如果找到，那么返回 `<find>` ，否则返回空字符串。\n- 示例：\n\n```makefile\n$(findstring a,a b c)\n$(findstring a,b c)\n```\n\n第一个函数返回 `a` 字符串，第二个返回空字符串\n\n## filter\n\n```html\n$(filter <pattern...>,<text>)\n```\n\n- 名称：过滤函数\n- 功能：以 `<pattern>` 模式过滤 `<text>` 字符串中的单词，保留符合模式 `<pattern>` 的单词。可以有多个模式。\n- 返回：返回符合模式 `<pattern>` 的字串。\n- 示例：\n\n```makefile\nsources := foo.c bar.c baz.s ugh.h\nfoo: $(sources)\n    cc $(filter %.c %.s,$(sources)) -o foo\n```\n\n`$(filter %.c %.s,$(sources))` 返回的值是 `foo.c` `bar.c` `baz.s` 。\n\n## filter-out\n\n```html\n$(filter-out <pattern...>,<text>)\n```\n\n- 名称：反过滤函数\n- 功能：以 `<pattern>` 模式过滤 `<text>` 字符串中的单词，去除符合模式 `<pattern>` 的单词。可以有多个模式。\n- 返回：返回不符合模式 `<pattern>` 的字串。\n- 示例：\n\n```makefile\nobjects=main1.o foo.o main2.o bar.o\nmains=main1.o main2.o\n```\n\n`$(filter-out $(mains),$(objects))` 返回值是 `foo.o` `bar.o` 。\n\n## sort\n\n```html\n$(sort <list>)\n```\n\n- 名称：排序函数\n- 功能：给字符串 `<list>` 中的单词排序（升序）。\n- 返回：返回排序后的字符串。\n- 示例： `$(sort foo bar lose)` 返回 `bar foo lose` 。\n- 备注： `sort` 函数会去掉 `<list>` 中相同的单词。\n\n## word\n\n```html\n$(word <n>,<text>)\n```\n\n- 名称：取单词函数\n- 功能：取字符串 `<text>` 中第 `<n>` 个单词。（从一开始）\n- 返回：返回字符串 `<text>` 中第 `<n>` 个单词。如果 `<n>` 比 `<text>` 中的 单词数要大，那么返回空字符串。\n- 示例： `$(word 2,foo bar baz)` 返回值是 `bar` 。\n\n## wordlist\n\n```html\n$(wordlist <ss>,<e>,<text>)\n```\n\n- 名称：取单词串函数\n- 功能：从字符串 `<text>` 中取从 `<ss>` 开始到 `<e>` 的单词串。 `<ss>` 和 `<e>` 是一个数字。\n- 返回：返回字符串 `<text>` 中从 `<ss>` 到 `<e>` 的单词字串。如果 `<ss>` 比 `<text>` 中的单词数要大，那么返回空字符串。如果 `<e>` 大于 `<text>` 的单词数， 那么返回从 `<ss>` 开始，到 `<text>` 结束的单词串。\n- 示例： `$(wordlist 2,3,foo bar baz)` 返回值是 `bar baz` 。\n\n## words\n\n```html\n$(words <text>)\n```\n\n- 名称：单词个数统计函数\n- 功能：统计 `<text>` 中字符串中的单词个数。\n- 返回：返回 `<text>` 中的单词数。\n- 示例： `$(words foo bar baz)` 返回值是 `3` 。\n- 备注：如果我们要取 `<text>` 中最后的一个单词，我们可以这样：`$(word $(words <text>),<text>)` 。\n\n## firstword\n\n```html\n$(firstword <text>)\n```\n\n- 名称：首单词函数——firstword。\n- 功能：取字符串 `<text>` 中的第一个单词。\n- 返回：返回字符串 `<text>` 的第一个单词。\n- 示例： `$(firstword foo bar)` 返回值是 `foo`。\n- 备注：这个函数可以用 word 函数来实现： `$(word 1,<text>)` 。\n\n以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中 应用的例子。我们知道，make 使用 `VPATH` 变量来指定 “依赖文件” 的搜索路径。于是，我们可以 利用这个搜索路径来指定编译器对头文件的搜索路径参数 `CFLAGS` ，如：\n\n```makefile\noverride CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))\n```\n\n如果我们的 `$(VPATH)` 值是 `src:../headers` ，那么 `$(patsubst %,-I%,$(subst :, ,$(VPATH)))` 将返回 `-Isrc -I../headers` ， 这正是 cc 或 gcc 搜索头文件路径的参数。\n\n\n\n# 文件名操作函数\n\n下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。\n\n## dir\n\n```html\n$(dir <names...>)\n```\n\n- 名称：取目录函数 —— dir。\n- 功能：从文件名序列 `<names>` 中取出目录部分。目录部分是指最后一个反斜杠 ` / ` 之前 的部分。如果没有反斜杠，那么返回 `./` 。\n- 返回：返回文件名序列 `<names>` 的目录部分。\n- 示例： `$(dir src/foo.c hacks)` 返回值是 `src/ ./` 。\n\n## notdir\n\n```html\n$(notdir <names...>)\n```\n\n- 名称：取文件函数 —— notdir。\n- 功能：从文件名序列 `<names>` 中取出非目录部分。非目录部分是指最後一个反斜杠 ` / ` 之后的部分。\n- 返回：返回文件名序列 `<names>` 的非目录部分。\n- 示例： `$(notdir src/foo.c hacks)` 返回值是 `foo.c hacks` 。\n\n## suffix\n\n```html\n$(suffix <names...>)\n```\n\n- 名称：取後缀函数 —— suffix。\n- 功能：从文件名序列 `<names>` 中取出各个文件名的后缀。\n- 返回：返回文件名序列 `<names>` 的后缀序列，如果文件没有后缀，则返回空字串。\n- 示例： `$(suffix src/foo.c src-1.0/bar.c hacks)` 返回值是 `.c .c`。\n\n## basename\n\n```html\n$(basename <names...>)\n```\n\n- 名称：取前缀函数 —— basename。\n- 功能：从文件名序列 `<names>` 中取出各个文件名的前缀部分。\n- 返回：返回文件名序列 `<names>` 的前缀序列，如果文件没有前缀，则返回空字串。\n- 示例： `$(basename src/foo.c src-1.0/bar.c hacks)` 返回值是 `src/foo src-1.0/bar hacks` 。\n\n## addsuffix\n\n```html\n$(addsuffix <suffix>,<names...>)\n```\n\n- 名称：加后缀函数 —— addsuffix。\n- 功能：把后缀 `<suffix>` 加到 `<names>` 中的每个单词后面。\n- 返回：返回加过后缀的文件名序列。\n- 示例： `$(addsuffix .c,foo bar)` 返回值是 `foo.c bar.c` 。\n\n## addprefix\n\n```html\n$(addprefix <prefix>,<names...>)\n```\n\n- 名称：加前缀函数 —— addprefix。\n- 功能：把前缀 `<prefix>` 加到 `<names>` 中的每个单词后面。\n- 返回：返回加过前缀的文件名序列。\n- 示例： `$(addprefix src/,foo bar)` 返回值是 `src/foo src/bar` 。\n\n## join\n\n```html\n$(join <list1>,<list2>)\n```\n\n- 名称：连接函数 —— join。\n- 功能：把 `<list2>` 中的单词对应地加到 `<list1>` 的单词后面。如果 `<list1>` 的单词个数要比 `<list2>` 的多，那么， `<list1>` 中的多出来的单词将保持原样。如果 `<list2>` 的单词个数要比 `<list1>` 多，那么， `<list2>` 多出来的单词将被复制到 `<list1>` 中。\n- 返回：返回连接过后的字符串。\n- 示例： `$(join aaa bbb,111 222 333)` 返回值是 `aaa111 bbb222 333` 。\n\n\n\n# foreach 函数\n\nforeach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile 中的 foreach 函数 几乎是仿照于 Unix 标准 Shell（/bin/sh）中的 for 语句，或是 C-Shell（/bin/csh）中的 foreach 语句而构建的。它的语法是：\n\n```html\n$(foreach <var>,<list>,<text>)\n```\n\n这个函数的意思是，把参数 `<list>` 中的单词逐一取出放到参数 `<var>` 所指定的变量中， 然后再执行 `<text>` 所包含的表达式。每一次 `<text>` 会返回一个字符串，循环过程中， `<text>` 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， `<text>` 所返回的 每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。\n\n所以， `<var>` 最好是一个变量名， `<list>` 可以是一个表达式，而 `<text>` 中一般会 使用 `<var>` 这个参数来依次枚举 `<list>` 中的单词。举个例子：\n\n```makefile\nnames := a b c d\n\nfiles := $(foreach n,$(names),$(n).o)\n```\n\n上面的例子中， `$(name)` 中的单词会被挨个取出，并存到变量 n 中， `$(n).o` 每次 根据 `$(n)` 计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回，所以， `$(files)` 的值是 `a.o b.o c.o d.o` 。\n\n注意，foreach中的 `<var>` 参数是一个临时的局部变量，foreach 函数执行完后，参数 `<var>` 的变量将不在作用，其作用域只在 foreach 函数当中。\n\n\n\n# if 函数\n\nif 函数很像 GNU 的 make 所支持的条件语句 —— ifeq（参见前面所述的章节），if 函数的语法是：\n\n```html\n$(if <condition>,<then-part>)\n```\n\n或是\n\n```html\n$(if <condition>,<then-part>,<else-part>)\n```\n\n可见，if 函数可以包含 “else” 部分，或是不含。即 if 函数的参数可以是两个，也可以是三个。`<condition>` 参数是 if 的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真， 于是， `<then-part>` 会被计算，否则 `<else-part>` 会被计算。\n\n而 if 函数的返回值是，如果 `<condition>` 为真（非空字符串），那个 `<then-part>` 会是整个函数的返回值，如果 `<condition>` 为假（空字符串），那么 `<else-part>` 会是 整个函数的返回值，此时如果 `<else-part>` 没有被定义，那么，整个函数返回空字串。\n\n所以， `<then-part>` 和 `<else-part>` 只会有一个被计算。\n\n\n\n# call函数\n\ncall 函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中， 你可以定义许多参数，然后你可以 call 函数来向这个表达式传递参数。其语法是：\n\n```html\n$(call <expression>,<parm1>,<parm2>,...,<parmn>)\n```\n\n当make执行这个函数时， `<expression>` 参数中的变量，如 $(1) 、 $(2) 等，会 被参数 `<parm1>`、 `<parm2>` 、 `<parm3>` 依次取代。而 `<expression>` 的 返回值就是 call 函数的返回值。例如：\n\n```makefile\nreverse =  $(1) $(2)\n\nfoo = $(call reverse,a,b)\n```\n\n\n\n那么， `foo` 的值就是 `a b` 。当然，参数的次序是可以自定义的，不一定是顺序的，如：\n\n```makefile\nreverse =  $(2) $(1)\n\nfoo = $(call reverse,a,b)\n```\n\n此时的 `foo` 的值就是 `b a` 。\n\n需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第 2 个及其之后的 参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向 call 函数提供参数时，最安全的做法是去除所有多余的空格。","tags":["history"]},{"title":"ADC 采样值转化成电压值详解","url":"/adc-value-conversion-analysis/","content":"\n\n\n\n> 如何利用单片机的ADC模块（或者独立的ADC芯片）得到接入ADC管脚上的实际电压值？ 这个问题，是第一次接触ADC时候，大家都会遇到的问题。\n\n单片机会读到什么值？ 需要看一个特性，就是几位的 ADC，在手册上就会给出，例如，STM32的 ADC是 12位的。另外，还有 8位，10位，16位，24位等。\n\n我先告诉你答案：STM32读到的 ADC值，是从 0到 4095，当你把 ADC引脚接了GND，读到的就是 0，当你把 ADC引脚接了 VDD，读到的就是 4095。\n\n接下来告诉你为什么：前面提到，STM32的 ADC是 12位的，我们知道，8位的值是从 0 ~ 255；16位的值，是从 0 ~ 65535。这两个位的最大值，是我们最为熟悉的。\n\n（怎么算出来的？这问题就又降低到另一个层面了，这里我们说的几位的值，每个位只能是 0或者 1，比如 2位的值，可以表示为 00 01 10 11四种不同的值，这是以 2进制表示的，转换成十进制就是 0 1 2 3，所以得出结论，2位的值可以表示从 0 ~ 3。同理，3位的值，可以表示十进制的 0 ~ 7，你可以展开计算一下。4位的值，可以表示 0 ~ 15，5位的值，可以表示从 0 ~ 31，同理，你可以得出任意位的值可以表示的范围。）\n\n所以，12位的值，可以表示从 0 ~ 4095（2^12），这就是先在感性上，认识了为什么 12位的 ADC的值，是从 0 ~ 4095。\n\n\n\n**读到的值怎么换算成实际的电压值？**\n==前面提到了，我们输入GND，读到的值是 0，输入 VDD，得到的值是 4095，那么，当你读到 2035的时候，你知道输入电压多少 V吗？这个问题，归根接地，就到了数学 XY坐标，已知两点坐标值（0, 0）（3.3, 4095），给出任意 X坐标值，求 Y值的问题了吧？简单不简单？==\n\nADC测电压示意图：\n\n ![在这里插入图片描述](20190705235230125.png)\n\n参考电压是什么？\n\n讨论这个问题之前，你先拿万用表量一下你的 VDDA的实际电压是多大？是不是标准的 3.300V？应该不是吧？或许是 2.296V，或许是 3.312V。然后你把 VDD连接到ADC引脚之后，得到的是 4095，也就是，实际上，当你读出4095这个数据的时候，实际的电压值不是你想象中的 3.300V。有些初学者，觉得几毫伏的电压差无所谓，但实际应用中，几毫伏就可能代表很大的实际工况，例如，在一个量程为 50克的电子称上。\n\n所以，这时候，芯片厂商就想了一个办法，给 ADC模块中引入参考电压，由非常标准的参考电压芯片来接入参考电压引脚。标准的电压芯片，我们一般叫做参考电压芯片，或者叫做基准电压芯片。例如 REF3133（输出 3.300V） REF3025（输出 2.500V）等等。\n\n注意：STM32 的 100脚以上（含 100脚）有参考电压引脚。在没有参考电压引脚的单片机上，可以把基准电压芯片接入 VDDA，但是 VDDA和 VDD的电压差不能超过 0.3V，例如，VDD是 3.3V的话，可以给 VDDA接入一个 3.3V的参考电压芯片或者 3.0V的参考电压芯片，但是不能接入 2.5V的参考电压芯片，后果就是芯片不能工作。\n\nADC引脚的输入电压范围是多大\n一般情况下，ADC引脚的输入电压，是从 0 ~ VDD，如果有REF引脚，一般是 0 ~ Vref，也有 0 ~ 2Vref 的情况。\n\n如果被测的电压大于 ADC的输入电压，例如，要用 STM32测量 0 ~ 5V的电压的话，可以在输入 ADC引脚之前，加入电阻分压和放大器电路。\n\n==注意：如果用内部基准电压作为参考基准，公式就跟用外部芯片供电电压测量有点不同==\n\n    #define REF_VOLTAGE     1224UL        // 基准电压千倍\n    #define VOLTAGE         3300UL        // 电压千倍\n    #define ADC_DIP(X)      (X)           // ADC分辨率\n\n - 一般我们用外部芯片供电电压为参考基准就用下面那个公式，也就是上面说的XY比例\n\n    Voltage_value = (uint32_t)(ADC_value*VOLTAGE >> ADC_DIP(12));     // 换算成千倍的电压值\n\n - 若用内部基准电压作为参考则用以下公式\n\n    Voltage_value = (uint32_t)((REF_VOLTAGE << ADC_DIP(12)) / ADC_value);      // 换算成千倍的电压值\n\n***内置的参照电压看芯片的 datasheet；外部芯片供电电压最好用万用表测一下***","tags":["history"]},{"title":"Altium Designer 常用总结","url":"/altium-designer-summary/","content":"\n\n\n> 首先说明一下，==单个按键直接用字母表示；组合键（是指先按住第一个键不放，然后按下第二个键，再放开这两个键。）则用 “ + ” 表示；多次按键（是指先按下第一个键并放开，然后按下第二个键并放开，以此类推。）则用 “ - ” 表示。\n\n\n\n（以下快捷键只列出一些个人常用的，至于 Ctrl + C/ V 这些熟悉的快捷键以及不怎么用的就不一一罗列出来了，需要的可以到下面链接自个查询）\n\n - 这个是在百度文库里面列出来的 [最全 Altium Designer快捷键](https://wenku.baidu.com/view/09b94f16770bf78a6429548f.html?from=search)\n - 当然你也可以直接在AD软件里面查看，教程：[Altium Designer查看所有快捷键，图文教程](https://jingyan.baidu.com/article/359911f57d771057fe030683.html)\n\n\n\n# 原理图快捷键\n\n1：按住 Shift 拖动某个元件，可快速复制\n\n2：按住鼠标滚轮，鼠标上下滑动即为放大缩小（PCB一样效果）\n\n3：按住 Ctrl 按住鼠标右键 鼠标上下滑动也放大缩小\n\n4：按住 Ctrl 拖动某个元件 可以移动位置 并且保持原来的线连接\n\n5：关于原理图分层画时候 `NET PART` 属性。在 工程 - 工程参数 - options 设置 \n\n6：Ctrl + F ---- 可以查找相应的文本网络或原件\n\n7：T - C ---- 交叉探针 在需要寻找 原理图 对应 PCB 的元件位置选下，然后跑到PCB 就能看到 原理图 那个元件的位置。\n\n8：Shift + F ---- 查找相识的对象（PCB一样效果）\n\n9：Tab键 ---- 鼠标带着元件移动的时候可以修改属性\n\n10：Shift + C ---- 清除当前过滤器。（当显示一片灰暗时，可恢复正常显示）（PCB一样效果）\n\n11：Alt + 鼠标单击网络 ---- NET 网络呈现高亮状态\n\n\n\n# PCB快捷键\n\n1：Shift + S 键 ---- 切换单层显示 \n\n2：Q ---- 英寸和毫米尺寸切换。若打开了窗口则按 Ctrl + Q 临时切换一次单位制度\n\n3： D - R ---- 进入布线规则设置。其中 Clearance 是设置最小安全线间距，覆铜时候间距的。比较常用\n\n4：Ctrl + 鼠标单击某个线 ---- 整个线的 NET 网络 呈现高亮状态\n\n5：小键盘上的 * （星号键）可以在 Top、Bottom layer 切换，达到快速切换上下层。若在布线过程中，会自动按照你设的规则自动放置过孔并翻转到另一层布线。另外 + - 可以把所有显示的层轮流切换\n\n6: Delete ---- 删任何东西\n\n7: Backspace键 ---- 在交互布线（手动布线）或者敷铜的过程中，放弃上一步操作\n\n8: M - G ---- 任意调整铜皮\n\n9：Ctrl + Shift+鼠标滚轮 ---- 切换不同布线层\n\n10：E - O - S ---- 设置原点\n\n11：Ctrl + G/ G - G ---- 设置跳转栅格尺寸\n\n12：I - L ---- 在区域内排列元器件，先原理图选中一个或多个元器件\n\n13：J - C ---- 鼠标定位到指定的元件处。在弹出的对话框内输入该元件的编号\n\n14：N ---- 飞线显示及隐藏（具体自己选择相应的操作）\n\n15：U ---- 取消布线（具体自己选择相应的操作）\n\n16：Tab键 在交互布线或放置元件、过孔等对象的过程中修改对象属性。\n\n17：Ctrl + M 测量任意两点间的距离\n\n18：Ctrl + Shift + T、B、L、R 可以快速对齐所选中的元件 上/ 下/ 左/ 右\n\n19：器件联合 ---- 选中两个器件，然后右击 选择 “ 联合 - 从选中的器件生成联合 ” 这样可以操作两个位置在一起的器件\n当要去掉时候 选中器件 右击 选择 “ 联合-从联合打散器件 ” 那么连接在一起的就能够单独操作了\n当选中联合的器件，右击选择联合，有个 “ 选择所有的联合 ” 这样一下子选择所有联合的器件。固定的外框就可以联合起来移动操作\n\n20：M - I ---- 可以把选中所有的元件，翻转过来（其实就是顶层跟底层的切换）；这样可以在上下层切换，方便布线，调整印丝层。 很实用的一个操作。\n\n21：E - A ---- 特殊粘贴 拼版或复制粘贴元件的时候可以保持网络也一起粘贴（具体自己选择相应的操作）\n\n22：T - C ---- 交叉探针 在需要寻找 PCB对应 原理图 的元件位置 选下，然后跑到原理图 就能看到PCB那个元件的位置。\n\n23：T - E ---- 滴泪 _ps：别记成~~泪滴~~ 了_\n\n24：L  ---- 视图配置\n\n25：选中所画的机械层 Mechanical1 边界，选择【Design】|【Board shape】|【Define from selected objects】命令再回车，其快捷键为 D - S - D - Enter，就会按照你设定好的边界定义出 PCB的形状。\n\n26：如何把零件放到另一面去？ ----- 鼠标左键点选元件，不要松开，按 L键，元件就放到另一面了。（也可以用 M - I 键）\n\n27：T - V - ?（?：以下其中一个） ---- 转换组合键，具体想转换什么看下面解释 \t  \n\n - “ -G ” 转换出来的区域是多边形敷铜的第三种模式，如需更改，双击选自己需要的敷铜方式就行了； \n - “ - R ” 转换出来的是一个实心的区域图形，相当于实心作画； \n - “ - T ” 转换出来的是多边形剪切块，说白了就是拿来挖铜的； \n - “ - B” 转换出来的是板剪切块，具体干嘛用的还不知道，只知道它相当于一个白色的底层背景，不会覆盖任何一个板层\n ==（注意：转化前必须先对线性封闭图形选中再按快捷键，转换出来的区域是由外围线段决定的，不是封闭图形的话，只会转换选中的线条；转化后得到的区域图形所在的层是你当前的层）==\n\n28：O - B ---- PCB板参数设置\n\n29：D - R ---- 规则设置\n\n30：T - P ---- 优先选项设置\n\n31:  蛇形走线 ---- 先 P->T 布线, 再 Shift + A 切换成蛇形走线（按数字 1 和 2 调整蛇形线拐角形状，按数字 3 和 4 调整占空比，按左右尖括号 < 和 > 键调整蛇形线幅度）\n\n32：P - G ---- 敷铜\n\n**未完待续。。。。。。**\n\n\n\n\n# AD设计中，三种大面积覆铜的区别\n\n在AD设计中，主要有三种大面积覆铜方式，分别是 ==Fill==(铜皮) ==Polygon Pour==(灌铜) 和==Plane==(平面层)，这三种方式刚开始的时候没有细细区分，现在分别应用了一下， 总结如下，欢迎指正 \n\n**Fill**：表示绘制一块实心的铜皮，有点无差别攻击的味道，就是覆盖区域之内，所有的连线和过孔全都连接在一起，而不考虑是否属于同一个net。\n\n应用——如果应用不好，就会造成信号干扰，接地或者短路的严重后果，一般用在散热，比如电源芯片的GND，可以大面积铺设。快捷键为Place/Fill(键盘依次P/F)\n\n**Polygon Pour**：作用类似于Fill，绘制大面积铜皮，但是区别之处在于，“Pour”,也就是会主动区分覆盖区域的连线和过孔，网络点，焊盘，如果属于同一个网络，就会按照设定的规则（比如网格形式，实心形式覆铜）。\n\n应用——一般在画好主要信号线或者控制线之后使用，比如大面积铺地，至于大面积铺地使用的是实心式还是网格式，在下一篇文章中详细介绍。快捷方式为Place/Polygon Pour(P/G)\n\n**Polygon Pour Cutout** : 在灌铜区建立挖铜区。\n\n应用——在某些重要元件底部进行挖空处理，像常见的RF信号，通常需要做挖空处理，还有变压器下面的，RJ45等\n\n**Slice Polygon Pour** : 切割灌铜区域，比如需要进行优化缩减，划分成不同的小区域，以便进行删减，快捷方式P/Y\n\ntip: 如果想要改变已经设计的好普通形状，比如改成锐角，凹进去形状之类，可以使用快捷键M/G(Move/polygon vertices)\n\n**Plane** : 平面层，一般用于电源网络，对于两层板，一般用不到，对于四层板，可以当转电源或者地网络使用\n\n\n\n\n# PCB各层含义\n\n1、Signal layer（信号层）：用于布置电路板上的导线。\n\n2、Mechanical layer（机械层）：一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。\n\n3、Solder mask layer（阻焊层）：在焊盘以外的各部位涂覆一层涂料，如防焊漆，用于阻止这些部位上锡；需要走线上开窗只需要在 Solder是阻焊层的 画出相应图形即可。\n\n4、Paste mask layer（锡膏防护层，SMD贴片层）：它和阻焊层的作用相似，不同的是在机器焊接时对应的表面粘贴式元件的焊盘，是用来开钢网漏锡用的。\n\n5、Keep out layer（禁止布线层）：用于定义在电路板上能够有效放置元件和布线的区域。在该层绘制一个封闭区域作为布线有效区，在该区域外是不能自动布局和布线的。\n\n6、Silkscreen layer（丝印层）：主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。\n\n7、Multi layer（多层）：电路板上焊盘和穿透式过孔要穿透整个电路板，与不同的导电图形层建立电气连接关系，因此系统专门设置了一个抽象的层----多层。\n\n\n\n\n# ~~**个人PCB画板流程**：~~ \n---> 不定时保存（这个贼重要） \n\n---> 机械边界（机械层）尺寸规格、板厚标记，一般用 机械层_1\t\n\n---> 电气边界（静止布线层）注意螺丝孔等需要往外扩展的边界\n\n---> 元件布局：核心元件布局在板中央，插件布置在PCB边缘，发热元件一般应均匀分布，以利于单板和整机的散热，除温度检测元件以外的温度敏感器件应远离发热量大的元器件\n\n---> 规则设置：线距、过孔、敷铜（查看：Altium PCB 基本规则的详解）\t\n\n---> 布线（查看：华为PCB布线规范、datasheet等）\n\n---> 添加滴泪（1、避免电路板受到巨大外力的冲撞时，导线与焊盘或者导线与导孔的接触点断开，也可使PCB电路板显得更加美观。2、焊接上，可以保护焊盘，避免多次焊接是焊盘的脱落。3、生产时可以避免蚀刻不均，过孔偏位出现的裂缝等。4、信号传输时平滑阻抗，减少阻抗的急剧跳变，避免高频信号传输时由于线宽突然变小而造成反射，可使走线与元件焊盘之间的连接趋于平稳过渡化）\n\n---> 敷铜\t\n\n---> 3d查看（主要用于查看丝印的遮挡以及各元件之间的间隙，另外对于一些有高度限制的，可以用来作参考）\t\n\n---> DRC检测\n\n---> 复查\n\n---> 如果需要拼板，外围两边要分别留出 5mm宽度传送板边\n\n","tags":["history","EDA"]},{"title":"USART、I2C、SPI 通信方式扫盲","url":"/usart-iic-spi/","content":"\n\n\n# UART / USART\n\n## 基本方式\n\n基本方式分并行通讯和串行通讯 \n\n### 并行通讯\n并行通讯是指数据的每一位同时在多根数据线上发送或者接收。 \n\n![在这里插入图片描述](2019033119162475.png)\n\n其特点是各数据位同时传送，速度快、效率高，有多少数据位就需要多少根数据线，传送成本高。在集成电路芯片的内部、同一硬件板上各部件之间等的数据传送采用并行的方式，并行通讯传送的距离通常小于 30m。\n\n### 串行通讯\n\n串行通讯指数据的每一位在同一根数据线上按照顺序逐位发生或者接收。\n\n![在这里插入图片描述](2019033119171560.png)\n\n其特点是数据按位顺序进行，最少只需要一根传输线即可完成，成本低，速度慢。计算机与远程终端、远程终端之间数据的传输同常都是串行的。\n\n### 串行通讯与并行通讯对比\n串行通讯的显著特点为：传输距离较长，可以从几米到几千米，串行通讯的通讯时钟频率较容易提高，抗干扰能力强，其信号间互相干扰可以完全忽略，但是串行通讯比并行通讯慢得多。串行通讯在数据采集和控制系统中得到了广泛的应用。\n\n![在这里插入图片描述](20190331192104312.png)\n\n## 工作模式\n\n串行通讯的基础是单线传输，数据通常是在两个站点之间进行传输，按照数据流的方向分为 3种传输模式： \n\n### 单工模式(Simplex)\n单工模式的数据是单向的，通讯双方一方为发送端，另一方则固定为接收端。信息只能沿一个方向传输，使用一根数据线。 \n\n![在这里插入图片描述](20190331192134882.png)\n\n例如收音机，只能接收发射塔给它的数据，并不能给发射塔发数据。 \n\n### 半双工模式(Half duplex)\n半双工模式是指通讯双方都具有发送器和接收器，双方既可以发射也可以接收，但是接收和发射不能同时进行。 \n\n![在这里插入图片描述](20190331192214823.png)\n\n半双工一般用数据能在两个方向传输的场合，例如对讲机。\n\n### 全双工模式(Full duplex)\n全双工数据通讯分别由两根可以在两个不同的站点同时发送和接收的传输线进行传输数据，通讯双方能在同一时刻进行发送和接收操作。 \n\n![在这里插入图片描述](20190331192246981.png)\n\n全双工模式下，每一端都有发送器和接收器，有两条传输线可以在交互式应用场合中使用，信息传输效率高，例如手机。\n\n## 同步方式\n根据通讯的数据同步方式，可分为同步和异步两种，根据通讯过程中是否使用到时钟信号进行区分。 \n\n - 在同步通讯中，收发设备上方会使用一根信号线传输信号，在时钟信号的驱动下双方进行协调，同步数据。例如，通讯中通常双方会统一规定在时钟信号的上升沿或者下降沿对数据线进行采样。\n\n ![在这里插入图片描述](20190331192347304.png)\n\n - 在异步通讯中不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些用于同步的信号位，或者将主题数据进行打包，以数据帧的格式传输数据。通讯中还需要双方规约好数据的传输速率等，以便更好地同步。\n\n ![在这里插入图片描述](20190331192433851.png)\n\n*在同步通讯中，数据信号所传输的内容绝大部分是有效数据，而异步通讯中会则会包含数据帧的各种标识符，所以同步通讯效率高，但是同步通讯双方的时钟允许误差小，稍稍时钟出错就可能导致数据错乱，异步通讯双方的时钟允许误差较大。*\n\n\n\n# I2C\nI2C总线是 PHLIPS公司在 20世纪 80年代推出的一种串行总线。具有引脚少，硬件实现简单，可扩展性强的优点。I2C总线的另一优点是支持多主控，总线上任何能够进行发送/接收数据的设备都可以占领总线。当然，任意时间点上只能存在一个主控。\n\nI2C即是一种总线，也是一种通讯协议。在嵌入式开发中，通讯协议可分为两层：物理层和协议层。物理层是数据在物理媒介传输的保障；协议层主要是规定通讯逻辑，同一收发双方的数据打包、解包标准。打个比方，物理层相当于现实中的公路，而协议层则是交通规则，汽车可以在路上行驶，但是需要交通规则对行驶规则进行约束，不然将出现危险，也就是数据传输紊乱、丢包。\n\n特性：\n\n - 2条双向串行线，一条数据线 SDA，一条时钟线 SCL。\nSDA传输数据是大端传输，每次传输 8bit，即一字节。\n - \t支持多主控(multimastering)，任何时间点只能有一个主控。\n - \t总线上每个设备都有自己的一个 addr，共 7个 bit，广播地址全 0.\n - \t系统中可能有多个同种芯片，为此 addr分为固定部分和可编程部份，细节视芯片而定，看 datasheet\n\n## 物理层\nI2C通讯系统接线图如下： \n![在这里插入图片描述](20190331192910123.png)\n(1) 在 I2C通讯总线上，可连接多个 I2C通讯设备，支持多个通讯主机和多个通讯从机 \n\n(2) I2C通讯只需要两条双向总线：串行数据线 (SDA)，串行时钟线 (SCL)。数据线用于传输数据，时钟线用于同步数据收发 \n\n(3) 每个连接到总线的设备都有一个独立的地址，主机正是利用该地址对设备进行访问 \n\n(4) SDA和 SCL总线都需要接上上拉电阻，当总线空闲时，两根线均为高电平。连接到总线上的任意器件输出低电平都会将总线信号拉低。即各器件的 SDA和 SCL都是线与的关系 \n\n(5) 多个主机同时使用总线时，需要用仲裁方式决定哪个设备占用总线，不然数据将会产生冲突 \n\n(6) 串行的 8位双向数据传输位速率在标准模式下可达 100kbps，快速模式下可达 400kbps，高速模式下可达 3.4Mbps(目前大多数 I2C设备还不支持高速)\n\n## 协议层\n协议层规约了通讯的起始、停止信号，数据有效性、响应、冲裁同步、地址广播等。\n\n##  I2C位传输\n数据传输：SCL为高电平时，SDA线若保持稳定，那么 SDA上是在传输数据 bit。\n\n数据改变：SCL为低电平时，SDA线才能改变传输的 bit。\n\n若 SDA发生跳变，则用来表示一个会话的开始或结束（后面讲）\n\n![在这里插入图片描述](20190331193049333.png)\n\n### I2C开始和结束信号\n开始信号：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。\n\n结束信号：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。\n\n![在这里插入图片描述](20190331193137616.png)\n\n### I2C应答信号\n\nMaster每发送完 8bit数据后等待 Slave的ACK。\n\n即在第 9个 clock，若从 IC发 ACK，SDA会被拉低。\n\n若没有 ACK，SDA会被置高，这会引起 Master发生 RESTART或 STOP流程，如下所示：\n\n![在这里插入图片描述](20190331193412844.png)\n\n## I2C写流程\n写寄存器的标准流程为：\n1. Master发起 START\n2. Master发送 I2C addr（7bit）和 w操作 0（1bit），等待 ACK\n3. Slave发送 ACK\n4. Master发送 reg addr（8bit），等待 ACK\n5. Slave发送 ACK\n6. Master发送 data（8bit），即要写入寄存器中的数据，等待 ACK\n7. Slave发送 ACK\n8. 第 6步和第 7步可以重复多次，即顺序写多个寄存器\n9. Master发起 STOP\n\n**写一个寄存器：** \n\n![在这里插入图片描述](20190331193524947.png)\n\n**写多个寄存器：**\n\n![在这里插入图片描述](20190331193545788.png)\n\n## I2C读流程\n\n读寄存器的标准流程为：\n1. Master发起 START\n2. Master发送 I2C addr（7bit）和 W操作 0（1bit），等待 ACK\n3. Slave发送 ACK\n4. Master发送 reg addr（8bit），等待 ACK\n5. Slave发送 ACK\n6. Master发起 START\n7. Master发送 I2C addr（7bit）和 R操作 1（1bit），等待 ACK\n8. Slave发送 ACK\n9. Slave发送 data（8bit），即寄存器里的值\n10. Master发送 ACK\n11. 第 9步和第 10步可以重复多次，即顺序读多个寄存器\n12. Master发起 STOP\n\n**读一个寄存器：**\n\n![在这里插入图片描述](20190331193648639.png)\n\n**读多个寄存器：**\n\n![在这里插入图片描述](20190331193700612.png)\n\n\n\n# SPI\n\nSPI（serial peripheral interface，串行外围设备接口）总线技术是 Motorola公司推出的一种同步串行接口。它用于 CPU与各种外围器件进行全双工、同步串行通讯。它只需四条线就可以完成 MCU与各种外围器件的通讯，这四条线是：串行时钟线（SCK）、主机输入 / 从机输出数据线（MISO）、主机输出 / 从机输入数据线（MOSI）、低电平有效从机选择线 CS。\n\n当 SPI工作时，在移位寄存器中的数据逐位从输出引脚（MOSI）输出（高位在前），同时从输入引脚（MISO）接收的数据逐位移到移位寄存器（高位在前）。发送一个字节后，从另一个外围器件接收的字节数据进入移位寄存器中。即完成一个字节数据传输的实质是两个器件寄存器内容的交换。主 SPI的时钟信号（SCK）使传输同步。其典型系统框图如下图所示。\n\n![在这里插入图片描述](20190331194140132.png)\n\n## 通信原理\n\n标准的 SPI 是 4 根线，分别是 SSEL（ 片选，也写作 SCS）、 SCLK（ 时钟，也写作 SCK）、 MOSI（ 主机输出从机输入 Master Output/Slave Input） 和 MISO（ 主机输入从机输出 Master Input/Slave Output）。\n\n - MOSI（SDO）：主器件数据输出，从器件数据输入。\n - MISO（SDI）：主器件数据输入，从器件数据输出。\n - SCLK ：时钟信号，由主器件产生。\n - CS：从器件使能信号，由主器件控制。(CS控制芯片是否被选中，只有片选信号为实现约定的使能信号时（高电位或地电位），对此芯片的操作才有效，这也就允许同一总线上连接多个SPI设备。)\n\nSPI串行传输，数据一位一位从 MSB到 LSB开始传输，产生相应的脉冲沿时，MOSI，MISO才进行数据传输。\n\n## 工作方式\n\nSPI有四种工作模式，取决于两个参数：（这两个参数其实就是控制了 CLK这一根线，SPI通信不像 UART或 IIC那样有专门的通信周期，有专门的通信起始信号和结束信号。所以 SPI协议能够通过控制时钟信号线在没有数据交流的时候保持的状态，要么是高电平，要么是低电平）\n\n1、 CPOL，clock polarity，译作时钟极性。\n\n2、 CPHA，clock phase，译作时钟相位。\n\n - CPOL具体说明：\nCPOL用于定义时钟信号在空闲状态下处于高电平还是低电平，为 1代表高电平，0为低电平。\n - CPHA具体说明：\n首先，在同步接口中，肯定存在一个接口时钟，用来同步采样接口上数据的。CPHA就是用来定义数据采样在第几个边沿的，数据的采样时刻。为 1代表第二个边沿采样，为 0代表第一个边沿采样。\n\n以上两个参数，总共有四种组合：\n\n(1) CPOL=0，CPHA=0：此时空闲态时，SCLK处于低电平，数据采样是在第 1个边沿，也就是 SCLK由==低电平到高电平==的跳变，所以数据采样是在上升沿，数据转换是在下降沿（第 2个边沿）。\n\n(2) CPOL=0，CPHA=1：此时空闲态时，SCLK处于低电平，数据采样是在第 2个边沿，也就是 SCLK由==高电平到低电平==的跳变，所以数据采样是在下降沿，数据转换是在上升沿（第 1个边沿）。\n\n(3) CPOL=1，CPHA=0：此时空闲态时，SCLK处于高电平，数据采样是在第 1个边沿，也就是 SCLK由==高电平到低电平==的跳变，所以数据采集是在下降沿，数据转换是在上升沿（第 2个边沿）。\n\n(4) CPOL=1，CPHA=1：此时空闲态时，SCLK处于高电平，数据采样是在第 2个边沿，也就是 SCLK由==低电平到高电平==的跳变，所以数据采集是在上升沿，数据转换是在下降沿（第 1个边沿）。\n\n ![在这里插入图片描述](20190331194425848.png)\n\n*由于 SPI 没有一个统一的规范，所以在时序上描述存在一定的差异，具体以 datasheet 为准。*","tags":["history","MCU"]},{"title":"关于 Keil、IAR 编译后数据内存的分析","url":"/keil-iar-memory-analysis/","content":"\n\n\n# Keil C51编译器\n\n1、首先，在 Options ----> Target ----> Memory Model 里可以设置变量分配的空间，如图示：\n![在这里插入图片描述](20190319214430417.png)\n\n - Small：变量默认分配到内部存储空间中，通过普通的 MOV指令寻址，只用低于 2K的程序空间。\n - Compact：变量默认分配到外部页存储空间中，单个函数的代码量不能超过 2K，整个程序可以使用 64K的程序空间，通过 MOVX, @Ri之类指令寻址，在不切换页的前提下，最大支持 256字节外部扩展 RAM。\n - Large：变量默认分配到外部存储空间中，通过 MOVX, @DPTR之类指令寻址，最大支持 64kB外部扩展 RAM（实际上配合硬件设计以及软件调整，还可以支持更大的扩展空间）。\n\n\n2、程序中，如果在变量声明时未声明变量的存储器类型，则该变量的存储器类型，由程序的存储模式来决定，也就是说编译器会根据我们在上面 Memory Model 里所选的模式默认储存在那个区域。\n\n - [ ] 小模式（Small model）：默认data区 \n - [ ] 紧凑模式（Compact model）：默认pdata区\n - [ ]  大模式（Large model）：默认xdata区\n\n3、各分配区域的理解\ndata：直接寻址的片内 RAM区低 128B（00H~7FH） , 可以用 acc直接读写的，速度最快，生成的代码也最小。\n\nbdata：片内 RAM的可位寻址区（20H~2FH），允许字节和位混合访问 \n\nidata：单片机间接访问的片内 RAM区，允许访问全部片内 RAM（前面 0x00-0xff的 256个 RAM）,其中前 128和 data的 128完全相同，只是因为访问的方式不同。idata是用类似 C中的指针方式访问的。汇编中的语句为：mox ACC,@Rx.(不重要的补充：C中 idata做指针式的访问效果很好) \n\npdata：Ri间接访问的片外 RAM的低 256B（00H~FFH） \n\nxdata：外部扩展 RAM，用 DPTR间接访问片外 RAM，允许访问全部 64KB片外 RAM（0000H~FFFFH） \n\ncode：单片机的 64KB程序存储区 ROM，即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM区，写入后就不能再更改，一般当你定义数组不用更改时可以加上这个关键词，对应的 data是存入 RAM的意思\n\n4、如下图所示，编译出来的 “ Program Size: data=10.3 xdata=588 code=8732 ” ，对应的数值就是该区域所占用的空间大小![在这里插入图片描述](20190319220144298.png)\n5、根据上面的信息，可以得知以下的 Flash和 RAM占用的空间大小，至于不知道为什么在 data数据区域内有小数点，估计是因为 51内核的单片机是 8bit的，并且支持 bit数据类型，像我们平时一般定义标志位 flag都是创建 bit位的，而在这里显示数据，都是以 Byte为单位的；估计是因为这样的原因吧；如果有哪个大佬知道，可以说明一下。\n- Flash = Code + data + xdata\n- RAM = data + xdata\n\n\n\n# Keil MDK-Arm编译器\n\n1、同样是 Keil编译器，MDK相对于 C51，在 Options ----> Target里并没有 Memory Model的设置，用的比较多的是下面的这个配置\n![在这里插入图片描述](20190319220847231.png)\n这个是程序存储在片内、片外的地址设置（一般下载程序都是下载到片内 FLASH），我们也不用怎么去更改它；只有在项目做大了，或有特殊要求时，片内不够使用了才将程序存储在片外\n\n2、数据类型的理解\nCode：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM区。 \n\nRO-data：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM区，因而程序不能修改其内容。例如 C语言中 const关键字定义的变量就是典型的 RO-data。  \n\nRW-data：Read Write data，即可读写数据域，它指初始化为 “ 非 0值 ” 的可读写数据，程序刚运行时，这些数据具有非 0的初始值，且运行的时候它们会常驻在 RAM区，因而应用程序可以修改其内容。例如 C语言中使用定义的全局变量，且定义时赋予“非0值”给该变量进行初始化。  \n\nZI-data：Zero Initialie data，即 0初始化数据，它指初始化为 “0值” 的可读写数据域，它与 RW-data的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与 RW-data的性质一样，它们也常驻在 RAM区，因而应用程序可以更改其内容。例如C语言中使用定义的全局变量，且定义时赋予 “0值” 给该变量进行初始化(若定义该变量时没有赋予初始值，编译器会把它当 ZI-data来对待，初始化为 0)；  \n\nZI-data的栈空间(Stack)及堆空间(Heap)：在 C语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。而使用 malloc动态分配的变量属于堆空间。在程序中的栈空间和堆空间都是属于 ZI-data区域的，这些空间都会被初始值化为 0值。编译器给出的 ZI-data占用的空间值中包含了堆栈的大小(经实际测试，若程序中完全没有使用 malloc动态申请堆空间，编译器会优化，不把堆空间计算在内)。\n\n3、对比 C51的，显示的数据类型多了那么几项；那么，根据上面的数据理解，就可以得到：\n- Flash = Code + RO-data + RW-data\n- RAM = RW-data + ZI-data\n\n\n\n# IAR For STM8(EWSTM8)编译器\n\n1、IAR查看编译后内存大小不会像 Keil那样在编译完直接在 Build窗口显示出来，需要我们去 Options for node里面设置一下，具体操作 Options for node ----> Linker ----> List ----> 把Generate linker map file打勾；如图：\n![在这里插入图片描述](20190319223141520.png)\n2、根据上面的操作，设置完后编译，在工作空间窗口 Output文件下可以找到 .map的文件，点击打开，在末尾可以看到目标代码占用的空间大小，如图所示：\n![在这里插入图片描述](20190319224645748.png)\n\n - Flash = readonly  code memory + readonly  data memory\n - RAM = readwrite data memory\n\n括号内的，表示内存的绝对使用量，对应你设的全局变量大小；对应生成的 bin文件大小 = 5590 + 168\n\n\n\n# Keil下的 .map文件\n\n实际上在 keil下也是可以找到 .map编译信息的，在 Options ----> Listings里：\n![在这里插入图片描述](20201010202944218.png)\n如此操作，就可以在 Select Folder for Listings...设置的文件夹里找到 .map编译信息文件了。\n\n\n\n# 优化\n\n一般每个编译器都有优化选项，对应选择不同的优化等级，你会发现同样的代码，编译出来的占用内存大小是不同的，再细心一点同样可以发现存放在 RAM区域的内存大小是不会怎么变化的，变化较大的是存在 Flash区域的内存，所以一般的不会定义全局变量（除非真的要用到），并且全局变量处理起来比较麻烦；另外，开了优化后，如果进入调试，可能有些地方会放不了小红点（打断点），因为编译器根据你所选的优化等级，把对应的代码给优化了。","tags":["history","IDE"]},{"title":"(转)Altium PCB 基本规则的详解","url":"/altium-pcb-rule/","content":"\n\n\n[原文出处](https://wenku.baidu.com/view/7fd4e60d77c66137ee06eff9aef8941ea76e4b78.html?re=view) ☜戳我啊\n\n\n\n> 规则的适应范围越小，则把优先级设得越高。以下只是一些非常基本规则的设置，仅仅是规则设置中的一点皮毛，还需要以后继续学习。\n\n\n\n# 规则列表\n\n - Electrical（电气规则）：安全间距、线网连接等\n - Routing（布线）：线宽、过孔形状尺寸、布线拓扑、布线层、封装出 线等\n - SMT（表面贴装（贴片））：贴片元件焊盘的一些要求\n - Mask（掩膜）：阻焊和焊膏的扩展\n - Plane（内电层和铺铜）：内电层和铺铜与焊盘的连接方式\n - Testpoint（测试点）\n - Manufacturing（加工）：孔、焊盘、丝印和阻焊的尺寸及相关关系\n - HighSpeed（高速信号）：串扰、线长、配长、过孔数量等与高速信号相关的\n - Placement（放置）：元件放置和元件间距等\n - SignalIntegrity（信号完整性）：走线阻抗及高速信号的过冲、摆率等\n\n\n\n# 内容\n\n## ***Electrical  （电气设计规则）*** \n\n1. Clearance（安全距离）设置的是 PCB 电路板在布置铜膜导线时，元件焊盘和焊盘之间、焊盘和导线之间、导线和导线之间的最小的距离。 \n2. Short Circuit（短路）选项区域设置短路设置就是否允许电路中有 导线交叉短路。系统默认不允许短路，即取消 Allow Short Circuit 复 选项的选定。\n3. Un-Routed Net（未布线网络）选项区域设置可以指定网络、检查 网络布线是否成功，如果不成功，将保持用飞线连接。 \n4. Un-Connected Pin（未连接管脚） 选项区域设置对指定的网络检查 是否所有 元件管脚都连线了。 \n\n\n\n\n## ***Routing  （布线设计规则）*** \n1. Width（导线宽度）选项区域设置导线的宽度有三个值可以供设置，分别为 Max width（最大宽度）、Preferred Width（最佳宽度）、 Min width（最小宽度）三个值。系统对导线宽度的默认值为 10mil， 单击每个项直接输入数值进行更改。 这里采用系统默认值 10mil 设置导线宽度。 \n\n2. Routing Topology（布线拓扑规则）选项区域设置拓扑规则定义是 采用的布线的拓扑逻辑约束。AD 中常用的布线约束为统计最短逻辑 规则。 \n\n  从 Topology 下拉菜单中选择拓扑类型选项。 \n\n  AD 提供了以下几种布线拓扑规则： \n  ①\tShortest (最短 )规则设置最短规则， 该选项的定义是在布线时连 接所有节点的连线最短规则。 \n  ②\tHorizontal（水平）规则设置水平规则设置它采用连接节点的水 平连线最短规则。 \n  ③\tVertical （垂直） 规则设置垂直规则设置它采和是连接所有节点， 在垂直方向连线最短规则。 \n  ④\tDaisy Simple（简单雏菊）规则设置简单雏菊规则设置。它采用的是使用链式连通法则，从一点到另一点连通所有的节点，并使连线 最短。 \n  ⑤\tDaisy MidDiven（雏菊中点）规则设置雏菊中点规则设置。该规 则选择一个 Source（源点），以它为中心向左右连通所有的节点， 并 使连线最短。 \n  ⑥\tDaisy Balanced（雏菊平衡）规则设置雏菊平衡规则设置。它也 选择一个源点，将所有的中间节点数目平均分成组，所有的组都连接 在源点上，并使连线最短。 \n  ⑦\tStar Burst（星形）规则设置星形规则设置。该规则也是采用选 择一个源点，以星形方式去连接别的节点，并使连线最短。 \n\n3. Routing Priority （布线优先级） 选项区域设置该规则用于设置布线 的优先次序，设置的范围从 0~100，数值越大，优先级越高。 \n\n4. Routing Layers（布线图规则）该规则设置布线板导的导线走线方 法。包括顶层和底层布线层，选择允许走线的层。 \n    AD 提供了 11 种布线走法。 各种布线方法为： Not Used 该层不进行布线； Horizontal 该层 按水平方向布线 ;Vertical 该层为垂直方向布线； Any 该层可以任意 方向布线；1.0 Clock 该层为按一点钟方向布线；2.0 Clock 该层为按两 点钟方向布线；4.0 Clock 该层为按四点钟方向布线；5.0 Clock 该层为 按五点钟方向布线； 45Up 该层为向上 45 °方向布线、 45Down 该层为向下 45°方法布线； Fan Out 该层以扇形方式布线。对于系统默认的双面板情况， 一面布线采用 Horizontal 方式另一面采 用 Vertical 方式。 \n\n5. Routing Corners（拐角）选项区域设置布线的拐角可以有 45°拐 角、90°拐角和圆形拐角三种。 \n\n6. Routing Via Style （过孔） 该规则设置用于设置布线中导孔的尺寸。\n\n7. Fatout Contrl（扇出布线）\n\n8. Differential Pairs Routing（利用差分对布线） \n\n\n\n## ***SMT （表面粘着类规则设计）*** \n1. SMD To Corner SMD：SMD 焊盘与导线拐角处最小间距规则。\n2. SMD To Plane：SMD 焊盘与电源层过孔最小间距规则。 \n3. SMD Neck-Down ：SMD 焊盘颈缩率规则。制定焊点宽度与连接 线宽度之比。 \n\n\n\n## ***Mask （屏蔽类设计规则）*** \n1. Solder Mask Expansion：阻焊层收缩量规则。\n2. Paste Mask Expansion：助焊层收缩量规则。 \n\n\n\n## ***Plane（电源层规则）*** \n1. Power Plane Connect Style：电源层连接类型规则。 \n2. Power Plane Clearance：电源层安全间距规则。 \n3. Polygon Connect Style：焊盘与覆铜连接类型规则。 \n\n\n\n## ***Test Point（测试点规则）*** \n1. Test Point Style：测试点样式规则。 \n2. Test Point Usage：测试点使用规则。\n3. Assembly Test Point Style：装配测试点样式规则。 \n\n\n\n## ***Manufacturing（PCB 制板规则）*** \n1.\tMinimum Annular Ring ：焊盘铜环最小宽度规则，防止焊盘脱落。 \n2.\tAcute Angle：（导线夹角）锐角限制规则，不小于 90°。 \n3.\tHole Size：孔径限制规则 \n4.\tLayer Pairs：配对层设置规则，设定所有钻孔电气符号（焊盘和过 孔）的起始层和终止层，使用导盲孔的设计。 \n5.\tHole To Hole Clearance：孔间间距桂鄂 \n6.\tMinimum Solder Mask Sliver： \n7.\tSilkscreen Over Component Pads：丝印与元器件焊盘间距规则 \n8.\tSilk To Silk Clearance：丝印间距规则 \n9.\tNet Antennae：网络天线规则 \n\n\n\n## ***High Speed（高频电路规则）*** \n1.\tParallelSegment：平行铜膜线段间距限制规则 \n2.\tLength：网络长度限制规则 \n3.\tMatched Net Lengths：网络长度匹配规则 \n4.\tDaisy Chain Stub Length：菊花状布线分支长度限制规则 \n5.\tVias Under SMD：SMD 焊盘下过孔限制规则 \n6.\tMaximum Via Count：最大过孔数目限制规则 \n\n\n\n## ***Placement（元件布置规则）*** \n1.\tRoom Definition：元件集合定义规则 \n2.\tComponent Clearance：元件间距限制规则\n3.\tComponent Orientations：元件布置方向规则 \n4.\tPermitted Layers：允许元件布置板层规则 \n5.\tNets To Ignore：网络忽略规则 \n6.\tHight：高度规则 \n\n\n\n## ***Signal Integrity（信号完整性规则）*** \n1.\tSignal Stimulus：激励信号规则\n2.\tUndershoot-Falling Edge：负下冲超调量限制规则 \n3.\tUndershoot-Rising Edge：正下冲超调量限制规则 \n4.\tImpedance：阻抗限制规则 \n5.\tSignal Top Value：高电平信号规则 \n6.\tSignal Base Value：低电平信号规则 \n7.\tFlight Time-Rising Edge：上升飞行时间规则 \n8.\tFlight Time-Falling Edge：下降飞行时间规则 \n9.\tSlope-Rising Edge：上升沿时间规则 \n10.\tSlope-Falling Edge：下降沿时间规则 \n11.\tSupply Nets：电源网络规则\n\n\n\n","tags":["history","EDA"]},{"title":"Windows 下常用的指令以及操作","url":"/common-windows-commands/","content":"\n\n\n# 截屏：快捷键是 Print Screen\n\n - Ctrl + PrScrn 使用这个组合键截屏，获得整个屏幕的图片。\n - Alt + PrScrn 这个组合键截屏，获得当前窗口的图片。\n\n==按下拷屏键之后，系统看似没有任何反应，但系统早已在你按下该键的同时把整个屏幕的内容以图形的形式保存在内存中了，你只要打开一个图像编辑软件（如Windows自带的“画图”软件、Office或photoshop），按下键盘快捷键“Ctrl+V”将画面粘贴下来，最后保存为图形文件就可以了。==\n\n- win10 平台下：win + Shift + s 可进行截屏。\n\n\n\n# Windows + R：打开 “运行” 窗口（在输入栏输入相关指令则作出相应的操作）\n\n 1. calc - - - - 启动计算器（程序员必备）\n 2. notepad - - - - 打开记事本（必备之二）\n 3. mspaint - - - - 画图板（截屏完可以用该指令调出画板，把截图粘贴出来）\n 4. write - - - - 写字板（类似word文档，但功能没那么强大）\n 5. taskmgr - - - - 任务管理器（利用快捷键 Ctrl + Alt + Delete 或者 Ctrl + shift + Esc也可以打开，前者还要再选择启动任务管理器，后者直接启动）\n  6. cmd - - - - 进入CMD命令提示符窗口\n\n\n\n# 任务管理器无法强制结束进程解决方法\n\n - **第一种：利用进程名结束进程**\n 1. 进入命令提示符窗口，\n 2. 在命令提示符窗口中输入：==tasklist==\n 3. 按回车键，显示出当前运行的程序\n 4. 输入“ ==Taskkill/im 映像名称 /f== ” （eg：Taskkill/im QQ.exe /f）\n 5. 按回车键，就会提示 “ 成功：已中止进程 ”\n\n - **第二种：利用PID号结束进程**\n 1. 同样进入命令提示符窗口，\n 2. 在命令提示符窗口中输入：==tskill PID号== （PID就是各进程的身份标识，程序一运行系统就会自动分配给进程一个独一无二的PID）PID号可以从任务管理器那里查看，也可以像上面那样输入tasklist显示出来；在任务管理器中查看进程时，总是在不断变换位置，很容易看错行，这个时候只要按住Ctrl键，就能让Windows动态显示瞬间暂停，定格在按下键盘时的那个瞬间，此招适用于Windows XP及以上版本的所有系统。win8 好像不能用 tskill 命令\n  3. 最后按回车键\n\n\n\n# 命令行打开回收站\n\n- 进 cmd 窗口，输入 `start shell:recyclebinfolder` 命令可以打开回收站；\n\n或者\n\n- win + r 打开“运行”，输入 `shell:recyclebinfolder` 打开回收站。\n\n\n\n# 常用 Windows 组合键\n\n 1. Windows 键：打开开始屏幕\n 2. Windows 键+空格键：切换输入语言和键盘布局\n 3. Windows 键+,：临时查看桌面\n 4. Windows 键+C：打开 Charms 栏(提供设置、设备、共享和搜索等选项)\n 5. Windows 键+I：打开设置栏\n 6. Windows 键+Q：打开应用搜索面板\n 7. Windows 键+Tab：循环切换应用\n 8. Windows 键+Shift+Tab：反向循环切换应用\n 9. Windows 键+X：快捷菜单\n 10. Windows 键 + ←：最大化窗口到左侧的屏幕上(与 Metro 应用无关)\n 11. Windows 键 + →：最大化窗口到右侧的屏幕上(与 Metro 应用无关)\n 12. Windows 键+ ↑：最大化窗口(与 Metro 应用无关)\n 13. Windows 键+ ↓：最小化窗口(与 Metro 应用无关)\n 14. Windows 键+D：显示桌面，第二次键击恢复桌面 (不恢复 Metro 应用)\n 15. Windows 键+E：打开资源管理器\n 16. Windows 键+L：锁住电脑或切换用户\n 17. Windows 键+R：打开“运行”对话框\n 18. Windows 键+减号：缩小(放大镜)\n 19. Windows 键+加号：放大(放大镜)\n  20. Windows 键+Esc：关闭放大镜\n\n\n\n# 常用基本组合键\n\n 1. Ctrl+A：选择所有\n 2. Ctrl+C：复制\n 3. Ctrl+E：选择搜索框（资源管理器）\n 4. Ctrl+N：新窗口（资源管理器）\n 5. Ctrl+R：刷新\n 6. Ctrl+V：粘贴\n 7. Ctrl+W：关闭当前窗口（资源管理器）\n 8. Ctrl+X：剪切\n 9. Ctrl+Y：重做\n 10. Ctrl+Z：撤销\n 11. Ctrl+Tab：在 Metro 应用历史中循环切换\n 12. Alt+Spacebar：快捷菜单\n 13. Alt+Tab：应用程序间切换\n 14. Ctrl+Shift+N：新建文件夹（资源管理器）\n 15. Ctrl+Shift+Esc：任务管理器\n  16. Ctrl+Shift+上下左右箭头：选择一段文字\n\n\n\n# 文件夹 / 文件的目录树查看\n\n首先，利用 cmd进入命令提示符窗口，然后利用 cd打开到相应的文件夹路径，文件名输入可以用 Tab键补全；当然，如果你觉得这样一步步打开到相应的文件夹里比较麻烦，那你可以尝试第二种方法，在当前文件夹里，按住 Shift键然后鼠标右击，会出现一个在此处打开命令窗口的操作，点击就会创建一个命令窗口，并且是指向当前文件夹路径的；紧接着，输入 tree回车，就会显示在当前文件夹下的子文件夹目录，并以树状形式列出；想要显示出所有文件名的目录（包括子文件夹下的文件）可以在后面加上 \" /f \"。\n如果想要输出到文本上，可以使用 `tree /f > tree.txt` 命令，就可以把生成的文件目录树形结构写入到当前目录的 tree.txt文件中了（txt的命名可以随意）。\n\n\n\n# 右 Alt 键组合失效\n\n可能是使用了英式键盘输入，切换成美式英语即可，参考：https://www.dell.com/support/kbdoc/zh-cn/000136390/%E6%8C%89%E5%8F%B3-alt-%E9%94%AE%E5%8D%95%E5%87%BB%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8"}]